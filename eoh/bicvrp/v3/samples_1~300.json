[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines route splitting, demand-based customer reallocation, and adaptive route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Check if route can be split or merged\n        if len(selected_route) > 3:  # Route has more than just depot and one customer\n            # Option 1: Split the route into two\n            split_pos = random.randint(1, len(selected_route) - 2)\n            new_route1 = np.concatenate([selected_route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], selected_route[split_pos:]])\n\n            # Check capacity constraints for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n        else:\n            # Option 2: Merge with another route if possible\n            other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n            if other_routes:\n                merge_idx = random.choice(other_routes)\n                merged_route = np.concatenate([new_solution[merge_idx][:-1], selected_route[1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[merge_idx] = merged_route\n                    del new_solution[route_idx]\n\n        # Option 3: Reallocate a customer from this route to another if possible\n        if len(selected_route) > 2:\n            customer_idx = random.randint(1, len(selected_route) - 2)\n            customer = selected_route[customer_idx]\n\n            # Try to insert into another route\n            for route in new_solution:\n                if len(route) > 2:\n                    # Find best insertion position\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route)):\n                        # Calculate capacity and distance impact\n                        new_demand = np.sum(demand[route[1:-1]]) + demand[customer]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate distance increase\n                        dist_increase = (distance_matrix[route[pos-1]][customer] +\n                                       distance_matrix[customer][route[pos]] -\n                                       distance_matrix[route[pos-1]][route[pos]])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        route = np.insert(route, best_pos, customer)\n                        selected_route = np.delete(selected_route, customer_idx)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7381189037676285,
            0.9575425982475281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Check if route can be split or merged\n        if len(selected_route) > 3:  # Route has more than just depot and one customer\n            # Option 1: Split the route into two\n            split_pos = random.randint(1, len(selected_route) - 2)\n            new_route1 = np.concatenate([selected_route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], selected_route[split_pos:]])\n\n            # Check capacity constraints for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n        else:\n            # Option 2: Merge with another route if possible\n            other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n            if other_routes:\n                merge_idx = random.choice(other_routes)\n                merged_route = np.concatenate([new_solution[merge_idx][:-1], selected_route[1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[merge_idx] = merged_route\n                    del new_solution[route_idx]\n\n        # Option 3: Reallocate a customer from this route to another if possible\n        if len(selected_route) > 2:\n            customer_idx = random.randint(1, len(selected_route) - 2)\n            customer = selected_route[customer_idx]\n\n            # Try to insert into another route\n            for route in new_solution:\n                if len(route) > 2:\n                    # Find best insertion position\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route)):\n                        # Calculate capacity and distance impact\n                        new_demand = np.sum(demand[route[1:-1]]) + demand[customer]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate distance increase\n                        dist_increase = (distance_matrix[route[pos-1]][customer] +\n                                       distance_matrix[customer][route[pos]] -\n                                       distance_matrix[route[pos-1]][route[pos]])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        route = np.insert(route, best_pos, customer)\n                        selected_route = np.delete(selected_route, customer_idx)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines route splitting, demand-based customer reallocation, and adaptive route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Check if route can be split or merged\n        if len(selected_route) > 3:  # Route has more than just depot and one customer\n            # Option 1: Split the route into two\n            split_pos = random.randint(1, len(selected_route) - 2)\n            new_route1 = np.concatenate([selected_route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], selected_route[split_pos:]])\n\n            # Check capacity constraints for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n        else:\n            # Option 2: Merge with another route if possible\n            other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n            if other_routes:\n                merge_idx = random.choice(other_routes)\n                merged_route = np.concatenate([new_solution[merge_idx][:-1], selected_route[1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[merge_idx] = merged_route\n                    del new_solution[route_idx]\n\n        # Option 3: Reallocate a customer from this route to another if possible\n        if len(selected_route) > 2:\n            customer_idx = random.randint(1, len(selected_route) - 2)\n            customer = selected_route[customer_idx]\n\n            # Try to insert into another route\n            for route in new_solution:\n                if len(route) > 2:\n                    # Find best insertion position\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route)):\n                        # Calculate capacity and distance impact\n                        new_demand = np.sum(demand[route[1:-1]]) + demand[customer]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate distance increase\n                        dist_increase = (distance_matrix[route[pos-1]][customer] +\n                                       distance_matrix[customer][route[pos]] -\n                                       distance_matrix[route[pos-1]][route[pos]])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        route = np.insert(route, best_pos, customer)\n                        selected_route = np.delete(selected_route, customer_idx)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7381189037676285,
            0.9575425982475281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Check if route can be split or merged\n        if len(selected_route) > 3:  # Route has more than just depot and one customer\n            # Option 1: Split the route into two\n            split_pos = random.randint(1, len(selected_route) - 2)\n            new_route1 = np.concatenate([selected_route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], selected_route[split_pos:]])\n\n            # Check capacity constraints for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n        else:\n            # Option 2: Merge with another route if possible\n            other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n            if other_routes:\n                merge_idx = random.choice(other_routes)\n                merged_route = np.concatenate([new_solution[merge_idx][:-1], selected_route[1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[merge_idx] = merged_route\n                    del new_solution[route_idx]\n\n        # Option 3: Reallocate a customer from this route to another if possible\n        if len(selected_route) > 2:\n            customer_idx = random.randint(1, len(selected_route) - 2)\n            customer = selected_route[customer_idx]\n\n            # Try to insert into another route\n            for route in new_solution:\n                if len(route) > 2:\n                    # Find best insertion position\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route)):\n                        # Calculate capacity and distance impact\n                        new_demand = np.sum(demand[route[1:-1]]) + demand[customer]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate distance increase\n                        dist_increase = (distance_matrix[route[pos-1]][customer] +\n                                       distance_matrix[customer][route[pos]] -\n                                       distance_matrix[route[pos-1]][route[pos]])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        route = np.insert(route, best_pos, customer)\n                        selected_route = np.delete(selected_route, customer_idx)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines route splitting, demand-based customer reallocation, and adaptive route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Check if route can be split or merged\n        if len(selected_route) > 3:  # Route has more than just depot and one customer\n            # Option 1: Split the route into two\n            split_pos = random.randint(1, len(selected_route) - 2)\n            new_route1 = np.concatenate([selected_route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], selected_route[split_pos:]])\n\n            # Check capacity constraints for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n        else:\n            # Option 2: Merge with another route if possible\n            other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n            if other_routes:\n                merge_idx = random.choice(other_routes)\n                merged_route = np.concatenate([new_solution[merge_idx][:-1], selected_route[1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[merge_idx] = merged_route\n                    del new_solution[route_idx]\n\n        # Option 3: Reallocate a customer from this route to another if possible\n        if len(selected_route) > 2:\n            customer_idx = random.randint(1, len(selected_route) - 2)\n            customer = selected_route[customer_idx]\n\n            # Try to insert into another route\n            for route in new_solution:\n                if len(route) > 2:\n                    # Find best insertion position\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route)):\n                        # Calculate capacity and distance impact\n                        new_demand = np.sum(demand[route[1:-1]]) + demand[customer]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate distance increase\n                        dist_increase = (distance_matrix[route[pos-1]][customer] +\n                                       distance_matrix[customer][route[pos]] -\n                                       distance_matrix[route[pos-1]][route[pos]])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        route = np.insert(route, best_pos, customer)\n                        selected_route = np.delete(selected_route, customer_idx)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7381189037676285,
            0.9575425982475281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Check if route can be split or merged\n        if len(selected_route) > 3:  # Route has more than just depot and one customer\n            # Option 1: Split the route into two\n            split_pos = random.randint(1, len(selected_route) - 2)\n            new_route1 = np.concatenate([selected_route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], selected_route[split_pos:]])\n\n            # Check capacity constraints for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n        else:\n            # Option 2: Merge with another route if possible\n            other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n            if other_routes:\n                merge_idx = random.choice(other_routes)\n                merged_route = np.concatenate([new_solution[merge_idx][:-1], selected_route[1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[merge_idx] = merged_route\n                    del new_solution[route_idx]\n\n        # Option 3: Reallocate a customer from this route to another if possible\n        if len(selected_route) > 2:\n            customer_idx = random.randint(1, len(selected_route) - 2)\n            customer = selected_route[customer_idx]\n\n            # Try to insert into another route\n            for route in new_solution:\n                if len(route) > 2:\n                    # Find best insertion position\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route)):\n                        # Calculate capacity and distance impact\n                        new_demand = np.sum(demand[route[1:-1]]) + demand[customer]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate distance increase\n                        dist_increase = (distance_matrix[route[pos-1]][customer] +\n                                       distance_matrix[customer][route[pos]] -\n                                       distance_matrix[route[pos-1]][route[pos]])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        route = np.insert(route, best_pos, customer)\n                        selected_route = np.delete(selected_route, customer_idx)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid operator: combine 2-opt with route splitting\n    if len(selected_route) > 4:\n        # Randomly select two non-depot nodes to swap (2-opt)\n        i, j = sorted(np.random.choice(range(1, len(selected_route)-1), 2, replace=False))\n        selected_route[i:j+1] = selected_route[i:j+1][::-1]\n\n        # Check capacity constraint after 2-opt\n        if np.sum(demand[selected_route[1:-1]]) > capacity:\n            # If violated, revert to original route\n            selected_route = base_solution[route_idx].copy()\n        else:\n            # If feasible, try splitting the route into two\n            split_point = np.random.randint(1, len(selected_route)-1)\n            new_route1 = np.concatenate((selected_route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], selected_route[split_point:]))\n\n            # Check capacity constraints for both new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                # Replace the original route with the two new routes\n                base_solution.pop(route_idx)\n                base_solution.insert(route_idx, new_route1)\n                base_solution.insert(route_idx + 1, new_route2)\n\n    # Apply a route relocation operator to balance makespan\n    if len(base_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = max(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n        shortest_route_idx = min(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n\n        longest_route = base_solution[longest_route_idx].copy()\n        shortest_route = base_solution[shortest_route_idx].copy()\n\n        # Try to move a customer from the longest to the shortest route\n        for node in longest_route[1:-1]:\n            # Check if moving this node to the shortest route is feasible\n            if (np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity and\n                len(shortest_route) < len(longest_route) - 2):  # Ensure we don't make routes too short\n                # Find the best insertion position in the shortest route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shortest_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[shortest_route[i-1], node] +\n                           distance_matrix[node, shortest_route[i]] -\n                           distance_matrix[shortest_route[i-1], shortest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Perform the move\n                shortest_route = np.insert(shortest_route, best_pos, node)\n                longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n\n                # Update the solution\n                base_solution[longest_route_idx] = longest_route\n                base_solution[shortest_route_idx] = shortest_route\n                break\n\n    return base_solution\n\n",
        "score": [
            -0.8361602171485933,
            0.7792419791221619
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid operator: combine 2-opt with route splitting\n    if len(selected_route) > 4:\n        # Randomly select two non-depot nodes to swap (2-opt)\n        i, j = sorted(np.random.choice(range(1, len(selected_route)-1), 2, replace=False))\n        selected_route[i:j+1] = selected_route[i:j+1][::-1]\n\n        # Check capacity constraint after 2-opt\n        if np.sum(demand[selected_route[1:-1]]) > capacity:\n            # If violated, revert to original route\n            selected_route = base_solution[route_idx].copy()\n        else:\n            # If feasible, try splitting the route into two\n            split_point = np.random.randint(1, len(selected_route)-1)\n            new_route1 = np.concatenate((selected_route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], selected_route[split_point:]))\n\n            # Check capacity constraints for both new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                # Replace the original route with the two new routes\n                base_solution.pop(route_idx)\n                base_solution.insert(route_idx, new_route1)\n                base_solution.insert(route_idx + 1, new_route2)\n\n    # Apply a route relocation operator to balance makespan\n    if len(base_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = max(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n        shortest_route_idx = min(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n\n        longest_route = base_solution[longest_route_idx].copy()\n        shortest_route = base_solution[shortest_route_idx].copy()\n\n        # Try to move a customer from the longest to the shortest route\n        for node in longest_route[1:-1]:\n            # Check if moving this node to the shortest route is feasible\n            if (np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity and\n                len(shortest_route) < len(longest_route) - 2):  # Ensure we don't make routes too short\n                # Find the best insertion position in the shortest route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shortest_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[shortest_route[i-1], node] +\n                           distance_matrix[node, shortest_route[i]] -\n                           distance_matrix[shortest_route[i-1], shortest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Perform the move\n                shortest_route = np.insert(shortest_route, best_pos, node)\n                longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n\n                # Update the solution\n                base_solution[longest_route_idx] = longest_route\n                base_solution[shortest_route_idx] = shortest_route\n                break\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid operator: combine 2-opt with route splitting\n    if len(selected_route) > 4:\n        # Randomly select two non-depot nodes to swap (2-opt)\n        i, j = sorted(np.random.choice(range(1, len(selected_route)-1), 2, replace=False))\n        selected_route[i:j+1] = selected_route[i:j+1][::-1]\n\n        # Check capacity constraint after 2-opt\n        if np.sum(demand[selected_route[1:-1]]) > capacity:\n            # If violated, revert to original route\n            selected_route = base_solution[route_idx].copy()\n        else:\n            # If feasible, try splitting the route into two\n            split_point = np.random.randint(1, len(selected_route)-1)\n            new_route1 = np.concatenate((selected_route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], selected_route[split_point:]))\n\n            # Check capacity constraints for both new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                # Replace the original route with the two new routes\n                base_solution.pop(route_idx)\n                base_solution.insert(route_idx, new_route1)\n                base_solution.insert(route_idx + 1, new_route2)\n\n    # Apply a route relocation operator to balance makespan\n    if len(base_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = max(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n        shortest_route_idx = min(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n\n        longest_route = base_solution[longest_route_idx].copy()\n        shortest_route = base_solution[shortest_route_idx].copy()\n\n        # Try to move a customer from the longest to the shortest route\n        for node in longest_route[1:-1]:\n            # Check if moving this node to the shortest route is feasible\n            if (np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity and\n                len(shortest_route) < len(longest_route) - 2):  # Ensure we don't make routes too short\n                # Find the best insertion position in the shortest route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shortest_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[shortest_route[i-1], node] +\n                           distance_matrix[node, shortest_route[i]] -\n                           distance_matrix[shortest_route[i-1], shortest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Perform the move\n                shortest_route = np.insert(shortest_route, best_pos, node)\n                longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n\n                # Update the solution\n                base_solution[longest_route_idx] = longest_route\n                base_solution[shortest_route_idx] = shortest_route\n                break\n\n    return base_solution\n\n",
        "score": [
            -0.8361602171485933,
            0.7792419791221619
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid operator: combine 2-opt with route splitting\n    if len(selected_route) > 4:\n        # Randomly select two non-depot nodes to swap (2-opt)\n        i, j = sorted(np.random.choice(range(1, len(selected_route)-1), 2, replace=False))\n        selected_route[i:j+1] = selected_route[i:j+1][::-1]\n\n        # Check capacity constraint after 2-opt\n        if np.sum(demand[selected_route[1:-1]]) > capacity:\n            # If violated, revert to original route\n            selected_route = base_solution[route_idx].copy()\n        else:\n            # If feasible, try splitting the route into two\n            split_point = np.random.randint(1, len(selected_route)-1)\n            new_route1 = np.concatenate((selected_route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], selected_route[split_point:]))\n\n            # Check capacity constraints for both new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                # Replace the original route with the two new routes\n                base_solution.pop(route_idx)\n                base_solution.insert(route_idx, new_route1)\n                base_solution.insert(route_idx + 1, new_route2)\n\n    # Apply a route relocation operator to balance makespan\n    if len(base_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = max(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n        shortest_route_idx = min(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n\n        longest_route = base_solution[longest_route_idx].copy()\n        shortest_route = base_solution[shortest_route_idx].copy()\n\n        # Try to move a customer from the longest to the shortest route\n        for node in longest_route[1:-1]:\n            # Check if moving this node to the shortest route is feasible\n            if (np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity and\n                len(shortest_route) < len(longest_route) - 2):  # Ensure we don't make routes too short\n                # Find the best insertion position in the shortest route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shortest_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[shortest_route[i-1], node] +\n                           distance_matrix[node, shortest_route[i]] -\n                           distance_matrix[shortest_route[i-1], shortest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Perform the move\n                shortest_route = np.insert(shortest_route, best_pos, node)\n                longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n\n                # Update the solution\n                base_solution[longest_route_idx] = longest_route\n                base_solution[shortest_route_idx] = shortest_route\n                break\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid operator: combine 2-opt with route splitting\n    if len(selected_route) > 4:\n        # Randomly select two non-depot nodes to swap (2-opt)\n        i, j = sorted(np.random.choice(range(1, len(selected_route)-1), 2, replace=False))\n        selected_route[i:j+1] = selected_route[i:j+1][::-1]\n\n        # Check capacity constraint after 2-opt\n        if np.sum(demand[selected_route[1:-1]]) > capacity:\n            # If violated, revert to original route\n            selected_route = base_solution[route_idx].copy()\n        else:\n            # If feasible, try splitting the route into two\n            split_point = np.random.randint(1, len(selected_route)-1)\n            new_route1 = np.concatenate((selected_route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], selected_route[split_point:]))\n\n            # Check capacity constraints for both new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                # Replace the original route with the two new routes\n                base_solution.pop(route_idx)\n                base_solution.insert(route_idx, new_route1)\n                base_solution.insert(route_idx + 1, new_route2)\n\n    # Apply a route relocation operator to balance makespan\n    if len(base_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = max(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n        shortest_route_idx = min(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n\n        longest_route = base_solution[longest_route_idx].copy()\n        shortest_route = base_solution[shortest_route_idx].copy()\n\n        # Try to move a customer from the longest to the shortest route\n        for node in longest_route[1:-1]:\n            # Check if moving this node to the shortest route is feasible\n            if (np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity and\n                len(shortest_route) < len(longest_route) - 2):  # Ensure we don't make routes too short\n                # Find the best insertion position in the shortest route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shortest_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[shortest_route[i-1], node] +\n                           distance_matrix[node, shortest_route[i]] -\n                           distance_matrix[shortest_route[i-1], shortest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Perform the move\n                shortest_route = np.insert(shortest_route, best_pos, node)\n                longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n\n                # Update the solution\n                base_solution[longest_route_idx] = longest_route\n                base_solution[shortest_route_idx] = shortest_route\n                break\n\n    return base_solution\n\n",
        "score": [
            -0.8361602171485933,
            0.7792419791221619
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid operator: combine 2-opt with route splitting\n    if len(selected_route) > 4:\n        # Randomly select two non-depot nodes to swap (2-opt)\n        i, j = sorted(np.random.choice(range(1, len(selected_route)-1), 2, replace=False))\n        selected_route[i:j+1] = selected_route[i:j+1][::-1]\n\n        # Check capacity constraint after 2-opt\n        if np.sum(demand[selected_route[1:-1]]) > capacity:\n            # If violated, revert to original route\n            selected_route = base_solution[route_idx].copy()\n        else:\n            # If feasible, try splitting the route into two\n            split_point = np.random.randint(1, len(selected_route)-1)\n            new_route1 = np.concatenate((selected_route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], selected_route[split_point:]))\n\n            # Check capacity constraints for both new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                # Replace the original route with the two new routes\n                base_solution.pop(route_idx)\n                base_solution.insert(route_idx, new_route1)\n                base_solution.insert(route_idx + 1, new_route2)\n\n    # Apply a route relocation operator to balance makespan\n    if len(base_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = max(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n        shortest_route_idx = min(range(len(base_solution)), key=lambda i: len(base_solution[i]))\n\n        longest_route = base_solution[longest_route_idx].copy()\n        shortest_route = base_solution[shortest_route_idx].copy()\n\n        # Try to move a customer from the longest to the shortest route\n        for node in longest_route[1:-1]:\n            # Check if moving this node to the shortest route is feasible\n            if (np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity and\n                len(shortest_route) < len(longest_route) - 2):  # Ensure we don't make routes too short\n                # Find the best insertion position in the shortest route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shortest_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[shortest_route[i-1], node] +\n                           distance_matrix[node, shortest_route[i]] -\n                           distance_matrix[shortest_route[i-1], shortest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Perform the move\n                shortest_route = np.insert(shortest_route, best_pos, node)\n                longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n\n                # Update the solution\n                base_solution[longest_route_idx] = longest_route\n                base_solution[shortest_route_idx] = shortest_route\n                break\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A hybrid local search operator that combines route segment swapping with demand-aware route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([(d + m) / 2 for _, (d, m) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap with demand-aware merging\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find feasible segments to swap\n        for _ in range(10):  # Try multiple times\n            # Randomly select segments from each route (excluding depot)\n            seg1_start = np.random.randint(1, len(route1)-1)\n            seg1_end = np.random.randint(seg1_start, len(route1)-1)\n            seg2_start = np.random.randint(1, len(route2)-1)\n            seg2_end = np.random.randint(seg2_start, len(route2)-1)\n\n            # Check capacity constraints for both routes after swap\n            seg1_demand = np.sum(demand[route1[seg1_start:seg1_end+1]])\n            seg2_demand = np.sum(demand[route2[seg2_start:seg2_end+1]])\n            route1_demand = np.sum(demand[route1[1:-1]]) - seg1_demand + seg2_demand\n            route2_demand = np.sum(demand[route2[1:-1]]) - seg2_demand + seg1_demand\n\n            if route1_demand <= capacity and route2_demand <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end+1], route1[seg1_end+1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end+1], route2[seg2_end+1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Try demand-aware merging if routes are too short\n                if len(new_route1) <= 3 or len(new_route2) <= 3:\n                    # Find the closest route for potential merging\n                    for i, route in enumerate(new_solution):\n                        if i != route1_idx and i != route2_idx:\n                            merged_demand = np.sum(demand[route[1:-1]])\n                            if merged_demand + seg1_demand <= capacity:\n                                new_route = np.concatenate([route[:-1], new_route1[1:]])\n                                new_solution[i] = new_route\n                                new_solution = np.delete(new_solution, route1_idx)\n                                break\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6333408641152671,
            1.3081625401973724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([(d + m) / 2 for _, (d, m) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap with demand-aware merging\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find feasible segments to swap\n        for _ in range(10):  # Try multiple times\n            # Randomly select segments from each route (excluding depot)\n            seg1_start = np.random.randint(1, len(route1)-1)\n            seg1_end = np.random.randint(seg1_start, len(route1)-1)\n            seg2_start = np.random.randint(1, len(route2)-1)\n            seg2_end = np.random.randint(seg2_start, len(route2)-1)\n\n            # Check capacity constraints for both routes after swap\n            seg1_demand = np.sum(demand[route1[seg1_start:seg1_end+1]])\n            seg2_demand = np.sum(demand[route2[seg2_start:seg2_end+1]])\n            route1_demand = np.sum(demand[route1[1:-1]]) - seg1_demand + seg2_demand\n            route2_demand = np.sum(demand[route2[1:-1]]) - seg2_demand + seg1_demand\n\n            if route1_demand <= capacity and route2_demand <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end+1], route1[seg1_end+1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end+1], route2[seg2_end+1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Try demand-aware merging if routes are too short\n                if len(new_route1) <= 3 or len(new_route2) <= 3:\n                    # Find the closest route for potential merging\n                    for i, route in enumerate(new_solution):\n                        if i != route1_idx and i != route2_idx:\n                            merged_demand = np.sum(demand[route[1:-1]])\n                            if merged_demand + seg1_demand <= capacity:\n                                new_route = np.concatenate([route[:-1], new_route1[1:]])\n                                new_solution[i] = new_route\n                                new_solution = np.delete(new_solution, route1_idx)\n                                break\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    if len(base_solution) > 1:\n        route_idx = np.random.randint(0, len(base_solution))\n        route = base_solution[route_idx].copy()\n\n        # Apply a hybrid local search: combine route reversal and insertion\n        if len(route) > 3:  # Ensure route has enough nodes to modify\n            # Reverse a segment of the route\n            start, end = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            route[start:end+1] = route[start:end+1][::-1]\n\n            # Check capacity constraint\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # If invalid, undo reversal and try insertion instead\n                route = base_solution[route_idx].copy()\n                # Find a random customer to move to another route\n                customer_idx = np.random.randint(1, len(route)-1)\n                customer = route[customer_idx]\n                # Remove customer from current route\n                route = np.delete(route, customer_idx)\n                # Try to insert into another route\n                for i in range(len(base_solution)):\n                    if i != route_idx:\n                        other_route = base_solution[i].copy()\n                        # Try inserting at all possible positions\n                        for pos in range(1, len(other_route)):\n                            new_route = np.insert(other_route, pos, customer)\n                            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                base_solution[i] = new_route\n                                break\n        base_solution[route_idx] = route\n\n    return base_solution\n\n",
        "score": [
            -0.5366134526203131,
            0.6977114677429199
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    if len(base_solution) > 1:\n        route_idx = np.random.randint(0, len(base_solution))\n        route = base_solution[route_idx].copy()\n\n        # Apply a hybrid local search: combine route reversal and insertion\n        if len(route) > 3:  # Ensure route has enough nodes to modify\n            # Reverse a segment of the route\n            start, end = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            route[start:end+1] = route[start:end+1][::-1]\n\n            # Check capacity constraint\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # If invalid, undo reversal and try insertion instead\n                route = base_solution[route_idx].copy()\n                # Find a random customer to move to another route\n                customer_idx = np.random.randint(1, len(route)-1)\n                customer = route[customer_idx]\n                # Remove customer from current route\n                route = np.delete(route, customer_idx)\n                # Try to insert into another route\n                for i in range(len(base_solution)):\n                    if i != route_idx:\n                        other_route = base_solution[i].copy()\n                        # Try inserting at all possible positions\n                        for pos in range(1, len(other_route)):\n                            new_route = np.insert(other_route, pos, customer)\n                            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                base_solution[i] = new_route\n                                break\n        base_solution[route_idx] = route\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    if len(base_solution) > 1:\n        route_idx = np.random.randint(0, len(base_solution))\n        route = base_solution[route_idx].copy()\n\n        # Apply a hybrid local search: combine route reversal and insertion\n        if len(route) > 3:  # Ensure route has enough nodes to modify\n            # Reverse a segment of the route\n            start, end = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            route[start:end+1] = route[start:end+1][::-1]\n\n            # Check capacity constraint\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # If invalid, undo reversal and try insertion instead\n                route = base_solution[route_idx].copy()\n                # Find a random customer to move to another route\n                customer_idx = np.random.randint(1, len(route)-1)\n                customer = route[customer_idx]\n                # Remove customer from current route\n                route = np.delete(route, customer_idx)\n                # Try to insert into another route\n                for i in range(len(base_solution)):\n                    if i != route_idx:\n                        other_route = base_solution[i].copy()\n                        # Try inserting at all possible positions\n                        for pos in range(1, len(other_route)):\n                            new_route = np.insert(other_route, pos, customer)\n                            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                base_solution[i] = new_route\n                                break\n        base_solution[route_idx] = route\n\n    return base_solution\n\n",
        "score": [
            -0.5366134526203131,
            0.6977114677429199
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    if len(base_solution) > 1:\n        route_idx = np.random.randint(0, len(base_solution))\n        route = base_solution[route_idx].copy()\n\n        # Apply a hybrid local search: combine route reversal and insertion\n        if len(route) > 3:  # Ensure route has enough nodes to modify\n            # Reverse a segment of the route\n            start, end = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            route[start:end+1] = route[start:end+1][::-1]\n\n            # Check capacity constraint\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # If invalid, undo reversal and try insertion instead\n                route = base_solution[route_idx].copy()\n                # Find a random customer to move to another route\n                customer_idx = np.random.randint(1, len(route)-1)\n                customer = route[customer_idx]\n                # Remove customer from current route\n                route = np.delete(route, customer_idx)\n                # Try to insert into another route\n                for i in range(len(base_solution)):\n                    if i != route_idx:\n                        other_route = base_solution[i].copy()\n                        # Try inserting at all possible positions\n                        for pos in range(1, len(other_route)):\n                            new_route = np.insert(other_route, pos, customer)\n                            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                base_solution[i] = new_route\n                                break\n        base_solution[route_idx] = route\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize high makespan\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a demand-aware swap\n    improved = False\n    for i in range(1, len(route) - 2):\n        for j in range(i + 1, len(route) - 1):\n            # Try a 2-opt swap\n            new_route = route.copy()\n            new_route[i:j+1] = route[j:i-1:-1]\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                # If feasible, accept the swap\n                route = new_route\n                improved = True\n\n            # Try a demand-aware swap: move a high-demand node to a different position\n            if np.random.rand() < 0.3:  # 30% chance of demand-aware swap\n                high_demand_nodes = np.argsort(demand[route[1:-1]])[-2:]  # Top 2 high-demand nodes\n                for node in high_demand_nodes:\n                    for pos in range(1, len(route) - 1):\n                        if pos != node + 1:  # Avoid same position\n                            new_route = route.copy()\n                            new_route[pos] = route[node + 1]\n                            new_route[node + 1] = route[pos]\n\n                            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                route = new_route\n                                improved = True\n\n    # Update the solution with the modified route\n    selected_solution[route_idx] = route\n\n    # Optionally, apply a route merge or split to further improve\n    if len(selected_solution) > 1 and np.random.rand() < 0.2:  # 20% chance of merge/split\n        # Try merging two routes if their combined demand is <= capacity\n        for i in range(len(selected_solution)):\n            for j in range(i + 1, len(selected_solution)):\n                combined_demand = np.sum(demand[selected_solution[i][1:-1]]) + np.sum(demand[selected_solution[j][1:-1]])\n                if combined_demand <= capacity:\n                    # Merge routes i and j\n                    merged_route = np.concatenate([selected_solution[i][:-1], selected_solution[j][1:]])\n                    selected_solution = [merged_route if k == i else route for k, route in enumerate(selected_solution) if k != j]\n                    break\n\n    return selected_solution\n\n",
        "score": [
            -0.6708282689930352,
            9.13568115234375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize high makespan\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a demand-aware swap\n    improved = False\n    for i in range(1, len(route) - 2):\n        for j in range(i + 1, len(route) - 1):\n            # Try a 2-opt swap\n            new_route = route.copy()\n            new_route[i:j+1] = route[j:i-1:-1]\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                # If feasible, accept the swap\n                route = new_route\n                improved = True\n\n            # Try a demand-aware swap: move a high-demand node to a different position\n            if np.random.rand() < 0.3:  # 30% chance of demand-aware swap\n                high_demand_nodes = np.argsort(demand[route[1:-1]])[-2:]  # Top 2 high-demand nodes\n                for node in high_demand_nodes:\n                    for pos in range(1, len(route) - 1):\n                        if pos != node + 1:  # Avoid same position\n                            new_route = route.copy()\n                            new_route[pos] = route[node + 1]\n                            new_route[node + 1] = route[pos]\n\n                            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                route = new_route\n                                improved = True\n\n    # Update the solution with the modified route\n    selected_solution[route_idx] = route\n\n    # Optionally, apply a route merge or split to further improve\n    if len(selected_solution) > 1 and np.random.rand() < 0.2:  # 20% chance of merge/split\n        # Try merging two routes if their combined demand is <= capacity\n        for i in range(len(selected_solution)):\n            for j in range(i + 1, len(selected_solution)):\n                combined_demand = np.sum(demand[selected_solution[i][1:-1]]) + np.sum(demand[selected_solution[j][1:-1]])\n                if combined_demand <= capacity:\n                    # Merge routes i and j\n                    merged_route = np.concatenate([selected_solution[i][:-1], selected_solution[j][1:]])\n                    selected_solution = [merged_route if k == i else route for k, route in enumerate(selected_solution) if k != j]\n                    break\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and route diversity, then applies a hybrid local search combining route fragmentation and capacity-aware reinsertion to generate a neighbor solution that balances distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    min_total_distance = float('inf')\n    max_makespan = float('inf')\n\n    for sol, (total_dist, makespan) in archive:\n        if total_dist < min_total_distance or (total_dist == min_total_distance and makespan < max_makespan):\n            min_total_distance = total_dist\n            max_makespan = makespan\n            selected_solution = sol\n\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: route fragmentation and reinsertion\n    new_solution = []\n\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Fragment the route by removing a random segment\n        frag_point1 = random.randint(1, len(route) - 2)\n        frag_point2 = random.randint(frag_point1 + 1, len(route) - 1)\n        segment = route[frag_point1:frag_point2]\n        remaining_route = np.concatenate([route[:frag_point1], route[frag_point2:]])\n\n        # Try to reinsert the segment into the best position in the same route\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(1, len(remaining_route)):\n            # Insert segment before position i\n            new_route = np.concatenate([remaining_route[:i], segment, remaining_route[i:]])\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                # Calculate insertion cost (approximate)\n                cost = distance_matrix[new_route[i-1], segment[0]] + distance_matrix[segment[-1], new_route[i]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_route = np.concatenate([remaining_route[:best_pos], segment, remaining_route[best_pos:]])\n            new_solution.append(new_route)\n        else:\n            new_solution.append(remaining_route)\n\n    # Try to merge routes if possible (to reduce makespan)\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        route_i = new_solution[i]\n        merged = False\n        for j in range(i + 1, len(new_solution)):\n            route_j = new_solution[j]\n            # Check if merging is feasible\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                merged_solution.append(merged_route)\n                merged = True\n                i = j + 1\n                break\n        if not merged:\n            merged_solution.append(route_i)\n            i += 1\n\n    return merged_solution\n\n",
        "score": [
            -0.5697332985041397,
            4.76633882522583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    min_total_distance = float('inf')\n    max_makespan = float('inf')\n\n    for sol, (total_dist, makespan) in archive:\n        if total_dist < min_total_distance or (total_dist == min_total_distance and makespan < max_makespan):\n            min_total_distance = total_dist\n            max_makespan = makespan\n            selected_solution = sol\n\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: route fragmentation and reinsertion\n    new_solution = []\n\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Fragment the route by removing a random segment\n        frag_point1 = random.randint(1, len(route) - 2)\n        frag_point2 = random.randint(frag_point1 + 1, len(route) - 1)\n        segment = route[frag_point1:frag_point2]\n        remaining_route = np.concatenate([route[:frag_point1], route[frag_point2:]])\n\n        # Try to reinsert the segment into the best position in the same route\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(1, len(remaining_route)):\n            # Insert segment before position i\n            new_route = np.concatenate([remaining_route[:i], segment, remaining_route[i:]])\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                # Calculate insertion cost (approximate)\n                cost = distance_matrix[new_route[i-1], segment[0]] + distance_matrix[segment[-1], new_route[i]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_route = np.concatenate([remaining_route[:best_pos], segment, remaining_route[best_pos:]])\n            new_solution.append(new_route)\n        else:\n            new_solution.append(remaining_route)\n\n    # Try to merge routes if possible (to reduce makespan)\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        route_i = new_solution[i]\n        merged = False\n        for j in range(i + 1, len(new_solution)):\n            route_j = new_solution[j]\n            # Check if merging is feasible\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                merged_solution.append(merged_route)\n                merged = True\n                i = j + 1\n                break\n        if not merged:\n            merged_solution.append(route_i)\n            i += 1\n\n    return merged_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and applies a hybrid local search operator that combines route segment swapping with demand-aware route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for sol, obj in archive])  # Prioritize solutions with high makespan relative to distance\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route segment swapping with demand-aware merging\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find feasible split points in both routes\n        def get_feasible_splits(route):\n            splits = []\n            current_load = 0\n            for i in range(1, len(route)-1):\n                current_load += demand[route[i]]\n                if current_load <= capacity:\n                    splits.append(i)\n            return splits\n\n        splits1 = get_feasible_splits(route1)\n        splits2 = get_feasible_splits(route2)\n\n        if splits1 and splits2:\n            # Randomly select split points\n            split1 = np.random.choice(splits1)\n            split2 = np.random.choice(splits2)\n\n            # Create segments\n            segment1 = route1[split1:-1]\n            segment2 = route2[split2:-1]\n\n            # Calculate loads\n            load1 = sum(demand[segment1])\n            load2 = sum(demand[segment2])\n\n            # Try to merge segments if demand allows\n            if load1 + load2 <= capacity:\n                # Merge segments\n                merged_route = np.concatenate([route1[:split1], segment2, [0], segment1, route2[split2+1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n            else:\n                # Swap segments\n                new_route1 = np.concatenate([route1[:split1], segment2, route1[split1+1:]])\n                new_route2 = np.concatenate([route2[:split2], segment1, route2[split2+1:]])\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Ensure all routes are feasible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, split the route at the first violation\n            current_load = 0\n            split_point = 1\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_point = j\n                    break\n            # Create two new routes\n            route1 = np.concatenate([route[:split_point], [0]])\n            route2 = np.concatenate([[0], route[split_point:]])\n            new_solution[i] = route1\n            new_solution.insert(i+1, route2)\n\n    return new_solution\n\n",
        "score": [
            -0.7676073053433576,
            0.8392346501350403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for sol, obj in archive])  # Prioritize solutions with high makespan relative to distance\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route segment swapping with demand-aware merging\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find feasible split points in both routes\n        def get_feasible_splits(route):\n            splits = []\n            current_load = 0\n            for i in range(1, len(route)-1):\n                current_load += demand[route[i]]\n                if current_load <= capacity:\n                    splits.append(i)\n            return splits\n\n        splits1 = get_feasible_splits(route1)\n        splits2 = get_feasible_splits(route2)\n\n        if splits1 and splits2:\n            # Randomly select split points\n            split1 = np.random.choice(splits1)\n            split2 = np.random.choice(splits2)\n\n            # Create segments\n            segment1 = route1[split1:-1]\n            segment2 = route2[split2:-1]\n\n            # Calculate loads\n            load1 = sum(demand[segment1])\n            load2 = sum(demand[segment2])\n\n            # Try to merge segments if demand allows\n            if load1 + load2 <= capacity:\n                # Merge segments\n                merged_route = np.concatenate([route1[:split1], segment2, [0], segment1, route2[split2+1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n            else:\n                # Swap segments\n                new_route1 = np.concatenate([route1[:split1], segment2, route1[split1+1:]])\n                new_route2 = np.concatenate([route2[:split2], segment1, route2[split2+1:]])\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Ensure all routes are feasible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, split the route at the first violation\n            current_load = 0\n            split_point = 1\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_point = j\n                    break\n            # Create two new routes\n            route1 = np.concatenate([route[:split_point], [0]])\n            route2 = np.concatenate([[0], route[split_point:]])\n            new_solution[i] = route1\n            new_solution.insert(i+1, route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The algorithm selects a promising solution from the archive by favoring those with low total distance and makespan, then applies a hybrid local search combining 2-opt with a novel route-splitting heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Apply 2-opt on a randomly selected route, then try to split long routes\n    if len(new_solution) > 1:\n        # Randomly select a route to apply 2-opt\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        # Apply 2-opt on the selected route\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(route) - 2):\n                for j in range(i + 1, len(route) - 1):\n                    # Check if reversing the segment between i and j improves the route\n                    old_dist = (distance_matrix[route[i-1], route[i]] +\n                                distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_dist < old_dist:\n                        # Reverse the segment\n                        route[i:j+1] = route[i:j+1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n        new_solution[route_idx] = route\n\n        # Try to split a long route into two feasible routes\n        long_route_idx = np.argmax([len(r) for r in new_solution])\n        long_route = new_solution[long_route_idx]\n        if len(long_route) > 3:  # Only split if the route has more than 3 nodes\n            # Find the best split point that minimizes the total distance increase\n            best_split = None\n            best_increase = float('inf')\n            for split in range(1, len(long_route) - 1):\n                # Calculate the total demand for the first part of the split\n                first_part_demand = sum(demand[long_route[1:split+1]])\n                if first_part_demand > capacity:\n                    continue  # Skip if the first part exceeds capacity\n\n                # Calculate the total demand for the second part of the split\n                second_part_demand = sum(demand[long_route[split+1:-1]])\n                if second_part_demand > capacity:\n                    continue  # Skip if the second part exceeds capacity\n\n                # Calculate the distance increase from splitting\n                original_dist = (distance_matrix[long_route[split-1], long_route[split]] +\n                                 distance_matrix[long_route[split], long_route[split+1]])\n                new_dist = (distance_matrix[long_route[split-1], 0] +\n                            distance_matrix[0, long_route[split]] +\n                            distance_matrix[long_route[split], 0] +\n                            distance_matrix[0, long_route[split+1]])\n                increase = new_dist - original_dist\n\n                if increase < best_increase:\n                    best_increase = increase\n                    best_split = split\n\n            if best_split is not None:\n                # Perform the split\n                first_part = np.concatenate(([0], long_route[1:best_split+1], [0]))\n                second_part = np.concatenate(([0], long_route[best_split+1:-1], [0]))\n                new_solution.pop(long_route_idx)\n                new_solution.append(first_part)\n                new_solution.append(second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.38789792136726287,
            9.11775016784668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Apply 2-opt on a randomly selected route, then try to split long routes\n    if len(new_solution) > 1:\n        # Randomly select a route to apply 2-opt\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        # Apply 2-opt on the selected route\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(route) - 2):\n                for j in range(i + 1, len(route) - 1):\n                    # Check if reversing the segment between i and j improves the route\n                    old_dist = (distance_matrix[route[i-1], route[i]] +\n                                distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_dist < old_dist:\n                        # Reverse the segment\n                        route[i:j+1] = route[i:j+1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n        new_solution[route_idx] = route\n\n        # Try to split a long route into two feasible routes\n        long_route_idx = np.argmax([len(r) for r in new_solution])\n        long_route = new_solution[long_route_idx]\n        if len(long_route) > 3:  # Only split if the route has more than 3 nodes\n            # Find the best split point that minimizes the total distance increase\n            best_split = None\n            best_increase = float('inf')\n            for split in range(1, len(long_route) - 1):\n                # Calculate the total demand for the first part of the split\n                first_part_demand = sum(demand[long_route[1:split+1]])\n                if first_part_demand > capacity:\n                    continue  # Skip if the first part exceeds capacity\n\n                # Calculate the total demand for the second part of the split\n                second_part_demand = sum(demand[long_route[split+1:-1]])\n                if second_part_demand > capacity:\n                    continue  # Skip if the second part exceeds capacity\n\n                # Calculate the distance increase from splitting\n                original_dist = (distance_matrix[long_route[split-1], long_route[split]] +\n                                 distance_matrix[long_route[split], long_route[split+1]])\n                new_dist = (distance_matrix[long_route[split-1], 0] +\n                            distance_matrix[0, long_route[split]] +\n                            distance_matrix[long_route[split], 0] +\n                            distance_matrix[0, long_route[split+1]])\n                increase = new_dist - original_dist\n\n                if increase < best_increase:\n                    best_increase = increase\n                    best_split = split\n\n            if best_split is not None:\n                # Perform the split\n                first_part = np.concatenate(([0], long_route[1:best_split+1], [0]))\n                second_part = np.concatenate(([0], long_route[best_split+1:-1], [0]))\n                new_solution.pop(long_route_idx)\n                new_solution.append(first_part)\n                new_solution.append(second_part)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan (longest route) and applies a hybrid local search operator that combines route splitting and customer reallocation to balance route lengths and reduce total distance while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Find the longest route in the solution\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Calculate total demand of the longest route\n    total_demand = sum(demand[longest_route[1:-1]])\n\n    # If the longest route can be split into two feasible routes\n    if total_demand <= 2 * capacity:\n        # Find the split point that balances the demands\n        split_demand = total_demand / 2\n        cumulative_demand = 0\n        split_point = 1  # Start after depot\n\n        for i in range(1, len(longest_route) - 1):\n            cumulative_demand += demand[longest_route[i]]\n            if cumulative_demand >= split_demand:\n                split_point = i\n                break\n\n        # Split the route into two\n        route1 = np.concatenate([longest_route[:split_point + 1], [0]])\n        route2 = np.concatenate([[0], longest_route[split_point + 1:]])\n\n        # Replace the original route with the two new routes\n        new_solution[longest_route_idx] = route1\n        new_solution.insert(longest_route_idx + 1, route2)\n\n        # Check capacity constraints for the new routes\n        if sum(demand[route1[1:-1]]) > capacity or sum(demand[route2[1:-1]]) > capacity:\n            # If split violates capacity, revert to original solution\n            new_solution = selected_solution.copy()\n    else:\n        # If the route cannot be split, try reallocating customers to other routes\n        for i in range(1, len(longest_route) - 1):\n            customer = longest_route[i]\n            best_route_idx = -1\n            best_insert_pos = -1\n            best_insert_cost = float('inf')\n\n            # Try inserting the customer into other routes\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n                route = new_solution[j]\n\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position in this route\n                for k in range(1, len(route)):\n                    # Calculate insertion cost (distance increase)\n                    cost = (distance_matrix[route[k-1]][customer] +\n                            distance_matrix[customer][route[k]] -\n                            distance_matrix[route[k-1]][route[k]])\n\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_route_idx = j\n                        best_insert_pos = k\n\n            # Perform the best insertion if found\n            if best_route_idx != -1:\n                # Remove customer from original route\n                longest_route = np.delete(longest_route, i)\n\n                # Insert customer into the best route\n                route = new_solution[best_route_idx]\n                new_solution[best_route_idx] = np.insert(route, best_insert_pos, customer)\n\n                # Update the longest route reference\n                new_solution[longest_route_idx] = longest_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6663971181052403,
            0.9456296563148499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Find the longest route in the solution\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Calculate total demand of the longest route\n    total_demand = sum(demand[longest_route[1:-1]])\n\n    # If the longest route can be split into two feasible routes\n    if total_demand <= 2 * capacity:\n        # Find the split point that balances the demands\n        split_demand = total_demand / 2\n        cumulative_demand = 0\n        split_point = 1  # Start after depot\n\n        for i in range(1, len(longest_route) - 1):\n            cumulative_demand += demand[longest_route[i]]\n            if cumulative_demand >= split_demand:\n                split_point = i\n                break\n\n        # Split the route into two\n        route1 = np.concatenate([longest_route[:split_point + 1], [0]])\n        route2 = np.concatenate([[0], longest_route[split_point + 1:]])\n\n        # Replace the original route with the two new routes\n        new_solution[longest_route_idx] = route1\n        new_solution.insert(longest_route_idx + 1, route2)\n\n        # Check capacity constraints for the new routes\n        if sum(demand[route1[1:-1]]) > capacity or sum(demand[route2[1:-1]]) > capacity:\n            # If split violates capacity, revert to original solution\n            new_solution = selected_solution.copy()\n    else:\n        # If the route cannot be split, try reallocating customers to other routes\n        for i in range(1, len(longest_route) - 1):\n            customer = longest_route[i]\n            best_route_idx = -1\n            best_insert_pos = -1\n            best_insert_cost = float('inf')\n\n            # Try inserting the customer into other routes\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n                route = new_solution[j]\n\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position in this route\n                for k in range(1, len(route)):\n                    # Calculate insertion cost (distance increase)\n                    cost = (distance_matrix[route[k-1]][customer] +\n                            distance_matrix[customer][route[k]] -\n                            distance_matrix[route[k-1]][route[k]])\n\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_route_idx = j\n                        best_insert_pos = k\n\n            # Perform the best insertion if found\n            if best_route_idx != -1:\n                # Remove customer from original route\n                longest_route = np.delete(longest_route, i)\n\n                # Insert customer into the best route\n                route = new_solution[best_route_idx]\n                new_solution[best_route_idx] = np.insert(route, best_insert_pos, customer)\n\n                # Update the longest route reference\n                new_solution[longest_route_idx] = longest_route\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Perform a hybrid local search: combine 2-opt with route splitting\n        improved_route = route.copy()\n        start_idx = np.random.randint(1, len(improved_route) - 2)\n        end_idx = np.random.randint(start_idx + 1, len(improved_route) - 1)\n\n        # Try 2-opt swap\n        new_route = improved_route.copy()\n        new_route[start_idx:end_idx] = improved_route[end_idx-1:start_idx-1:-1]\n\n        # Check feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            improved_route = new_route\n\n        # Try splitting the route at a random point\n        split_point = np.random.randint(1, len(improved_route) - 1)\n        split_route1 = improved_route[:split_point + 1]\n        split_route2 = improved_route[split_point:]\n\n        # Check feasibility of both new routes\n        if (np.sum(demand[split_route1[1:-1]]) <= capacity and\n            np.sum(demand[split_route2[1:-1]]) <= capacity):\n            new_solution.extend([split_route1, split_route2])\n        else:\n            new_solution.append(improved_route)\n\n    # Remove empty routes and ensure depot is properly handled\n    new_solution = [r for r in new_solution if len(r) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7982839334347094,
            1.5296688377857208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Perform a hybrid local search: combine 2-opt with route splitting\n        improved_route = route.copy()\n        start_idx = np.random.randint(1, len(improved_route) - 2)\n        end_idx = np.random.randint(start_idx + 1, len(improved_route) - 1)\n\n        # Try 2-opt swap\n        new_route = improved_route.copy()\n        new_route[start_idx:end_idx] = improved_route[end_idx-1:start_idx-1:-1]\n\n        # Check feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            improved_route = new_route\n\n        # Try splitting the route at a random point\n        split_point = np.random.randint(1, len(improved_route) - 1)\n        split_route1 = improved_route[:split_point + 1]\n        split_route2 = improved_route[split_point:]\n\n        # Check feasibility of both new routes\n        if (np.sum(demand[split_route1[1:-1]]) <= capacity and\n            np.sum(demand[split_route2[1:-1]]) <= capacity):\n            new_solution.extend([split_route1, split_route2])\n        else:\n            new_solution.append(improved_route)\n\n    # Remove empty routes and ensure depot is properly handled\n    new_solution = [r for r in new_solution if len(r) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by prioritizing those with lower total distance and makespan, then applies a hybrid local search combining route segmentation and customer reinsertion with capacity-aware optimizations to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route segmentation and customer reinsertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment of the route to modify\n        start = random.randint(1, len(route) - 3)\n        end = random.randint(start + 1, len(route) - 2)\n        segment = route[start:end]\n\n        # Calculate current segment distance and demand\n        segment_distance = sum(distance_matrix[route[i]][route[i+1]] for i in range(start, end))\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Remove the segment from the route\n        new_route = np.concatenate([route[:start], route[end:]]).tolist()\n\n        # Find the best insertion position for the segment in the same route\n        best_insert_pos = start\n        best_insert_distance = float('inf')\n\n        for pos in range(len(new_route) - 1):\n            # Check capacity constraint\n            if pos == 0:\n                # Insert at the beginning of the route\n                new_demand = sum(demand[node] for node in segment) + sum(demand[node] for node in new_route[1:])\n            elif pos == len(new_route) - 2:\n                # Insert at the end of the route\n                new_demand = sum(demand[node] for node in segment) + sum(demand[node] for node in new_route[:-1])\n            else:\n                # Insert in the middle\n                new_demand = sum(demand[node] for node in segment) + sum(demand[node] for node in new_route[1:pos+1]) + sum(demand[node] for node in new_route[pos+1:-1])\n\n            if new_demand > capacity:\n                continue\n\n            # Calculate the new distance\n            new_distance = (distance_matrix[new_route[pos]][segment[0]] +\n                           sum(distance_matrix[segment[i]][segment[i+1]] for i in range(len(segment)-1)) +\n                           distance_matrix[segment[-1]][new_route[pos+1]] -\n                           distance_matrix[new_route[pos]][new_route[pos+1]])\n\n            if new_distance < best_insert_distance:\n                best_insert_distance = new_distance\n                best_insert_pos = pos\n\n        # Insert the segment back at the best position\n        if best_insert_pos == 0:\n            new_route = np.concatenate([route[:1], segment, new_route[1:]]).tolist()\n        elif best_insert_pos == len(new_route) - 1:\n            new_route = np.concatenate([new_route[:-1], segment, route[-1:]]).tolist()\n        else:\n            new_route = np.concatenate([new_route[:best_insert_pos+1], segment, new_route[best_insert_pos+1:]]).tolist()\n\n        new_solution[route_idx] = np.array(new_route)\n\n    # Additional: Try moving a customer between routes if it improves both objectives\n    for _ in range(10):  # Limit iterations for efficiency\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx == route2_idx or len(new_solution[route1_idx]) <= 2 or len(new_solution[route2_idx]) <= 2:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random customer from route1\n        customer_pos = random.randint(1, len(route1) - 2)\n        customer = route1[customer_pos]\n\n        # Check if moving the customer to route2 violates capacity\n        if sum(demand[node] for node in route2[1:-1]) + demand[customer] > capacity:\n            continue\n\n        # Calculate the change in total distance\n        delta_distance = (distance_matrix[route1[customer_pos-1]][route1[customer_pos+1]] -\n                         distance_matrix[route1[customer_pos-1]][customer] -\n                         distance_matrix[customer][route1[customer_pos+1]])\n\n        # Find the best insertion position in route2\n        best_pos = 1\n        best_delta = float('inf')\n\n        for pos in range(1, len(route2) - 1):\n            delta = (distance_matrix[route2[pos-1]][customer] +\n                     distance_matrix[customer][route2[pos]] -\n                     distance_matrix[route2[pos-1]][route2[pos]])\n\n            if delta < best_delta:\n                best_delta = delta\n                best_pos = pos\n\n        delta_distance += best_delta\n\n        # If the move improves the solution, apply it\n        if delta_distance < 0:\n            # Remove customer from route1\n            new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]]).tolist()\n            new_solution[route1_idx] = np.array(new_route1)\n\n            # Insert customer into route2\n            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]]).tolist()\n            new_solution[route2_idx] = np.array(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.4251290485113377,
            8.721247553825378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route segmentation and customer reinsertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment of the route to modify\n        start = random.randint(1, len(route) - 3)\n        end = random.randint(start + 1, len(route) - 2)\n        segment = route[start:end]\n\n        # Calculate current segment distance and demand\n        segment_distance = sum(distance_matrix[route[i]][route[i+1]] for i in range(start, end))\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Remove the segment from the route\n        new_route = np.concatenate([route[:start], route[end:]]).tolist()\n\n        # Find the best insertion position for the segment in the same route\n        best_insert_pos = start\n        best_insert_distance = float('inf')\n\n        for pos in range(len(new_route) - 1):\n            # Check capacity constraint\n            if pos == 0:\n                # Insert at the beginning of the route\n                new_demand = sum(demand[node] for node in segment) + sum(demand[node] for node in new_route[1:])\n            elif pos == len(new_route) - 2:\n                # Insert at the end of the route\n                new_demand = sum(demand[node] for node in segment) + sum(demand[node] for node in new_route[:-1])\n            else:\n                # Insert in the middle\n                new_demand = sum(demand[node] for node in segment) + sum(demand[node] for node in new_route[1:pos+1]) + sum(demand[node] for node in new_route[pos+1:-1])\n\n            if new_demand > capacity:\n                continue\n\n            # Calculate the new distance\n            new_distance = (distance_matrix[new_route[pos]][segment[0]] +\n                           sum(distance_matrix[segment[i]][segment[i+1]] for i in range(len(segment)-1)) +\n                           distance_matrix[segment[-1]][new_route[pos+1]] -\n                           distance_matrix[new_route[pos]][new_route[pos+1]])\n\n            if new_distance < best_insert_distance:\n                best_insert_distance = new_distance\n                best_insert_pos = pos\n\n        # Insert the segment back at the best position\n        if best_insert_pos == 0:\n            new_route = np.concatenate([route[:1], segment, new_route[1:]]).tolist()\n        elif best_insert_pos == len(new_route) - 1:\n            new_route = np.concatenate([new_route[:-1], segment, route[-1:]]).tolist()\n        else:\n            new_route = np.concatenate([new_route[:best_insert_pos+1], segment, new_route[best_insert_pos+1:]]).tolist()\n\n        new_solution[route_idx] = np.array(new_route)\n\n    # Additional: Try moving a customer between routes if it improves both objectives\n    for _ in range(10):  # Limit iterations for efficiency\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx == route2_idx or len(new_solution[route1_idx]) <= 2 or len(new_solution[route2_idx]) <= 2:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random customer from route1\n        customer_pos = random.randint(1, len(route1) - 2)\n        customer = route1[customer_pos]\n\n        # Check if moving the customer to route2 violates capacity\n        if sum(demand[node] for node in route2[1:-1]) + demand[customer] > capacity:\n            continue\n\n        # Calculate the change in total distance\n        delta_distance = (distance_matrix[route1[customer_pos-1]][route1[customer_pos+1]] -\n                         distance_matrix[route1[customer_pos-1]][customer] -\n                         distance_matrix[customer][route1[customer_pos+1]])\n\n        # Find the best insertion position in route2\n        best_pos = 1\n        best_delta = float('inf')\n\n        for pos in range(1, len(route2) - 1):\n            delta = (distance_matrix[route2[pos-1]][customer] +\n                     distance_matrix[customer][route2[pos]] -\n                     distance_matrix[route2[pos-1]][route2[pos]])\n\n            if delta < best_delta:\n                best_delta = delta\n                best_pos = pos\n\n        delta_distance += best_delta\n\n        # If the move improves the solution, apply it\n        if delta_distance < 0:\n            # Remove customer from route1\n            new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]]).tolist()\n            new_solution[route1_idx] = np.array(new_route1)\n\n            # Insert customer into route2\n            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]]).tolist()\n            new_solution[route2_idx] = np.array(new_route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search strategy combines route splitting, demand-balanced merging, and adaptive 2-opt moves to intelligently balance travel distance and makespan reduction while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1][0], x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting, demand-balanced merging, and adaptive 2-opt\n    for _ in range(5):  # Limit iterations to balance exploration and computation\n        # Randomly select a route to modify\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        # Route splitting: split a long route into two balanced routes\n        if len(route) > 4:  # Avoid trivial splits\n            split_pos = np.random.randint(2, len(route)-1)\n            first_half = route[:split_pos]\n            second_half = route[split_pos-1:]\n\n            # Check demand feasibility\n            if (np.sum(demand[first_half[1:-1]]) <= capacity and\n                np.sum(demand[second_half[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_half\n                new_solution.insert(route_idx + 1, second_half)\n\n        # Demand-balanced merging: merge two routes if their combined demand fits\n        if len(new_solution) > 1:\n            other_idx = np.random.randint(0, len(new_solution))\n            if other_idx != route_idx:\n                other_route = new_solution[other_idx].copy()\n                combined_demand = (np.sum(demand[route[1:-1]]) +\n                                  np.sum(demand[other_route[1:-1]]))\n\n                if combined_demand <= capacity:\n                    # Merge routes by connecting them with shortest possible links\n                    best_merge = None\n                    min_merge_dist = float('inf')\n\n                    for i in range(1, len(route)-1):\n                        for j in range(1, len(other_route)-1):\n                            # Try connecting route[i] -> other_route[j]\n                            dist = distance_matrix[route[i], other_route[j]]\n                            if dist < min_merge_dist:\n                                min_merge_dist = dist\n                                best_merge = (i, j)\n\n                    if best_merge:\n                        i, j = best_merge\n                        merged_route = np.concatenate([\n                            route[:i+1],\n                            other_route[j:-1],\n                            route[i+1:]\n                        ])\n                        new_solution[route_idx] = merged_route\n                        new_solution.pop(other_idx)\n                        if other_idx < route_idx:\n                            route_idx -= 1\n\n        # Adaptive 2-opt: only perform if it reduces the longest route (makespan)\n        if len(new_solution) > 1:\n            # Find the longest route\n            longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n            longest_route = new_solution[longest_route_idx].copy()\n\n            # Try 2-opt on the longest route\n            improved = False\n            for i in range(1, len(longest_route)-2):\n                for j in range(i+2, len(longest_route)-1):\n                    # Reverse the segment between i and j\n                    new_segment = np.concatenate([\n                        longest_route[i:j][::-1],\n                        longest_route[j:]\n                    ])\n                    new_route = np.concatenate([\n                        longest_route[:i],\n                        new_segment\n                    ])\n\n                    # Check if the new route is better (shorter) and feasible\n                    new_dist = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n                    old_dist = np.sum(distance_matrix[longest_route[:-1], longest_route[1:]])\n\n                    if new_dist < old_dist and np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[longest_route_idx] = new_route\n                        improved = True\n                        break\n                if improved:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8164335123917537,
            4.755643874406815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1][0], x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting, demand-balanced merging, and adaptive 2-opt\n    for _ in range(5):  # Limit iterations to balance exploration and computation\n        # Randomly select a route to modify\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        # Route splitting: split a long route into two balanced routes\n        if len(route) > 4:  # Avoid trivial splits\n            split_pos = np.random.randint(2, len(route)-1)\n            first_half = route[:split_pos]\n            second_half = route[split_pos-1:]\n\n            # Check demand feasibility\n            if (np.sum(demand[first_half[1:-1]]) <= capacity and\n                np.sum(demand[second_half[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_half\n                new_solution.insert(route_idx + 1, second_half)\n\n        # Demand-balanced merging: merge two routes if their combined demand fits\n        if len(new_solution) > 1:\n            other_idx = np.random.randint(0, len(new_solution))\n            if other_idx != route_idx:\n                other_route = new_solution[other_idx].copy()\n                combined_demand = (np.sum(demand[route[1:-1]]) +\n                                  np.sum(demand[other_route[1:-1]]))\n\n                if combined_demand <= capacity:\n                    # Merge routes by connecting them with shortest possible links\n                    best_merge = None\n                    min_merge_dist = float('inf')\n\n                    for i in range(1, len(route)-1):\n                        for j in range(1, len(other_route)-1):\n                            # Try connecting route[i] -> other_route[j]\n                            dist = distance_matrix[route[i], other_route[j]]\n                            if dist < min_merge_dist:\n                                min_merge_dist = dist\n                                best_merge = (i, j)\n\n                    if best_merge:\n                        i, j = best_merge\n                        merged_route = np.concatenate([\n                            route[:i+1],\n                            other_route[j:-1],\n                            route[i+1:]\n                        ])\n                        new_solution[route_idx] = merged_route\n                        new_solution.pop(other_idx)\n                        if other_idx < route_idx:\n                            route_idx -= 1\n\n        # Adaptive 2-opt: only perform if it reduces the longest route (makespan)\n        if len(new_solution) > 1:\n            # Find the longest route\n            longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n            longest_route = new_solution[longest_route_idx].copy()\n\n            # Try 2-opt on the longest route\n            improved = False\n            for i in range(1, len(longest_route)-2):\n                for j in range(i+2, len(longest_route)-1):\n                    # Reverse the segment between i and j\n                    new_segment = np.concatenate([\n                        longest_route[i:j][::-1],\n                        longest_route[j:]\n                    ])\n                    new_route = np.concatenate([\n                        longest_route[:i],\n                        new_segment\n                    ])\n\n                    # Check if the new route is better (shorter) and feasible\n                    new_dist = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n                    old_dist = np.sum(distance_matrix[longest_route[:-1], longest_route[1:]])\n\n                    if new_dist < old_dist and np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[longest_route_idx] = new_route\n                        improved = True\n                        break\n                if improved:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with route splitting\n    if len(selected_route) > 4:  # Ensure route has enough nodes to modify\n        # 2-opt swap: randomly select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(np.random.choice(range(1, len(selected_route) - 2), 2, replace=False))\n        selected_route[i:j+1] = selected_route[i:j+1][::-1]\n\n        # Check capacity feasibility\n        if np.sum(demand[selected_route[1:-1]]) <= capacity:\n            base_solution[route_idx] = selected_route\n        else:\n            # If infeasible, split the route into two at the first point where capacity is exceeded\n            cumulative_demand = 0\n            split_point = 1\n            for k in range(1, len(selected_route) - 1):\n                cumulative_demand += demand[selected_route[k]]\n                if cumulative_demand > capacity:\n                    split_point = k\n                    break\n\n            # Create two new routes\n            route1 = np.concatenate(([0], selected_route[1:split_point], [0]))\n            route2 = np.concatenate(([0], selected_route[split_point:-1], [0]))\n\n            # Replace the original route with the two new routes\n            base_solution.pop(route_idx)\n            base_solution.insert(route_idx, route1)\n            base_solution.insert(route_idx + 1, route2)\n\n    return base_solution\n\n",
        "score": [
            -0.3596013336941979,
            0.531059205532074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with route splitting\n    if len(selected_route) > 4:  # Ensure route has enough nodes to modify\n        # 2-opt swap: randomly select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(np.random.choice(range(1, len(selected_route) - 2), 2, replace=False))\n        selected_route[i:j+1] = selected_route[i:j+1][::-1]\n\n        # Check capacity feasibility\n        if np.sum(demand[selected_route[1:-1]]) <= capacity:\n            base_solution[route_idx] = selected_route\n        else:\n            # If infeasible, split the route into two at the first point where capacity is exceeded\n            cumulative_demand = 0\n            split_point = 1\n            for k in range(1, len(selected_route) - 1):\n                cumulative_demand += demand[selected_route[k]]\n                if cumulative_demand > capacity:\n                    split_point = k\n                    break\n\n            # Create two new routes\n            route1 = np.concatenate(([0], selected_route[1:split_point], [0]))\n            route2 = np.concatenate(([0], selected_route[split_point:-1], [0]))\n\n            # Replace the original route with the two new routes\n            base_solution.pop(route_idx)\n            base_solution.insert(route_idx, route1)\n            base_solution.insert(route_idx + 1, route2)\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with route splitting\n    if len(selected_route) > 4:  # Ensure route has enough nodes to modify\n        # 2-opt swap: randomly select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(np.random.choice(range(1, len(selected_route) - 2), 2, replace=False))\n        selected_route[i:j+1] = selected_route[i:j+1][::-1]\n\n        # Check capacity feasibility\n        if np.sum(demand[selected_route[1:-1]]) <= capacity:\n            base_solution[route_idx] = selected_route\n        else:\n            # If infeasible, split the route into two at the first point where capacity is exceeded\n            cumulative_demand = 0\n            split_point = 1\n            for k in range(1, len(selected_route) - 1):\n                cumulative_demand += demand[selected_route[k]]\n                if cumulative_demand > capacity:\n                    split_point = k\n                    break\n\n            # Create two new routes\n            route1 = np.concatenate(([0], selected_route[1:split_point], [0]))\n            route2 = np.concatenate(([0], selected_route[split_point:-1], [0]))\n\n            # Replace the original route with the two new routes\n            base_solution.pop(route_idx)\n            base_solution.insert(route_idx, route1)\n            base_solution.insert(route_idx + 1, route2)\n\n    return base_solution\n\n",
        "score": [
            -0.3596013336941979,
            0.531059205532074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with route splitting\n    if len(selected_route) > 4:  # Ensure route has enough nodes to modify\n        # 2-opt swap: randomly select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(np.random.choice(range(1, len(selected_route) - 2), 2, replace=False))\n        selected_route[i:j+1] = selected_route[i:j+1][::-1]\n\n        # Check capacity feasibility\n        if np.sum(demand[selected_route[1:-1]]) <= capacity:\n            base_solution[route_idx] = selected_route\n        else:\n            # If infeasible, split the route into two at the first point where capacity is exceeded\n            cumulative_demand = 0\n            split_point = 1\n            for k in range(1, len(selected_route) - 1):\n                cumulative_demand += demand[selected_route[k]]\n                if cumulative_demand > capacity:\n                    split_point = k\n                    break\n\n            # Create two new routes\n            route1 = np.concatenate(([0], selected_route[1:split_point], [0]))\n            route2 = np.concatenate(([0], selected_route[split_point:-1], [0]))\n\n            # Replace the original route with the two new routes\n            base_solution.pop(route_idx)\n            base_solution.insert(route_idx, route1)\n            base_solution.insert(route_idx + 1, route2)\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This novel local search algorithm combines route segmentation, demand-aware reinsertion, and adaptive route merging to balance distance and makespan minimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(new_solution))\n    route = new_solution[route_idx]\n    customers = route[1:-1]  # Exclude depot\n    if len(customers) < 2:\n        return new_solution\n\n    # Segment the route into two parts at a random point\n    split_pos = np.random.randint(1, len(customers))\n    part1 = customers[:split_pos]\n    part2 = customers[split_pos:]\n\n    # Calculate demand for each part\n    demand1 = np.sum(demand[part1])\n    demand2 = np.sum(demand[part2])\n\n    # Reinsert part2 into the most suitable position in part1\n    best_insert_pos = -1\n    best_insert_cost = float('inf')\n    for i in range(1, len(part1)):\n        temp_route = np.concatenate([part1[:i], part2, part1[i:]])\n        if np.sum(demand[temp_route]) > capacity:\n            continue\n        # Calculate insertion cost (distance increase)\n        prev_node = part1[i-1] if i > 0 else 0\n        next_node = part1[i] if i < len(part1) else 0\n        insert_cost = (distance_matrix[prev_node, part2[0]] +\n                       distance_matrix[part2[-1], next_node] -\n                       distance_matrix[prev_node, next_node])\n        if insert_cost < best_insert_cost:\n            best_insert_cost = insert_cost\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        new_route = np.concatenate([part1[:best_insert_pos], part2, part1[best_insert_pos:]])\n        new_solution[route_idx] = np.concatenate([[0], new_route, [0]])\n\n    # Adaptive route merging: if two routes can be merged without exceeding capacity\n    if len(new_solution) > 1:\n        merge_candidates = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                combined_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n                if combined_demand <= capacity:\n                    merge_candidates.append((i, j))\n\n        if merge_candidates:\n            i, j = random.choice(merge_candidates)\n            merged_route = np.concatenate([new_solution[i][1:-1], new_solution[j][1:-1]])\n            new_solution[i] = np.concatenate([[0], merged_route, [0]])\n            new_solution.pop(j)\n\n    return new_solution\n\n",
        "score": [
            -0.4366438215612899,
            3.3303466737270355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(new_solution))\n    route = new_solution[route_idx]\n    customers = route[1:-1]  # Exclude depot\n    if len(customers) < 2:\n        return new_solution\n\n    # Segment the route into two parts at a random point\n    split_pos = np.random.randint(1, len(customers))\n    part1 = customers[:split_pos]\n    part2 = customers[split_pos:]\n\n    # Calculate demand for each part\n    demand1 = np.sum(demand[part1])\n    demand2 = np.sum(demand[part2])\n\n    # Reinsert part2 into the most suitable position in part1\n    best_insert_pos = -1\n    best_insert_cost = float('inf')\n    for i in range(1, len(part1)):\n        temp_route = np.concatenate([part1[:i], part2, part1[i:]])\n        if np.sum(demand[temp_route]) > capacity:\n            continue\n        # Calculate insertion cost (distance increase)\n        prev_node = part1[i-1] if i > 0 else 0\n        next_node = part1[i] if i < len(part1) else 0\n        insert_cost = (distance_matrix[prev_node, part2[0]] +\n                       distance_matrix[part2[-1], next_node] -\n                       distance_matrix[prev_node, next_node])\n        if insert_cost < best_insert_cost:\n            best_insert_cost = insert_cost\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        new_route = np.concatenate([part1[:best_insert_pos], part2, part1[best_insert_pos:]])\n        new_solution[route_idx] = np.concatenate([[0], new_route, [0]])\n\n    # Adaptive route merging: if two routes can be merged without exceeding capacity\n    if len(new_solution) > 1:\n        merge_candidates = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                combined_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n                if combined_demand <= capacity:\n                    merge_candidates.append((i, j))\n\n        if merge_candidates:\n            i, j = random.choice(merge_candidates)\n            merged_route = np.concatenate([new_solution[i][1:-1], new_solution[j][1:-1]])\n            new_solution[i] = np.concatenate([[0], merged_route, [0]])\n            new_solution.pop(j)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search operator combines route merging, segment relinking, and capacity-aware route splitting to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge two shortest routes, then relink segments\n    if len(new_solution) > 1:\n        # Find the two shortest routes\n        route_lengths = [(i, sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)))\n                        for i, route in enumerate(new_solution)]\n        route_lengths.sort(key=lambda x: x[1])\n        r1_idx, r1_len = route_lengths[0]\n        r2_idx, r2_len = route_lengths[1]\n\n        route1 = new_solution[r1_idx]\n        route2 = new_solution[r2_idx]\n\n        # Merge the two routes by connecting their closest nodes\n        min_dist = float('inf')\n        best_merge = None\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                dist = distance_matrix[route1[i], route2[j]]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_merge = (i, j)\n\n        if best_merge:\n            i, j = best_merge\n            # Create merged route\n            merged_route = np.concatenate([route1[:i+1], route2[j:], route2[:j+1], route1[i+1:]])\n\n            # Check capacity constraint\n            total_demand = sum(demand[node] for node in merged_route[1:-1])\n            if total_demand <= capacity:\n                # Replace the two routes with the merged one\n                new_solution.pop(max(r1_idx, r2_idx))\n                new_solution.pop(min(r1_idx, r2_idx))\n                new_solution.append(merged_route)\n\n                # Now perform segment relinking between the remaining routes\n                if len(new_solution) > 1:\n                    # Select two routes at random\n                    r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n                    route_a = new_solution[r1]\n                    route_b = new_solution[r2]\n\n                    # Find the best segment from route_a to insert into route_b\n                    best_insert = None\n                    best_improvement = 0\n                    for start in range(1, len(route_a)-1):\n                        for end in range(start, len(route_a)-1):\n                            segment = route_a[start:end+1]\n                            segment_demand = sum(demand[node] for node in segment)\n\n                            for pos in range(1, len(route_b)-1):\n                                # Check capacity constraint\n                                if sum(demand[node] for node in route_b[1:-1]) - sum(demand[node] for node in segment) + segment_demand <= capacity:\n                                    # Calculate potential improvement\n                                    old_dist = distance_matrix[route_b[pos-1], route_b[pos]] + \\\n                                               distance_matrix[route_b[pos], route_b[pos+1]]\n                                    new_dist = distance_matrix[route_b[pos-1], segment[0]] + \\\n                                               sum(distance_matrix[segment[i], segment[i+1]] for i in range(len(segment)-1)) + \\\n                                               distance_matrix[segment[-1], route_b[pos+1]]\n                                    improvement = old_dist - new_dist\n\n                                    if improvement > best_improvement:\n                                        best_improvement = improvement\n                                        best_insert = (start, end, pos, segment)\n\n                    if best_insert:\n                        start, end, pos, segment = best_insert\n                        # Perform the insertion\n                        new_route_b = np.concatenate([route_b[:pos+1], segment, route_b[pos+1:]])\n                        new_solution[r2] = new_route_b\n\n    # If no improvement possible, try a different operator: capacity-aware route splitting\n    if len(new_solution) < len(selected_solution):\n        # Find the longest route\n        longest_route = max(new_solution, key=lambda x: sum(distance_matrix[x[i], x[i+1]] for i in range(len(x)-1)))\n\n        # Try to split the longest route at the point that balances distance and demand\n        best_split = None\n        best_balance = float('inf')\n        for i in range(1, len(longest_route)-1):\n            # First part: depot to split point\n            first_part = longest_route[:i+1]\n            first_demand = sum(demand[node] for node in first_part[1:-1])\n\n            # Second part: split point to depot\n            second_part = longest_route[i:]\n            second_demand = sum(demand[node] for node in second_part[1:-1])\n\n            # Check capacity constraints\n            if first_demand <= capacity and second_demand <= capacity:\n                # Calculate balance (difference in distance between parts)\n                first_dist = sum(distance_matrix[first_part[j], first_part[j+1]] for j in range(len(first_part)-1))\n                second_dist = sum(distance_matrix[second_part[j], second_part[j+1]] for j in range(len(second_part)-1))\n                balance = abs(first_dist - second_dist)\n\n                if balance < best_balance:\n                    best_balance = balance\n                    best_split = i\n\n        if best_split:\n            # Perform the split\n            first_part = longest_route[:best_split+1]\n            second_part = longest_route[best_split:]\n\n            # Replace the longest route with the two new routes\n            new_solution.remove(longest_route)\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.7266135532849993,
            1.1194400489330292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge two shortest routes, then relink segments\n    if len(new_solution) > 1:\n        # Find the two shortest routes\n        route_lengths = [(i, sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)))\n                        for i, route in enumerate(new_solution)]\n        route_lengths.sort(key=lambda x: x[1])\n        r1_idx, r1_len = route_lengths[0]\n        r2_idx, r2_len = route_lengths[1]\n\n        route1 = new_solution[r1_idx]\n        route2 = new_solution[r2_idx]\n\n        # Merge the two routes by connecting their closest nodes\n        min_dist = float('inf')\n        best_merge = None\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                dist = distance_matrix[route1[i], route2[j]]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_merge = (i, j)\n\n        if best_merge:\n            i, j = best_merge\n            # Create merged route\n            merged_route = np.concatenate([route1[:i+1], route2[j:], route2[:j+1], route1[i+1:]])\n\n            # Check capacity constraint\n            total_demand = sum(demand[node] for node in merged_route[1:-1])\n            if total_demand <= capacity:\n                # Replace the two routes with the merged one\n                new_solution.pop(max(r1_idx, r2_idx))\n                new_solution.pop(min(r1_idx, r2_idx))\n                new_solution.append(merged_route)\n\n                # Now perform segment relinking between the remaining routes\n                if len(new_solution) > 1:\n                    # Select two routes at random\n                    r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n                    route_a = new_solution[r1]\n                    route_b = new_solution[r2]\n\n                    # Find the best segment from route_a to insert into route_b\n                    best_insert = None\n                    best_improvement = 0\n                    for start in range(1, len(route_a)-1):\n                        for end in range(start, len(route_a)-1):\n                            segment = route_a[start:end+1]\n                            segment_demand = sum(demand[node] for node in segment)\n\n                            for pos in range(1, len(route_b)-1):\n                                # Check capacity constraint\n                                if sum(demand[node] for node in route_b[1:-1]) - sum(demand[node] for node in segment) + segment_demand <= capacity:\n                                    # Calculate potential improvement\n                                    old_dist = distance_matrix[route_b[pos-1], route_b[pos]] + \\\n                                               distance_matrix[route_b[pos], route_b[pos+1]]\n                                    new_dist = distance_matrix[route_b[pos-1], segment[0]] + \\\n                                               sum(distance_matrix[segment[i], segment[i+1]] for i in range(len(segment)-1)) + \\\n                                               distance_matrix[segment[-1], route_b[pos+1]]\n                                    improvement = old_dist - new_dist\n\n                                    if improvement > best_improvement:\n                                        best_improvement = improvement\n                                        best_insert = (start, end, pos, segment)\n\n                    if best_insert:\n                        start, end, pos, segment = best_insert\n                        # Perform the insertion\n                        new_route_b = np.concatenate([route_b[:pos+1], segment, route_b[pos+1:]])\n                        new_solution[r2] = new_route_b\n\n    # If no improvement possible, try a different operator: capacity-aware route splitting\n    if len(new_solution) < len(selected_solution):\n        # Find the longest route\n        longest_route = max(new_solution, key=lambda x: sum(distance_matrix[x[i], x[i+1]] for i in range(len(x)-1)))\n\n        # Try to split the longest route at the point that balances distance and demand\n        best_split = None\n        best_balance = float('inf')\n        for i in range(1, len(longest_route)-1):\n            # First part: depot to split point\n            first_part = longest_route[:i+1]\n            first_demand = sum(demand[node] for node in first_part[1:-1])\n\n            # Second part: split point to depot\n            second_part = longest_route[i:]\n            second_demand = sum(demand[node] for node in second_part[1:-1])\n\n            # Check capacity constraints\n            if first_demand <= capacity and second_demand <= capacity:\n                # Calculate balance (difference in distance between parts)\n                first_dist = sum(distance_matrix[first_part[j], first_part[j+1]] for j in range(len(first_part)-1))\n                second_dist = sum(distance_matrix[second_part[j], second_part[j+1]] for j in range(len(second_part)-1))\n                balance = abs(first_dist - second_dist)\n\n                if balance < best_balance:\n                    best_balance = balance\n                    best_split = i\n\n        if best_split:\n            # Perform the split\n            first_part = longest_route[:best_split+1]\n            second_part = longest_route[best_split:]\n\n            # Replace the longest route with the two new routes\n            new_solution.remove(longest_route)\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route fragmentation and intra-route 2-opt with demand-aware swaps to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([s[1][0] * 0.7 + s[1][1] * 0.3 for s in archive])\n    selected_idx = np.argmin(weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route fragmentation + demand-aware 2-opt\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route fragmentation (split long routes into smaller ones)\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.8:  # If route is over 80% capacity, try to split\n            split_points = []\n            current_demand = 0\n            for i in range(1, len(route)-1):\n                current_demand += demand[route[i]]\n                if current_demand > capacity * 0.6:  # Split at 60% capacity\n                    split_points.append(i)\n                    current_demand = 0\n\n            if split_points:\n                split_routes = []\n                prev_split = 0\n                for sp in split_points:\n                    split_routes.append(np.concatenate([[0], route[prev_split:sp+1], [0]]))\n                    prev_split = sp\n                split_routes.append(np.concatenate([[0], route[prev_split:], [0]]))\n                new_solution.extend(split_routes)\n                continue\n\n        # Step 2: Demand-aware 2-opt for intra-route improvement\n        improved_route = route.copy()\n        for _ in range(10):  # Limited iterations for efficiency\n            i, j = sorted(random.sample(range(1, len(improved_route)-1), 2))\n            # Check demand constraint for the swapped segment\n            segment_demand = sum(demand[improved_route[i:j+1]])\n            if segment_demand > capacity:\n                continue  # Skip if swap violates capacity\n            # Calculate distance difference\n            old_dist = (distance_matrix[improved_route[i-1], improved_route[i]] +\n                        distance_matrix[improved_route[j], improved_route[j+1]])\n            new_dist = (distance_matrix[improved_route[i-1], improved_route[j]] +\n                        distance_matrix[improved_route[i], improved_route[j+1]])\n            if new_dist < old_dist:\n                improved_route[i:j+1] = improved_route[i:j+1][::-1]\n\n        new_solution.append(improved_route)\n\n    # Step 3: Post-processing: merge small routes if possible\n    final_solution = []\n    for route in new_solution:\n        if len(route) <= 3:\n            final_solution.append(route)\n            continue\n\n        # Try to merge with adjacent routes if total demand allows\n        merged = False\n        for i in range(len(final_solution)):\n            candidate_route = final_solution[i]\n            if len(candidate_route) + len(route) - 2 > 50:  # Limit route length\n                continue\n            total_demand = sum(demand[np.concatenate([candidate_route[1:-1], route[1:-1]])])\n            if total_demand <= capacity:\n                # Calculate distance improvement\n                old_dist = (distance_matrix[candidate_route[-2], 0] +\n                            distance_matrix[0, route[1]])\n                new_dist = (distance_matrix[candidate_route[-2], route[1]] +\n                            distance_matrix[route[-2], 0])\n                if new_dist < old_dist:\n                    merged_route = np.concatenate([candidate_route[:-1], route[1:]])\n                    final_solution[i] = merged_route\n                    merged = True\n                    break\n\n        if not merged:\n            final_solution.append(route)\n\n    return final_solution\n\n",
        "score": [
            -0.8250609343763688,
            6.5637631714344025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([s[1][0] * 0.7 + s[1][1] * 0.3 for s in archive])\n    selected_idx = np.argmin(weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route fragmentation + demand-aware 2-opt\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route fragmentation (split long routes into smaller ones)\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.8:  # If route is over 80% capacity, try to split\n            split_points = []\n            current_demand = 0\n            for i in range(1, len(route)-1):\n                current_demand += demand[route[i]]\n                if current_demand > capacity * 0.6:  # Split at 60% capacity\n                    split_points.append(i)\n                    current_demand = 0\n\n            if split_points:\n                split_routes = []\n                prev_split = 0\n                for sp in split_points:\n                    split_routes.append(np.concatenate([[0], route[prev_split:sp+1], [0]]))\n                    prev_split = sp\n                split_routes.append(np.concatenate([[0], route[prev_split:], [0]]))\n                new_solution.extend(split_routes)\n                continue\n\n        # Step 2: Demand-aware 2-opt for intra-route improvement\n        improved_route = route.copy()\n        for _ in range(10):  # Limited iterations for efficiency\n            i, j = sorted(random.sample(range(1, len(improved_route)-1), 2))\n            # Check demand constraint for the swapped segment\n            segment_demand = sum(demand[improved_route[i:j+1]])\n            if segment_demand > capacity:\n                continue  # Skip if swap violates capacity\n            # Calculate distance difference\n            old_dist = (distance_matrix[improved_route[i-1], improved_route[i]] +\n                        distance_matrix[improved_route[j], improved_route[j+1]])\n            new_dist = (distance_matrix[improved_route[i-1], improved_route[j]] +\n                        distance_matrix[improved_route[i], improved_route[j+1]])\n            if new_dist < old_dist:\n                improved_route[i:j+1] = improved_route[i:j+1][::-1]\n\n        new_solution.append(improved_route)\n\n    # Step 3: Post-processing: merge small routes if possible\n    final_solution = []\n    for route in new_solution:\n        if len(route) <= 3:\n            final_solution.append(route)\n            continue\n\n        # Try to merge with adjacent routes if total demand allows\n        merged = False\n        for i in range(len(final_solution)):\n            candidate_route = final_solution[i]\n            if len(candidate_route) + len(route) - 2 > 50:  # Limit route length\n                continue\n            total_demand = sum(demand[np.concatenate([candidate_route[1:-1], route[1:-1]])])\n            if total_demand <= capacity:\n                # Calculate distance improvement\n                old_dist = (distance_matrix[candidate_route[-2], 0] +\n                            distance_matrix[0, route[1]])\n                new_dist = (distance_matrix[candidate_route[-2], route[1]] +\n                            distance_matrix[route[-2], 0])\n                if new_dist < old_dist:\n                    merged_route = np.concatenate([candidate_route[:-1], route[1:]])\n                    final_solution[i] = merged_route\n                    merged = True\n                    break\n\n        if not merged:\n            final_solution.append(route)\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly choose a route to modify\n    if len(selected_solution) > 1:\n        route_idx = np.random.randint(0, len(selected_solution))\n        selected_route = selected_solution[route_idx].copy()\n\n        # Apply a hybrid local search: split and reinsert segments\n        if len(selected_route) > 4:  # Ensure sufficient nodes to split\n            # Split the route into two parts at a random position\n            split_pos = np.random.randint(2, len(selected_route) - 2)\n            part1 = selected_route[:split_pos]\n            part2 = selected_route[split_pos:]\n\n            # Create a new route by reversing part1 and appending part2\n            new_route = np.concatenate([part1[::-1], part2])\n\n            # Check feasibility: ensure capacity is not exceeded\n            total_demand = np.sum(demand[new_route[1:-1]])  # Exclude depots\n            if total_demand <= capacity:\n                selected_solution[route_idx] = new_route\n\n                # Attempt to merge the split route with another route\n                if len(selected_solution) > 1:\n                    other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n                    other_route = selected_solution[other_route_idx].copy()\n\n                    # Try to merge part1 into another route\n                    merged_route = np.concatenate([other_route[:-1], part1[1:]])\n                    merged_demand = np.sum(demand[merged_route[1:-1]])\n                    if merged_demand <= capacity:\n                        selected_solution[other_route_idx] = merged_route\n\n    return selected_solution\n\n",
        "score": [
            -0.694182034539304,
            0.30582961440086365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly choose a route to modify\n    if len(selected_solution) > 1:\n        route_idx = np.random.randint(0, len(selected_solution))\n        selected_route = selected_solution[route_idx].copy()\n\n        # Apply a hybrid local search: split and reinsert segments\n        if len(selected_route) > 4:  # Ensure sufficient nodes to split\n            # Split the route into two parts at a random position\n            split_pos = np.random.randint(2, len(selected_route) - 2)\n            part1 = selected_route[:split_pos]\n            part2 = selected_route[split_pos:]\n\n            # Create a new route by reversing part1 and appending part2\n            new_route = np.concatenate([part1[::-1], part2])\n\n            # Check feasibility: ensure capacity is not exceeded\n            total_demand = np.sum(demand[new_route[1:-1]])  # Exclude depots\n            if total_demand <= capacity:\n                selected_solution[route_idx] = new_route\n\n                # Attempt to merge the split route with another route\n                if len(selected_solution) > 1:\n                    other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n                    other_route = selected_solution[other_route_idx].copy()\n\n                    # Try to merge part1 into another route\n                    merged_route = np.concatenate([other_route[:-1], part1[1:]])\n                    merged_demand = np.sum(demand[merged_route[1:-1]])\n                    if merged_demand <= capacity:\n                        selected_solution[other_route_idx] = merged_route\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly choose a route to modify\n    if len(selected_solution) > 1:\n        route_idx = np.random.randint(0, len(selected_solution))\n        selected_route = selected_solution[route_idx].copy()\n\n        # Apply a hybrid local search: split and reinsert segments\n        if len(selected_route) > 4:  # Ensure sufficient nodes to split\n            # Split the route into two parts at a random position\n            split_pos = np.random.randint(2, len(selected_route) - 2)\n            part1 = selected_route[:split_pos]\n            part2 = selected_route[split_pos:]\n\n            # Create a new route by reversing part1 and appending part2\n            new_route = np.concatenate([part1[::-1], part2])\n\n            # Check feasibility: ensure capacity is not exceeded\n            total_demand = np.sum(demand[new_route[1:-1]])  # Exclude depots\n            if total_demand <= capacity:\n                selected_solution[route_idx] = new_route\n\n                # Attempt to merge the split route with another route\n                if len(selected_solution) > 1:\n                    other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n                    other_route = selected_solution[other_route_idx].copy()\n\n                    # Try to merge part1 into another route\n                    merged_route = np.concatenate([other_route[:-1], part1[1:]])\n                    merged_demand = np.sum(demand[merged_route[1:-1]])\n                    if merged_demand <= capacity:\n                        selected_solution[other_route_idx] = merged_route\n\n    return selected_solution\n\n",
        "score": [
            -0.694182034539304,
            0.30582961440086365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly choose a route to modify\n    if len(selected_solution) > 1:\n        route_idx = np.random.randint(0, len(selected_solution))\n        selected_route = selected_solution[route_idx].copy()\n\n        # Apply a hybrid local search: split and reinsert segments\n        if len(selected_route) > 4:  # Ensure sufficient nodes to split\n            # Split the route into two parts at a random position\n            split_pos = np.random.randint(2, len(selected_route) - 2)\n            part1 = selected_route[:split_pos]\n            part2 = selected_route[split_pos:]\n\n            # Create a new route by reversing part1 and appending part2\n            new_route = np.concatenate([part1[::-1], part2])\n\n            # Check feasibility: ensure capacity is not exceeded\n            total_demand = np.sum(demand[new_route[1:-1]])  # Exclude depots\n            if total_demand <= capacity:\n                selected_solution[route_idx] = new_route\n\n                # Attempt to merge the split route with another route\n                if len(selected_solution) > 1:\n                    other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n                    other_route = selected_solution[other_route_idx].copy()\n\n                    # Try to merge part1 into another route\n                    merged_route = np.concatenate([other_route[:-1], part1[1:]])\n                    merged_demand = np.sum(demand[merged_route[1:-1]])\n                    if merged_demand <= capacity:\n                        selected_solution[other_route_idx] = merged_route\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining route splitting, customer reallocation, and capacity-aware edge swaps to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted random choice favoring lower makespan and total distance\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route splitting, customer reallocation, and capacity-aware edge swaps\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 4:  # Skip very short routes\n            continue\n\n        # Route splitting: Try to split a long route into two\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = route[split_pos:]\n\n        # Check capacity constraints for both new routes\n        if (sum(demand[new_route1[1:-1]]) <= capacity and\n            sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n            i += 1  # Skip the new route in next iteration\n            continue\n\n        # Customer reallocation: Try to move a customer to another route\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                candidate_route = new_solution[k].copy()\n                insert_pos = 1\n                while insert_pos < len(candidate_route) - 1:\n                    # Try inserting customer at different positions\n                    candidate_route_inserted = np.insert(candidate_route, insert_pos, customer)\n                    if sum(demand[candidate_route_inserted[1:-1]]) <= capacity:\n                        # Check if this insertion reduces total distance\n                        original_dist = (distance_matrix[candidate_route[insert_pos-1], candidate_route[insert_pos]] +\n                                        distance_matrix[customer, candidate_route[insert_pos]])\n                        new_dist = (distance_matrix[candidate_route_inserted[insert_pos-1], customer] +\n                                   distance_matrix[customer, candidate_route_inserted[insert_pos+1]])\n                        if new_dist < original_dist:\n                            # Remove customer from original route\n                            route = np.delete(route, j)\n                            if len(route) <= 2:  # Route becomes empty after removal\n                                del new_solution[i]\n                                i -= 1\n                                break\n                            else:\n                                new_solution[i] = route\n                            # Add customer to new route\n                            new_solution[k] = candidate_route_inserted\n                            break\n                    insert_pos += 1\n                else:\n                    continue\n                break\n\n        # Capacity-aware edge swaps: Swap adjacent customers if it improves both objectives\n        for j in range(1, len(route)-2):\n            a, b, c = route[j], route[j+1], route[j+2]\n            if (demand[a] + demand[c] <= capacity and\n                distance_matrix[a, b] + distance_matrix[b, c] > distance_matrix[a, c] + distance_matrix[c, b]):\n                # Perform the swap\n                route[j+1], route[j+2] = route[j+2], route[j+1]\n                new_solution[i] = route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7132054975760445,
            1.2722634971141815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted random choice favoring lower makespan and total distance\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route splitting, customer reallocation, and capacity-aware edge swaps\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 4:  # Skip very short routes\n            continue\n\n        # Route splitting: Try to split a long route into two\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = route[split_pos:]\n\n        # Check capacity constraints for both new routes\n        if (sum(demand[new_route1[1:-1]]) <= capacity and\n            sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n            i += 1  # Skip the new route in next iteration\n            continue\n\n        # Customer reallocation: Try to move a customer to another route\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                candidate_route = new_solution[k].copy()\n                insert_pos = 1\n                while insert_pos < len(candidate_route) - 1:\n                    # Try inserting customer at different positions\n                    candidate_route_inserted = np.insert(candidate_route, insert_pos, customer)\n                    if sum(demand[candidate_route_inserted[1:-1]]) <= capacity:\n                        # Check if this insertion reduces total distance\n                        original_dist = (distance_matrix[candidate_route[insert_pos-1], candidate_route[insert_pos]] +\n                                        distance_matrix[customer, candidate_route[insert_pos]])\n                        new_dist = (distance_matrix[candidate_route_inserted[insert_pos-1], customer] +\n                                   distance_matrix[customer, candidate_route_inserted[insert_pos+1]])\n                        if new_dist < original_dist:\n                            # Remove customer from original route\n                            route = np.delete(route, j)\n                            if len(route) <= 2:  # Route becomes empty after removal\n                                del new_solution[i]\n                                i -= 1\n                                break\n                            else:\n                                new_solution[i] = route\n                            # Add customer to new route\n                            new_solution[k] = candidate_route_inserted\n                            break\n                    insert_pos += 1\n                else:\n                    continue\n                break\n\n        # Capacity-aware edge swaps: Swap adjacent customers if it improves both objectives\n        for j in range(1, len(route)-2):\n            a, b, c = route[j], route[j+1], route[j+2]\n            if (demand[a] + demand[c] <= capacity and\n                distance_matrix[a, b] + distance_matrix[b, c] > distance_matrix[a, c] + distance_matrix[c, b]):\n                # Perform the swap\n                route[j+1], route[j+2] = route[j+2], route[j+1]\n                new_solution[i] = route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on a weighted objective score\n    weighted_scores = []\n    for sol, (dist, makespan) in archive:\n        # Normalize objectives and compute a score (lower is better)\n        norm_dist = dist / (max(1, max(s[1][0] for s in archive)))\n        norm_makespan = makespan / (max(1, max(s[1][1] for s in archive)))\n        score = 0.7 * norm_dist + 0.3 * norm_makespan  # Prioritize distance reduction\n        weighted_scores.append(score)\n\n    # Select the solution with the lowest score (best potential)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel local search: Route-splitting and merging with demand-aware insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts\n        split_pos = len(route) // 2\n        route1 = route[:split_pos + 1]  # First part (includes depot)\n        route2 = route[split_pos:]     # Second part (starts with split node)\n\n        # Check capacity feasibility for both new routes\n        def is_feasible(r):\n            return sum(demand[r[1:-1]]) <= capacity\n\n        if is_feasible(route1) and is_feasible(route2):\n            # Replace the original route with the two new routes\n            new_solution[i] = route1\n            new_solution.insert(i + 1, route2)\n            break  # Apply only one split per call for diversity\n\n    # Optional: Apply demand-aware 2-opt within routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to reverse a segment to improve distance and balance load\n        for a in range(1, len(route) - 2):\n            for b in range(a + 1, len(route) - 1):\n                # Check capacity feasibility of the reversed segment\n                segment = route[a:b+1]\n                reversed_segment = segment[::-1]\n                if sum(demand[reversed_segment[1:-1]]) <= capacity:\n                    # Apply the reversal\n                    new_route = np.concatenate([route[:a], reversed_segment, route[b+1:]])\n                    new_solution[i] = new_route\n                    break  # Apply only one reversal per route\n\n    return new_solution\n\n",
        "score": [
            -0.6758490539615903,
            2.445678234100342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on a weighted objective score\n    weighted_scores = []\n    for sol, (dist, makespan) in archive:\n        # Normalize objectives and compute a score (lower is better)\n        norm_dist = dist / (max(1, max(s[1][0] for s in archive)))\n        norm_makespan = makespan / (max(1, max(s[1][1] for s in archive)))\n        score = 0.7 * norm_dist + 0.3 * norm_makespan  # Prioritize distance reduction\n        weighted_scores.append(score)\n\n    # Select the solution with the lowest score (best potential)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel local search: Route-splitting and merging with demand-aware insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts\n        split_pos = len(route) // 2\n        route1 = route[:split_pos + 1]  # First part (includes depot)\n        route2 = route[split_pos:]     # Second part (starts with split node)\n\n        # Check capacity feasibility for both new routes\n        def is_feasible(r):\n            return sum(demand[r[1:-1]]) <= capacity\n\n        if is_feasible(route1) and is_feasible(route2):\n            # Replace the original route with the two new routes\n            new_solution[i] = route1\n            new_solution.insert(i + 1, route2)\n            break  # Apply only one split per call for diversity\n\n    # Optional: Apply demand-aware 2-opt within routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to reverse a segment to improve distance and balance load\n        for a in range(1, len(route) - 2):\n            for b in range(a + 1, len(route) - 1):\n                # Check capacity feasibility of the reversed segment\n                segment = route[a:b+1]\n                reversed_segment = segment[::-1]\n                if sum(demand[reversed_segment[1:-1]]) <= capacity:\n                    # Apply the reversal\n                    new_route = np.concatenate([route[:a], reversed_segment, route[b+1:]])\n                    new_solution[i] = new_route\n                    break  # Apply only one reversal per route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply a hybrid local search operator: Route Splitting and Customer Relocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Randomly select a segment of the route to split\n        split_start = random.randint(1, len(route) - 3)\n        split_end = random.randint(split_start + 1, len(route) - 2)\n\n        # Extract the segment to be relocated\n        segment = route[split_start:split_end + 1]\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Try to relocate the segment to another route or create a new route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue  # Skip the same route\n\n            candidate_route = new_solution[j]\n            candidate_demand = sum(demand[node] for node in candidate_route)\n\n            if candidate_demand + segment_demand <= capacity:\n                # Insert the segment into the candidate route\n                insert_pos = random.randint(1, len(candidate_route) - 1)\n                new_route = np.concatenate([candidate_route[:insert_pos], segment, candidate_route[insert_pos:]])\n                new_solution[j] = new_route\n\n                # Remove the segment from the original route\n                new_solution[i] = np.concatenate([route[:split_start], route[split_end + 1:]])\n                break\n\n        else:\n            # If no suitable route found, create a new route\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n            new_solution[i] = np.concatenate([route[:split_start], route[split_end + 1:]])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6640515666066458,
            3.0222003161907196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply a hybrid local search operator: Route Splitting and Customer Relocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Randomly select a segment of the route to split\n        split_start = random.randint(1, len(route) - 3)\n        split_end = random.randint(split_start + 1, len(route) - 2)\n\n        # Extract the segment to be relocated\n        segment = route[split_start:split_end + 1]\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Try to relocate the segment to another route or create a new route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue  # Skip the same route\n\n            candidate_route = new_solution[j]\n            candidate_demand = sum(demand[node] for node in candidate_route)\n\n            if candidate_demand + segment_demand <= capacity:\n                # Insert the segment into the candidate route\n                insert_pos = random.randint(1, len(candidate_route) - 1)\n                new_route = np.concatenate([candidate_route[:insert_pos], segment, candidate_route[insert_pos:]])\n                new_solution[j] = new_route\n\n                # Remove the segment from the original route\n                new_solution[i] = np.concatenate([route[:split_start], route[split_end + 1:]])\n                break\n\n        else:\n            # If no suitable route found, create a new route\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n            new_solution[i] = np.concatenate([route[:split_start], route[split_end + 1:]])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly choose a route to split or modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Split the route into two segments at a random point\n    split_point = np.random.randint(1, len(route) - 1)\n    segment1 = route[:split_point + 1]\n    segment2 = route[split_point:]\n\n    # Check if splitting is feasible (capacity constraints)\n    if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n        # Replace the original route with the two new segments\n        new_solution = selected_solution.copy()\n        new_solution[route_idx] = segment1\n        new_solution.insert(route_idx + 1, segment2)\n    else:\n        # If splitting is not feasible, perform a segment relocation instead\n        # Find a random segment from another route\n        other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n        other_route = selected_solution[other_route_idx].copy()\n\n        if len(other_route) > 3:  # Ensure the other route has enough nodes to relocate\n            # Select a random segment from the other route\n            other_split_point = np.random.randint(1, len(other_route) - 1)\n            relocated_segment = other_route[other_split_point:-1]\n\n            # Check feasibility of relocation\n            if np.sum(demand[relocated_segment]) <= capacity - np.sum(demand[route[1:-1]]):\n                # Insert the relocated segment into the original route\n                new_segment = np.concatenate([route[:-1], relocated_segment, [0]])\n                new_solution = selected_solution.copy()\n                new_solution[route_idx] = new_segment\n\n                # Update the other route by removing the relocated segment\n                new_other_route = np.concatenate([other_route[:other_split_point], [0]])\n                new_solution[other_route_idx] = new_other_route\n            else:\n                new_solution = selected_solution.copy()\n        else:\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7919072814156997,
            0.19629591703414917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly choose a route to split or modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Split the route into two segments at a random point\n    split_point = np.random.randint(1, len(route) - 1)\n    segment1 = route[:split_point + 1]\n    segment2 = route[split_point:]\n\n    # Check if splitting is feasible (capacity constraints)\n    if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n        # Replace the original route with the two new segments\n        new_solution = selected_solution.copy()\n        new_solution[route_idx] = segment1\n        new_solution.insert(route_idx + 1, segment2)\n    else:\n        # If splitting is not feasible, perform a segment relocation instead\n        # Find a random segment from another route\n        other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n        other_route = selected_solution[other_route_idx].copy()\n\n        if len(other_route) > 3:  # Ensure the other route has enough nodes to relocate\n            # Select a random segment from the other route\n            other_split_point = np.random.randint(1, len(other_route) - 1)\n            relocated_segment = other_route[other_split_point:-1]\n\n            # Check feasibility of relocation\n            if np.sum(demand[relocated_segment]) <= capacity - np.sum(demand[route[1:-1]]):\n                # Insert the relocated segment into the original route\n                new_segment = np.concatenate([route[:-1], relocated_segment, [0]])\n                new_solution = selected_solution.copy()\n                new_solution[route_idx] = new_segment\n\n                # Update the other route by removing the relocated segment\n                new_other_route = np.concatenate([other_route[:other_split_point], [0]])\n                new_solution[other_route_idx] = new_other_route\n            else:\n                new_solution = selected_solution.copy()\n        else:\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly choose a route to split or modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Split the route into two segments at a random point\n    split_point = np.random.randint(1, len(route) - 1)\n    segment1 = route[:split_point + 1]\n    segment2 = route[split_point:]\n\n    # Check if splitting is feasible (capacity constraints)\n    if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n        # Replace the original route with the two new segments\n        new_solution = selected_solution.copy()\n        new_solution[route_idx] = segment1\n        new_solution.insert(route_idx + 1, segment2)\n    else:\n        # If splitting is not feasible, perform a segment relocation instead\n        # Find a random segment from another route\n        other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n        other_route = selected_solution[other_route_idx].copy()\n\n        if len(other_route) > 3:  # Ensure the other route has enough nodes to relocate\n            # Select a random segment from the other route\n            other_split_point = np.random.randint(1, len(other_route) - 1)\n            relocated_segment = other_route[other_split_point:-1]\n\n            # Check feasibility of relocation\n            if np.sum(demand[relocated_segment]) <= capacity - np.sum(demand[route[1:-1]]):\n                # Insert the relocated segment into the original route\n                new_segment = np.concatenate([route[:-1], relocated_segment, [0]])\n                new_solution = selected_solution.copy()\n                new_solution[route_idx] = new_segment\n\n                # Update the other route by removing the relocated segment\n                new_other_route = np.concatenate([other_route[:other_split_point], [0]])\n                new_solution[other_route_idx] = new_other_route\n            else:\n                new_solution = selected_solution.copy()\n        else:\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7919072814156997,
            0.19629591703414917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly choose a route to split or modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Split the route into two segments at a random point\n    split_point = np.random.randint(1, len(route) - 1)\n    segment1 = route[:split_point + 1]\n    segment2 = route[split_point:]\n\n    # Check if splitting is feasible (capacity constraints)\n    if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n        # Replace the original route with the two new segments\n        new_solution = selected_solution.copy()\n        new_solution[route_idx] = segment1\n        new_solution.insert(route_idx + 1, segment2)\n    else:\n        # If splitting is not feasible, perform a segment relocation instead\n        # Find a random segment from another route\n        other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n        other_route = selected_solution[other_route_idx].copy()\n\n        if len(other_route) > 3:  # Ensure the other route has enough nodes to relocate\n            # Select a random segment from the other route\n            other_split_point = np.random.randint(1, len(other_route) - 1)\n            relocated_segment = other_route[other_split_point:-1]\n\n            # Check feasibility of relocation\n            if np.sum(demand[relocated_segment]) <= capacity - np.sum(demand[route[1:-1]]):\n                # Insert the relocated segment into the original route\n                new_segment = np.concatenate([route[:-1], relocated_segment, [0]])\n                new_solution = selected_solution.copy()\n                new_solution[route_idx] = new_segment\n\n                # Update the other route by removing the relocated segment\n                new_other_route = np.concatenate([other_route[:other_split_point], [0]])\n                new_solution[other_route_idx] = new_other_route\n            else:\n                new_solution = selected_solution.copy()\n        else:\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid approach combining route-segment swapping with adaptive capacity-aware reinsertion, then applies a novel \"inter-route segment crossover\" operator to generate a neighbor solution while ensuring feasibility through demand validation and capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: inter-route segment crossover\n    if len(new_solution) >= 2:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Extract a random segment from each route (excluding depot)\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Check capacity constraints for the swaps\n        segment1_demand = sum(demand[node] for node in segment1)\n        segment2_demand = sum(demand[node] for node in segment2)\n\n        # Try swapping segments if capacity allows\n        if (sum(demand[node] for node in route1) - segment1_demand + segment2_demand <= capacity and\n            sum(demand[node] for node in route2) - segment2_demand + segment1_demand <= capacity):\n\n            # Perform the swap\n            new_route1 = np.concatenate([\n                route1[:segment1_start],\n                segment2,\n                route1[segment1_end + 1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:segment2_start],\n                segment1,\n                route2[segment2_end + 1:]\n            ])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Adaptive reinsertion: move a node from a long route to a short route if possible\n    if len(new_solution) >= 2:\n        # Find the longest and shortest routes\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n\n        if len(new_solution[longest_route_idx]) > 3:  # Ensure we can remove a node\n            # Select a random node from the longest route (excluding depots)\n            node_to_move = random.choice(new_solution[longest_route_idx][1:-1])\n            node_demand = demand[node_to_move]\n\n            # Try to insert into the shortest route\n            shortest_route = new_solution[shortest_route_idx]\n            if sum(demand[node] for node in shortest_route) + node_demand <= capacity:\n                # Remove node from longest route\n                new_longest_route = np.array([node for node in new_solution[longest_route_idx] if node != node_to_move])\n\n                # Find the best insertion position in the shortest route\n                best_insert_pos = 1  # default to first position\n                min_increase = float('inf')\n\n                for i in range(1, len(shortest_route)):\n                    # Calculate distance increase\n                    dist_increase = (\n                        distance_matrix[shortest_route[i-1]][node_to_move] +\n                        distance_matrix[node_to_move][shortest_route[i]] -\n                        distance_matrix[shortest_route[i-1]][shortest_route[i]]\n                    )\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_insert_pos = i\n\n                # Insert the node\n                new_shortest_route = np.concatenate([\n                    shortest_route[:best_insert_pos],\n                    [node_to_move],\n                    shortest_route[best_insert_pos:]\n                ])\n\n                # Update the solution\n                new_solution[longest_route_idx] = new_longest_route\n                new_solution[shortest_route_idx] = new_shortest_route\n\n    return new_solution\n\n",
        "score": [
            -0.6723257376740941,
            0.7984502017498016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: inter-route segment crossover\n    if len(new_solution) >= 2:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Extract a random segment from each route (excluding depot)\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Check capacity constraints for the swaps\n        segment1_demand = sum(demand[node] for node in segment1)\n        segment2_demand = sum(demand[node] for node in segment2)\n\n        # Try swapping segments if capacity allows\n        if (sum(demand[node] for node in route1) - segment1_demand + segment2_demand <= capacity and\n            sum(demand[node] for node in route2) - segment2_demand + segment1_demand <= capacity):\n\n            # Perform the swap\n            new_route1 = np.concatenate([\n                route1[:segment1_start],\n                segment2,\n                route1[segment1_end + 1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:segment2_start],\n                segment1,\n                route2[segment2_end + 1:]\n            ])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Adaptive reinsertion: move a node from a long route to a short route if possible\n    if len(new_solution) >= 2:\n        # Find the longest and shortest routes\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n\n        if len(new_solution[longest_route_idx]) > 3:  # Ensure we can remove a node\n            # Select a random node from the longest route (excluding depots)\n            node_to_move = random.choice(new_solution[longest_route_idx][1:-1])\n            node_demand = demand[node_to_move]\n\n            # Try to insert into the shortest route\n            shortest_route = new_solution[shortest_route_idx]\n            if sum(demand[node] for node in shortest_route) + node_demand <= capacity:\n                # Remove node from longest route\n                new_longest_route = np.array([node for node in new_solution[longest_route_idx] if node != node_to_move])\n\n                # Find the best insertion position in the shortest route\n                best_insert_pos = 1  # default to first position\n                min_increase = float('inf')\n\n                for i in range(1, len(shortest_route)):\n                    # Calculate distance increase\n                    dist_increase = (\n                        distance_matrix[shortest_route[i-1]][node_to_move] +\n                        distance_matrix[node_to_move][shortest_route[i]] -\n                        distance_matrix[shortest_route[i-1]][shortest_route[i]]\n                    )\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_insert_pos = i\n\n                # Insert the node\n                new_shortest_route = np.concatenate([\n                    shortest_route[:best_insert_pos],\n                    [node_to_move],\n                    shortest_route[best_insert_pos:]\n                ])\n\n                # Update the solution\n                new_solution[longest_route_idx] = new_longest_route\n                new_solution[shortest_route_idx] = new_shortest_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{A novel hybrid local search operator combines route splitting, customer reinsertion with demand-aware arc swapping, and route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # 1. Route splitting: Split a long route into two\n    if len(new_solution) > 1:\n        long_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        split_pos = len(long_route) // 2\n        new_route1 = np.concatenate([long_route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], long_route[split_pos:]])\n\n        # Check feasibility\n        if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n            new_solution[long_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # 2. Demand-aware customer reinsertion\n    for route in new_solution:\n        if len(route) > 3:  # Skip if route is too short\n            # Select a customer to remove\n            remove_pos = random.randint(1, len(route)-2)\n            customer = route[remove_pos]\n            # Try to reinsert at a better position in the same route\n            route_without = np.concatenate([route[:remove_pos], route[remove_pos+1:]])\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route_without)):\n                new_route = np.concatenate([route_without[:pos], [customer], route_without[pos:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = distance_matrix[new_route[pos-1], customer] + distance_matrix[customer, new_route[pos+1]] - distance_matrix[new_route[pos-1], new_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n            new_route = np.concatenate([route_without[:best_pos], [customer], route_without[best_pos:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    # 3. Route merging: Merge two short routes if possible\n    if len(new_solution) > 2:\n        short_routes = sorted([(i, route) for i, route in enumerate(new_solution) if len(route) < 10], key=lambda x: len(x[1]))\n        if len(short_routes) >= 2:\n            i1, route1 = short_routes[0]\n            i2, route2 = short_routes[1]\n            # Try to merge route1 into route2\n            merged_route = np.concatenate([route2[:-1], route1[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i2] = merged_route\n                new_solution.pop(i1)\n\n    return new_solution\n\n",
        "score": [
            -0.3045011182021946,
            6.594450622797012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # 1. Route splitting: Split a long route into two\n    if len(new_solution) > 1:\n        long_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        split_pos = len(long_route) // 2\n        new_route1 = np.concatenate([long_route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], long_route[split_pos:]])\n\n        # Check feasibility\n        if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n            new_solution[long_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # 2. Demand-aware customer reinsertion\n    for route in new_solution:\n        if len(route) > 3:  # Skip if route is too short\n            # Select a customer to remove\n            remove_pos = random.randint(1, len(route)-2)\n            customer = route[remove_pos]\n            # Try to reinsert at a better position in the same route\n            route_without = np.concatenate([route[:remove_pos], route[remove_pos+1:]])\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route_without)):\n                new_route = np.concatenate([route_without[:pos], [customer], route_without[pos:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = distance_matrix[new_route[pos-1], customer] + distance_matrix[customer, new_route[pos+1]] - distance_matrix[new_route[pos-1], new_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n            new_route = np.concatenate([route_without[:best_pos], [customer], route_without[best_pos:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    # 3. Route merging: Merge two short routes if possible\n    if len(new_solution) > 2:\n        short_routes = sorted([(i, route) for i, route in enumerate(new_solution) if len(route) < 10], key=lambda x: len(x[1]))\n        if len(short_routes) >= 2:\n            i1, route1 = short_routes[0]\n            i2, route2 = short_routes[1]\n            # Try to merge route1 into route2\n            merged_route = np.concatenate([route2[:-1], route1[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i2] = merged_route\n                new_solution.pop(i1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{A novel hybrid local search operator combines route splitting, customer reallocation, and adaptive 2-opt moves, guided by a dynamic balance between distance and makespan objectives to intelligently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize makespan, then distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = random.randint(0, len(selected_solution) - 1)\n    route = selected_solution[route_idx].copy()\n\n    # Hybrid local search steps\n    if len(route) > 4:  # Only consider routes with enough customers\n        # Step 1: Route splitting (if route is too long)\n        if distance_matrix[route[0], route[-1]] > np.mean([distance_matrix[r[i], r[i+1]] for r in selected_solution for i in range(len(r)-1)]):\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                selected_solution = np.append(selected_solution, [new_route2], axis=0)\n                selected_solution[route_idx] = new_route1\n\n        # Step 2: Customer reallocation (move a customer to another route)\n        if len(selected_solution) > 1 and len(route) > 3:\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find another route to insert the customer\n            for other_route_idx in range(len(selected_solution)):\n                if other_route_idx != route_idx:\n                    other_route = selected_solution[other_route_idx].copy()\n                    for insert_pos in range(1, len(other_route)):\n                        # Try inserting the customer\n                        new_other_route = np.insert(other_route, insert_pos, customer)\n\n                        # Check capacity constraint\n                        if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                            # Update routes\n                            new_route = np.delete(route, customer_pos)\n                            selected_solution[route_idx] = new_route\n                            selected_solution[other_route_idx] = new_other_route\n                            break\n                    else:\n                        continue\n                    break\n\n        # Step 3: Adaptive 2-opt (focus on improving distance or makespan)\n        if len(route) > 4:\n            i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n            new_route = np.concatenate((route[:i], route[i:j][::-1], route[j:]))\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                selected_solution[route_idx] = new_route\n\n    # Ensure no empty routes\n    selected_solution = [r for r in selected_solution if len(r) > 2]\n\n    return selected_solution\n\n",
        "score": [
            -0.6146037404545632,
            4.794387221336365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize makespan, then distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = random.randint(0, len(selected_solution) - 1)\n    route = selected_solution[route_idx].copy()\n\n    # Hybrid local search steps\n    if len(route) > 4:  # Only consider routes with enough customers\n        # Step 1: Route splitting (if route is too long)\n        if distance_matrix[route[0], route[-1]] > np.mean([distance_matrix[r[i], r[i+1]] for r in selected_solution for i in range(len(r)-1)]):\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                selected_solution = np.append(selected_solution, [new_route2], axis=0)\n                selected_solution[route_idx] = new_route1\n\n        # Step 2: Customer reallocation (move a customer to another route)\n        if len(selected_solution) > 1 and len(route) > 3:\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find another route to insert the customer\n            for other_route_idx in range(len(selected_solution)):\n                if other_route_idx != route_idx:\n                    other_route = selected_solution[other_route_idx].copy()\n                    for insert_pos in range(1, len(other_route)):\n                        # Try inserting the customer\n                        new_other_route = np.insert(other_route, insert_pos, customer)\n\n                        # Check capacity constraint\n                        if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                            # Update routes\n                            new_route = np.delete(route, customer_pos)\n                            selected_solution[route_idx] = new_route\n                            selected_solution[other_route_idx] = new_other_route\n                            break\n                    else:\n                        continue\n                    break\n\n        # Step 3: Adaptive 2-opt (focus on improving distance or makespan)\n        if len(route) > 4:\n            i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n            new_route = np.concatenate((route[:i], route[i:j][::-1], route[j:]))\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                selected_solution[route_idx] = new_route\n\n    # Ensure no empty routes\n    selected_solution = [r for r in selected_solution if len(r) > 2]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Route splitting: divide long routes into two shorter ones\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos:-1] + [0]\n\n        # Check capacity constraints for both new routes\n        def check_capacity(r):\n            return sum(demand[r[1:-1]]) <= capacity\n\n        if check_capacity(new_route1) and check_capacity(new_route2):\n            new_solution[i] = new_route1\n            new_solution.insert(i + 1, new_route2)\n            continue\n\n        # If splitting fails, perform customer reinsertion\n        for j in range(1, len(route) - 1):\n            customer = route[j]\n            # Remove customer from current route\n            new_route = route[:j] + route[j+1:]\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                # Try inserting into other routes or create a new route\n                inserted = False\n                for k in range(len(new_solution)):\n                    if k == i:\n                        continue\n                    temp_route = new_solution[k].tolist()\n                    for pos in range(1, len(temp_route)):\n                        temp_route.insert(pos, customer)\n                        if sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[k] = np.array(temp_route)\n                            inserted = True\n                            break\n                        temp_route.pop(pos)\n                    if inserted:\n                        break\n                if not inserted:\n                    # Create a new route if insertion fails\n                    new_solution.append(np.array([0, customer, 0]))\n                route = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8126903771672755,
            0.5100371837615967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Route splitting: divide long routes into two shorter ones\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos:-1] + [0]\n\n        # Check capacity constraints for both new routes\n        def check_capacity(r):\n            return sum(demand[r[1:-1]]) <= capacity\n\n        if check_capacity(new_route1) and check_capacity(new_route2):\n            new_solution[i] = new_route1\n            new_solution.insert(i + 1, new_route2)\n            continue\n\n        # If splitting fails, perform customer reinsertion\n        for j in range(1, len(route) - 1):\n            customer = route[j]\n            # Remove customer from current route\n            new_route = route[:j] + route[j+1:]\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                # Try inserting into other routes or create a new route\n                inserted = False\n                for k in range(len(new_solution)):\n                    if k == i:\n                        continue\n                    temp_route = new_solution[k].tolist()\n                    for pos in range(1, len(temp_route)):\n                        temp_route.insert(pos, customer)\n                        if sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[k] = np.array(temp_route)\n                            inserted = True\n                            break\n                        temp_route.pop(pos)\n                    if inserted:\n                        break\n                if not inserted:\n                    # Create a new route if insertion fails\n                    new_solution.append(np.array([0, customer, 0]))\n                route = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0]\n\n    # Hybrid local search: combine route merging and customer reinsertion\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Step 2: Remove a random customer from the selected route\n        if len(selected_route) > 3:  # Ensure route has customers to remove\n            remove_pos = np.random.randint(1, len(selected_route)-1)\n            removed_customer = selected_route[remove_pos]\n\n            # Step 3: Find the best insertion position in another route\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                current_load = sum(demand[route[1:-1]])\n                if current_load + demand[removed_customer] > capacity:\n                    continue\n\n                for j in range(1, len(route)):\n                    # Insert after route[j-1] and before route[j]\n                    new_distance = (distance_matrix[route[j-1]][removed_customer] +\n                                   distance_matrix[removed_customer][route[j]] -\n                                   distance_matrix[route[j-1]][route[j]])\n\n                    if new_distance < best_cost:\n                        best_cost = new_distance\n                        best_route = i\n                        best_pos = j\n\n            # Perform the insertion if feasible\n            if best_route != -1:\n                new_solution[route_idx] = np.delete(selected_route, remove_pos)\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, removed_customer)\n\n    # Step 4: Optionally merge two routes if their total demand fits in one vehicle\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity and\n            route1_idx != route2_idx):\n\n            # Create merged route by combining the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Update the solution\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    # Ensure solution remains feasible (all customers are served)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Fallback: ensure all customers are served by reinserting missing ones\n        missing = all_customers - served_customers\n        for customer in missing:\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_load = sum(demand[route[1:-1]])\n                if current_load + demand[customer] > capacity:\n                    continue\n\n                for j in range(1, len(route)):\n                    new_distance = (distance_matrix[route[j-1]][customer] +\n                                   distance_matrix[customer][route[j]] -\n                                   distance_matrix[route[j-1]][route[j]])\n\n                    if new_distance < best_cost:\n                        best_cost = new_distance\n                        best_route = i\n                        best_pos = j\n\n            if best_route != -1:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.7494070128567258,
            1.4189967811107635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0]\n\n    # Hybrid local search: combine route merging and customer reinsertion\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Step 2: Remove a random customer from the selected route\n        if len(selected_route) > 3:  # Ensure route has customers to remove\n            remove_pos = np.random.randint(1, len(selected_route)-1)\n            removed_customer = selected_route[remove_pos]\n\n            # Step 3: Find the best insertion position in another route\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                current_load = sum(demand[route[1:-1]])\n                if current_load + demand[removed_customer] > capacity:\n                    continue\n\n                for j in range(1, len(route)):\n                    # Insert after route[j-1] and before route[j]\n                    new_distance = (distance_matrix[route[j-1]][removed_customer] +\n                                   distance_matrix[removed_customer][route[j]] -\n                                   distance_matrix[route[j-1]][route[j]])\n\n                    if new_distance < best_cost:\n                        best_cost = new_distance\n                        best_route = i\n                        best_pos = j\n\n            # Perform the insertion if feasible\n            if best_route != -1:\n                new_solution[route_idx] = np.delete(selected_route, remove_pos)\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, removed_customer)\n\n    # Step 4: Optionally merge two routes if their total demand fits in one vehicle\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity and\n            route1_idx != route2_idx):\n\n            # Create merged route by combining the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Update the solution\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    # Ensure solution remains feasible (all customers are served)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Fallback: ensure all customers are served by reinserting missing ones\n        missing = all_customers - served_customers\n        for customer in missing:\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_load = sum(demand[route[1:-1]])\n                if current_load + demand[customer] > capacity:\n                    continue\n\n                for j in range(1, len(route)):\n                    new_distance = (distance_matrix[route[j-1]][customer] +\n                                   distance_matrix[customer][route[j]] -\n                                   distance_matrix[route[j-1]][route[j]])\n\n                    if new_distance < best_cost:\n                        best_cost = new_distance\n                        best_route = i\n                        best_pos = j\n\n            if best_route != -1:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    best_makespan_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route from the best makespan solution\n    selected_route_idx = np.random.randint(0, len(best_makespan_solution))\n    selected_route = best_makespan_solution[selected_route_idx].copy()\n\n    # Apply a hybrid local search operator: a combination of route splitting and customer reinsertion\n    # Step 1: Split the selected route into two parts at a random split point\n    split_point = np.random.randint(1, len(selected_route) - 1)\n    first_part = selected_route[:split_point + 1]\n    second_part = selected_route[split_point:]\n    second_part = np.concatenate(([0], second_part[1:]))\n\n    # Step 2: Check if the split parts are feasible (demand constraints)\n    first_part_demand = np.sum(demand[first_part[1:-1]])\n    second_part_demand = np.sum(demand[second_part[1:-1]])\n\n    if first_part_demand > capacity or second_part_demand > capacity:\n        # If not feasible, revert to the original route\n        new_route = selected_route\n    else:\n        # Step 3: Randomly select a customer from the second part and reinsert it into the first part\n        if len(second_part) > 2:\n            customer_to_reinsert = np.random.choice(second_part[1:-1])\n            # Find the best insertion position in the first part\n            best_insert_pos = 1\n            best_insert_cost = float('inf')\n            for i in range(1, len(first_part)):\n                # Calculate the cost of inserting the customer at position i\n                insert_cost = (distance_matrix[first_part[i-1], customer_to_reinsert] +\n                              distance_matrix[customer_to_reinsert, first_part[i]] -\n                              distance_matrix[first_part[i-1], first_part[i]])\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_pos = i\n            # Insert the customer into the first part\n            first_part = np.insert(first_part, best_insert_pos, customer_to_reinsert)\n            # Remove the customer from the second part\n            second_part = np.delete(second_part, np.where(second_part == customer_to_reinsert)[0][0])\n\n    # Step 4: Update the solution with the modified routes\n    new_solution = best_makespan_solution.copy()\n    new_solution[selected_route_idx] = first_part\n    if len(second_part) > 2:\n        new_solution.append(second_part)\n    else:\n        # If the second part is empty or only depot, remove it\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.828423209674221,
            0.4659484326839447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    best_makespan_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route from the best makespan solution\n    selected_route_idx = np.random.randint(0, len(best_makespan_solution))\n    selected_route = best_makespan_solution[selected_route_idx].copy()\n\n    # Apply a hybrid local search operator: a combination of route splitting and customer reinsertion\n    # Step 1: Split the selected route into two parts at a random split point\n    split_point = np.random.randint(1, len(selected_route) - 1)\n    first_part = selected_route[:split_point + 1]\n    second_part = selected_route[split_point:]\n    second_part = np.concatenate(([0], second_part[1:]))\n\n    # Step 2: Check if the split parts are feasible (demand constraints)\n    first_part_demand = np.sum(demand[first_part[1:-1]])\n    second_part_demand = np.sum(demand[second_part[1:-1]])\n\n    if first_part_demand > capacity or second_part_demand > capacity:\n        # If not feasible, revert to the original route\n        new_route = selected_route\n    else:\n        # Step 3: Randomly select a customer from the second part and reinsert it into the first part\n        if len(second_part) > 2:\n            customer_to_reinsert = np.random.choice(second_part[1:-1])\n            # Find the best insertion position in the first part\n            best_insert_pos = 1\n            best_insert_cost = float('inf')\n            for i in range(1, len(first_part)):\n                # Calculate the cost of inserting the customer at position i\n                insert_cost = (distance_matrix[first_part[i-1], customer_to_reinsert] +\n                              distance_matrix[customer_to_reinsert, first_part[i]] -\n                              distance_matrix[first_part[i-1], first_part[i]])\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_pos = i\n            # Insert the customer into the first part\n            first_part = np.insert(first_part, best_insert_pos, customer_to_reinsert)\n            # Remove the customer from the second part\n            second_part = np.delete(second_part, np.where(second_part == customer_to_reinsert)[0][0])\n\n    # Step 4: Update the solution with the modified routes\n    new_solution = best_makespan_solution.copy()\n    new_solution[selected_route_idx] = first_part\n    if len(second_part) > 2:\n        new_solution.append(second_part)\n    else:\n        # If the second part is empty or only depot, remove it\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{The algorithm selects a solution from the archive with the highest combined normalized improvement potential, then applies a hybrid local search combining route merging, intra-route relocations, and capacity-aware swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(1 / (obj[0] + 1e-6)) + (1 / (obj[1] + 1e-6)) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Multiple iterations for better exploration\n        # 1. Route merging (if possible)\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            # Check if merging is feasible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                merged = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged\n                del new_solution[j]\n\n        # 2. Intra-route relocation with capacity check\n        for route in new_solution:\n            if len(route) > 3:  # Only if route has customers\n                a, b = np.random.choice(len(route) - 2, 2, replace=False) + 1\n                if a > b:\n                    a, b = b, a\n\n                # Check capacity constraint\n                segment = route[a:b+1]\n                remaining_route = np.concatenate([route[:a], route[b+1:]])\n                if sum(demand[segment[1:-1]]) + sum(demand[remaining_route[1:-1]]) <= capacity:\n                    # Relocate segment\n                    insert_pos = np.random.randint(1, len(remaining_route))\n                    new_route = np.concatenate([remaining_route[:insert_pos], segment, remaining_route[insert_pos:]])\n                    route[:] = new_route\n\n        # 3. Capacity-aware swap between routes\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            if len(route1) > 2 and len(route2) > 2:\n                a = np.random.randint(1, len(route1) - 1)\n                b = np.random.randint(1, len(route2) - 1)\n\n                # Check capacity constraints\n                if (sum(demand[route1[1:-1]]) - demand[route1[a]] + demand[route2[b]] <= capacity and\n                    sum(demand[route2[1:-1]]) - demand[route2[b]] + demand[route1[a]] <= capacity):\n                    # Perform swap\n                    route1[a], route2[b] = route2[b], route1[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5414220038625113,
            6.321032077074051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(1 / (obj[0] + 1e-6)) + (1 / (obj[1] + 1e-6)) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Multiple iterations for better exploration\n        # 1. Route merging (if possible)\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            # Check if merging is feasible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                merged = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged\n                del new_solution[j]\n\n        # 2. Intra-route relocation with capacity check\n        for route in new_solution:\n            if len(route) > 3:  # Only if route has customers\n                a, b = np.random.choice(len(route) - 2, 2, replace=False) + 1\n                if a > b:\n                    a, b = b, a\n\n                # Check capacity constraint\n                segment = route[a:b+1]\n                remaining_route = np.concatenate([route[:a], route[b+1:]])\n                if sum(demand[segment[1:-1]]) + sum(demand[remaining_route[1:-1]]) <= capacity:\n                    # Relocate segment\n                    insert_pos = np.random.randint(1, len(remaining_route))\n                    new_route = np.concatenate([remaining_route[:insert_pos], segment, remaining_route[insert_pos:]])\n                    route[:] = new_route\n\n        # 3. Capacity-aware swap between routes\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            if len(route1) > 2 and len(route2) > 2:\n                a = np.random.randint(1, len(route1) - 1)\n                b = np.random.randint(1, len(route2) - 1)\n\n                # Check capacity constraints\n                if (sum(demand[route1[1:-1]]) - demand[route1[a]] + demand[route2[b]] <= capacity and\n                    sum(demand[route2[1:-1]]) - demand[route2[b]] + demand[route1[a]] <= capacity):\n                    # Perform swap\n                    route1[a], route2[b] = route2[b], route1[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route-segment swapping with capacity-aware demand rebalancing to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = [obj[0] for _, obj in archive]\n    makespans = [obj[1] for _, obj in archive]\n\n    # Normalize objectives\n    min_dist, max_dist = min(total_distances), max(total_distances)\n    min_makespan, max_makespan = min(makespans), max(makespans)\n\n    normalized_scores = []\n    for i, (dist, makespan) in enumerate(zip(total_distances, makespans)):\n        norm_dist = (dist - min_dist) / (max_dist - min_dist + 1e-8)\n        norm_makespan = (makespan - min_makespan) / (max_makespan - min_makespan + 1e-8)\n        # Weighted score (higher weight to makespan to encourage diversity)\n        score = 0.3 * norm_dist + 0.7 * norm_makespan\n        normalized_scores.append(score)\n\n    # Invert scores to select solutions with lower scores (better objectives)\n    inverted_scores = [1 / (s + 1e-8) for s in normalized_scores]\n    total_score = sum(inverted_scores)\n    probabilities = [s / total_score for s in inverted_scores]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Route-segment swapping with demand rebalancing\n    new_solution = [route.copy() for route in base_solution]\n\n    # Select two random routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Select random segments from each route (excluding depot)\n    if len(route1) <= 2 or len(route2) <= 2:\n        return new_solution\n\n    # Select segment from route1\n    start1 = random.randint(1, len(route1) - 2)\n    end1 = random.randint(start1, len(route1) - 2)\n    segment1 = route1[start1:end1 + 1]\n\n    # Select segment from route2\n    start2 = random.randint(1, len(route2) - 2)\n    end2 = random.randint(start2, len(route2) - 2)\n    segment2 = route2[start2:end2 + 1]\n\n    # Calculate demand of segments\n    demand1 = np.sum(demand[segment1])\n    demand2 = np.sum(demand[segment2])\n\n    # Check feasibility: swap if demand constraints are satisfied\n    current_demand1 = np.sum(demand[route1]) - demand1\n    current_demand2 = np.sum(demand[route2]) - demand2\n\n    if (current_demand1 + demand2 <= capacity) and (current_demand2 + demand1 <= capacity):\n        # Perform swap\n        new_route1 = np.concatenate([route1[:start1], segment2, route1[end1 + 1:]])\n        new_route2 = np.concatenate([route2[:start2], segment1, route2[end2 + 1:]])\n\n        # Update solution\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    # Optional: Apply additional local search (e.g., 2-opt on individual routes)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:\n            # Randomly select two edges to reverse\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            # Check if reversal improves distance\n            original_dist = (distance_matrix[route[a - 1], route[a]] +\n                           distance_matrix[route[b], route[b + 1]])\n            reversed_dist = (distance_matrix[route[a - 1], route[b]] +\n                            distance_matrix[route[a], route[b + 1]])\n            if reversed_dist < original_dist:\n                new_route = np.concatenate([route[:a], route[a:b + 1][::-1], route[b + 1:]])\n                new_solution[i] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.33297477322321595,
            1.6607674062252045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = [obj[0] for _, obj in archive]\n    makespans = [obj[1] for _, obj in archive]\n\n    # Normalize objectives\n    min_dist, max_dist = min(total_distances), max(total_distances)\n    min_makespan, max_makespan = min(makespans), max(makespans)\n\n    normalized_scores = []\n    for i, (dist, makespan) in enumerate(zip(total_distances, makespans)):\n        norm_dist = (dist - min_dist) / (max_dist - min_dist + 1e-8)\n        norm_makespan = (makespan - min_makespan) / (max_makespan - min_makespan + 1e-8)\n        # Weighted score (higher weight to makespan to encourage diversity)\n        score = 0.3 * norm_dist + 0.7 * norm_makespan\n        normalized_scores.append(score)\n\n    # Invert scores to select solutions with lower scores (better objectives)\n    inverted_scores = [1 / (s + 1e-8) for s in normalized_scores]\n    total_score = sum(inverted_scores)\n    probabilities = [s / total_score for s in inverted_scores]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Route-segment swapping with demand rebalancing\n    new_solution = [route.copy() for route in base_solution]\n\n    # Select two random routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Select random segments from each route (excluding depot)\n    if len(route1) <= 2 or len(route2) <= 2:\n        return new_solution\n\n    # Select segment from route1\n    start1 = random.randint(1, len(route1) - 2)\n    end1 = random.randint(start1, len(route1) - 2)\n    segment1 = route1[start1:end1 + 1]\n\n    # Select segment from route2\n    start2 = random.randint(1, len(route2) - 2)\n    end2 = random.randint(start2, len(route2) - 2)\n    segment2 = route2[start2:end2 + 1]\n\n    # Calculate demand of segments\n    demand1 = np.sum(demand[segment1])\n    demand2 = np.sum(demand[segment2])\n\n    # Check feasibility: swap if demand constraints are satisfied\n    current_demand1 = np.sum(demand[route1]) - demand1\n    current_demand2 = np.sum(demand[route2]) - demand2\n\n    if (current_demand1 + demand2 <= capacity) and (current_demand2 + demand1 <= capacity):\n        # Perform swap\n        new_route1 = np.concatenate([route1[:start1], segment2, route1[end1 + 1:]])\n        new_route2 = np.concatenate([route2[:start2], segment1, route2[end2 + 1:]])\n\n        # Update solution\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    # Optional: Apply additional local search (e.g., 2-opt on individual routes)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:\n            # Randomly select two edges to reverse\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            # Check if reversal improves distance\n            original_dist = (distance_matrix[route[a - 1], route[a]] +\n                           distance_matrix[route[b], route[b + 1]])\n            reversed_dist = (distance_matrix[route[a - 1], route[b]] +\n                            distance_matrix[route[a], route[b + 1]])\n            if reversed_dist < original_dist:\n                new_route = np.concatenate([route[:a], route[a:b + 1][::-1], route[b + 1:]])\n                new_solution[i] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The algorithm selects a solution from the archive based on the Pareto front, then applies a hybrid local search combining route segment reversal with demand-aware insertion to balance distance and makespan objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    for i, (sol, (dist, span)) in enumerate(archive):\n        if dist <= archive[selected_idx][1][0] and span <= archive[selected_idx][1][1]:\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route segment reversal with demand-aware insertion\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a segment from route1\n        if len(route1) > 3:  # Ensure segment has at least one customer\n            start = random.randint(1, len(route1) - 2)\n            end = random.randint(start, len(route1) - 2)\n            segment = route1[start:end+1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Try to insert segment into route2\n            if segment_demand <= capacity:\n                # Find insertion point in route2\n                best_pos = -1\n                best_cost = float('inf')\n                for i in range(1, len(route2)):\n                    # Calculate cost of inserting segment before i\n                    prev_node = route2[i-1]\n                    next_node = route2[i]\n                    insert_cost = (distance_matrix[prev_node, segment[0]] +\n                                 distance_matrix[segment[-1], next_node] -\n                                 distance_matrix[prev_node, next_node])\n\n                    if insert_cost < best_cost:\n                        best_cost = insert_cost\n                        best_pos = i\n\n                if best_pos != -1:\n                    # Perform insertion\n                    new_route2 = np.concatenate((route2[:best_pos], segment, route2[best_pos:]))\n                    # Remove segment from route1\n                    new_route1 = np.concatenate((route1[:start], route1[end+1:]))\n                    # Update solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Additional: Try to reverse a segment in a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            # Check capacity constraint for reversed segment\n            segment_demand = sum(demand[node] for node in route[start:end+1])\n            if segment_demand <= capacity:\n                # Reverse the segment\n                new_route = np.concatenate((route[:start], route[start:end+1][::-1], route[end+1:]))\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7103222713702485,
            0.5301930606365204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    for i, (sol, (dist, span)) in enumerate(archive):\n        if dist <= archive[selected_idx][1][0] and span <= archive[selected_idx][1][1]:\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route segment reversal with demand-aware insertion\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a segment from route1\n        if len(route1) > 3:  # Ensure segment has at least one customer\n            start = random.randint(1, len(route1) - 2)\n            end = random.randint(start, len(route1) - 2)\n            segment = route1[start:end+1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Try to insert segment into route2\n            if segment_demand <= capacity:\n                # Find insertion point in route2\n                best_pos = -1\n                best_cost = float('inf')\n                for i in range(1, len(route2)):\n                    # Calculate cost of inserting segment before i\n                    prev_node = route2[i-1]\n                    next_node = route2[i]\n                    insert_cost = (distance_matrix[prev_node, segment[0]] +\n                                 distance_matrix[segment[-1], next_node] -\n                                 distance_matrix[prev_node, next_node])\n\n                    if insert_cost < best_cost:\n                        best_cost = insert_cost\n                        best_pos = i\n\n                if best_pos != -1:\n                    # Perform insertion\n                    new_route2 = np.concatenate((route2[:best_pos], segment, route2[best_pos:]))\n                    # Remove segment from route1\n                    new_route1 = np.concatenate((route1[:start], route1[end+1:]))\n                    # Update solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Additional: Try to reverse a segment in a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            # Check capacity constraint for reversed segment\n            segment_demand = sum(demand[node] for node in route[start:end+1])\n            if segment_demand <= capacity:\n                # Reverse the segment\n                new_route = np.concatenate((route[:start], route[start:end+1][::-1], route[end+1:]))\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{A novel local search strategy combines route splitting, customer reallocation, and smart route merging to balance distance and makespan objectives while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidate_solutions = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan\n    selected_solution = random.choice(candidate_solutions[:max(1, len(candidate_solutions)//2)])[0].copy()\n\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 2:  # Skip empty or trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two segments at a random point\n        split_idx = random.randint(1, len(route)-2)\n        segment1 = route[:split_idx+1]\n        segment2 = route[split_idx:]\n\n        # Check capacity constraints for both segments\n        def is_feasible(segment):\n            return np.sum(demand[segment[1:-1]]) <= capacity\n\n        if is_feasible(segment1) and is_feasible(segment2):\n            new_solution.append(segment1)\n            new_solution.append(segment2)\n        else:\n            new_solution.append(route.copy())\n\n    # Attempt to merge routes if possible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Try merging route1 and route2\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Reallocate customers between routes if possible\n    for _ in range(2):  # Try a few reallocations\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) <= 2 or len(route_j) <= 2:\n            continue\n\n        # Try moving a customer from route_i to route_j\n        customer_pos = random.randint(1, len(route_i)-2)\n        customer = route_i[customer_pos]\n\n        # Check if moving the customer to route_j is feasible\n        if np.sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n            # Find best insertion position in route_j\n            best_pos = 1\n            min_cost = float('inf')\n            for pos in range(1, len(route_j)):\n                cost = distance_matrix[route_j[pos-1], customer] + distance_matrix[customer, route_j[pos]] - distance_matrix[route_j[pos-1], route_j[pos]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n            # Perform the move\n            new_route_i = np.concatenate([route_i[:customer_pos], route_i[customer_pos+1:]])\n            new_route_j = np.insert(route_j, best_pos, customer)\n\n            new_solution[i] = new_route_i\n            new_solution[j] = new_route_j\n\n    return new_solution\n\n",
        "score": [
            -0.726801203405929,
            0.9673751890659332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidate_solutions = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan\n    selected_solution = random.choice(candidate_solutions[:max(1, len(candidate_solutions)//2)])[0].copy()\n\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 2:  # Skip empty or trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two segments at a random point\n        split_idx = random.randint(1, len(route)-2)\n        segment1 = route[:split_idx+1]\n        segment2 = route[split_idx:]\n\n        # Check capacity constraints for both segments\n        def is_feasible(segment):\n            return np.sum(demand[segment[1:-1]]) <= capacity\n\n        if is_feasible(segment1) and is_feasible(segment2):\n            new_solution.append(segment1)\n            new_solution.append(segment2)\n        else:\n            new_solution.append(route.copy())\n\n    # Attempt to merge routes if possible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Try merging route1 and route2\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Reallocate customers between routes if possible\n    for _ in range(2):  # Try a few reallocations\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) <= 2 or len(route_j) <= 2:\n            continue\n\n        # Try moving a customer from route_i to route_j\n        customer_pos = random.randint(1, len(route_i)-2)\n        customer = route_i[customer_pos]\n\n        # Check if moving the customer to route_j is feasible\n        if np.sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n            # Find best insertion position in route_j\n            best_pos = 1\n            min_cost = float('inf')\n            for pos in range(1, len(route_j)):\n                cost = distance_matrix[route_j[pos-1], customer] + distance_matrix[customer, route_j[pos]] - distance_matrix[route_j[pos-1], route_j[pos]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n            # Perform the move\n            new_route_i = np.concatenate([route_i[:customer_pos], route_i[customer_pos+1:]])\n            new_route_j = np.insert(route_j, best_pos, customer)\n\n            new_solution[i] = new_route_i\n            new_solution[j] = new_route_j\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the two routes by concatenating them (excluding the second depot)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n            # Step 3: Apply a 3-opt* local search to improve the merged route\n            improved_route = _apply_3opt_star(merged_route, distance_matrix, demand, capacity)\n            new_solution[route1_idx] = improved_route\n\n    # Step 4: Randomly select a route and apply a customer reinsertion\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure there are customers to reinsert\n            # Randomly select a customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Remove the customer from the route\n            route = np.delete(route, customer_pos)\n\n            # Find the best insertion position in the same route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                if sum(demand[route[1:pos]]) + demand[customer] <= capacity and sum(demand[route[pos:-1]]) + demand[customer] <= capacity:\n                    cost = distance_matrix[route[pos-1]][customer] + distance_matrix[customer][route[pos]] - distance_matrix[route[pos-1]][route[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            # Insert the customer at the best position\n            route = np.insert(route, best_pos, customer)\n            new_solution[route_idx] = route\n\n    return new_solution\n\n",
        "score": [
            -0.4825758663116867,
            5.407526850700378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the two routes by concatenating them (excluding the second depot)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n            # Step 3: Apply a 3-opt* local search to improve the merged route\n            improved_route = _apply_3opt_star(merged_route, distance_matrix, demand, capacity)\n            new_solution[route1_idx] = improved_route\n\n    # Step 4: Randomly select a route and apply a customer reinsertion\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure there are customers to reinsert\n            # Randomly select a customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Remove the customer from the route\n            route = np.delete(route, customer_pos)\n\n            # Find the best insertion position in the same route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                if sum(demand[route[1:pos]]) + demand[customer] <= capacity and sum(demand[route[pos:-1]]) + demand[customer] <= capacity:\n                    cost = distance_matrix[route[pos-1]][customer] + distance_matrix[customer][route[pos]] - distance_matrix[route[pos-1]][route[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            # Insert the customer at the best position\n            route = np.insert(route, best_pos, customer)\n            new_solution[route_idx] = route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{A novel hybrid local search operator combines route segmentation, demand-aware customer reallocation, and adaptive route merging to balance distance and makespan minimization while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search steps:\n    # 1. Route segmentation: Split long routes into smaller segments\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            split_pos = np.random.randint(1, len(route)-1)\n            new_route1 = route[:split_pos+1]\n            new_route2 = [0] + route[split_pos:]\n\n            # Check capacity feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    # 2. Demand-aware reallocation: Move customers between routes\n    for _ in range(2):  # Try multiple times\n        route1_idx = np.random.randint(len(new_solution))\n        route2_idx = np.random.randint(len(new_solution))\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a customer from route1\n        if len(route1) > 2:\n            customer_pos = np.random.randint(1, len(route1)-1)\n            customer = route1[customer_pos]\n\n            # Check if moving to route2 is feasible\n            if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into route2 (greedy position)\n                best_pos = 1\n                min_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    # Calculate insertion cost (distance increase)\n                    cost = (distance_matrix[route2[pos-1]][customer] +\n                            distance_matrix[customer][route2[pos]] -\n                            distance_matrix[route2[pos-1]][route2[pos]])\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = pos\n\n                # Perform the move\n                new_route1 = np.delete(route1, customer_pos)\n                new_route2 = np.insert(route2, best_pos, customer)\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # 3. Adaptive route merging: Combine short routes if beneficial\n    for i in range(len(new_solution)-1):\n        for j in range(i+1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible and beneficial\n            if (len(route1) > 2 and len(route2) > 2 and\n                sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity):\n\n                # Try merging in both directions\n                merged_route1 = np.concatenate((route1[:-1], route2[1:]))\n                merged_route2 = np.concatenate((route2[:-1], route1[1:]))\n\n                # Calculate potential cost reduction\n                original_cost = (distance_matrix[route1[-2]][0] +\n                               distance_matrix[route2[-2]][0])\n                new_cost1 = distance_matrix[merged_route1[-2]][0]\n                new_cost2 = distance_matrix[merged_route2[-2]][0]\n\n                if new_cost1 < original_cost or new_cost2 < original_cost:\n                    # Choose the better merging option\n                    if new_cost1 < new_cost2:\n                        new_solution[i] = merged_route1\n                        new_solution.pop(j)\n                    else:\n                        new_solution[j] = merged_route2\n                        new_solution.pop(i)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7128478156591425,
            2.2725031077861786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search steps:\n    # 1. Route segmentation: Split long routes into smaller segments\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            split_pos = np.random.randint(1, len(route)-1)\n            new_route1 = route[:split_pos+1]\n            new_route2 = [0] + route[split_pos:]\n\n            # Check capacity feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    # 2. Demand-aware reallocation: Move customers between routes\n    for _ in range(2):  # Try multiple times\n        route1_idx = np.random.randint(len(new_solution))\n        route2_idx = np.random.randint(len(new_solution))\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a customer from route1\n        if len(route1) > 2:\n            customer_pos = np.random.randint(1, len(route1)-1)\n            customer = route1[customer_pos]\n\n            # Check if moving to route2 is feasible\n            if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into route2 (greedy position)\n                best_pos = 1\n                min_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    # Calculate insertion cost (distance increase)\n                    cost = (distance_matrix[route2[pos-1]][customer] +\n                            distance_matrix[customer][route2[pos]] -\n                            distance_matrix[route2[pos-1]][route2[pos]])\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = pos\n\n                # Perform the move\n                new_route1 = np.delete(route1, customer_pos)\n                new_route2 = np.insert(route2, best_pos, customer)\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # 3. Adaptive route merging: Combine short routes if beneficial\n    for i in range(len(new_solution)-1):\n        for j in range(i+1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible and beneficial\n            if (len(route1) > 2 and len(route2) > 2 and\n                sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity):\n\n                # Try merging in both directions\n                merged_route1 = np.concatenate((route1[:-1], route2[1:]))\n                merged_route2 = np.concatenate((route2[:-1], route1[1:]))\n\n                # Calculate potential cost reduction\n                original_cost = (distance_matrix[route1[-2]][0] +\n                               distance_matrix[route2[-2]][0])\n                new_cost1 = distance_matrix[merged_route1[-2]][0]\n                new_cost2 = distance_matrix[merged_route2[-2]][0]\n\n                if new_cost1 < original_cost or new_cost2 < original_cost:\n                    # Choose the better merging option\n                    if new_cost1 < new_cost2:\n                        new_solution[i] = merged_route1\n                        new_solution.pop(j)\n                    else:\n                        new_solution[j] = merged_route2\n                        new_solution.pop(i)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a weighted random choice favoring solutions with high potential for improvement (low makespan or total distance), then applies a hybrid local search combining route merging, split-and-rebalance, and adaptive node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route merging + split-and-rebalance + adaptive reinsertion\n    if len(new_solution) > 1:\n        # Step 1: Route merging (merge two routes if feasible)\n        route1, route2 = random.sample(range(len(new_solution)), 2)\n        merged_route = np.concatenate([new_solution[route1][:-1], new_solution[route2][1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [merged_route if i == route1 else route for i, route in enumerate(new_solution) if i != route2]\n\n    # Step 2: Split-and-rebalance (split long routes if possible)\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Only consider routes with more than 3 customers\n            split_point = random.randint(2, len(route)-3)\n            first_part = route[:split_point+1]\n            second_part = np.concatenate([[0], route[split_point:]])\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[i] = first_part\n                new_solution.insert(i+1, second_part)\n\n    # Step 3: Adaptive node reinsertion (move nodes between routes intelligently)\n    for _ in range(3):  # Try 3 times\n        if len(new_solution) > 1:\n            src_route_idx = random.randint(0, len(new_solution)-1)\n            src_route = new_solution[src_route_idx]\n            if len(src_route) > 3:  # Only if route has enough nodes to remove\n                node_pos = random.randint(1, len(src_route)-2)\n                node = src_route[node_pos]\n                # Try inserting into a different route\n                for dst_route_idx in range(len(new_solution)):\n                    if dst_route_idx != src_route_idx:\n                        dst_route = new_solution[dst_route_idx]\n                        # Try to insert at every possible position\n                        for pos in range(1, len(dst_route)):\n                            new_route = np.insert(dst_route, pos, node)\n                            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                # Remove from source route\n                                new_solution[src_route_idx] = np.delete(src_route, node_pos)\n                                # Update destination route\n                                new_solution[dst_route_idx] = new_route\n                                break\n                        else:\n                            continue\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6874182635920354,
            1.5641948878765106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route merging + split-and-rebalance + adaptive reinsertion\n    if len(new_solution) > 1:\n        # Step 1: Route merging (merge two routes if feasible)\n        route1, route2 = random.sample(range(len(new_solution)), 2)\n        merged_route = np.concatenate([new_solution[route1][:-1], new_solution[route2][1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [merged_route if i == route1 else route for i, route in enumerate(new_solution) if i != route2]\n\n    # Step 2: Split-and-rebalance (split long routes if possible)\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Only consider routes with more than 3 customers\n            split_point = random.randint(2, len(route)-3)\n            first_part = route[:split_point+1]\n            second_part = np.concatenate([[0], route[split_point:]])\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[i] = first_part\n                new_solution.insert(i+1, second_part)\n\n    # Step 3: Adaptive node reinsertion (move nodes between routes intelligently)\n    for _ in range(3):  # Try 3 times\n        if len(new_solution) > 1:\n            src_route_idx = random.randint(0, len(new_solution)-1)\n            src_route = new_solution[src_route_idx]\n            if len(src_route) > 3:  # Only if route has enough nodes to remove\n                node_pos = random.randint(1, len(src_route)-2)\n                node = src_route[node_pos]\n                # Try inserting into a different route\n                for dst_route_idx in range(len(new_solution)):\n                    if dst_route_idx != src_route_idx:\n                        dst_route = new_solution[dst_route_idx]\n                        # Try to insert at every possible position\n                        for pos in range(1, len(dst_route)):\n                            new_route = np.insert(dst_route, pos, node)\n                            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                # Remove from source route\n                                new_solution[src_route_idx] = np.delete(src_route, node_pos)\n                                # Update destination route\n                                new_solution[dst_route_idx] = new_route\n                                break\n                        else:\n                            continue\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route splitting, demand-based customer reallocation, and adaptive 2-opt with capacity checks to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route Splitting (split long routes into shorter ones)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Demand-based Customer Reallocation (move customers between routes)\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select a customer from route1 and try to insert into route2\n        customer = random.choice(route1[1:-1])\n        new_route2 = np.concatenate((route2[:-1], [customer], [0]))\n        new_route1 = np.delete(route1, np.where(route1 == customer))\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n            break\n\n    # Step 3: Adaptive 2-opt with capacity checks\n    for route in new_solution:\n        if len(route) < 4:\n            continue\n        a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n        new_route = np.concatenate((route[:a], route[b:a-1:-1], route[b+1:]))\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route[:] = new_route\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.6941488581810642,
            2.639125317335129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route Splitting (split long routes into shorter ones)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Demand-based Customer Reallocation (move customers between routes)\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select a customer from route1 and try to insert into route2\n        customer = random.choice(route1[1:-1])\n        new_route2 = np.concatenate((route2[:-1], [customer], [0]))\n        new_route1 = np.delete(route1, np.where(route1 == customer))\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n            break\n\n    # Step 3: Adaptive 2-opt with capacity checks\n    for route in new_solution:\n        if len(route) < 4:\n            continue\n        a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n        new_route = np.concatenate((route[:a], route[b:a-1:-1], route[b+1:]))\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route[:] = new_route\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_point = len(route) // 2\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity and\n            np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.extend([part1, part2])\n        else:\n            new_solution.append(route.copy())\n\n    # Try to merge adjacent routes if capacity allows\n    i = 0\n    while i < len(new_solution) - 1:\n        route1 = new_solution[i]\n        route2 = new_solution[i+1]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged\n            new_solution.pop(i+1)\n        else:\n            i += 1\n\n    # Perform random customer reallocation between routes\n    for _ in range(3):  # Try 3 random reallocations\n        if len(new_solution) < 2:\n            break\n\n        # Select two random routes\n        r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[r1]\n        route2 = new_solution[r2]\n\n        # Select a random customer from each route\n        if len(route1) > 2 and len(route2) > 2:\n            cust1 = np.random.choice(route1[1:-1])\n            cust2 = np.random.choice(route2[1:-1])\n\n            # Check if swapping improves feasibility\n            new_route1 = np.delete(route1, np.where(route1 == cust1))\n            new_route1 = np.insert(new_route1, -1, cust2)\n\n            new_route2 = np.delete(route2, np.where(route2 == cust2))\n            new_route2 = np.insert(new_route2, -1, cust1)\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[r1] = new_route1\n                new_solution[r2] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.6962731791667964,
            2.999816358089447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_point = len(route) // 2\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity and\n            np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.extend([part1, part2])\n        else:\n            new_solution.append(route.copy())\n\n    # Try to merge adjacent routes if capacity allows\n    i = 0\n    while i < len(new_solution) - 1:\n        route1 = new_solution[i]\n        route2 = new_solution[i+1]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged\n            new_solution.pop(i+1)\n        else:\n            i += 1\n\n    # Perform random customer reallocation between routes\n    for _ in range(3):  # Try 3 random reallocations\n        if len(new_solution) < 2:\n            break\n\n        # Select two random routes\n        r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[r1]\n        route2 = new_solution[r2]\n\n        # Select a random customer from each route\n        if len(route1) > 2 and len(route2) > 2:\n            cust1 = np.random.choice(route1[1:-1])\n            cust2 = np.random.choice(route2[1:-1])\n\n            # Check if swapping improves feasibility\n            new_route1 = np.delete(route1, np.where(route1 == cust1))\n            new_route1 = np.insert(new_route1, -1, cust2)\n\n            new_route2 = np.delete(route2, np.where(route2 == cust2))\n            new_route2 = np.insert(new_route2, -1, cust1)\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[r1] = new_route1\n                new_solution[r2] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes (only depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Hybrid local search: Combine route splitting with inter-route insertion\n        split_pos = np.random.randint(1, len(route) - 1)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n            np.sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n        else:\n            # If splitting violates capacity, try inter-route insertion\n            # Find the most promising customer to move to another route\n            best_customer = None\n            best_reduction = 0\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                # Calculate potential distance reduction if moved\n                prev_node = route[i-1]\n                next_node = route[i+1]\n                original_dist = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                new_dist = distance_matrix[prev_node][next_node]\n                reduction = original_dist - new_dist\n\n                if reduction > best_reduction:\n                    best_reduction = reduction\n                    best_customer = customer\n\n            if best_customer is not None:\n                # Find the route with the most capacity available\n                target_route = max(new_solution, key=lambda r: capacity - np.sum(demand[r[1:-1]]))\n                if capacity - np.sum(demand[target_route[1:-1]]) >= demand[best_customer]:\n                    # Insert customer into the target route (simplified insertion)\n                    insert_pos = len(target_route) - 1\n                    target_route.insert(insert_pos, best_customer)\n                    # Remove from original route\n                    route = np.delete(route, i)\n                    if len(route) > 2:  # Ensure route remains valid\n                        new_solution.append(route)\n            else:\n                new_solution.append(route)\n\n    return new_solution\n\n",
        "score": [
            -0.6933014100613455,
            0.7022131681442261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes (only depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Hybrid local search: Combine route splitting with inter-route insertion\n        split_pos = np.random.randint(1, len(route) - 1)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n            np.sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n        else:\n            # If splitting violates capacity, try inter-route insertion\n            # Find the most promising customer to move to another route\n            best_customer = None\n            best_reduction = 0\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                # Calculate potential distance reduction if moved\n                prev_node = route[i-1]\n                next_node = route[i+1]\n                original_dist = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                new_dist = distance_matrix[prev_node][next_node]\n                reduction = original_dist - new_dist\n\n                if reduction > best_reduction:\n                    best_reduction = reduction\n                    best_customer = customer\n\n            if best_customer is not None:\n                # Find the route with the most capacity available\n                target_route = max(new_solution, key=lambda r: capacity - np.sum(demand[r[1:-1]]))\n                if capacity - np.sum(demand[target_route[1:-1]]) >= demand[best_customer]:\n                    # Insert customer into the target route (simplified insertion)\n                    insert_pos = len(target_route) - 1\n                    target_route.insert(insert_pos, best_customer)\n                    # Remove from original route\n                    route = np.delete(route, i)\n                    if len(route) > 2:  # Ensure route remains valid\n                        new_solution.append(route)\n            else:\n                new_solution.append(route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        # Split long routes into two parts if possible\n        if len(route) > 3:  # Ensure route has at least one customer\n            split_point = len(route) // 2\n            first_half = route[:split_point + 1]  # Include depot\n            second_half = [route[0]] + route[split_point:-1] + [route[-1]]  # Include depot\n\n            # Check capacity constraints for both halves\n            if (np.sum(demand[first_half[1:-1]]) <= capacity and\n                np.sum(demand[second_half[1:-1]]) <= capacity):\n                new_solution.extend([first_half, second_half])\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i != j:\n                # Try to move a random customer from route i to route j\n                route_i = new_solution[i]\n                if len(route_i) > 3:  # Ensure route has customers to move\n                    customer_idx = np.random.randint(1, len(route_i) - 1)\n                    customer = route_i[customer_idx]\n\n                    # Check if moving this customer to route j is feasible\n                    if (np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity):\n                        # Update routes\n                        new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx + 1:]])\n                        new_solution[i] = new_route_i\n                        new_solution[j] = np.concatenate([new_solution[j][:-1], [customer], [new_solution[j][-1]]])\n                        break\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7161651759999692,
            3.373935341835022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        # Split long routes into two parts if possible\n        if len(route) > 3:  # Ensure route has at least one customer\n            split_point = len(route) // 2\n            first_half = route[:split_point + 1]  # Include depot\n            second_half = [route[0]] + route[split_point:-1] + [route[-1]]  # Include depot\n\n            # Check capacity constraints for both halves\n            if (np.sum(demand[first_half[1:-1]]) <= capacity and\n                np.sum(demand[second_half[1:-1]]) <= capacity):\n                new_solution.extend([first_half, second_half])\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i != j:\n                # Try to move a random customer from route i to route j\n                route_i = new_solution[i]\n                if len(route_i) > 3:  # Ensure route has customers to move\n                    customer_idx = np.random.randint(1, len(route_i) - 1)\n                    customer = route_i[customer_idx]\n\n                    # Check if moving this customer to route j is feasible\n                    if (np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity):\n                        # Update routes\n                        new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx + 1:]])\n                        new_solution[i] = new_route_i\n                        new_solution[j] = np.concatenate([new_solution[j][:-1], [customer], [new_solution[j][-1]]])\n                        break\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of the two objectives, then applies a hybrid local search combining route segment swaps with capacity-aware insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segment swap with capacity check\n    if len(new_solution) >= 2:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random segment from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            # Segment from route1\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg1 = route1[seg1_start:seg1_end + 1]\n\n            # Segment from route2\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n            seg2 = route2[seg2_start:seg2_end + 1]\n\n            # Calculate new demands for both routes\n            current_demand1 = sum(demand[route1[1:-1]])\n            current_demand2 = sum(demand[route2[1:-1]])\n\n            new_demand1 = current_demand1 - sum(demand[seg1]) + sum(demand[seg2])\n            new_demand2 = current_demand2 - sum(demand[seg2]) + sum(demand[seg1])\n\n            # Check capacity constraints\n            if new_demand1 <= capacity and new_demand2 <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end + 1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end + 1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Capacity-aware insertion: try to move a customer from one route to another\n    if len(new_solution) >= 2:\n        # Select a random route to take a customer from\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        from_route = new_solution[from_route_idx]\n\n        if len(from_route) > 2:\n            # Select a random customer (not depot)\n            customer_idx = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_idx]\n\n            # Try to insert into another route\n            to_route_idx = random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n            to_route = new_solution[to_route_idx]\n\n            # Find feasible insertion positions\n            feasible_positions = []\n            for i in range(len(to_route) - 1):\n                # Check capacity constraint\n                if sum(demand[to_route[1:i+1]]) + demand[customer] <= capacity:\n                    feasible_positions.append(i)\n\n            if feasible_positions:\n                # Select a random feasible position\n                insert_pos = random.choice(feasible_positions)\n                # Create new routes\n                new_from_route = np.concatenate([from_route[:customer_idx], from_route[customer_idx + 1:]])\n                new_to_route = np.concatenate([to_route[:insert_pos + 1], [customer], to_route[insert_pos + 1:]])\n\n                # Update the solution\n                new_solution[from_route_idx] = new_from_route\n                new_solution[to_route_idx] = new_to_route\n\n    return new_solution\n\n",
        "score": [
            -0.6963278098711744,
            0.6662402451038361
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segment swap with capacity check\n    if len(new_solution) >= 2:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random segment from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            # Segment from route1\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg1 = route1[seg1_start:seg1_end + 1]\n\n            # Segment from route2\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n            seg2 = route2[seg2_start:seg2_end + 1]\n\n            # Calculate new demands for both routes\n            current_demand1 = sum(demand[route1[1:-1]])\n            current_demand2 = sum(demand[route2[1:-1]])\n\n            new_demand1 = current_demand1 - sum(demand[seg1]) + sum(demand[seg2])\n            new_demand2 = current_demand2 - sum(demand[seg2]) + sum(demand[seg1])\n\n            # Check capacity constraints\n            if new_demand1 <= capacity and new_demand2 <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end + 1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end + 1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Capacity-aware insertion: try to move a customer from one route to another\n    if len(new_solution) >= 2:\n        # Select a random route to take a customer from\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        from_route = new_solution[from_route_idx]\n\n        if len(from_route) > 2:\n            # Select a random customer (not depot)\n            customer_idx = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_idx]\n\n            # Try to insert into another route\n            to_route_idx = random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n            to_route = new_solution[to_route_idx]\n\n            # Find feasible insertion positions\n            feasible_positions = []\n            for i in range(len(to_route) - 1):\n                # Check capacity constraint\n                if sum(demand[to_route[1:i+1]]) + demand[customer] <= capacity:\n                    feasible_positions.append(i)\n\n            if feasible_positions:\n                # Select a random feasible position\n                insert_pos = random.choice(feasible_positions)\n                # Create new routes\n                new_from_route = np.concatenate([from_route[:customer_idx], from_route[customer_idx + 1:]])\n                new_to_route = np.concatenate([to_route[:insert_pos + 1], [customer], to_route[insert_pos + 1:]])\n\n                # Update the solution\n                new_solution[from_route_idx] = new_from_route\n                new_solution[to_route_idx] = new_to_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Apply a hybrid local search: route splitting and inter-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts at a random customer\n            split_pos = np.random.randint(1, len(route)-1)\n            part1 = route[:split_pos+1]\n            part2 = [0] + route[split_pos:]\n\n            # Try inserting part2 into another route if feasible\n            inserted = False\n            for i, other_route in enumerate(new_solution):\n                if sum(demand[customer] for customer in other_route) + sum(demand[customer] for customer in part2) <= capacity:\n                    new_solution[i] = np.concatenate([other_route[:-1], part2])\n                    inserted = True\n                    break\n\n            if not inserted:\n                new_solution.append(part1)\n                new_solution.append(part2)\n            else:\n                new_solution.append(part1)\n        else:\n            new_solution.append(route)\n\n    # Further improve by trying to merge small routes\n    i = 0\n    while i < len(new_solution):\n        if len(new_solution[i]) <= 3:  # Very short route\n            best_merge = None\n            best_merge_cost = float('inf')\n            for j in range(len(new_solution)):\n                if i != j:\n                    merged_route = np.concatenate([new_solution[i][:-1], new_solution[j]])\n                    if sum(demand[customer] for customer in merged_route) <= capacity:\n                        # Calculate cost increase\n                        cost_increase = (distance_matrix[new_solution[i][-2], new_solution[j][1]] +\n                                       distance_matrix[new_solution[j][-2], 0] -\n                                       distance_matrix[new_solution[i][-2], 0] -\n                                       distance_matrix[new_solution[j][-2], new_solution[j][1]])\n                        if cost_increase < best_merge_cost:\n                            best_merge_cost = cost_increase\n                            best_merge = j\n            if best_merge is not None:\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[best_merge]])\n                new_solution[i] = merged_route\n                new_solution.pop(best_merge)\n                i -= 1  # Adjust index after deletion\n        i += 1\n\n    return new_solution\n\n",
        "score": [
            -0.8907077968917092,
            2.39478462934494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Apply a hybrid local search: route splitting and inter-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts at a random customer\n            split_pos = np.random.randint(1, len(route)-1)\n            part1 = route[:split_pos+1]\n            part2 = [0] + route[split_pos:]\n\n            # Try inserting part2 into another route if feasible\n            inserted = False\n            for i, other_route in enumerate(new_solution):\n                if sum(demand[customer] for customer in other_route) + sum(demand[customer] for customer in part2) <= capacity:\n                    new_solution[i] = np.concatenate([other_route[:-1], part2])\n                    inserted = True\n                    break\n\n            if not inserted:\n                new_solution.append(part1)\n                new_solution.append(part2)\n            else:\n                new_solution.append(part1)\n        else:\n            new_solution.append(route)\n\n    # Further improve by trying to merge small routes\n    i = 0\n    while i < len(new_solution):\n        if len(new_solution[i]) <= 3:  # Very short route\n            best_merge = None\n            best_merge_cost = float('inf')\n            for j in range(len(new_solution)):\n                if i != j:\n                    merged_route = np.concatenate([new_solution[i][:-1], new_solution[j]])\n                    if sum(demand[customer] for customer in merged_route) <= capacity:\n                        # Calculate cost increase\n                        cost_increase = (distance_matrix[new_solution[i][-2], new_solution[j][1]] +\n                                       distance_matrix[new_solution[j][-2], 0] -\n                                       distance_matrix[new_solution[i][-2], 0] -\n                                       distance_matrix[new_solution[j][-2], new_solution[j][1]])\n                        if cost_increase < best_merge_cost:\n                            best_merge_cost = cost_increase\n                            best_merge = j\n            if best_merge is not None:\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[best_merge]])\n                new_solution[i] = merged_route\n                new_solution.pop(best_merge)\n                i -= 1  # Adjust index after deletion\n        i += 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Apply a hybrid local search: route splitting and inter-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts at a random customer\n            split_pos = np.random.randint(1, len(route)-1)\n            part1 = route[:split_pos+1]\n            part2 = [0] + route[split_pos:]\n\n            # Try inserting part2 into another route if feasible\n            inserted = False\n            for i, other_route in enumerate(new_solution):\n                if sum(demand[customer] for customer in other_route) + sum(demand[customer] for customer in part2) <= capacity:\n                    new_solution[i] = np.concatenate([other_route[:-1], part2])\n                    inserted = True\n                    break\n\n            if not inserted:\n                new_solution.append(part1)\n                new_solution.append(part2)\n            else:\n                new_solution.append(part1)\n        else:\n            new_solution.append(route)\n\n    # Further improve by trying to merge small routes\n    i = 0\n    while i < len(new_solution):\n        if len(new_solution[i]) <= 3:  # Very short route\n            best_merge = None\n            best_merge_cost = float('inf')\n            for j in range(len(new_solution)):\n                if i != j:\n                    merged_route = np.concatenate([new_solution[i][:-1], new_solution[j]])\n                    if sum(demand[customer] for customer in merged_route) <= capacity:\n                        # Calculate cost increase\n                        cost_increase = (distance_matrix[new_solution[i][-2], new_solution[j][1]] +\n                                       distance_matrix[new_solution[j][-2], 0] -\n                                       distance_matrix[new_solution[i][-2], 0] -\n                                       distance_matrix[new_solution[j][-2], new_solution[j][1]])\n                        if cost_increase < best_merge_cost:\n                            best_merge_cost = cost_increase\n                            best_merge = j\n            if best_merge is not None:\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[best_merge]])\n                new_solution[i] = merged_route\n                new_solution.pop(best_merge)\n                i -= 1  # Adjust index after deletion\n        i += 1\n\n    return new_solution\n\n",
        "score": [
            -0.8907077968917092,
            2.39478462934494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Apply a hybrid local search: route splitting and inter-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts at a random customer\n            split_pos = np.random.randint(1, len(route)-1)\n            part1 = route[:split_pos+1]\n            part2 = [0] + route[split_pos:]\n\n            # Try inserting part2 into another route if feasible\n            inserted = False\n            for i, other_route in enumerate(new_solution):\n                if sum(demand[customer] for customer in other_route) + sum(demand[customer] for customer in part2) <= capacity:\n                    new_solution[i] = np.concatenate([other_route[:-1], part2])\n                    inserted = True\n                    break\n\n            if not inserted:\n                new_solution.append(part1)\n                new_solution.append(part2)\n            else:\n                new_solution.append(part1)\n        else:\n            new_solution.append(route)\n\n    # Further improve by trying to merge small routes\n    i = 0\n    while i < len(new_solution):\n        if len(new_solution[i]) <= 3:  # Very short route\n            best_merge = None\n            best_merge_cost = float('inf')\n            for j in range(len(new_solution)):\n                if i != j:\n                    merged_route = np.concatenate([new_solution[i][:-1], new_solution[j]])\n                    if sum(demand[customer] for customer in merged_route) <= capacity:\n                        # Calculate cost increase\n                        cost_increase = (distance_matrix[new_solution[i][-2], new_solution[j][1]] +\n                                       distance_matrix[new_solution[j][-2], 0] -\n                                       distance_matrix[new_solution[i][-2], 0] -\n                                       distance_matrix[new_solution[j][-2], new_solution[j][1]])\n                        if cost_increase < best_merge_cost:\n                            best_merge_cost = cost_increase\n                            best_merge = j\n            if best_merge is not None:\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[best_merge]])\n                new_solution[i] = merged_route\n                new_solution.pop(best_merge)\n                i -= 1  # Adjust index after deletion\n        i += 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This function selects a promising solution from the archive, then applies a hybrid local search operator combining route-splitting and demand-based insertion to generate a neighbor solution, ensuring feasibility and potentially improving both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1] - x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route-splitting with demand-based insertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route at a random point\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if splitting is feasible\n        part1_demand = sum(demand[node] for node in part1[1:-1])\n        part2_demand = sum(demand[node] for node in part2[1:-1])\n\n        if part1_demand <= capacity and part2_demand <= capacity:\n            # Try inserting part2 into another route or create a new route\n            inserted = False\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                temp_route = np.concatenate([new_solution[i], part2[1:-1], [0]])\n                temp_demand = sum(demand[node] for node in temp_route[1:-1])\n                if temp_demand <= capacity:\n                    new_solution[i] = temp_route\n                    new_solution[route_idx] = np.concatenate([part1, [0]])\n                    inserted = True\n                    break\n\n            if not inserted and len(new_solution) < len(demand) - 1:  # Can add a new route\n                new_solution.append(np.concatenate([part2, [0]]))\n                new_solution[route_idx] = np.concatenate([part1, [0]])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7504526384710043,
            2.6898269057273865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1] - x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route-splitting with demand-based insertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route at a random point\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if splitting is feasible\n        part1_demand = sum(demand[node] for node in part1[1:-1])\n        part2_demand = sum(demand[node] for node in part2[1:-1])\n\n        if part1_demand <= capacity and part2_demand <= capacity:\n            # Try inserting part2 into another route or create a new route\n            inserted = False\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                temp_route = np.concatenate([new_solution[i], part2[1:-1], [0]])\n                temp_demand = sum(demand[node] for node in temp_route[1:-1])\n                if temp_demand <= capacity:\n                    new_solution[i] = temp_route\n                    new_solution[route_idx] = np.concatenate([part1, [0]])\n                    inserted = True\n                    break\n\n            if not inserted and len(new_solution) < len(demand) - 1:  # Can add a new route\n                new_solution.append(np.concatenate([part2, [0]]))\n                new_solution[route_idx] = np.concatenate([part1, [0]])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: Combine route-splitting and cross-exchange\n    new_solution = base_solution.copy()\n\n    # Step 1: Route-splitting - Split the longest route into two\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in base_solution])\n    longest_route = base_solution[longest_route_idx]\n\n    if len(longest_route) > 3:  # Ensure route can be split\n        split_point = len(longest_route) // 2\n        route1 = longest_route[:split_point + 1]\n        route2 = longest_route[split_point:]\n        route2[0] = 0  # Ensure new route starts at depot\n\n        # Check capacity constraints\n        demand1 = demand[route1[1:-1]].sum()\n        demand2 = demand[route2[1:-1]].sum()\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.pop(longest_route_idx)\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n    # Step 2: Cross-exchange - Swap segments between two routes\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random segments from both routes\n            seg1_start = np.random.randint(1, len(route1) - 1)\n            seg1_end = np.random.randint(seg1_start, len(route1) - 1)\n            seg2_start = np.random.randint(1, len(route2) - 1)\n            seg2_end = np.random.randint(seg2_start, len(route2) - 1)\n\n            # Create new routes by exchanging segments\n            new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end + 1], route1[seg1_end + 1:]])\n            new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end + 1], route2[seg2_end + 1:]])\n\n            # Check capacity constraints\n            demand1_new = demand[new_route1[1:-1]].sum()\n            demand2_new = demand[new_route2[1:-1]].sum()\n\n            if demand1_new <= capacity and demand2_new <= capacity:\n                new_solution[i] = new_route1\n                new_solution[j] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.7376603974686833,
            0.769745409488678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: Combine route-splitting and cross-exchange\n    new_solution = base_solution.copy()\n\n    # Step 1: Route-splitting - Split the longest route into two\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in base_solution])\n    longest_route = base_solution[longest_route_idx]\n\n    if len(longest_route) > 3:  # Ensure route can be split\n        split_point = len(longest_route) // 2\n        route1 = longest_route[:split_point + 1]\n        route2 = longest_route[split_point:]\n        route2[0] = 0  # Ensure new route starts at depot\n\n        # Check capacity constraints\n        demand1 = demand[route1[1:-1]].sum()\n        demand2 = demand[route2[1:-1]].sum()\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.pop(longest_route_idx)\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n    # Step 2: Cross-exchange - Swap segments between two routes\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random segments from both routes\n            seg1_start = np.random.randint(1, len(route1) - 1)\n            seg1_end = np.random.randint(seg1_start, len(route1) - 1)\n            seg2_start = np.random.randint(1, len(route2) - 1)\n            seg2_end = np.random.randint(seg2_start, len(route2) - 1)\n\n            # Create new routes by exchanging segments\n            new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end + 1], route1[seg1_end + 1:]])\n            new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end + 1], route2[seg2_end + 1:]])\n\n            # Check capacity constraints\n            demand1_new = demand[new_route1[1:-1]].sum()\n            demand2_new = demand[new_route2[1:-1]].sum()\n\n            if demand1_new <= capacity and demand2_new <= capacity:\n                new_solution[i] = new_route1\n                new_solution[j] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Apply a hybrid local search: 2-opt on the longest route + route splitting\n    if len(selected_solution) > 1:\n        # Identify the longest route\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n        longest_route = selected_solution[longest_route_idx].copy()\n\n        # Apply 2-opt on the longest route\n        improved_route = longest_route.copy()\n        n = len(improved_route)\n        for i in range(1, n - 2):\n            for j in range(i + 1, n - 1):\n                if j + 1 < n:\n                    # Check if swapping i and j improves the route\n                    new_route = improved_route.copy()\n                    new_route[i:j+1] = np.flip(new_route[i:j+1])\n                    if np.sum(distance_matrix[new_route[:-1], new_route[1:]]) < np.sum(distance_matrix[improved_route[:-1], improved_route[1:]]):\n                        improved_route = new_route\n\n        # Check if splitting the longest route into two improves the makespan\n        if len(improved_route) > 3:  # Ensure the route can be split\n            best_split_pos = -1\n            best_makespan_diff = 0\n            current_makespan = np.sum(distance_matrix[improved_route[:-1], improved_route[1:]])\n            for k in range(2, len(improved_route) - 2):\n                # Split the route into two parts\n                part1 = improved_route[:k+1]\n                part2 = np.concatenate([[0], improved_route[k:-1], [0]])\n                # Check capacity constraints\n                if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n                    new_makespan = max(np.sum(distance_matrix[part1[:-1], part1[1:]]), np.sum(distance_matrix[part2[:-1], part2[1:]]))\n                    if new_makespan < current_makespan:\n                        if new_makespan - current_makespan < best_makespan_diff:\n                            best_makespan_diff = new_makespan - current_makespan\n                            best_split_pos = k\n            if best_split_pos != -1:\n                # Perform the split\n                part1 = improved_route[:best_split_pos+1]\n                part2 = np.concatenate([[0], improved_route[best_split_pos:-1], [0]])\n                selected_solution[longest_route_idx] = part1\n                selected_solution.append(part2)\n\n    return selected_solution\n\n",
        "score": [
            -0.8294549719595619,
            4.314878225326538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Apply a hybrid local search: 2-opt on the longest route + route splitting\n    if len(selected_solution) > 1:\n        # Identify the longest route\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n        longest_route = selected_solution[longest_route_idx].copy()\n\n        # Apply 2-opt on the longest route\n        improved_route = longest_route.copy()\n        n = len(improved_route)\n        for i in range(1, n - 2):\n            for j in range(i + 1, n - 1):\n                if j + 1 < n:\n                    # Check if swapping i and j improves the route\n                    new_route = improved_route.copy()\n                    new_route[i:j+1] = np.flip(new_route[i:j+1])\n                    if np.sum(distance_matrix[new_route[:-1], new_route[1:]]) < np.sum(distance_matrix[improved_route[:-1], improved_route[1:]]):\n                        improved_route = new_route\n\n        # Check if splitting the longest route into two improves the makespan\n        if len(improved_route) > 3:  # Ensure the route can be split\n            best_split_pos = -1\n            best_makespan_diff = 0\n            current_makespan = np.sum(distance_matrix[improved_route[:-1], improved_route[1:]])\n            for k in range(2, len(improved_route) - 2):\n                # Split the route into two parts\n                part1 = improved_route[:k+1]\n                part2 = np.concatenate([[0], improved_route[k:-1], [0]])\n                # Check capacity constraints\n                if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n                    new_makespan = max(np.sum(distance_matrix[part1[:-1], part1[1:]]), np.sum(distance_matrix[part2[:-1], part2[1:]]))\n                    if new_makespan < current_makespan:\n                        if new_makespan - current_makespan < best_makespan_diff:\n                            best_makespan_diff = new_makespan - current_makespan\n                            best_split_pos = k\n            if best_split_pos != -1:\n                # Perform the split\n                part1 = improved_route[:best_split_pos+1]\n                part2 = np.concatenate([[0], improved_route[best_split_pos:-1], [0]])\n                selected_solution[longest_route_idx] = part1\n                selected_solution.append(part2)\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + 0.5 * x[1][1])[0].copy()\n\n    # Hybrid local search: combine route splitting and cross-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Cross-route insertion: move a random customer from one route to another\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select a random customer from route1 (not depot)\n            customer_idx = np.random.randint(1, len(route1) - 1)\n            customer = route1[customer_idx]\n\n            # Check if insertion into route2 is feasible\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Find the best insertion position in route2\n                best_pos = 1\n                min_increase = float('inf')\n                for i in range(1, len(route2)):\n                    increase = distance_matrix[route2[i-1], customer] + distance_matrix[customer, route2[i]] - distance_matrix[route2[i-1], route2[i]]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n\n                # Perform the insertion\n                new_route2 = np.insert(route2, best_pos, customer)\n                new_solution[route2_idx] = new_route2\n\n                # Remove the customer from route1\n                new_route1 = np.delete(route1, customer_idx)\n                new_solution[route1_idx] = new_route1\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    return new_solution\n\n",
        "score": [
            -0.7151033175158037,
            2.935347318649292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + 0.5 * x[1][1])[0].copy()\n\n    # Hybrid local search: combine route splitting and cross-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Cross-route insertion: move a random customer from one route to another\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select a random customer from route1 (not depot)\n            customer_idx = np.random.randint(1, len(route1) - 1)\n            customer = route1[customer_idx]\n\n            # Check if insertion into route2 is feasible\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Find the best insertion position in route2\n                best_pos = 1\n                min_increase = float('inf')\n                for i in range(1, len(route2)):\n                    increase = distance_matrix[route2[i-1], customer] + distance_matrix[customer, route2[i]] - distance_matrix[route2[i-1], route2[i]]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n\n                # Perform the insertion\n                new_route2 = np.insert(route2, best_pos, customer)\n                new_solution[route2_idx] = new_route2\n\n                # Remove the customer from route1\n                new_route1 = np.delete(route1, customer_idx)\n                new_solution[route1_idx] = new_route1\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with route merging/splitting\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select two non-depot nodes to swap\n        swap_indices = np.random.choice(range(1, len(route)-1), size=2, replace=False)\n        i, j = min(swap_indices), max(swap_indices)\n        new_route = route.copy()\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution.append(new_route)\n        else:\n            # If swap violates capacity, try splitting the route\n            split_pos = i if i < j else j\n            route1 = np.concatenate([route[:split_pos+1], [0]])\n            route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution.extend([route1, route2])\n            else:\n                new_solution.append(route.copy())  # Revert if split fails\n\n    # Randomly try to merge two routes if they fit capacity\n    if len(new_solution) > 1 and np.random.rand() < 0.3:\n        merge_indices = np.random.choice(range(len(new_solution)), size=2, replace=False)\n        route1, route2 = new_solution[merge_indices[0]], new_solution[merge_indices[1]]\n        combined_route = np.concatenate([route1[:-1], route2[1:]])\n\n        if np.sum(demand[combined_route[1:-1]]) <= capacity:\n            new_solution = [r for i, r in enumerate(new_solution) if i not in merge_indices]\n            new_solution.append(combined_route)\n\n    return new_solution\n\n",
        "score": [
            -0.4737645161816583,
            2.205966144800186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with route merging/splitting\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select two non-depot nodes to swap\n        swap_indices = np.random.choice(range(1, len(route)-1), size=2, replace=False)\n        i, j = min(swap_indices), max(swap_indices)\n        new_route = route.copy()\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution.append(new_route)\n        else:\n            # If swap violates capacity, try splitting the route\n            split_pos = i if i < j else j\n            route1 = np.concatenate([route[:split_pos+1], [0]])\n            route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution.extend([route1, route2])\n            else:\n                new_solution.append(route.copy())  # Revert if split fails\n\n    # Randomly try to merge two routes if they fit capacity\n    if len(new_solution) > 1 and np.random.rand() < 0.3:\n        merge_indices = np.random.choice(range(len(new_solution)), size=2, replace=False)\n        route1, route2 = new_solution[merge_indices[0]], new_solution[merge_indices[1]]\n        combined_route = np.concatenate([route1[:-1], route2[1:]])\n\n        if np.sum(demand[combined_route[1:-1]]) <= capacity:\n            new_solution = [r for i, r in enumerate(new_solution) if i not in merge_indices]\n            new_solution.append(combined_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with low makespan and total distance, and then applies a hybrid local search combining route splitting, insertion, and 2-opt with capacity checks to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: Combine route splitting, insertion, and 2-opt with capacity checks\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Step 2: Split the route at a random point (if long enough)\n        if len(selected_route) > 4:  # Ensure we can split into two valid routes\n            split_point = np.random.randint(2, len(selected_route) - 2)\n            new_route1 = selected_route[:split_point + 1]\n            new_route2 = selected_route[split_point:]\n\n            # Check capacity constraints for both new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n        # Step 3: Apply 2-opt on the selected route (if feasible)\n        if len(selected_route) > 4:\n            i = np.random.randint(1, len(selected_route) - 2)\n            j = np.random.randint(i + 1, len(selected_route) - 1)\n            reversed_segment = selected_route[i:j+1][::-1]\n            new_route = np.concatenate([selected_route[:i], reversed_segment, selected_route[j+1:]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n        # Step 4: Randomly insert a customer from another route (if feasible)\n        if len(new_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx].copy()\n\n            if len(other_route) > 3:\n                # Select a random customer from the other route (excluding depot)\n                customer_idx = np.random.randint(1, len(other_route) - 1)\n                customer = other_route[customer_idx]\n\n                # Find the best insertion position in the selected route\n                best_cost = float('inf')\n                best_pos = -1\n\n                for pos in range(1, len(selected_route)):\n                    # Insert customer at position pos\n                    test_route = np.insert(selected_route, pos, customer)\n\n                    # Check capacity constraint\n                    if np.sum(demand[test_route[1:-1]]) > capacity:\n                        continue\n\n                    # Calculate insertion cost\n                    cost = (distance_matrix[selected_route[pos-1], customer] +\n                            distance_matrix[customer, selected_route[pos]] -\n                            distance_matrix[selected_route[pos-1], selected_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                if best_pos != -1:\n                    # Perform the insertion\n                    new_route = np.insert(selected_route, best_pos, customer)\n                    new_solution[route_idx] = new_route\n\n                    # Remove the customer from the other route\n                    other_route = np.delete(other_route, customer_idx)\n                    if len(other_route) > 2:  # Ensure the route remains valid\n                        new_solution[other_route_idx] = other_route\n                    else:  # Remove the route if it's empty\n                        new_solution.pop(other_route_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.773685401561068,
            1.559880018234253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: Combine route splitting, insertion, and 2-opt with capacity checks\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Step 2: Split the route at a random point (if long enough)\n        if len(selected_route) > 4:  # Ensure we can split into two valid routes\n            split_point = np.random.randint(2, len(selected_route) - 2)\n            new_route1 = selected_route[:split_point + 1]\n            new_route2 = selected_route[split_point:]\n\n            # Check capacity constraints for both new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n        # Step 3: Apply 2-opt on the selected route (if feasible)\n        if len(selected_route) > 4:\n            i = np.random.randint(1, len(selected_route) - 2)\n            j = np.random.randint(i + 1, len(selected_route) - 1)\n            reversed_segment = selected_route[i:j+1][::-1]\n            new_route = np.concatenate([selected_route[:i], reversed_segment, selected_route[j+1:]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n        # Step 4: Randomly insert a customer from another route (if feasible)\n        if len(new_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx].copy()\n\n            if len(other_route) > 3:\n                # Select a random customer from the other route (excluding depot)\n                customer_idx = np.random.randint(1, len(other_route) - 1)\n                customer = other_route[customer_idx]\n\n                # Find the best insertion position in the selected route\n                best_cost = float('inf')\n                best_pos = -1\n\n                for pos in range(1, len(selected_route)):\n                    # Insert customer at position pos\n                    test_route = np.insert(selected_route, pos, customer)\n\n                    # Check capacity constraint\n                    if np.sum(demand[test_route[1:-1]]) > capacity:\n                        continue\n\n                    # Calculate insertion cost\n                    cost = (distance_matrix[selected_route[pos-1], customer] +\n                            distance_matrix[customer, selected_route[pos]] -\n                            distance_matrix[selected_route[pos-1], selected_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                if best_pos != -1:\n                    # Perform the insertion\n                    new_route = np.insert(selected_route, best_pos, customer)\n                    new_solution[route_idx] = new_route\n\n                    # Remove the customer from the other route\n                    other_route = np.delete(other_route, customer_idx)\n                    if len(other_route) > 2:  # Ensure the route remains valid\n                        new_solution[other_route_idx] = other_route\n                    else:  # Remove the route if it's empty\n                        new_solution.pop(other_route_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (1 / (x[1][0] + 1e-6), 1 / (x[1][1] + 1e-6)))[0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for the split\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Reallocate customers between routes to balance makespan\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route = max(new_solution, key=lambda x: len(x))\n        shortest_route = min(new_solution, key=lambda x: len(x))\n\n        if len(longest_route) > 3 and len(shortest_route) > 2:\n            # Try to move a customer from the longest to the shortest route\n            candidate_customers = [c for c in longest_route[1:-1] if sum(demand[shortest_route[1:-1]]) + demand[c] <= capacity]\n\n            if candidate_customers:\n                # Select a random customer to move\n                customer_to_move = np.random.choice(candidate_customers)\n                # Remove from longest route\n                longest_route = np.array([c for c in longest_route if c != customer_to_move])\n                # Insert into shortest route (after the depot)\n                shortest_route = np.insert(shortest_route, 1, customer_to_move)\n\n                # Update the solution\n                new_solution = [route for route in new_solution if not np.array_equal(route, longest_route)]\n                new_solution.append(longest_route)\n                new_solution = [route for route in new_solution if not np.array_equal(route, shortest_route)]\n                new_solution.append(shortest_route)\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    return new_solution\n\n",
        "score": [
            -0.6656560003533918,
            1.80085951089859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (1 / (x[1][0] + 1e-6), 1 / (x[1][1] + 1e-6)))[0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for the split\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Reallocate customers between routes to balance makespan\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route = max(new_solution, key=lambda x: len(x))\n        shortest_route = min(new_solution, key=lambda x: len(x))\n\n        if len(longest_route) > 3 and len(shortest_route) > 2:\n            # Try to move a customer from the longest to the shortest route\n            candidate_customers = [c for c in longest_route[1:-1] if sum(demand[shortest_route[1:-1]]) + demand[c] <= capacity]\n\n            if candidate_customers:\n                # Select a random customer to move\n                customer_to_move = np.random.choice(candidate_customers)\n                # Remove from longest route\n                longest_route = np.array([c for c in longest_route if c != customer_to_move])\n                # Insert into shortest route (after the depot)\n                shortest_route = np.insert(shortest_route, 1, customer_to_move)\n\n                # Update the solution\n                new_solution = [route for route in new_solution if not np.array_equal(route, longest_route)]\n                new_solution.append(longest_route)\n                new_solution = [route for route in new_solution if not np.array_equal(route, shortest_route)]\n                new_solution.append(shortest_route)\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the two longest routes\n    route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    second_longest_route_idx = np.argmax([l if i != longest_route_idx else -1 for i, l in enumerate(route_lengths)])\n\n    longest_route = new_solution[longest_route_idx].copy()\n    second_longest_route = new_solution[second_longest_route_idx].copy()\n\n    # Attempt to merge the two longest routes\n    merged_route = np.concatenate([second_longest_route[:-1], longest_route[1:]])\n    merged_demand = sum(demand[node] for node in merged_route if node != 0)\n\n    if merged_demand <= capacity:\n        # Merge successful, replace the two routes with the merged one\n        new_solution.pop(longest_route_idx)\n        if longest_route_idx < second_longest_route_idx:\n            new_solution.pop(second_longest_route_idx - 1)\n        else:\n            new_solution.pop(second_longest_route_idx)\n        new_solution.append(merged_route)\n    else:\n        # If merging is not feasible, perform customer reallocation between routes\n        for i in range(1, len(longest_route) - 1):\n            customer = longest_route[i]\n            # Try to insert the customer into the second longest route\n            for j in range(1, len(second_longest_route)):\n                temp_route = np.insert(second_longest_route, j, customer)\n                temp_demand = sum(demand[node] for node in temp_route if node != 0)\n                if temp_demand <= capacity:\n                    # Update routes if feasible\n                    second_longest_route = temp_route\n                    longest_route = np.delete(longest_route, i)\n                    break\n            else:\n                continue\n            break\n\n        # Update the solution with the modified routes\n        new_solution[longest_route_idx] = longest_route\n        new_solution[second_longest_route_idx] = second_longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.707637098462431,
            6.779592216014862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the two longest routes\n    route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    second_longest_route_idx = np.argmax([l if i != longest_route_idx else -1 for i, l in enumerate(route_lengths)])\n\n    longest_route = new_solution[longest_route_idx].copy()\n    second_longest_route = new_solution[second_longest_route_idx].copy()\n\n    # Attempt to merge the two longest routes\n    merged_route = np.concatenate([second_longest_route[:-1], longest_route[1:]])\n    merged_demand = sum(demand[node] for node in merged_route if node != 0)\n\n    if merged_demand <= capacity:\n        # Merge successful, replace the two routes with the merged one\n        new_solution.pop(longest_route_idx)\n        if longest_route_idx < second_longest_route_idx:\n            new_solution.pop(second_longest_route_idx - 1)\n        else:\n            new_solution.pop(second_longest_route_idx)\n        new_solution.append(merged_route)\n    else:\n        # If merging is not feasible, perform customer reallocation between routes\n        for i in range(1, len(longest_route) - 1):\n            customer = longest_route[i]\n            # Try to insert the customer into the second longest route\n            for j in range(1, len(second_longest_route)):\n                temp_route = np.insert(second_longest_route, j, customer)\n                temp_demand = sum(demand[node] for node in temp_route if node != 0)\n                if temp_demand <= capacity:\n                    # Update routes if feasible\n                    second_longest_route = temp_route\n                    longest_route = np.delete(longest_route, i)\n                    break\n            else:\n                continue\n            break\n\n        # Update the solution with the modified routes\n        new_solution[longest_route_idx] = longest_route\n        new_solution[second_longest_route_idx] = second_longest_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Apply a hybrid local search: combine route merging and segment relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only process routes with more than 2 customers\n            # Split the route into two segments\n            split_point = np.random.randint(1, len(route)-1)\n            segment1 = route[:split_point+1]\n            segment2 = route[split_point:]\n\n            # Try to merge segment2 into another route or relocate it\n            merged = False\n            for i, other_route in enumerate(new_solution):\n                if np.sum(demand[other_route[1:-1]]) + np.sum(demand[segment2[1:-1]]) <= capacity:\n                    # Merge segment2 into other_route\n                    new_route = np.concatenate([other_route[:-1], segment2[1:]])\n                    new_solution[i] = new_route\n                    merged = True\n                    break\n\n            if not merged:\n                # If not merged, try to relocate segment2 to a new route\n                if np.sum(demand[segment2[1:-1]]) <= capacity:\n                    new_solution.append(segment2)\n\n            new_solution.append(segment1)\n        else:\n            new_solution.append(route)\n\n    # Ensure all customers are served\n    all_nodes = set(range(1, len(demand)))\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n\n    missing_nodes = all_nodes - served_nodes\n    if missing_nodes:\n        # Assign missing nodes to the shortest possible route\n        for node in missing_nodes:\n            best_route = None\n            best_insert_pos = None\n            best_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[route[1:-1]]) + demand[node] > capacity:\n                    continue\n\n                for j in range(len(route)-1):\n                    increase = distance_matrix[route[j], node] + distance_matrix[node, route[j+1]] - distance_matrix[route[j], route[j+1]]\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_route = i\n                        best_insert_pos = j+1\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_insert_pos, node)\n                new_solution[best_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7469728327957856,
            10.104987353086472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Apply a hybrid local search: combine route merging and segment relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only process routes with more than 2 customers\n            # Split the route into two segments\n            split_point = np.random.randint(1, len(route)-1)\n            segment1 = route[:split_point+1]\n            segment2 = route[split_point:]\n\n            # Try to merge segment2 into another route or relocate it\n            merged = False\n            for i, other_route in enumerate(new_solution):\n                if np.sum(demand[other_route[1:-1]]) + np.sum(demand[segment2[1:-1]]) <= capacity:\n                    # Merge segment2 into other_route\n                    new_route = np.concatenate([other_route[:-1], segment2[1:]])\n                    new_solution[i] = new_route\n                    merged = True\n                    break\n\n            if not merged:\n                # If not merged, try to relocate segment2 to a new route\n                if np.sum(demand[segment2[1:-1]]) <= capacity:\n                    new_solution.append(segment2)\n\n            new_solution.append(segment1)\n        else:\n            new_solution.append(route)\n\n    # Ensure all customers are served\n    all_nodes = set(range(1, len(demand)))\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n\n    missing_nodes = all_nodes - served_nodes\n    if missing_nodes:\n        # Assign missing nodes to the shortest possible route\n        for node in missing_nodes:\n            best_route = None\n            best_insert_pos = None\n            best_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[route[1:-1]]) + demand[node] > capacity:\n                    continue\n\n                for j in range(len(route)-1):\n                    increase = distance_matrix[route[j], node] + distance_matrix[node, route[j+1]] - distance_matrix[route[j], route[j+1]]\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_route = i\n                        best_insert_pos = j+1\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_insert_pos, node)\n                new_solution[best_route] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a combination of total distance and makespan, then applies a hybrid local search operator that combines route merging and partial 2-opt with demand-aware insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route merging with demand-aware insertion\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Try to merge route2 into route1\n        merged = False\n        for k in range(1, len(route2) - 1):\n            customer = route2[k]\n            # Find insertion point in route1\n            for l in range(1, len(route1)):\n                # Check if inserting customer between l-1 and l maintains capacity\n                segment_demand = np.sum(demand[route1[l-1:l+1]])\n                if segment_demand + demand[customer] <= capacity:\n                    # Insert customer and update route\n                    new_route = np.concatenate([route1[:l], [customer], route1[l:]])\n                    # Check if the new route is feasible\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[i] = new_route\n                        new_solution.pop(j)\n                        merged = True\n                        break\n            if merged:\n                break\n\n    # Apply partial 2-opt on a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes to perform 2-opt\n            a, b = random.sample(range(1, len(route) - 2), 2)\n            if a > b:\n                a, b = b, a\n            # Reverse the segment between a and b\n            new_route = np.concatenate([route[:a], route[a:b+1][::-1], route[b+1:]])\n            # Check feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    # Ensure the solution remains feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible!\")\n\n    return new_solution\n\n",
        "score": [
            -0.5299570340550186,
            2.9408363103866577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route merging with demand-aware insertion\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Try to merge route2 into route1\n        merged = False\n        for k in range(1, len(route2) - 1):\n            customer = route2[k]\n            # Find insertion point in route1\n            for l in range(1, len(route1)):\n                # Check if inserting customer between l-1 and l maintains capacity\n                segment_demand = np.sum(demand[route1[l-1:l+1]])\n                if segment_demand + demand[customer] <= capacity:\n                    # Insert customer and update route\n                    new_route = np.concatenate([route1[:l], [customer], route1[l:]])\n                    # Check if the new route is feasible\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[i] = new_route\n                        new_solution.pop(j)\n                        merged = True\n                        break\n            if merged:\n                break\n\n    # Apply partial 2-opt on a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes to perform 2-opt\n            a, b = random.sample(range(1, len(route) - 2), 2)\n            if a > b:\n                a, b = b, a\n            # Reverse the segment between a and b\n            new_route = np.concatenate([route[:a], route[a:b+1][::-1], route[b+1:]])\n            # Check feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    # Ensure the solution remains feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible!\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    best_makespan = min(sol[1][1] for sol in archive)\n    candidates = [sol[0] for sol in archive if sol[1][1] == best_makespan]\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search: combine route splitting and segment relocation\n    new_solution = base_solution.copy()\n    route_idx = random.randint(0, len(new_solution) - 1)\n    route = new_solution[route_idx]\n\n    if len(route) > 3:  # Ensure route has at least one customer\n        # Randomly select a segment to relocate\n        split_pos = random.randint(1, len(route) - 2)\n        segment = route[split_pos:-1]  # Exclude the last depot\n\n        # Check if segment can be moved to another route or split into a new route\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Try to merge into an existing route\n        merged = False\n        for i, r in enumerate(new_solution):\n            if i != route_idx and sum(demand[node] for node in r[1:-1]) + segment_demand <= capacity:\n                # Insert segment into this route (greedy insertion)\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(r)):\n                    cost = distance_matrix[r[pos-1], segment[0]] + distance_matrix[segment[-1], r[pos]] - distance_matrix[r[pos-1], r[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                # Insert segment and update route\n                new_route = np.concatenate([r[:best_pos], segment, r[best_pos:]])\n                new_solution[i] = new_route\n                # Remove segment from original route\n                new_solution[route_idx] = np.concatenate([route[:split_pos], route[-1:]])\n                merged = True\n                break\n\n        # If not merged, try to split into a new route\n        if not merged and segment_demand <= capacity:\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n            new_solution[route_idx] = np.concatenate([route[:split_pos], route[-1:]])\n\n        # Ensure no empty routes\n        new_solution = [r for r in new_solution if len(r) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5005625643554781,
            0.8827952742576599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    best_makespan = min(sol[1][1] for sol in archive)\n    candidates = [sol[0] for sol in archive if sol[1][1] == best_makespan]\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search: combine route splitting and segment relocation\n    new_solution = base_solution.copy()\n    route_idx = random.randint(0, len(new_solution) - 1)\n    route = new_solution[route_idx]\n\n    if len(route) > 3:  # Ensure route has at least one customer\n        # Randomly select a segment to relocate\n        split_pos = random.randint(1, len(route) - 2)\n        segment = route[split_pos:-1]  # Exclude the last depot\n\n        # Check if segment can be moved to another route or split into a new route\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Try to merge into an existing route\n        merged = False\n        for i, r in enumerate(new_solution):\n            if i != route_idx and sum(demand[node] for node in r[1:-1]) + segment_demand <= capacity:\n                # Insert segment into this route (greedy insertion)\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(r)):\n                    cost = distance_matrix[r[pos-1], segment[0]] + distance_matrix[segment[-1], r[pos]] - distance_matrix[r[pos-1], r[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                # Insert segment and update route\n                new_route = np.concatenate([r[:best_pos], segment, r[best_pos:]])\n                new_solution[i] = new_route\n                # Remove segment from original route\n                new_solution[route_idx] = np.concatenate([route[:split_pos], route[-1:]])\n                merged = True\n                break\n\n        # If not merged, try to split into a new route\n        if not merged and segment_demand <= capacity:\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n            new_solution[route_idx] = np.concatenate([route[:split_pos], route[-1:]])\n\n        # Ensure no empty routes\n        new_solution = [r for r in new_solution if len(r) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: combine 2-opt with route merging and splitting\n    n_routes = len(new_solution)\n\n    # Randomly select two routes for potential merging\n    if n_routes > 1:\n        i, j = np.random.choice(n_routes, 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Apply 2-opt on the merged route\n            n = len(merged_route)\n            improved = True\n            while improved:\n                improved = False\n                for u in range(1, n-2):\n                    for v in range(u+2, n-1):\n                        # Check if reversing the segment improves distance\n                        original_dist = distance_matrix[merged_route[u-1], merged_route[u]] + distance_matrix[merged_route[v], merged_route[v+1]]\n                        new_dist = distance_matrix[merged_route[u-1], merged_route[v]] + distance_matrix[merged_route[u], merged_route[v+1]]\n                        if new_dist < original_dist:\n                            merged_route[u:v+1] = merged_route[u:v+1][::-1]\n                            improved = True\n                            break\n                    if improved:\n                        break\n            new_solution[i] = merged_route\n\n    # Apply route splitting if a route is too long\n    for k in range(len(new_solution)):\n        route = new_solution[k]\n        if len(route) > 4:  # Arbitrary threshold to avoid trivial splits\n            split_pos = np.random.randint(2, len(route)-2)\n            split_route1 = np.concatenate([route[:split_pos+1], [0]])\n            split_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Check feasibility\n            if sum(demand[split_route1[1:-1]]) <= capacity and sum(demand[split_route2[1:-1]]) <= capacity:\n                new_solution[k] = split_route1\n                new_solution.insert(k+1, split_route2)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6801566799597232,
            0.7352758944034576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: combine 2-opt with route merging and splitting\n    n_routes = len(new_solution)\n\n    # Randomly select two routes for potential merging\n    if n_routes > 1:\n        i, j = np.random.choice(n_routes, 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Apply 2-opt on the merged route\n            n = len(merged_route)\n            improved = True\n            while improved:\n                improved = False\n                for u in range(1, n-2):\n                    for v in range(u+2, n-1):\n                        # Check if reversing the segment improves distance\n                        original_dist = distance_matrix[merged_route[u-1], merged_route[u]] + distance_matrix[merged_route[v], merged_route[v+1]]\n                        new_dist = distance_matrix[merged_route[u-1], merged_route[v]] + distance_matrix[merged_route[u], merged_route[v+1]]\n                        if new_dist < original_dist:\n                            merged_route[u:v+1] = merged_route[u:v+1][::-1]\n                            improved = True\n                            break\n                    if improved:\n                        break\n            new_solution[i] = merged_route\n\n    # Apply route splitting if a route is too long\n    for k in range(len(new_solution)):\n        route = new_solution[k]\n        if len(route) > 4:  # Arbitrary threshold to avoid trivial splits\n            split_pos = np.random.randint(2, len(route)-2)\n            split_route1 = np.concatenate([route[:split_pos+1], [0]])\n            split_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Check feasibility\n            if sum(demand[split_route1[1:-1]]) <= capacity and sum(demand[split_route2[1:-1]]) <= capacity:\n                new_solution[k] = split_route1\n                new_solution.insert(k+1, split_route2)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            # Create a new route by reallocating customers between parts\n            for j in range(1, len(part1) - 1):\n                for k in range(1, len(part2) - 1):\n                    # Try swapping customers between parts\n                    temp_part1 = part1.copy()\n                    temp_part2 = part2.copy()\n                    temp_part1[j], temp_part2[k] = temp_part2[k], temp_part1[j]\n\n                    if (np.sum(demand[temp_part1[1:-1]]) <= capacity and\n                        np.sum(demand[temp_part2[1:-1]]) <= capacity):\n                        part1, part2 = temp_part1, temp_part2\n\n            # Update the solution\n            new_solution[i] = part1\n            if len(part2) > 2:  # Only add if part2 has customers\n                new_solution.append(part2)\n\n    return new_solution\n\n",
        "score": [
            -0.6575193870355405,
            6.445380806922913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            # Create a new route by reallocating customers between parts\n            for j in range(1, len(part1) - 1):\n                for k in range(1, len(part2) - 1):\n                    # Try swapping customers between parts\n                    temp_part1 = part1.copy()\n                    temp_part2 = part2.copy()\n                    temp_part1[j], temp_part2[k] = temp_part2[k], temp_part1[j]\n\n                    if (np.sum(demand[temp_part1[1:-1]]) <= capacity and\n                        np.sum(demand[temp_part2[1:-1]]) <= capacity):\n                        part1, part2 = temp_part1, temp_part2\n\n            # Update the solution\n            new_solution[i] = part1\n            if len(part2) > 2:  # Only add if part2 has customers\n                new_solution.append(part2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining route splitting, customer reallocation, and route merging to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # More weight on distance to balance makespan\n    archive_sorted = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting, customer reallocation, and route merging\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Step 1: Randomly select a route to split\n        if len(new_solution) > 1:\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n            if len(route) > 3:  # Ensure we can split\n                split_pos = np.random.randint(1, len(route) - 1)\n                new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Step 2: Reallocate a random customer to a different route if feasible\n        all_customers = [node for route in new_solution for node in route if node != 0]\n        if len(all_customers) > 0:\n            customer = np.random.choice(all_customers)\n            for route in new_solution:\n                if customer in route:\n                    remaining_route = route[route != customer]\n                    if np.sum(demand[remaining_route]) <= capacity:\n                        new_solution = [route for route in new_solution if customer not in route]\n                        new_solution.append(np.concatenate([[0], [customer], [0]]))\n                        break\n\n        # Step 3: Merge two routes if feasible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.8238558416939068,
            2.988527089357376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # More weight on distance to balance makespan\n    archive_sorted = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting, customer reallocation, and route merging\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Step 1: Randomly select a route to split\n        if len(new_solution) > 1:\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n            if len(route) > 3:  # Ensure we can split\n                split_pos = np.random.randint(1, len(route) - 1)\n                new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Step 2: Reallocate a random customer to a different route if feasible\n        all_customers = [node for route in new_solution for node in route if node != 0]\n        if len(all_customers) > 0:\n            customer = np.random.choice(all_customers)\n            for route in new_solution:\n                if customer in route:\n                    remaining_route = route[route != customer]\n                    if np.sum(demand[remaining_route]) <= capacity:\n                        new_solution = [route for route in new_solution if customer not in route]\n                        new_solution.append(np.concatenate([[0], [customer], [0]]))\n                        break\n\n        # Step 3: Merge two routes if feasible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid approach combining route clustering and adaptive insertion, then applies a novel \"route merging and splitting\" operator that intelligently combines and divides routes based on demand and distance patterns to balance the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_idx = min(len(archive) - 1, int(len(archive) * 0.3))  # Select from top 30%\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: Route merging and splitting\n    if len(new_solution) > 1:\n        # Step 1: Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Check if merging is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n            # Step 3: Try to split the merged route to balance objectives\n            if len(merged_route) > 3:  # Only split if route has more than 2 customers\n                best_split = None\n                best_score = float('inf')\n\n                for i in range(1, len(merged_route) - 1):\n                    # Split into two parts\n                    part1 = merged_route[:i+1]\n                    part2 = np.concatenate(([0], merged_route[i+1:]))\n\n                    # Check feasibility\n                    if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n                        # Calculate score (balance between distance and makespan)\n                        dist1 = sum(distance_matrix[part1[j], part1[j+1]] for j in range(len(part1)-1))\n                        dist2 = sum(distance_matrix[part2[j], part2[j+1]] for j in range(len(part2)-1))\n                        score = abs(dist1 - dist2)  # Prefer balanced routes\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = (part1, part2)\n\n                if best_split is not None:\n                    new_solution[route1_idx] = best_split[0]\n                    new_solution.insert(route1_idx + 1, best_split[1])\n\n    # Ensure solution is feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8253033416635228,
            0.8317824006080627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_idx = min(len(archive) - 1, int(len(archive) * 0.3))  # Select from top 30%\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: Route merging and splitting\n    if len(new_solution) > 1:\n        # Step 1: Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Check if merging is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n            # Step 3: Try to split the merged route to balance objectives\n            if len(merged_route) > 3:  # Only split if route has more than 2 customers\n                best_split = None\n                best_score = float('inf')\n\n                for i in range(1, len(merged_route) - 1):\n                    # Split into two parts\n                    part1 = merged_route[:i+1]\n                    part2 = np.concatenate(([0], merged_route[i+1:]))\n\n                    # Check feasibility\n                    if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n                        # Calculate score (balance between distance and makespan)\n                        dist1 = sum(distance_matrix[part1[j], part1[j+1]] for j in range(len(part1)-1))\n                        dist2 = sum(distance_matrix[part2[j], part2[j+1]] for j in range(len(part2)-1))\n                        score = abs(dist1 - dist2)  # Prefer balanced routes\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = (part1, part2)\n\n                if best_split is not None:\n                    new_solution[route1_idx] = best_split[0]\n                    new_solution.insert(route1_idx + 1, best_split[1])\n\n    # Ensure solution is feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This algorithm selects a solution with high potential for improvement by combining route decomposition, inter-route insertion, and capacity-aware route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] + x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route decomposition + inter-route insertion + capacity-aware merging\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to decompose\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Step 2: Split the route into two parts at a random point (excluding depot)\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route) - 2)\n            part1 = route[:split_pos + 1]\n            part2 = route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            demand_part1 = np.sum(demand[part1[1:-1]])\n            demand_part2 = np.sum(demand[part2[1:-1]])\n\n            if demand_part1 <= capacity and demand_part2 <= capacity:\n                new_solution[route_idx] = part1\n                new_solution.insert(route_idx + 1, part2)\n\n    # Step 3: Inter-route insertion (move a random customer from one route to another)\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random customer from route1 (excluding depots)\n        if len(route1) > 2:\n            cust_idx = random.randint(1, len(route1) - 2)\n            customer = route1[cust_idx]\n\n            # Check if insertion in route2 is feasible\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Remove customer from route1\n                new_solution[route1_idx] = np.delete(route1, cust_idx)\n\n                # Insert customer into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_solution[route2_idx] = np.insert(route2, insert_pos, customer)\n\n    # Step 4: Capacity-aware route merging (merge two routes if their combined demand fits)\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge route2 into route1 (excluding depot of route2)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Replace route1 with merged route and remove route2\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7183613344380295,
            0.39354413747787476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] + x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route decomposition + inter-route insertion + capacity-aware merging\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to decompose\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Step 2: Split the route into two parts at a random point (excluding depot)\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route) - 2)\n            part1 = route[:split_pos + 1]\n            part2 = route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            demand_part1 = np.sum(demand[part1[1:-1]])\n            demand_part2 = np.sum(demand[part2[1:-1]])\n\n            if demand_part1 <= capacity and demand_part2 <= capacity:\n                new_solution[route_idx] = part1\n                new_solution.insert(route_idx + 1, part2)\n\n    # Step 3: Inter-route insertion (move a random customer from one route to another)\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random customer from route1 (excluding depots)\n        if len(route1) > 2:\n            cust_idx = random.randint(1, len(route1) - 2)\n            customer = route1[cust_idx]\n\n            # Check if insertion in route2 is feasible\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Remove customer from route1\n                new_solution[route1_idx] = np.delete(route1, cust_idx)\n\n                # Insert customer into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_solution[route2_idx] = np.insert(route2, insert_pos, customer)\n\n    # Step 4: Capacity-aware route merging (merge two routes if their combined demand fits)\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge route2 into route1 (excluding depot of route2)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Replace route1 with merged route and remove route2\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Choose the solution with the lowest makespan or total distance, with some randomness\n    if np.random.rand() < 0.7:\n        # Prefer solutions with lower makespan\n        best_idx = np.argmin([obj[1] for obj in archive_objectives])\n    else:\n        # Occasionally prefer solutions with lower total distance\n        best_idx = np.argmin([obj[0] for obj in archive_objectives])\n\n    base_solution = archive_solutions[best_idx].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Randomly select a segment to split or reallocate\n        split_pos = np.random.randint(1, len(route) - 1)\n\n        # Option 1: Split the route into two parts\n        if np.random.rand() < 0.5:\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check feasibility of the new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n        # Option 2: Reallocate a customer to another route\n        else:\n            customer = route[split_pos]\n            new_solution[i] = np.concatenate([route[:split_pos], route[split_pos + 1:]])\n\n            # Find the best route to insert the customer\n            best_insert_route = -1\n            best_insert_pos = -1\n            best_insert_cost = float('inf')\n\n            for j in range(len(new_solution)):\n                if j == i:\n                    continue\n                other_route = new_solution[j]\n\n                # Try inserting the customer at every possible position\n                for pos in range(1, len(other_route)):\n                    temp_route = np.concatenate([other_route[:pos], [customer], other_route[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Calculate the increase in total distance\n                        cost_increase = (distance_matrix[temp_route[pos - 1], customer] +\n                                        distance_matrix[customer, temp_route[pos]] -\n                                        distance_matrix[temp_route[pos - 1], temp_route[pos]])\n                        if cost_increase < best_insert_cost:\n                            best_insert_cost = cost_increase\n                            best_insert_route = j\n                            best_insert_pos = pos\n\n            if best_insert_route != -1:\n                temp_route = np.concatenate([new_solution[best_insert_route][:best_insert_pos],\n                                            [customer],\n                                            new_solution[best_insert_route][best_insert_pos:]])\n                new_solution[best_insert_route] = temp_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.42812831291017817,
            2.486717611551285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Choose the solution with the lowest makespan or total distance, with some randomness\n    if np.random.rand() < 0.7:\n        # Prefer solutions with lower makespan\n        best_idx = np.argmin([obj[1] for obj in archive_objectives])\n    else:\n        # Occasionally prefer solutions with lower total distance\n        best_idx = np.argmin([obj[0] for obj in archive_objectives])\n\n    base_solution = archive_solutions[best_idx].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Randomly select a segment to split or reallocate\n        split_pos = np.random.randint(1, len(route) - 1)\n\n        # Option 1: Split the route into two parts\n        if np.random.rand() < 0.5:\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check feasibility of the new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n        # Option 2: Reallocate a customer to another route\n        else:\n            customer = route[split_pos]\n            new_solution[i] = np.concatenate([route[:split_pos], route[split_pos + 1:]])\n\n            # Find the best route to insert the customer\n            best_insert_route = -1\n            best_insert_pos = -1\n            best_insert_cost = float('inf')\n\n            for j in range(len(new_solution)):\n                if j == i:\n                    continue\n                other_route = new_solution[j]\n\n                # Try inserting the customer at every possible position\n                for pos in range(1, len(other_route)):\n                    temp_route = np.concatenate([other_route[:pos], [customer], other_route[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Calculate the increase in total distance\n                        cost_increase = (distance_matrix[temp_route[pos - 1], customer] +\n                                        distance_matrix[customer, temp_route[pos]] -\n                                        distance_matrix[temp_route[pos - 1], temp_route[pos]])\n                        if cost_increase < best_insert_cost:\n                            best_insert_cost = cost_increase\n                            best_insert_route = j\n                            best_insert_pos = pos\n\n            if best_insert_route != -1:\n                temp_route = np.concatenate([new_solution[best_insert_route][:best_insert_pos],\n                                            [customer],\n                                            new_solution[best_insert_route][best_insert_pos:]])\n                new_solution[best_insert_route] = temp_route\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search: merge two routes and reallocate customers\n    if len(selected_solution) > 1:\n        # Merge two shortest routes\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution]\n        route1_idx, route2_idx = sorted(range(len(route_lengths)), key=lambda i: route_lengths[i])[:2]\n\n        route1, route2 = selected_solution[route1_idx], selected_solution[route2_idx]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check capacity constraint\n        total_demand = sum(demand[node] for node in merged_route if node != 0)\n        if total_demand <= capacity:\n            # Reallocate customers from the merged route to minimize detour\n            for i in range(1, len(merged_route)-1):\n                node = merged_route[i]\n                # Try moving the customer to another route if it reduces total distance\n                for j in range(len(selected_solution)):\n                    if j == route1_idx or j == route2_idx:\n                        continue\n                    temp_route = np.insert(selected_solution[j][:-1], -1, node)\n                    temp_route = np.append(temp_route, 0)\n                    if sum(demand[node] for node in temp_route if node != 0) <= capacity:\n                        detour = (distance_matrix[temp_route[-2]][node] + distance_matrix[node][0]) - distance_matrix[temp_route[-2]][0]\n                        if detour < 0:\n                            selected_solution[j] = temp_route\n                            merged_route = np.delete(merged_route, i)\n                            break\n\n            # Update the merged route\n            selected_solution[route1_idx] = merged_route\n            del selected_solution[route2_idx]\n\n    return selected_solution\n\n",
        "score": [
            -0.8544169006863387,
            1.0211526453495026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search: merge two routes and reallocate customers\n    if len(selected_solution) > 1:\n        # Merge two shortest routes\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution]\n        route1_idx, route2_idx = sorted(range(len(route_lengths)), key=lambda i: route_lengths[i])[:2]\n\n        route1, route2 = selected_solution[route1_idx], selected_solution[route2_idx]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check capacity constraint\n        total_demand = sum(demand[node] for node in merged_route if node != 0)\n        if total_demand <= capacity:\n            # Reallocate customers from the merged route to minimize detour\n            for i in range(1, len(merged_route)-1):\n                node = merged_route[i]\n                # Try moving the customer to another route if it reduces total distance\n                for j in range(len(selected_solution)):\n                    if j == route1_idx or j == route2_idx:\n                        continue\n                    temp_route = np.insert(selected_solution[j][:-1], -1, node)\n                    temp_route = np.append(temp_route, 0)\n                    if sum(demand[node] for node in temp_route if node != 0) <= capacity:\n                        detour = (distance_matrix[temp_route[-2]][node] + distance_matrix[node][0]) - distance_matrix[temp_route[-2]][0]\n                        if detour < 0:\n                            selected_solution[j] = temp_route\n                            merged_route = np.delete(merged_route, i)\n                            break\n\n            # Update the merged route\n            selected_solution[route1_idx] = merged_route\n            del selected_solution[route2_idx]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best makespan (promising for distance reduction)\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Convert solution to a list of routes for easier manipulation\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            continue\n\n        # Split route into two parts at a random position\n        split_pos = random.randint(1, len(route)-2)\n        part1 = route[:split_pos+1]  # Includes depot\n        part2 = route[split_pos:]    # Includes depot\n\n        # Check capacity constraints for both parts\n        demand1 = sum(demand[node] for node in part1[1:-1])\n        demand2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Valid split, now try to reallocate customers between routes\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                other_demand = sum(demand[node] for node in other_route[1:-1])\n\n                # Find customers in the other route that can be moved to this route\n                for k in range(1, len(other_route)-1):\n                    customer = other_route[k]\n                    if other_demand - demand[customer] >= 0 and demand[customer] <= capacity - demand1:\n                        # Move customer to the split route\n                        other_route = np.delete(other_route, k)\n                        part1 = np.insert(part1, -1, customer)\n                        demand1 += demand[customer]\n                        other_demand -= demand[customer]\n\n                        # Rebuild the solution\n                        new_solution[i] = part1\n                        new_solution[j] = other_route\n                        break\n\n    # Ensure all routes are valid and non-empty\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6755221882190732,
            10.12086370587349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best makespan (promising for distance reduction)\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Convert solution to a list of routes for easier manipulation\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            continue\n\n        # Split route into two parts at a random position\n        split_pos = random.randint(1, len(route)-2)\n        part1 = route[:split_pos+1]  # Includes depot\n        part2 = route[split_pos:]    # Includes depot\n\n        # Check capacity constraints for both parts\n        demand1 = sum(demand[node] for node in part1[1:-1])\n        demand2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Valid split, now try to reallocate customers between routes\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                other_demand = sum(demand[node] for node in other_route[1:-1])\n\n                # Find customers in the other route that can be moved to this route\n                for k in range(1, len(other_route)-1):\n                    customer = other_route[k]\n                    if other_demand - demand[customer] >= 0 and demand[customer] <= capacity - demand1:\n                        # Move customer to the split route\n                        other_route = np.delete(other_route, k)\n                        part1 = np.insert(part1, -1, customer)\n                        demand1 += demand[customer]\n                        other_demand -= demand[customer]\n\n                        # Rebuild the solution\n                        new_solution[i] = part1\n                        new_solution[j] = other_route\n                        break\n\n    # Ensure all routes are valid and non-empty\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(new_solution))\n    route = new_solution[route_idx]\n\n    # If the route has only depot nodes, skip\n    if len(route) <= 2:\n        return new_solution\n\n    # Hybrid local search: combine 2-opt with route splitting\n    # Step 1: Perform 2-opt on the selected route to improve distance\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, len(route) - 2):\n            for j in range(i + 1, len(route) - 1):\n                # Check if reversing the segment improves distance\n                old_dist = distance_matrix[route[i-1], route[i]] + distance_matrix[route[j], route[j+1]]\n                new_dist = distance_matrix[route[i-1], route[j]] + distance_matrix[route[i], route[j+1]]\n                if new_dist < old_dist:\n                    # Reverse the segment\n                    route[i:j+1] = route[i:j+1][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Step 2: Check if splitting the route can reduce makespan\n    for i in range(1, len(route) - 1):\n        # Calculate cumulative demand up to node i\n        cumulative_demand = np.sum(demand[route[1:i+1]])\n        if cumulative_demand > capacity:\n            continue  # Cannot split here due to capacity\n\n        # Split the route into two parts\n        new_route1 = np.concatenate([route[:i+1], [0]])\n        new_route2 = np.concatenate([[0], route[i+1:]])\n\n        # Check if the new routes are feasible\n        if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n            # Replace the original route with the two new routes\n            new_solution.pop(route_idx)\n            new_solution.insert(route_idx, new_route2)\n            new_solution.insert(route_idx, new_route1)\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7916662268619823,
            8.107020169496536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(new_solution))\n    route = new_solution[route_idx]\n\n    # If the route has only depot nodes, skip\n    if len(route) <= 2:\n        return new_solution\n\n    # Hybrid local search: combine 2-opt with route splitting\n    # Step 1: Perform 2-opt on the selected route to improve distance\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, len(route) - 2):\n            for j in range(i + 1, len(route) - 1):\n                # Check if reversing the segment improves distance\n                old_dist = distance_matrix[route[i-1], route[i]] + distance_matrix[route[j], route[j+1]]\n                new_dist = distance_matrix[route[i-1], route[j]] + distance_matrix[route[i], route[j+1]]\n                if new_dist < old_dist:\n                    # Reverse the segment\n                    route[i:j+1] = route[i:j+1][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Step 2: Check if splitting the route can reduce makespan\n    for i in range(1, len(route) - 1):\n        # Calculate cumulative demand up to node i\n        cumulative_demand = np.sum(demand[route[1:i+1]])\n        if cumulative_demand > capacity:\n            continue  # Cannot split here due to capacity\n\n        # Split the route into two parts\n        new_route1 = np.concatenate([route[:i+1], [0]])\n        new_route2 = np.concatenate([[0], route[i+1:]])\n\n        # Check if the new routes are feasible\n        if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n            # Replace the original route with the two new routes\n            new_solution.pop(route_idx)\n            new_solution.insert(route_idx, new_route2)\n            new_solution.insert(route_idx, new_route1)\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route)-1)\n        part1 = route[:split_idx+1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if (sum(demand[part1]) <= capacity) and (sum(demand[part2]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Try moving a random customer from route_i to route_j\n            if len(route_i) <= 3:\n                continue\n\n            customer_idx = np.random.randint(1, len(route_i)-1)\n            customer = route_i[customer_idx]\n\n            # Check if moving customer to route_j is feasible\n            if sum(demand[route_j]) + demand[customer] <= capacity:\n                # Insert customer into route_j at the best position\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route_j)):\n                    increase = (distance_matrix[route_j[pos-1], customer] +\n                               distance_matrix[customer, route_j[pos]] -\n                               distance_matrix[route_j[pos-1], route_j[pos]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Perform the move\n                new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx+1:]])\n                new_route_j = np.concatenate([route_j[:best_pos], [customer], route_j[best_pos:]])\n\n                # Update routes if feasible\n                if (sum(demand[new_route_i]) <= capacity) and (sum(demand[new_route_j]) <= capacity):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8483017608063704,
            2.225905478000641
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route)-1)\n        part1 = route[:split_idx+1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if (sum(demand[part1]) <= capacity) and (sum(demand[part2]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Try moving a random customer from route_i to route_j\n            if len(route_i) <= 3:\n                continue\n\n            customer_idx = np.random.randint(1, len(route_i)-1)\n            customer = route_i[customer_idx]\n\n            # Check if moving customer to route_j is feasible\n            if sum(demand[route_j]) + demand[customer] <= capacity:\n                # Insert customer into route_j at the best position\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route_j)):\n                    increase = (distance_matrix[route_j[pos-1], customer] +\n                               distance_matrix[customer, route_j[pos]] -\n                               distance_matrix[route_j[pos-1], route_j[pos]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Perform the move\n                new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx+1:]])\n                new_route_j = np.concatenate([route_j[:best_pos], [customer], route_j[best_pos:]])\n\n                # Update routes if feasible\n                if (sum(demand[new_route_i]) <= capacity) and (sum(demand[new_route_j]) <= capacity):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive, applies a hybrid local search combining route-segment inversion and inter-route customer swapping to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route-segment inversion and inter-route customer swapping\n    if len(new_solution) > 1:\n        # Inter-route customer swapping\n        route1_idx, route2_idx = np.random.choice(len(new_solution), size=2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers from each route (excluding depot)\n            cust1 = np.random.randint(1, len(route1)-1)\n            cust2 = np.random.randint(1, len(route2)-1)\n\n            # Check capacity constraints before swapping\n            demand1 = demand[route1[cust1]]\n            demand2 = demand[route2[cust2]]\n\n            if (sum(demand[route1]) - demand1 + demand2 <= capacity and\n                sum(demand[route2]) - demand2 + demand1 <= capacity):\n                # Perform the swap\n                route1[cust1], route2[cust2] = route2[cust2], route1[cust1]\n\n    # Route-segment inversion (2-opt-like but for segments)\n    for route in new_solution:\n        if len(route) > 4:  # Need at least 4 nodes to invert a segment\n            i, j = np.random.choice(range(1, len(route)-2), size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Invert the segment between i and j\n            route[i:j+1] = route[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6014039784203484,
            1.4171441197395325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route-segment inversion and inter-route customer swapping\n    if len(new_solution) > 1:\n        # Inter-route customer swapping\n        route1_idx, route2_idx = np.random.choice(len(new_solution), size=2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers from each route (excluding depot)\n            cust1 = np.random.randint(1, len(route1)-1)\n            cust2 = np.random.randint(1, len(route2)-1)\n\n            # Check capacity constraints before swapping\n            demand1 = demand[route1[cust1]]\n            demand2 = demand[route2[cust2]]\n\n            if (sum(demand[route1]) - demand1 + demand2 <= capacity and\n                sum(demand[route2]) - demand2 + demand1 <= capacity):\n                # Perform the swap\n                route1[cust1], route2[cust2] = route2[cust2], route1[cust1]\n\n    # Route-segment inversion (2-opt-like but for segments)\n    for route in new_solution:\n        if len(route) > 4:  # Need at least 4 nodes to invert a segment\n            i, j = np.random.choice(range(1, len(route)-2), size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Invert the segment between i and j\n            route[i:j+1] = route[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted random choice favoring solutions with better makespan, then applies a hybrid local search combining route splitting, customer reallocation, and a novel \"demand-balanced\" 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[1]) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + customer reallocation + demand-balanced 2-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route splitting - identify high-demand segments\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # Split if demand exceeds 70% of capacity\n            split_pos = np.argmax(np.cumsum(demand[route[1:-1]]) > capacity * 0.5)\n            if split_pos > 0 and split_pos < len(route)-2:\n                new_route1 = np.concatenate([[0], route[1:split_pos+2], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+2:-1], [0]])\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.extend([new_route1, new_route2])\n                break\n\n        # Step 2: Customer reallocation - move customers between routes\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                # Check if adding customer to other route is feasible\n                other_route = new_solution[k].copy()\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer at best position\n                    best_pos = 1\n                    min_dist = float('inf')\n                    for pos in range(1, len(other_route)):\n                        dist = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos = pos\n                    # Update routes\n                    new_route = np.insert(other_route, best_pos, customer)\n                    new_solution[k] = new_route\n                    new_solution[i] = np.delete(route, j)\n                    break\n\n        # Step 3: Demand-balanced 2-opt\n        improved = True\n        while improved:\n            improved = False\n            for a in range(1, len(route)-2):\n                for b in range(a+1, len(route)-1):\n                    # Calculate demand before and after swap\n                    segment_a = route[a:b+1]\n                    segment_b = route[b+1:a-1:-1]  # Reversed segment\n                    before_demand = sum(demand[segment_a])\n                    after_demand = sum(demand[segment_b])\n\n                    if before_demand <= capacity and after_demand <= capacity:\n                        # Calculate distance change\n                        old_dist = (distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]] +\n                                    distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]])\n                        new_dist = (distance_matrix[route[a-1], route[b]] +\n                                    distance_matrix[route[a], route[b+1]] +\n                                    distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]])\n\n                        if new_dist < old_dist:\n                            # Perform the swap\n                            route[a:b+1] = route[b:a-1:-1]\n                            new_solution[i] = route\n                            improved = True\n                            break\n                if improved:\n                    break\n\n    # Ensure all customers are served (sanity check)\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    if len(all_nodes) != len(coords) - 1:  # Exclude depot\n        # Recover missing customers by adding to shortest route\n        missing = set(range(1, len(coords))) - all_nodes\n        for customer in missing:\n            best_route = min(range(len(new_solution)),\n                           key=lambda r: (sum(demand[new_solution[r][1:-1]]) + demand[customer] <= capacity,\n                                         len(new_solution[r])))\n            if sum(demand[new_solution[best_route][1:-1]]) + demand[customer] <= capacity:\n                # Insert at best position\n                best_pos = 1\n                min_dist = float('inf')\n                for pos in range(1, len(new_solution[best_route])):\n                    dist = (distance_matrix[new_solution[best_route][pos-1], customer] +\n                            distance_matrix[customer, new_solution[best_route][pos]] -\n                            distance_matrix[new_solution[best_route][pos-1], new_solution[best_route][pos]])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_pos = pos\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.7679923644779165,
            1.1920163035392761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[1]) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + customer reallocation + demand-balanced 2-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route splitting - identify high-demand segments\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # Split if demand exceeds 70% of capacity\n            split_pos = np.argmax(np.cumsum(demand[route[1:-1]]) > capacity * 0.5)\n            if split_pos > 0 and split_pos < len(route)-2:\n                new_route1 = np.concatenate([[0], route[1:split_pos+2], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+2:-1], [0]])\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.extend([new_route1, new_route2])\n                break\n\n        # Step 2: Customer reallocation - move customers between routes\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                # Check if adding customer to other route is feasible\n                other_route = new_solution[k].copy()\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer at best position\n                    best_pos = 1\n                    min_dist = float('inf')\n                    for pos in range(1, len(other_route)):\n                        dist = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos = pos\n                    # Update routes\n                    new_route = np.insert(other_route, best_pos, customer)\n                    new_solution[k] = new_route\n                    new_solution[i] = np.delete(route, j)\n                    break\n\n        # Step 3: Demand-balanced 2-opt\n        improved = True\n        while improved:\n            improved = False\n            for a in range(1, len(route)-2):\n                for b in range(a+1, len(route)-1):\n                    # Calculate demand before and after swap\n                    segment_a = route[a:b+1]\n                    segment_b = route[b+1:a-1:-1]  # Reversed segment\n                    before_demand = sum(demand[segment_a])\n                    after_demand = sum(demand[segment_b])\n\n                    if before_demand <= capacity and after_demand <= capacity:\n                        # Calculate distance change\n                        old_dist = (distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]] +\n                                    distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]])\n                        new_dist = (distance_matrix[route[a-1], route[b]] +\n                                    distance_matrix[route[a], route[b+1]] +\n                                    distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]])\n\n                        if new_dist < old_dist:\n                            # Perform the swap\n                            route[a:b+1] = route[b:a-1:-1]\n                            new_solution[i] = route\n                            improved = True\n                            break\n                if improved:\n                    break\n\n    # Ensure all customers are served (sanity check)\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    if len(all_nodes) != len(coords) - 1:  # Exclude depot\n        # Recover missing customers by adding to shortest route\n        missing = set(range(1, len(coords))) - all_nodes\n        for customer in missing:\n            best_route = min(range(len(new_solution)),\n                           key=lambda r: (sum(demand[new_solution[r][1:-1]]) + demand[customer] <= capacity,\n                                         len(new_solution[r])))\n            if sum(demand[new_solution[best_route][1:-1]]) + demand[customer] <= capacity:\n                # Insert at best position\n                best_pos = 1\n                min_dist = float('inf')\n                for pos in range(1, len(new_solution[best_route])):\n                    dist = (distance_matrix[new_solution[best_route][pos-1], customer] +\n                            distance_matrix[customer, new_solution[best_route][pos]] -\n                            distance_matrix[new_solution[best_route][pos-1], new_solution[best_route][pos]])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_pos = pos\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route splitting and merging with demand-aware 2-opt to balance objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 2:  # Skip empty or trivial routes\n            continue\n\n        # Try to split the route into two parts\n        split_pos = len(route) // 2\n        route1 = np.concatenate((route[:split_pos], [0]))\n        route2 = np.concatenate(([0], route[split_pos:]))\n\n        # Check feasibility for both new routes\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.extend([route1, route2])\n            continue\n\n        # If splitting fails, apply demand-aware 2-opt\n        improved_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Check if swapping i and j improves makespan\n                new_route = route.copy()\n                new_route[i:j+1] = np.flip(new_route[i:j+1])\n                new_demand = np.sum(demand[new_route[1:-1]])\n\n                if new_demand <= capacity:\n                    improved_route = new_route\n\n        new_solution.append(improved_route)\n\n    # Merge routes if possible to reduce total distance\n    merged_solution = []\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            # Try to merge routes i and j if they are close\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            last1 = route1[-2]\n            first2 = route2[1]\n\n            # Check if merging is feasible\n            merged_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if merged_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                merged_solution.append(merged_route)\n                break\n        else:\n            merged_solution.append(new_solution[i])\n\n    return merged_solution\n\n",
        "score": [
            -0.5756531313281398,
            2.4829971194267273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 2:  # Skip empty or trivial routes\n            continue\n\n        # Try to split the route into two parts\n        split_pos = len(route) // 2\n        route1 = np.concatenate((route[:split_pos], [0]))\n        route2 = np.concatenate(([0], route[split_pos:]))\n\n        # Check feasibility for both new routes\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.extend([route1, route2])\n            continue\n\n        # If splitting fails, apply demand-aware 2-opt\n        improved_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Check if swapping i and j improves makespan\n                new_route = route.copy()\n                new_route[i:j+1] = np.flip(new_route[i:j+1])\n                new_demand = np.sum(demand[new_route[1:-1]])\n\n                if new_demand <= capacity:\n                    improved_route = new_route\n\n        new_solution.append(improved_route)\n\n    # Merge routes if possible to reduce total distance\n    merged_solution = []\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            # Try to merge routes i and j if they are close\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            last1 = route1[-2]\n            first2 = route2[1]\n\n            # Check if merging is feasible\n            merged_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if merged_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                merged_solution.append(merged_route)\n                break\n        else:\n            merged_solution.append(new_solution[i])\n\n    return merged_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This algorithm adaptively selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route segment relocation and capacity-aware route merging to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def normalize_objectives(solutions):\n        distances = np.array([obj[0] for _, obj in solutions])\n        makespans = np.array([obj[1] for _, obj in solutions])\n        min_dist, max_dist = np.min(distances), np.max(distances)\n        min_make, max_make = np.min(makespans), np.max(makespans)\n        normalized = []\n        for i, (sol, (dist, make)) in enumerate(solutions):\n            norm_dist = (dist - min_dist) / (max_dist - min_dist + 1e-10)\n            norm_make = (make - min_make) / (max_make - min_make + 1e-10)\n            score = 0.7 * norm_dist + 0.3 * norm_make  # Weighted combination\n            normalized.append((i, score))\n        return sorted(normalized, key=lambda x: x[1])\n\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    normalized = normalize_objectives(archive)\n    selected_idx = normalized[0][0]  # Select the best solution\n    base_solution = archive[selected_idx][0]\n\n    # Hybrid local search: route segment relocation + capacity-aware merging\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Randomly select a route and a segment\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_idx = random.randint(0, len(new_solution) - 1)\n    route = new_solution[route_idx]\n    if len(route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Extract a segment (excluding depot)\n    segment_start = random.randint(1, len(route) - 3)\n    segment_end = random.randint(segment_start + 1, len(route) - 2)\n    segment = route[segment_start:segment_end]\n\n    # Step 2: Try to relocate the segment to another route\n    other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n    if not other_routes:\n        return new_solution\n\n    target_route_idx = random.choice(other_routes)\n    target_route = new_solution[target_route_idx]\n\n    # Check capacity constraint\n    segment_demand = sum(demand[node] for node in segment)\n    if segment_demand + sum(demand[node] for node in target_route[1:-1]) > capacity:\n        return new_solution\n\n    # Insert segment into target route (random position)\n    insert_pos = random.randint(1, len(target_route) - 1)\n    new_target_route = np.concatenate([\n        target_route[:insert_pos],\n        segment,\n        target_route[insert_pos:]\n    ])\n\n    # Remove the segment from the original route\n    new_original_route = np.concatenate([\n        route[:segment_start],\n        route[segment_end:]\n    ])\n\n    # Update the solution\n    new_solution[route_idx] = new_original_route\n    new_solution[target_route_idx] = new_target_route\n\n    # Step 3: Capacity-aware route merging (if possible)\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            combined_demand = sum(demand[node] for node in route_i[1:-1]) + sum(demand[node] for node in route_j[1:-1])\n            if combined_demand <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([\n                    route_i[:-1],  # Exclude last depot of first route\n                    route_j[1:]    # Exclude first depot of second route\n                ])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.4777808557652064,
            1.7165151834487915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def normalize_objectives(solutions):\n        distances = np.array([obj[0] for _, obj in solutions])\n        makespans = np.array([obj[1] for _, obj in solutions])\n        min_dist, max_dist = np.min(distances), np.max(distances)\n        min_make, max_make = np.min(makespans), np.max(makespans)\n        normalized = []\n        for i, (sol, (dist, make)) in enumerate(solutions):\n            norm_dist = (dist - min_dist) / (max_dist - min_dist + 1e-10)\n            norm_make = (make - min_make) / (max_make - min_make + 1e-10)\n            score = 0.7 * norm_dist + 0.3 * norm_make  # Weighted combination\n            normalized.append((i, score))\n        return sorted(normalized, key=lambda x: x[1])\n\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    normalized = normalize_objectives(archive)\n    selected_idx = normalized[0][0]  # Select the best solution\n    base_solution = archive[selected_idx][0]\n\n    # Hybrid local search: route segment relocation + capacity-aware merging\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Randomly select a route and a segment\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_idx = random.randint(0, len(new_solution) - 1)\n    route = new_solution[route_idx]\n    if len(route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Extract a segment (excluding depot)\n    segment_start = random.randint(1, len(route) - 3)\n    segment_end = random.randint(segment_start + 1, len(route) - 2)\n    segment = route[segment_start:segment_end]\n\n    # Step 2: Try to relocate the segment to another route\n    other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n    if not other_routes:\n        return new_solution\n\n    target_route_idx = random.choice(other_routes)\n    target_route = new_solution[target_route_idx]\n\n    # Check capacity constraint\n    segment_demand = sum(demand[node] for node in segment)\n    if segment_demand + sum(demand[node] for node in target_route[1:-1]) > capacity:\n        return new_solution\n\n    # Insert segment into target route (random position)\n    insert_pos = random.randint(1, len(target_route) - 1)\n    new_target_route = np.concatenate([\n        target_route[:insert_pos],\n        segment,\n        target_route[insert_pos:]\n    ])\n\n    # Remove the segment from the original route\n    new_original_route = np.concatenate([\n        route[:segment_start],\n        route[segment_end:]\n    ])\n\n    # Update the solution\n    new_solution[route_idx] = new_original_route\n    new_solution[target_route_idx] = new_target_route\n\n    # Step 3: Capacity-aware route merging (if possible)\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            combined_demand = sum(demand[node] for node in route_i[1:-1]) + sum(demand[node] for node in route_j[1:-1])\n            if combined_demand <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([\n                    route_i[:-1],  # Exclude last depot of first route\n                    route_j[1:]    # Exclude first depot of second route\n                ])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive using a stochastic tournament selection, then applies a hybrid local search combining adaptive route merging and intra-route 3-opt with demand-aware edge swaps to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def tournament_selection(archive, k=3):\n        selected = random.sample(archive, min(k, len(archive)))\n        return min(selected, key=lambda x: sum(x[1]))\n\n    selected = tournament_selection(archive)\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        # Step 1: Adaptive route merging (merge short routes if demand allows)\n        merged_solution = []\n        i = 0\n        while i < len(solution):\n            current_route = solution[i]\n            if len(current_route) <= 3:  # Skip very short routes\n                merged_solution.append(current_route)\n                i += 1\n                continue\n\n            # Try to merge with next route if demand allows\n            merged = False\n            if i + 1 < len(solution):\n                next_route = solution[i+1]\n                total_demand = np.sum(demand[current_route[1:-1]]) + np.sum(demand[next_route[1:-1]])\n                if total_demand <= capacity:\n                    # Check if merging reduces distance\n                    last_node = current_route[-2]\n                    first_node = next_route[1]\n                    original_dist = distance_matrix[last_node, 0] + distance_matrix[0, first_node]\n                    merged_dist = distance_matrix[last_node, first_node]\n                    if merged_dist < original_dist:\n                        # Merge routes\n                        merged_route = np.concatenate([current_route[:-1], next_route[1:]])\n                        merged_solution.append(merged_route)\n                        i += 2\n                        merged = True\n            if not merged:\n                merged_solution.append(current_route)\n                i += 1\n\n        # Step 2: Demand-aware intra-route 3-opt with edge swaps\n        for route in merged_solution:\n            if len(route) <= 4:  # Skip very short routes\n                continue\n\n            # Select 3 random edges to modify\n            indices = random.sample(range(1, len(route)-2), min(3, len(route)-3))\n            indices.sort()\n\n            # Try different configurations\n            for _ in range(3):\n                # Create a copy of the route\n                temp_route = route.copy()\n\n                # Perform edge swaps\n                for i in indices:\n                    # Try different swap patterns\n                    if random.random() < 0.5:\n                        # Reverse a segment\n                        start, end = i, i+2\n                        temp_route[start:end+1] = temp_route[start:end+1][::-1]\n                    else:\n                        # Swap two edges\n                        if i+3 < len(temp_route)-1:\n                            temp_route[i], temp_route[i+3] = temp_route[i+3], temp_route[i]\n\n                # Check feasibility\n                route_demand = np.sum(demand[temp_route[1:-1]])\n                if route_demand <= capacity:\n                    # Accept if improvement is found\n                    if np.sum(distance_matrix[temp_route[:-1], temp_route[1:]]) < np.sum(distance_matrix[route[:-1], route[1:]]):\n                        route[:] = temp_route\n\n        return merged_solution\n\n    new_solution = hybrid_local_search(new_solution)\n\n    # Ensure depot consistency\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3104694122005013,
            6.876887768507004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def tournament_selection(archive, k=3):\n        selected = random.sample(archive, min(k, len(archive)))\n        return min(selected, key=lambda x: sum(x[1]))\n\n    selected = tournament_selection(archive)\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        # Step 1: Adaptive route merging (merge short routes if demand allows)\n        merged_solution = []\n        i = 0\n        while i < len(solution):\n            current_route = solution[i]\n            if len(current_route) <= 3:  # Skip very short routes\n                merged_solution.append(current_route)\n                i += 1\n                continue\n\n            # Try to merge with next route if demand allows\n            merged = False\n            if i + 1 < len(solution):\n                next_route = solution[i+1]\n                total_demand = np.sum(demand[current_route[1:-1]]) + np.sum(demand[next_route[1:-1]])\n                if total_demand <= capacity:\n                    # Check if merging reduces distance\n                    last_node = current_route[-2]\n                    first_node = next_route[1]\n                    original_dist = distance_matrix[last_node, 0] + distance_matrix[0, first_node]\n                    merged_dist = distance_matrix[last_node, first_node]\n                    if merged_dist < original_dist:\n                        # Merge routes\n                        merged_route = np.concatenate([current_route[:-1], next_route[1:]])\n                        merged_solution.append(merged_route)\n                        i += 2\n                        merged = True\n            if not merged:\n                merged_solution.append(current_route)\n                i += 1\n\n        # Step 2: Demand-aware intra-route 3-opt with edge swaps\n        for route in merged_solution:\n            if len(route) <= 4:  # Skip very short routes\n                continue\n\n            # Select 3 random edges to modify\n            indices = random.sample(range(1, len(route)-2), min(3, len(route)-3))\n            indices.sort()\n\n            # Try different configurations\n            for _ in range(3):\n                # Create a copy of the route\n                temp_route = route.copy()\n\n                # Perform edge swaps\n                for i in indices:\n                    # Try different swap patterns\n                    if random.random() < 0.5:\n                        # Reverse a segment\n                        start, end = i, i+2\n                        temp_route[start:end+1] = temp_route[start:end+1][::-1]\n                    else:\n                        # Swap two edges\n                        if i+3 < len(temp_route)-1:\n                            temp_route[i], temp_route[i+3] = temp_route[i+3], temp_route[i]\n\n                # Check feasibility\n                route_demand = np.sum(demand[temp_route[1:-1]])\n                if route_demand <= capacity:\n                    # Accept if improvement is found\n                    if np.sum(distance_matrix[temp_route[:-1], temp_route[1:]]) < np.sum(distance_matrix[route[:-1], route[1:]]):\n                        route[:] = temp_route\n\n        return merged_solution\n\n    new_solution = hybrid_local_search(new_solution)\n\n    # Ensure depot consistency\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search: swap routes between vehicles and merge adjacent routes if capacity allows\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two distinct routes\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Step 2: Attempt to swap segments between routes if capacity constraints are satisfied\n        route_i = new_solution[i][1:-1]  # Exclude depot\n        route_j = new_solution[j][1:-1]  # Exclude depot\n\n        # Try all possible split points for route_i\n        for k in range(1, len(route_i)):\n            segment_i = route_i[:k]\n            remaining_i = route_i[k:]\n\n            # Try all possible split points for route_j\n            for l in range(1, len(route_j)):\n                segment_j = route_j[:l]\n                remaining_j = route_j[l:]\n\n                # Check capacity constraints for new routes\n                if (np.sum(demand[segment_i]) + np.sum(demand[remaining_j]) <= capacity and\n                    np.sum(demand[segment_j]) + np.sum(demand[remaining_i]) <= capacity):\n\n                    # Create new routes\n                    new_route1 = np.concatenate([[0], segment_i, remaining_j, [0]])\n                    new_route2 = np.concatenate([[0], segment_j, remaining_i, [0]])\n\n                    # Replace original routes\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n                    # If any route is empty, remove it\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n                    return new_solution\n\n    # If no improvement, try merging two routes if capacity allows\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i][1:-1]\n            route_j = new_solution[j][1:-1]\n\n            if np.sum(demand[route_i]) + np.sum(demand[route_j]) <= capacity:\n                merged_route = np.concatenate([[0], route_i, route_j, [0]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n                return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.3908646320552757,
            1.0378258526325226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search: swap routes between vehicles and merge adjacent routes if capacity allows\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two distinct routes\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Step 2: Attempt to swap segments between routes if capacity constraints are satisfied\n        route_i = new_solution[i][1:-1]  # Exclude depot\n        route_j = new_solution[j][1:-1]  # Exclude depot\n\n        # Try all possible split points for route_i\n        for k in range(1, len(route_i)):\n            segment_i = route_i[:k]\n            remaining_i = route_i[k:]\n\n            # Try all possible split points for route_j\n            for l in range(1, len(route_j)):\n                segment_j = route_j[:l]\n                remaining_j = route_j[l:]\n\n                # Check capacity constraints for new routes\n                if (np.sum(demand[segment_i]) + np.sum(demand[remaining_j]) <= capacity and\n                    np.sum(demand[segment_j]) + np.sum(demand[remaining_i]) <= capacity):\n\n                    # Create new routes\n                    new_route1 = np.concatenate([[0], segment_i, remaining_j, [0]])\n                    new_route2 = np.concatenate([[0], segment_j, remaining_i, [0]])\n\n                    # Replace original routes\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n                    # If any route is empty, remove it\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n                    return new_solution\n\n    # If no improvement, try merging two routes if capacity allows\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i][1:-1]\n            route_j = new_solution[j][1:-1]\n\n            if np.sum(demand[route_i]) + np.sum(demand[route_j]) <= capacity:\n                merged_route = np.concatenate([[0], route_i, route_j, [0]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n                return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{A novel hybrid local search operator combines route merging, split-and-reconnect, and demand-aware edge swaps to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Sort solutions by total distance (descending) and makespan (descending)\n    sorted_by_distance = sorted(zip(archive_solutions, objectives), key=lambda x: -x[1][0])\n    sorted_by_makespan = sorted(zip(archive_solutions, objectives), key=lambda x: -x[1][1])\n\n    # Combine the two rankings to select a promising solution\n    combined_rank = [(sol, (i + j)) for i, (sol, _) in enumerate(sorted_by_distance) for j, (sol2, _) in enumerate(sorted_by_makespan) if sol is sol2]\n    combined_rank.sort(key=lambda x: x[1])\n    selected_solution = combined_rank[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search operator\n    for _ in range(3):  # Perform multiple iterations\n        # Step 1: Route merging (if possible)\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                continue\n\n        # Step 2: Split-and-reconnect\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure route can be split\n            split_pos = np.random.randint(2, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx+1, new_route2)\n                continue\n\n        # Step 3: Demand-aware edge swap\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            a, b = np.random.choice(len(route)-2, 2, replace=False) + 1\n            if a > b:\n                a, b = b, a\n            # Check if swap maintains feasibility\n            if (np.sum(demand[route[a:b]]) <= capacity and\n                np.sum(demand[np.concatenate([route[:a], route[b:b+1], route[a:a+1], route[b+1:]])]) <= capacity):\n                new_route = np.concatenate([route[:a], route[b:b+1], route[a:a+1], route[b+1:]])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7312398091829534,
            1.215927630662918
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Sort solutions by total distance (descending) and makespan (descending)\n    sorted_by_distance = sorted(zip(archive_solutions, objectives), key=lambda x: -x[1][0])\n    sorted_by_makespan = sorted(zip(archive_solutions, objectives), key=lambda x: -x[1][1])\n\n    # Combine the two rankings to select a promising solution\n    combined_rank = [(sol, (i + j)) for i, (sol, _) in enumerate(sorted_by_distance) for j, (sol2, _) in enumerate(sorted_by_makespan) if sol is sol2]\n    combined_rank.sort(key=lambda x: x[1])\n    selected_solution = combined_rank[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search operator\n    for _ in range(3):  # Perform multiple iterations\n        # Step 1: Route merging (if possible)\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                continue\n\n        # Step 2: Split-and-reconnect\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure route can be split\n            split_pos = np.random.randint(2, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx+1, new_route2)\n                continue\n\n        # Step 3: Demand-aware edge swap\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            a, b = np.random.choice(len(route)-2, 2, replace=False) + 1\n            if a > b:\n                a, b = b, a\n            # Check if swap maintains feasibility\n            if (np.sum(demand[route[a:b]]) <= capacity and\n                np.sum(demand[np.concatenate([route[:a], route[b:b+1], route[a:a+1], route[b+1:]])]) <= capacity):\n                new_route = np.concatenate([route[:a], route[b:b+1], route[a:a+1], route[b+1:]])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: Combine route merging and intra-route reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route)\n            continue\n\n        # Intra-route reinsertion (move a random customer to a new position)\n        route_list = list(route[1:-1])  # Exclude depots\n        if len(route_list) > 1:\n            i = np.random.randint(0, len(route_list))\n            customer = route_list.pop(i)\n            # Insert at a random position\n            j = np.random.randint(0, len(route_list) + 1)\n            route_list.insert(j, customer)\n\n        # Rebuild route with depots\n        new_route = np.array([0] + route_list + [0])\n        # Check capacity constraint\n        if np.sum(demand[new_route]) <= capacity:\n            new_solution.append(new_route)\n        else:\n            new_solution.append(route)  # Revert if infeasible\n\n    # Route merging: Try to merge two routes if feasible\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        merged_route = np.concatenate((route1[:-1], route2[1:]))  # Merge without double depot\n        if np.sum(demand[merged_route]) <= capacity:\n            # Insert merged route and remove originals\n            new_solution.append(merged_route)\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n\n    return new_solution\n\n",
        "score": [
            -0.6134994430056254,
            1.7411991953849792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: Combine route merging and intra-route reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route)\n            continue\n\n        # Intra-route reinsertion (move a random customer to a new position)\n        route_list = list(route[1:-1])  # Exclude depots\n        if len(route_list) > 1:\n            i = np.random.randint(0, len(route_list))\n            customer = route_list.pop(i)\n            # Insert at a random position\n            j = np.random.randint(0, len(route_list) + 1)\n            route_list.insert(j, customer)\n\n        # Rebuild route with depots\n        new_route = np.array([0] + route_list + [0])\n        # Check capacity constraint\n        if np.sum(demand[new_route]) <= capacity:\n            new_solution.append(new_route)\n        else:\n            new_solution.append(route)  # Revert if infeasible\n\n    # Route merging: Try to merge two routes if feasible\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        merged_route = np.concatenate((route1[:-1], route2[1:]))  # Merge without double depot\n        if np.sum(demand[merged_route]) <= capacity:\n            # Insert merged route and remove originals\n            new_solution.append(merged_route)\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the best makespan (longest route) and applies a hybrid local search combining route segmentation and inter-route insertion, followed by a capacity-aware swap to improve both total distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search: Route segmentation + inter-route insertion\n    if len(new_solution) > 1:\n        # Randomly select a route to split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure there are customers to split\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n                # Apply inter-route insertion\n                for _ in range(2):\n                    # Randomly select two routes\n                    route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                    route1 = new_solution[route1_idx]\n                    route2 = new_solution[route2_idx]\n\n                    if len(route1) > 3 and len(route2) > 2:\n                        # Select a customer from route1 and insert into route2\n                        customer_pos = random.randint(1, len(route1) - 2)\n                        customer = route1[customer_pos]\n\n                        # Find the best insertion position in route2\n                        best_pos = 1\n                        min_increase = float('inf')\n                        for pos in range(1, len(route2)):\n                            new_route = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                increase = (distance_matrix[route2[pos-1], customer] +\n                                            distance_matrix[customer, route2[pos]] -\n                                            distance_matrix[route2[pos-1], route2[pos]])\n                                if increase < min_increase:\n                                    min_increase = increase\n                                    best_pos = pos\n\n                        if min_increase < float('inf'):\n                            new_route = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_solution[route2_idx] = new_route\n                            new_solution[route1_idx] = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n\n    # Capacity-aware swap operator\n    for route in new_solution:\n        if len(route) > 3:\n            # Select two random customers in the route\n            pos1, pos2 = random.sample(range(1, len(route) - 1), 2)\n            # Swap them if capacity allows\n            new_route = route.copy()\n            new_route[pos1], new_route[pos2] = new_route[pos2], new_route[pos1]\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7071450089720428,
            1.5787757635116577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search: Route segmentation + inter-route insertion\n    if len(new_solution) > 1:\n        # Randomly select a route to split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure there are customers to split\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n                # Apply inter-route insertion\n                for _ in range(2):\n                    # Randomly select two routes\n                    route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                    route1 = new_solution[route1_idx]\n                    route2 = new_solution[route2_idx]\n\n                    if len(route1) > 3 and len(route2) > 2:\n                        # Select a customer from route1 and insert into route2\n                        customer_pos = random.randint(1, len(route1) - 2)\n                        customer = route1[customer_pos]\n\n                        # Find the best insertion position in route2\n                        best_pos = 1\n                        min_increase = float('inf')\n                        for pos in range(1, len(route2)):\n                            new_route = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                increase = (distance_matrix[route2[pos-1], customer] +\n                                            distance_matrix[customer, route2[pos]] -\n                                            distance_matrix[route2[pos-1], route2[pos]])\n                                if increase < min_increase:\n                                    min_increase = increase\n                                    best_pos = pos\n\n                        if min_increase < float('inf'):\n                            new_route = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_solution[route2_idx] = new_route\n                            new_solution[route1_idx] = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n\n    # Capacity-aware swap operator\n    for route in new_solution:\n        if len(route) > 3:\n            # Select two random customers in the route\n            pos1, pos2 = random.sample(range(1, len(route) - 1), 2)\n            # Swap them if capacity allows\n            new_route = route.copy()\n            new_route[pos1], new_route[pos2] = new_route[pos2], new_route[pos1]\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{A novel hybrid local search strategy combines route merging and split operations with demand-aware insertion, dynamically balancing distance and makespan reduction by prioritizing high-demand nodes and long routes for intensified optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_idx = random.randint(0, len(base_solution) - 1)\n    selected_route = base_solution[route_idx].copy()\n\n    # Hybrid local search: Route merging or split with demand-aware insertion\n    if len(base_solution) > 1 and random.random() < 0.5:\n        # Try to merge with another route\n        other_idx = random.choice([i for i in range(len(base_solution)) if i != route_idx])\n        other_route = base_solution[other_idx].copy()\n\n        # Check if merging is feasible\n        if np.sum(demand[selected_route[1:-1]]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n            merged_route = np.concatenate([selected_route[:-1], other_route[1:]])\n            new_solution = [r for i, r in enumerate(base_solution) if i not in {route_idx, other_idx}]\n            new_solution.append(merged_route)\n            return new_solution\n\n    # If merging fails or not attempted, try demand-aware split and insertion\n    if len(selected_route) > 4:  # Ensure route can be split\n        split_pos = random.randint(2, len(selected_route) - 3)\n        route1 = selected_route[:split_pos + 1]\n        route2 = selected_route[split_pos:]\n\n        # Check capacity constraints\n        if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n            # Try inserting one route into another\n            for i in range(len(base_solution)):\n                if i == route_idx:\n                    continue\n                candidate_route = base_solution[i].copy()\n                for pos in range(1, len(candidate_route)):\n                    # Insert route1 into candidate_route\n                    new_route = np.concatenate([candidate_route[:pos], route1[1:-1], candidate_route[pos:]])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Replace routes\n                        new_solution = [r for j, r in enumerate(base_solution) if j != route_idx and j != i]\n                        new_solution.append(new_route)\n                        new_solution.append(route2)\n                        return new_solution\n\n    # If no improvement, return original solution\n    return base_solution\n\n",
        "score": [
            -0.736194943920994,
            2.705024629831314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_idx = random.randint(0, len(base_solution) - 1)\n    selected_route = base_solution[route_idx].copy()\n\n    # Hybrid local search: Route merging or split with demand-aware insertion\n    if len(base_solution) > 1 and random.random() < 0.5:\n        # Try to merge with another route\n        other_idx = random.choice([i for i in range(len(base_solution)) if i != route_idx])\n        other_route = base_solution[other_idx].copy()\n\n        # Check if merging is feasible\n        if np.sum(demand[selected_route[1:-1]]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n            merged_route = np.concatenate([selected_route[:-1], other_route[1:]])\n            new_solution = [r for i, r in enumerate(base_solution) if i not in {route_idx, other_idx}]\n            new_solution.append(merged_route)\n            return new_solution\n\n    # If merging fails or not attempted, try demand-aware split and insertion\n    if len(selected_route) > 4:  # Ensure route can be split\n        split_pos = random.randint(2, len(selected_route) - 3)\n        route1 = selected_route[:split_pos + 1]\n        route2 = selected_route[split_pos:]\n\n        # Check capacity constraints\n        if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n            # Try inserting one route into another\n            for i in range(len(base_solution)):\n                if i == route_idx:\n                    continue\n                candidate_route = base_solution[i].copy()\n                for pos in range(1, len(candidate_route)):\n                    # Insert route1 into candidate_route\n                    new_route = np.concatenate([candidate_route[:pos], route1[1:-1], candidate_route[pos:]])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Replace routes\n                        new_solution = [r for j, r in enumerate(base_solution) if j != route_idx and j != i]\n                        new_solution.append(new_route)\n                        new_solution.append(route2)\n                        return new_solution\n\n    # If no improvement, return original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of total distance and makespan, then applies a hybrid local search operator that combines route swapping and partial route reversal to generate a neighbor solution, while ensuring feasibility through capacity checks and Euclidean distance calculations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choices(\n        archive,\n        weights=[1 / (obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route swapping and partial route reversal\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if swapping entire routes is feasible\n        if (np.sum(demand[route1[1:-1]]) <= capacity and\n            np.sum(demand[route2[1:-1]]) <= capacity):\n            # Swap entire routes\n            new_solution[route1_idx], new_solution[route2_idx] = route2, route1\n        else:\n            # If not feasible, try partial route reversal\n            if len(route1) > 3:  # Ensure there's enough nodes to reverse\n                # Randomly select a segment to reverse\n                start, end = sorted(random.sample(range(1, len(route1)-1), 2))\n                reversed_segment = route1[start:end+1][::-1]\n\n                # Check feasibility after reversal\n                if np.sum(demand[reversed_segment]) <= capacity:\n                    new_route = np.concatenate([route1[:start], reversed_segment, route1[end+1:]])\n                    new_solution[route1_idx] = new_route\n\n    # Ensure all routes are feasible (in case of previous operations)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If route is infeasible, try to split it\n            feasible_routes = []\n            current_route = [0]\n            current_load = 0\n            for node in route[1:-1]:\n                if current_load + demand[node] <= capacity:\n                    current_route.append(node)\n                    current_load += demand[node]\n                else:\n                    current_route.append(0)\n                    feasible_routes.append(np.array(current_route))\n                    current_route = [0, node]\n                    current_load = demand[node]\n            current_route.append(0)\n            feasible_routes.append(np.array(current_route))\n\n            # Replace the infeasible route with feasible ones\n            new_solution = np.concatenate([new_solution[:i], feasible_routes, new_solution[i+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.5256500508788171,
            2.5501768589019775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choices(\n        archive,\n        weights=[1 / (obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route swapping and partial route reversal\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if swapping entire routes is feasible\n        if (np.sum(demand[route1[1:-1]]) <= capacity and\n            np.sum(demand[route2[1:-1]]) <= capacity):\n            # Swap entire routes\n            new_solution[route1_idx], new_solution[route2_idx] = route2, route1\n        else:\n            # If not feasible, try partial route reversal\n            if len(route1) > 3:  # Ensure there's enough nodes to reverse\n                # Randomly select a segment to reverse\n                start, end = sorted(random.sample(range(1, len(route1)-1), 2))\n                reversed_segment = route1[start:end+1][::-1]\n\n                # Check feasibility after reversal\n                if np.sum(demand[reversed_segment]) <= capacity:\n                    new_route = np.concatenate([route1[:start], reversed_segment, route1[end+1:]])\n                    new_solution[route1_idx] = new_route\n\n    # Ensure all routes are feasible (in case of previous operations)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If route is infeasible, try to split it\n            feasible_routes = []\n            current_route = [0]\n            current_load = 0\n            for node in route[1:-1]:\n                if current_load + demand[node] <= capacity:\n                    current_route.append(node)\n                    current_load += demand[node]\n                else:\n                    current_route.append(0)\n                    feasible_routes.append(np.array(current_route))\n                    current_route = [0, node]\n                    current_load = demand[node]\n            current_route.append(0)\n            feasible_routes.append(np.array(current_route))\n\n            # Replace the infeasible route with feasible ones\n            new_solution = np.concatenate([new_solution[:i], feasible_routes, new_solution[i+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search operator combining route splitting and customer reallocation to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_idx = min(len(archive) - 1, max(1, int(len(archive) * 0.3)))  # Select from middle to avoid extremes\n    base_solution, _ = archive[selected_idx]\n\n    # Copy the base solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes and reallocate customers\n    for i, route in enumerate(new_solution):\n        if len(route) < 4:  # Skip very short routes\n            continue\n\n        # Check if this route can be split\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # If route is over 70% capacity\n            # Try to split the route\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Customer reallocation to balance routes\n    for route in new_solution:\n        if len(route) < 4:\n            continue\n\n        # Find the most expensive customer in terms of distance\n        max_dist = -1\n        best_cust = -1\n        for i in range(1, len(route)-1):\n            cust = route[i]\n            dist = distance_matrix[route[i-1]][cust] + distance_matrix[cust][route[i+1]]\n            if dist > max_dist:\n                max_dist = dist\n                best_cust = cust\n\n        if best_cust != -1:\n            # Try to move this customer to another route\n            for other_route in new_solution:\n                if other_route is route:\n                    continue\n                if sum(demand[other_route[1:-1]]) + demand[best_cust] <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    min_added_dist = float('inf')\n                    for i in range(1, len(other_route)):\n                        added_dist = (distance_matrix[other_route[i-1]][best_cust] +\n                                     distance_matrix[best_cust][other_route[i]] -\n                                     distance_matrix[other_route[i-1]][other_route[i]])\n                        if added_dist < min_added_dist:\n                            min_added_dist = added_dist\n                            best_pos = i\n\n                    # Perform the move\n                    other_route = np.insert(other_route, best_pos, best_cust)\n                    route = np.delete(route, np.where(route == best_cust)[0][0])\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.66672099843052,
            3.6069312393665314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_idx = min(len(archive) - 1, max(1, int(len(archive) * 0.3)))  # Select from middle to avoid extremes\n    base_solution, _ = archive[selected_idx]\n\n    # Copy the base solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes and reallocate customers\n    for i, route in enumerate(new_solution):\n        if len(route) < 4:  # Skip very short routes\n            continue\n\n        # Check if this route can be split\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # If route is over 70% capacity\n            # Try to split the route\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Customer reallocation to balance routes\n    for route in new_solution:\n        if len(route) < 4:\n            continue\n\n        # Find the most expensive customer in terms of distance\n        max_dist = -1\n        best_cust = -1\n        for i in range(1, len(route)-1):\n            cust = route[i]\n            dist = distance_matrix[route[i-1]][cust] + distance_matrix[cust][route[i+1]]\n            if dist > max_dist:\n                max_dist = dist\n                best_cust = cust\n\n        if best_cust != -1:\n            # Try to move this customer to another route\n            for other_route in new_solution:\n                if other_route is route:\n                    continue\n                if sum(demand[other_route[1:-1]]) + demand[best_cust] <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    min_added_dist = float('inf')\n                    for i in range(1, len(other_route)):\n                        added_dist = (distance_matrix[other_route[i-1]][best_cust] +\n                                     distance_matrix[best_cust][other_route[i]] -\n                                     distance_matrix[other_route[i-1]][other_route[i]])\n                        if added_dist < min_added_dist:\n                            min_added_dist = added_dist\n                            best_pos = i\n\n                    # Perform the move\n                    other_route = np.insert(other_route, best_pos, best_cust)\n                    route = np.delete(route, np.where(route == best_cust)[0][0])\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random feasible point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Reallocate customers between parts based on demand and distance\n        total_demand = sum(demand[route[1:-1]])\n        part1_demand = sum(demand[part1[1:-1]])\n        part2_demand = sum(demand[part2[1:-1]])\n\n        # Attempt to balance demands between parts\n        if part1_demand > capacity or part2_demand > capacity:\n            # If either part exceeds capacity, try to reallocate customers\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                if part1_demand + demand[customer] <= capacity:\n                    part1 = np.insert(part1, -1, customer)\n                    part1_demand += demand[customer]\n                elif part2_demand + demand[customer] <= capacity:\n                    part2 = np.insert(part2, -1, customer)\n                    part2_demand += demand[customer]\n\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n    # Remove empty routes and ensure feasibility\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If a route exceeds capacity, split it further\n            while sum(demand[route[1:-1]]) > capacity:\n                split_idx = np.random.randint(1, len(route) - 1)\n                part1 = route[:split_idx + 1]\n                part2 = route[split_idx:]\n                if sum(demand[part1[1:-1]]) <= capacity:\n                    route = part1\n                    new_solution.append(part2)\n                else:\n                    route = part2\n\n    return new_solution\n\n",
        "score": [
            -0.6864775048205333,
            0.7995604872703552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random feasible point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Reallocate customers between parts based on demand and distance\n        total_demand = sum(demand[route[1:-1]])\n        part1_demand = sum(demand[part1[1:-1]])\n        part2_demand = sum(demand[part2[1:-1]])\n\n        # Attempt to balance demands between parts\n        if part1_demand > capacity or part2_demand > capacity:\n            # If either part exceeds capacity, try to reallocate customers\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                if part1_demand + demand[customer] <= capacity:\n                    part1 = np.insert(part1, -1, customer)\n                    part1_demand += demand[customer]\n                elif part2_demand + demand[customer] <= capacity:\n                    part2 = np.insert(part2, -1, customer)\n                    part2_demand += demand[customer]\n\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n    # Remove empty routes and ensure feasibility\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If a route exceeds capacity, split it further\n            while sum(demand[route[1:-1]]) > capacity:\n                split_idx = np.random.randint(1, len(route) - 1)\n                part1 = route[:split_idx + 1]\n                part2 = route[split_idx:]\n                if sum(demand[part1[1:-1]]) <= capacity:\n                    route = part1\n                    new_solution.append(part2)\n                else:\n                    route = part2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol in archive if sol[1][0] > np.mean([s[1][0] for s in archive]) and sol[1][1] < np.mean([s[1][1] for s in archive])]\n    if not candidates:\n        candidates = archive\n    selected_sol = random.choice(candidates)[0].copy()\n\n    new_solution = []\n    for route in selected_sol:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Hybrid local search: combine route splitting and customer insertion\n        split_pos = random.randint(1, len(route)-2)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split is infeasible, try inserting a customer from another route\n            other_route = random.choice([r for r in selected_sol if r is not route and len(r) > 3])\n            if other_route is not None:\n                insert_pos = random.randint(1, len(other_route)-1)\n                customer = other_route[insert_pos]\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, split_pos, customer)\n                    new_solution.append(new_route.copy())\n                    other_route = np.delete(other_route, insert_pos)\n                    if len(other_route) > 2:\n                        new_solution.append(other_route.copy())\n            else:\n                new_solution.append(route.copy())\n\n    # Ensure all customers are served\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = [i for i in range(1, len(demand)) if i not in served]\n    if missing:\n        # Greedily assign missing customers to routes with remaining capacity\n        for customer in missing:\n            for route in new_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    insert_pos = np.argmax([distance_matrix[route[i]][customer] + distance_matrix[customer][route[i+1]] - distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)])\n                    route = np.insert(route, insert_pos+1, customer)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7912823217868223,
            2.8666924238204956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol in archive if sol[1][0] > np.mean([s[1][0] for s in archive]) and sol[1][1] < np.mean([s[1][1] for s in archive])]\n    if not candidates:\n        candidates = archive\n    selected_sol = random.choice(candidates)[0].copy()\n\n    new_solution = []\n    for route in selected_sol:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Hybrid local search: combine route splitting and customer insertion\n        split_pos = random.randint(1, len(route)-2)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split is infeasible, try inserting a customer from another route\n            other_route = random.choice([r for r in selected_sol if r is not route and len(r) > 3])\n            if other_route is not None:\n                insert_pos = random.randint(1, len(other_route)-1)\n                customer = other_route[insert_pos]\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, split_pos, customer)\n                    new_solution.append(new_route.copy())\n                    other_route = np.delete(other_route, insert_pos)\n                    if len(other_route) > 2:\n                        new_solution.append(other_route.copy())\n            else:\n                new_solution.append(route.copy())\n\n    # Ensure all customers are served\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = [i for i in range(1, len(demand)) if i not in served]\n    if missing:\n        # Greedily assign missing customers to routes with remaining capacity\n        for customer in missing:\n            for route in new_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    insert_pos = np.argmax([distance_matrix[route[i]][customer] + distance_matrix[customer][route[i+1]] - distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)])\n                    route = np.insert(route, insert_pos+1, customer)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Hybrid local search: Combine route reversal and insertion of a random customer\n    if len(route) > 3:  # Ensure route has at least one customer\n        # Reverse a random segment of the route\n        start = np.random.randint(1, len(route) - 2)  # Avoid depot\n        end = np.random.randint(start + 1, len(route) - 1)\n        route[start:end] = route[start:end][::-1]\n\n        # Insert a random customer from another route\n        other_route_idx = (route_idx + 1) % len(selected_solution)\n        other_route = selected_solution[other_route_idx].copy()\n        if len(other_route) > 2:  # Ensure other route has at least one customer\n            customer_to_insert = np.random.choice(other_route[1:-1])\n            insert_pos = np.random.randint(1, len(route))\n            route = np.insert(route, insert_pos, customer_to_insert)\n\n            # Remove the inserted customer from the other route\n            other_route = np.delete(other_route, np.where(other_route == customer_to_insert)[0][0])\n            selected_solution[other_route_idx] = other_route\n\n    # Check capacity constraint and adjust if violated\n    current_capacity = np.sum(demand[route[1:-1]])\n    if current_capacity > capacity:\n        # Remove excess customers by removing the one with the smallest demand\n        excess = current_capacity - capacity\n        customers = route[1:-1]\n        customer_demands = demand[customers]\n        while excess > 0 and len(customers) > 0:\n            min_demand_idx = np.argmin(customer_demands)\n            excess -= customer_demands[min_demand_idx]\n            customers = np.delete(customers, min_demand_idx)\n            customer_demands = np.delete(customer_demands, min_demand_idx)\n        route = np.concatenate([[0], customers, [0]])\n\n    selected_solution[route_idx] = route\n    return selected_solution\n\n",
        "score": [
            -0.3797479510268894,
            0.7971891164779663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Hybrid local search: Combine route reversal and insertion of a random customer\n    if len(route) > 3:  # Ensure route has at least one customer\n        # Reverse a random segment of the route\n        start = np.random.randint(1, len(route) - 2)  # Avoid depot\n        end = np.random.randint(start + 1, len(route) - 1)\n        route[start:end] = route[start:end][::-1]\n\n        # Insert a random customer from another route\n        other_route_idx = (route_idx + 1) % len(selected_solution)\n        other_route = selected_solution[other_route_idx].copy()\n        if len(other_route) > 2:  # Ensure other route has at least one customer\n            customer_to_insert = np.random.choice(other_route[1:-1])\n            insert_pos = np.random.randint(1, len(route))\n            route = np.insert(route, insert_pos, customer_to_insert)\n\n            # Remove the inserted customer from the other route\n            other_route = np.delete(other_route, np.where(other_route == customer_to_insert)[0][0])\n            selected_solution[other_route_idx] = other_route\n\n    # Check capacity constraint and adjust if violated\n    current_capacity = np.sum(demand[route[1:-1]])\n    if current_capacity > capacity:\n        # Remove excess customers by removing the one with the smallest demand\n        excess = current_capacity - capacity\n        customers = route[1:-1]\n        customer_demands = demand[customers]\n        while excess > 0 and len(customers) > 0:\n            min_demand_idx = np.argmin(customer_demands)\n            excess -= customer_demands[min_demand_idx]\n            customers = np.delete(customers, min_demand_idx)\n            customer_demands = np.delete(customer_demands, min_demand_idx)\n        route = np.concatenate([[0], customers, [0]])\n\n    selected_solution[route_idx] = route\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route2 into route1 at the closest possible point\n            best_pos = -1\n            best_cost = float('inf')\n            for pos in range(1, len(route1)):\n                # Insert route2 before and after each node in route1\n                for insert_pos in [pos, pos + 1]:\n                    merged_route = np.concatenate([route1[:insert_pos], route2[1:-1], route1[insert_pos:]])\n                    # Check feasibility (demand constraint)\n                    if sum(demand[merged_route[1:-1]]) <= capacity:\n                        # Calculate the cost of the merged route\n                        cost = 0\n                        for k in range(len(merged_route) - 1):\n                            cost += distance_matrix[merged_route[k]][merged_route[k+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = insert_pos\n            if best_pos != -1:\n                # Apply the best merge\n                merged_route = np.concatenate([route1[:best_pos], route2[1:-1], route1[best_pos:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    # Customer reallocation to improve makespan\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with customers\n            # Find the most distant customer from the depot in this route\n            farthest_node = max(route[1:-1], key=lambda x: distance_matrix[0][x])\n            # Try to relocate this customer to another route to balance makespan\n            for other_route in new_solution:\n                if other_route is not route:\n                    # Check if relocating the customer is feasible\n                    if sum(demand[other_route[1:-1]]) + demand[farthest_node] <= capacity:\n                        # Find the best insertion point in the other route\n                        best_pos = -1\n                        best_cost = float('inf')\n                        for pos in range(1, len(other_route)):\n                            # Calculate the cost of inserting the customer\n                            cost = distance_matrix[other_route[pos-1]][farthest_node] + \\\n                                   distance_matrix[farthest_node][other_route[pos]] - \\\n                                   distance_matrix[other_route[pos-1]][other_route[pos]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        if best_pos != -1:\n                            # Relocate the customer\n                            other_route = np.insert(other_route, best_pos, farthest_node)\n                            route[route == farthest_node] = 0  # Remove from original route\n                            route = route[route != 0]  # Clean up zeros\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.8534318958429021,
            3.090667963027954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route2 into route1 at the closest possible point\n            best_pos = -1\n            best_cost = float('inf')\n            for pos in range(1, len(route1)):\n                # Insert route2 before and after each node in route1\n                for insert_pos in [pos, pos + 1]:\n                    merged_route = np.concatenate([route1[:insert_pos], route2[1:-1], route1[insert_pos:]])\n                    # Check feasibility (demand constraint)\n                    if sum(demand[merged_route[1:-1]]) <= capacity:\n                        # Calculate the cost of the merged route\n                        cost = 0\n                        for k in range(len(merged_route) - 1):\n                            cost += distance_matrix[merged_route[k]][merged_route[k+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = insert_pos\n            if best_pos != -1:\n                # Apply the best merge\n                merged_route = np.concatenate([route1[:best_pos], route2[1:-1], route1[best_pos:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    # Customer reallocation to improve makespan\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with customers\n            # Find the most distant customer from the depot in this route\n            farthest_node = max(route[1:-1], key=lambda x: distance_matrix[0][x])\n            # Try to relocate this customer to another route to balance makespan\n            for other_route in new_solution:\n                if other_route is not route:\n                    # Check if relocating the customer is feasible\n                    if sum(demand[other_route[1:-1]]) + demand[farthest_node] <= capacity:\n                        # Find the best insertion point in the other route\n                        best_pos = -1\n                        best_cost = float('inf')\n                        for pos in range(1, len(other_route)):\n                            # Calculate the cost of inserting the customer\n                            cost = distance_matrix[other_route[pos-1]][farthest_node] + \\\n                                   distance_matrix[farthest_node][other_route[pos]] - \\\n                                   distance_matrix[other_route[pos-1]][other_route[pos]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        if best_pos != -1:\n                            # Relocate the customer\n                            other_route = np.insert(other_route, best_pos, farthest_node)\n                            route[route == farthest_node] = 0  # Remove from original route\n                            route = route[route != 0]  # Clean up zeros\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split the longest route and redistribute customers to other routes\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([distance_matrix[route[-2], 0] for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Split the longest route into two parts at a random customer\n        split_pos = np.random.randint(1, len(longest_route) - 1)\n        part1 = longest_route[:split_pos + 1]\n        part2 = longest_route[split_pos:-1]\n\n        # Check capacity constraints for the split parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting violates capacity, try inter-route insertion instead\n            target_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != longest_route_idx])\n            target_route = new_solution[target_route_idx].copy()\n\n            # Find a customer in the longest route to move to the target route\n            for i in range(1, len(longest_route) - 1):\n                customer = longest_route[i]\n                if (np.sum(demand[target_route[1:-1]]) + demand[customer]) <= capacity:\n                    # Insert the customer into the target route at the best position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(target_route)):\n                        new_route = np.insert(target_route, pos, customer)\n                        increase = (distance_matrix[new_route[pos-1], customer] +\n                                    distance_matrix[customer, new_route[pos+1]] -\n                                    distance_matrix[new_route[pos-1], new_route[pos+1]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    target_route = np.insert(target_route, best_pos, customer)\n                    longest_route = np.delete(longest_route, i)\n                    break\n\n            if len(longest_route) > 2:  # Ensure the longest route still has customers\n                new_solution[longest_route_idx] = longest_route\n                new_solution[target_route_idx] = target_route\n            else:\n                # Remove the empty route\n                new_solution.pop(longest_route_idx)\n\n    # Ensure the solution is feasible and non-empty\n    if not new_solution:\n        new_solution = [np.array([0, 0])]\n\n    return new_solution\n\n",
        "score": [
            -0.8471660053629609,
            0.11483585834503174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split the longest route and redistribute customers to other routes\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([distance_matrix[route[-2], 0] for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Split the longest route into two parts at a random customer\n        split_pos = np.random.randint(1, len(longest_route) - 1)\n        part1 = longest_route[:split_pos + 1]\n        part2 = longest_route[split_pos:-1]\n\n        # Check capacity constraints for the split parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting violates capacity, try inter-route insertion instead\n            target_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != longest_route_idx])\n            target_route = new_solution[target_route_idx].copy()\n\n            # Find a customer in the longest route to move to the target route\n            for i in range(1, len(longest_route) - 1):\n                customer = longest_route[i]\n                if (np.sum(demand[target_route[1:-1]]) + demand[customer]) <= capacity:\n                    # Insert the customer into the target route at the best position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(target_route)):\n                        new_route = np.insert(target_route, pos, customer)\n                        increase = (distance_matrix[new_route[pos-1], customer] +\n                                    distance_matrix[customer, new_route[pos+1]] -\n                                    distance_matrix[new_route[pos-1], new_route[pos+1]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    target_route = np.insert(target_route, best_pos, customer)\n                    longest_route = np.delete(longest_route, i)\n                    break\n\n            if len(longest_route) > 2:  # Ensure the longest route still has customers\n                new_solution[longest_route_idx] = longest_route\n                new_solution[target_route_idx] = target_route\n            else:\n                # Remove the empty route\n                new_solution.pop(longest_route_idx)\n\n    # Ensure the solution is feasible and non-empty\n    if not new_solution:\n        new_solution = [np.array([0, 0])]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split the longest route and redistribute customers to other routes\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([distance_matrix[route[-2], 0] for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Split the longest route into two parts at a random customer\n        split_pos = np.random.randint(1, len(longest_route) - 1)\n        part1 = longest_route[:split_pos + 1]\n        part2 = longest_route[split_pos:-1]\n\n        # Check capacity constraints for the split parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting violates capacity, try inter-route insertion instead\n            target_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != longest_route_idx])\n            target_route = new_solution[target_route_idx].copy()\n\n            # Find a customer in the longest route to move to the target route\n            for i in range(1, len(longest_route) - 1):\n                customer = longest_route[i]\n                if (np.sum(demand[target_route[1:-1]]) + demand[customer]) <= capacity:\n                    # Insert the customer into the target route at the best position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(target_route)):\n                        new_route = np.insert(target_route, pos, customer)\n                        increase = (distance_matrix[new_route[pos-1], customer] +\n                                    distance_matrix[customer, new_route[pos+1]] -\n                                    distance_matrix[new_route[pos-1], new_route[pos+1]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    target_route = np.insert(target_route, best_pos, customer)\n                    longest_route = np.delete(longest_route, i)\n                    break\n\n            if len(longest_route) > 2:  # Ensure the longest route still has customers\n                new_solution[longest_route_idx] = longest_route\n                new_solution[target_route_idx] = target_route\n            else:\n                # Remove the empty route\n                new_solution.pop(longest_route_idx)\n\n    # Ensure the solution is feasible and non-empty\n    if not new_solution:\n        new_solution = [np.array([0, 0])]\n\n    return new_solution\n\n",
        "score": [
            -0.8471660053629609,
            0.11483585834503174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split the longest route and redistribute customers to other routes\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([distance_matrix[route[-2], 0] for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Split the longest route into two parts at a random customer\n        split_pos = np.random.randint(1, len(longest_route) - 1)\n        part1 = longest_route[:split_pos + 1]\n        part2 = longest_route[split_pos:-1]\n\n        # Check capacity constraints for the split parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting violates capacity, try inter-route insertion instead\n            target_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != longest_route_idx])\n            target_route = new_solution[target_route_idx].copy()\n\n            # Find a customer in the longest route to move to the target route\n            for i in range(1, len(longest_route) - 1):\n                customer = longest_route[i]\n                if (np.sum(demand[target_route[1:-1]]) + demand[customer]) <= capacity:\n                    # Insert the customer into the target route at the best position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(target_route)):\n                        new_route = np.insert(target_route, pos, customer)\n                        increase = (distance_matrix[new_route[pos-1], customer] +\n                                    distance_matrix[customer, new_route[pos+1]] -\n                                    distance_matrix[new_route[pos-1], new_route[pos+1]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    target_route = np.insert(target_route, best_pos, customer)\n                    longest_route = np.delete(longest_route, i)\n                    break\n\n            if len(longest_route) > 2:  # Ensure the longest route still has customers\n                new_solution[longest_route_idx] = longest_route\n                new_solution[target_route_idx] = target_route\n            else:\n                # Remove the empty route\n                new_solution.pop(longest_route_idx)\n\n    # Ensure the solution is feasible and non-empty\n    if not new_solution:\n        new_solution = [np.array([0, 0])]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{A novel hybrid local search operator combines route segment swaps with adaptive demand-based relocations, dynamically balancing distance and makespan reduction while ensuring feasibility through capacity-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    base_solution = random.choice(archive_sorted[:max(3, len(archive) // 3)])[0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Number of perturbation attempts\n        # Step 1: Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Step 2: Extract a segment from route1\n        if len(route1) <= 3:\n            continue\n        start, end = sorted(random.sample(range(1, len(route1) - 1), 2))\n        segment = route1[start:end+1]\n\n        # Step 3: Check demand feasibility for insertion into route2\n        segment_demand = sum(demand[node] for node in segment)\n        if segment_demand > capacity:\n            continue\n\n        # Step 4: Find insertion point in route2 that minimizes distance increase\n        min_increase = float('inf')\n        best_pos = -1\n        for pos in range(1, len(route2)):\n            # Calculate distance increase for insertion\n            prev_node = route2[pos-1]\n            next_node = route2[pos]\n            increase = (distance_matrix[prev_node][segment[0]] +\n                        distance_matrix[segment[-1]][next_node] -\n                        distance_matrix[prev_node][next_node])\n            if increase < min_increase:\n                min_increase = increase\n                best_pos = pos\n\n        if best_pos == -1:\n            continue\n\n        # Step 5: Insert segment into route2\n        new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n        new_solution[route2_idx] = new_route2\n\n        # Step 6: Remove segment from route1\n        new_route1 = np.concatenate([route1[:start], route1[end+1:]])\n        if len(new_route1) > 2:  # Ensure route remains valid\n            new_solution[route1_idx] = new_route1\n        else:\n            new_solution.pop(route1_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.7629531571419486,
            0.6056119799613953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    base_solution = random.choice(archive_sorted[:max(3, len(archive) // 3)])[0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Number of perturbation attempts\n        # Step 1: Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Step 2: Extract a segment from route1\n        if len(route1) <= 3:\n            continue\n        start, end = sorted(random.sample(range(1, len(route1) - 1), 2))\n        segment = route1[start:end+1]\n\n        # Step 3: Check demand feasibility for insertion into route2\n        segment_demand = sum(demand[node] for node in segment)\n        if segment_demand > capacity:\n            continue\n\n        # Step 4: Find insertion point in route2 that minimizes distance increase\n        min_increase = float('inf')\n        best_pos = -1\n        for pos in range(1, len(route2)):\n            # Calculate distance increase for insertion\n            prev_node = route2[pos-1]\n            next_node = route2[pos]\n            increase = (distance_matrix[prev_node][segment[0]] +\n                        distance_matrix[segment[-1]][next_node] -\n                        distance_matrix[prev_node][next_node])\n            if increase < min_increase:\n                min_increase = increase\n                best_pos = pos\n\n        if best_pos == -1:\n            continue\n\n        # Step 5: Insert segment into route2\n        new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n        new_solution[route2_idx] = new_route2\n\n        # Step 6: Remove segment from route1\n        new_route1 = np.concatenate([route1[:start], route1[end+1:]])\n        if len(new_route1) > 2:  # Ensure route remains valid\n            new_solution[route1_idx] = new_route1\n        else:\n            new_solution.pop(route1_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{The algorithm selects a solution from the archive based on a random weighted selection favoring solutions with lower makespan and total distance, then applies a hybrid local search combining route splitting, customer reallocation, and capacity-aware edge swaps to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] * obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=normalized_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer reallocation, and edge swaps\n    # Step 1: Route splitting - split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route has enough customers\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reallocation - move customers between routes\n    for _ in range(2):  # Try multiple times\n        if len(new_solution) < 2:\n            break\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        # Select a customer from route1 to move to route2\n        if len(route1) > 3:  # Ensure route1 has customers to move\n            customer_pos = random.randint(1, len(route1) - 2)\n            customer = route1[customer_pos]\n            # Check if moving this customer to route2 violates capacity\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into route2 at a random position\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], [customer], route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n                # Remove customer from route1\n                new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                new_solution[route1_idx] = new_route1\n                break  # Only move one customer per iteration\n\n    # Step 3: Capacity-aware edge swaps - swap adjacent customers between routes\n    for _ in range(2):  # Try multiple times\n        if len(new_solution) < 2:\n            break\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        if len(route1) > 3 and len(route2) > 3:  # Both routes must have enough customers\n            # Select adjacent customers in route1 to swap with adjacent customers in route2\n            pos1 = random.randint(1, len(route1) - 3)\n            pos2 = random.randint(1, len(route2) - 3)\n            # Get the two adjacent customers in each route\n            customers1 = route1[pos1:pos1+2]\n            customers2 = route2[pos2:pos2+2]\n            # Check if swapping these pairs violates capacity\n            if (np.sum(demand[route1[1:-1]]) - np.sum(demand[customers1]) + np.sum(demand[customers2]) <= capacity and\n                np.sum(demand[route2[1:-1]]) - np.sum(demand[customers2]) + np.sum(demand[customers1]) <= capacity):\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:pos1], customers2, route1[pos1+2:]])\n                new_route2 = np.concatenate([route2[:pos2], customers1, route2[pos2+2:]])\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break  # Only swap once per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.733775103515458,
            1.420227825641632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] * obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=normalized_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer reallocation, and edge swaps\n    # Step 1: Route splitting - split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route has enough customers\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reallocation - move customers between routes\n    for _ in range(2):  # Try multiple times\n        if len(new_solution) < 2:\n            break\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        # Select a customer from route1 to move to route2\n        if len(route1) > 3:  # Ensure route1 has customers to move\n            customer_pos = random.randint(1, len(route1) - 2)\n            customer = route1[customer_pos]\n            # Check if moving this customer to route2 violates capacity\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into route2 at a random position\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], [customer], route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n                # Remove customer from route1\n                new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                new_solution[route1_idx] = new_route1\n                break  # Only move one customer per iteration\n\n    # Step 3: Capacity-aware edge swaps - swap adjacent customers between routes\n    for _ in range(2):  # Try multiple times\n        if len(new_solution) < 2:\n            break\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        if len(route1) > 3 and len(route2) > 3:  # Both routes must have enough customers\n            # Select adjacent customers in route1 to swap with adjacent customers in route2\n            pos1 = random.randint(1, len(route1) - 3)\n            pos2 = random.randint(1, len(route2) - 3)\n            # Get the two adjacent customers in each route\n            customers1 = route1[pos1:pos1+2]\n            customers2 = route2[pos2:pos2+2]\n            # Check if swapping these pairs violates capacity\n            if (np.sum(demand[route1[1:-1]]) - np.sum(demand[customers1]) + np.sum(demand[customers2]) <= capacity and\n                np.sum(demand[route2[1:-1]]) - np.sum(demand[customers2]) + np.sum(demand[customers1]) <= capacity):\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:pos1], customers2, route1[pos1+2:]])\n                new_route2 = np.concatenate([route2[:pos2], customers1, route2[pos2+2:]])\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break  # Only swap once per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This algorithm combines route merging and customer reallocation to balance distance and makespan, while ensuring feasibility through capacity checks and distance matrix updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_indices = list(range(len(selected_solution)))\n    if len(route_indices) < 2:\n        return selected_solution\n\n    # Choose two distinct routes for merging or reallocation\n    route1_idx, route2_idx = random.sample(route_indices, 2)\n    route1 = selected_solution[route1_idx].copy()\n    route2 = selected_solution[route2_idx].copy()\n\n    # Try to merge the two routes if capacity allows\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n    total_demand = sum(demand[node] for node in merged_route if node != 0)\n    if total_demand <= capacity:\n        # Update the solution with the merged route\n        new_solution = [r for i, r in enumerate(selected_solution) if i not in [route1_idx, route2_idx]]\n        new_solution.append(merged_route)\n        return new_solution\n\n    # If merging fails, try reallocating a customer from route2 to route1\n    for i in range(1, len(route2)-1):\n        customer = route2[i]\n        # Check if adding this customer to route1 is feasible\n        if sum(demand[node] for node in route1 if node != 0) + demand[customer] <= capacity:\n            # Insert customer into route1 at the position that minimizes additional distance\n            min_increase = float('inf')\n            best_pos = 1\n            for pos in range(1, len(route1)):\n                increase = distance_matrix[route1[pos-1], customer] + distance_matrix[customer, route1[pos]] - distance_matrix[route1[pos-1], route1[pos]]\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n            # Create new routes\n            new_route1 = np.insert(route1, best_pos, customer)\n            new_route2 = np.delete(route2, i)\n            # Update solution\n            new_solution = [r for i, r in enumerate(selected_solution) if i != route1_idx and i != route2_idx]\n            new_solution.append(new_route1)\n            if len(new_route2) > 2:  # Ensure route2 is not empty\n                new_solution.append(new_route2)\n            return new_solution\n\n    # If no improvement found, return the original solution\n    return selected_solution\n\n",
        "score": [
            -0.6708412402282552,
            0.8527402877807617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_indices = list(range(len(selected_solution)))\n    if len(route_indices) < 2:\n        return selected_solution\n\n    # Choose two distinct routes for merging or reallocation\n    route1_idx, route2_idx = random.sample(route_indices, 2)\n    route1 = selected_solution[route1_idx].copy()\n    route2 = selected_solution[route2_idx].copy()\n\n    # Try to merge the two routes if capacity allows\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n    total_demand = sum(demand[node] for node in merged_route if node != 0)\n    if total_demand <= capacity:\n        # Update the solution with the merged route\n        new_solution = [r for i, r in enumerate(selected_solution) if i not in [route1_idx, route2_idx]]\n        new_solution.append(merged_route)\n        return new_solution\n\n    # If merging fails, try reallocating a customer from route2 to route1\n    for i in range(1, len(route2)-1):\n        customer = route2[i]\n        # Check if adding this customer to route1 is feasible\n        if sum(demand[node] for node in route1 if node != 0) + demand[customer] <= capacity:\n            # Insert customer into route1 at the position that minimizes additional distance\n            min_increase = float('inf')\n            best_pos = 1\n            for pos in range(1, len(route1)):\n                increase = distance_matrix[route1[pos-1], customer] + distance_matrix[customer, route1[pos]] - distance_matrix[route1[pos-1], route1[pos]]\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n            # Create new routes\n            new_route1 = np.insert(route1, best_pos, customer)\n            new_route2 = np.delete(route2, i)\n            # Update solution\n            new_solution = [r for i, r in enumerate(selected_solution) if i != route1_idx and i != route2_idx]\n            new_solution.append(new_route1)\n            if len(new_route2) > 2:  # Ensure route2 is not empty\n                new_solution.append(new_route2)\n            return new_solution\n\n    # If no improvement found, return the original solution\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting with cross-route 2-opt\n    for i in range(len(base_solution)):\n        route = base_solution[i]\n        if len(route) > 4:  # Only split if route has enough nodes\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity constraints\n            if (demand[new_route1[1:-1]].sum() <= capacity and\n                demand[new_route2[1:-1]].sum() <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Cross-route 2-opt improvement\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Select random segments from each route\n            if len(route1) > 3 and len(route2) > 3:\n                seg1_start = random.randint(1, len(route1)-3)\n                seg1_end = random.randint(seg1_start+1, len(route1)-2)\n                seg2_start = random.randint(1, len(route2)-3)\n                seg2_end = random.randint(seg2_start+1, len(route2)-2)\n\n                # Create new routes by exchanging segments\n                new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end], route1[seg1_end:]])\n                new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end], route2[seg2_end:]])\n\n                # Check capacity constraints\n                if (demand[new_route1[1:-1]].sum() <= capacity and\n                    demand[new_route2[1:-1]].sum() <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.4854050051237111,
            1.145508885383606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting with cross-route 2-opt\n    for i in range(len(base_solution)):\n        route = base_solution[i]\n        if len(route) > 4:  # Only split if route has enough nodes\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity constraints\n            if (demand[new_route1[1:-1]].sum() <= capacity and\n                demand[new_route2[1:-1]].sum() <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Cross-route 2-opt improvement\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Select random segments from each route\n            if len(route1) > 3 and len(route2) > 3:\n                seg1_start = random.randint(1, len(route1)-3)\n                seg1_end = random.randint(seg1_start+1, len(route1)-2)\n                seg2_start = random.randint(1, len(route2)-3)\n                seg2_end = random.randint(seg2_start+1, len(route2)-2)\n\n                # Create new routes by exchanging segments\n                new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end], route1[seg1_end:]])\n                new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end], route2[seg2_end:]])\n\n                # Check capacity constraints\n                if (demand[new_route1[1:-1]].sum() <= capacity and\n                    demand[new_route2[1:-1]].sum() <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with the lowest total distance or makespan, then applies a hybrid local search operator that combines route splitting and merging with a demand-aware insertion heuristic to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting and merging with demand-aware insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge or split\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try merging routes if their total demand is within capacity\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge route2 into route1\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n        else:\n            # Split one route if possible\n            if len(route1) > 3:\n                split_pos = random.randint(1, len(route1)-2)\n                new_route = np.concatenate(([0], route1[split_pos:], [0]))\n                new_solution[route1_idx] = np.concatenate(([0], route1[1:split_pos], [0]))\n                new_solution.append(new_route)\n\n    # Apply demand-aware insertion to improve the solution\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select a customer to move\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n            # Remove the customer from the route\n            route = np.concatenate((route[:customer_pos], route[customer_pos+1:]))\n            # Find the best insertion position in the same route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                new_route = np.concatenate((route[:pos], [customer], route[pos:]))\n                cost = (distance_matrix[new_route[pos-1], customer] +\n                        distance_matrix[customer, new_route[pos+1]] -\n                        distance_matrix[new_route[pos-1], new_route[pos+1]])\n                if cost < best_cost and np.sum(demand[new_route[1:-1]]) <= capacity:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert the customer at the best position\n            route = np.concatenate((route[:best_pos], [customer], route[best_pos:]))\n\n    return new_solution\n\n",
        "score": [
            -0.8014403639614245,
            3.615389734506607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting and merging with demand-aware insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge or split\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try merging routes if their total demand is within capacity\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge route2 into route1\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n        else:\n            # Split one route if possible\n            if len(route1) > 3:\n                split_pos = random.randint(1, len(route1)-2)\n                new_route = np.concatenate(([0], route1[split_pos:], [0]))\n                new_solution[route1_idx] = np.concatenate(([0], route1[1:split_pos], [0]))\n                new_solution.append(new_route)\n\n    # Apply demand-aware insertion to improve the solution\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select a customer to move\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n            # Remove the customer from the route\n            route = np.concatenate((route[:customer_pos], route[customer_pos+1:]))\n            # Find the best insertion position in the same route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                new_route = np.concatenate((route[:pos], [customer], route[pos:]))\n                cost = (distance_matrix[new_route[pos-1], customer] +\n                        distance_matrix[customer, new_route[pos+1]] -\n                        distance_matrix[new_route[pos-1], new_route[pos+1]])\n                if cost < best_cost and np.sum(demand[new_route[1:-1]]) <= capacity:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert the customer at the best position\n            route = np.concatenate((route[:best_pos], [customer], route[best_pos:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with high makespan\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine route fragmentation and insertion with demand-aware rebalancing\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Fragment route into smaller segments and reinsert customers\n        frag_points = sorted(random.sample(range(1, len(route)-1), min(2, len(route)-2)))  # Random fragmentation points\n        segments = np.split(route, frag_points)\n        temp_route = [0]\n\n        for seg in segments:\n            if len(seg) <= 1:\n                continue\n            # Try to reinsert customers from the segment into the temp_route while respecting capacity\n            for customer in seg[1:-1]:\n                best_pos = -1\n                best_cost = float('inf')\n                for i in range(1, len(temp_route)):\n                    # Check capacity constraint\n                    if sum(demand[temp_route[i-1:i+1]]) + demand[customer] > capacity:\n                        continue\n                    # Evaluate insertion cost\n                    cost = distance_matrix[temp_route[i-1], customer] + distance_matrix[customer, temp_route[i]] - distance_matrix[temp_route[i-1], temp_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n                if best_pos != -1:\n                    temp_route.insert(best_pos, customer)\n        temp_route.append(0)\n        new_solution.append(np.array(temp_route))\n\n    # Demand-aware rebalancing: Merge small routes to reduce makespan\n    if len(new_solution) > 1:\n        # Sort routes by makespan in descending order\n        new_solution.sort(key=lambda r: distance_matrix[r[-2], 0], reverse=True)\n        i = 0\n        while i < len(new_solution) - 1:\n            current_route = new_solution[i]\n            next_route = new_solution[i+1]\n            # Try to merge next_route into current_route if it fits capacity\n            if sum(demand[current_route[1:-1]]) + sum(demand[next_route[1:-1]]) <= capacity:\n                merged_route = np.concatenate([current_route[:-1], next_route[1:]])\n                new_solution[i] = merged_route\n                del new_solution[i+1]\n            else:\n                i += 1\n\n    return new_solution\n\n",
        "score": [
            -0.7381708078264752,
            1.1363850831985474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with high makespan\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine route fragmentation and insertion with demand-aware rebalancing\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Fragment route into smaller segments and reinsert customers\n        frag_points = sorted(random.sample(range(1, len(route)-1), min(2, len(route)-2)))  # Random fragmentation points\n        segments = np.split(route, frag_points)\n        temp_route = [0]\n\n        for seg in segments:\n            if len(seg) <= 1:\n                continue\n            # Try to reinsert customers from the segment into the temp_route while respecting capacity\n            for customer in seg[1:-1]:\n                best_pos = -1\n                best_cost = float('inf')\n                for i in range(1, len(temp_route)):\n                    # Check capacity constraint\n                    if sum(demand[temp_route[i-1:i+1]]) + demand[customer] > capacity:\n                        continue\n                    # Evaluate insertion cost\n                    cost = distance_matrix[temp_route[i-1], customer] + distance_matrix[customer, temp_route[i]] - distance_matrix[temp_route[i-1], temp_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n                if best_pos != -1:\n                    temp_route.insert(best_pos, customer)\n        temp_route.append(0)\n        new_solution.append(np.array(temp_route))\n\n    # Demand-aware rebalancing: Merge small routes to reduce makespan\n    if len(new_solution) > 1:\n        # Sort routes by makespan in descending order\n        new_solution.sort(key=lambda r: distance_matrix[r[-2], 0], reverse=True)\n        i = 0\n        while i < len(new_solution) - 1:\n            current_route = new_solution[i]\n            next_route = new_solution[i+1]\n            # Try to merge next_route into current_route if it fits capacity\n            if sum(demand[current_route[1:-1]]) + sum(demand[next_route[1:-1]]) <= capacity:\n                merged_route = np.concatenate([current_route[:-1], next_route[1:]])\n                new_solution[i] = merged_route\n                del new_solution[i+1]\n            else:\n                i += 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a balanced objective score, then applies a hybrid local search combining route merging, customer reallocation, and capacity-aware swapping to generate a neighbor solution while optimizing both distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_scores = [(i, (obj[0] + obj[1]) / 2) for i, (_, obj) in enumerate(archive)]\n    archive_scores.sort(key=lambda x: x[1])\n    selected_idx = archive_scores[0][0] if len(archive_scores) > 1 else 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route merging, reallocation, and capacity-aware swapping\n    new_solution = base_solution.copy()\n\n    # Step 1: Route merging - try to merge two short routes if their combined load is feasible\n    if len(new_solution) > 2:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            merged_load = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if merged_load <= capacity:\n                # Merge route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # Step 2: Customer reallocation - move a customer from one route to another if feasible\n    if len(new_solution) > 1:\n        source_route_idx = random.randint(0, len(new_solution) - 1)\n        dest_route_idx = random.randint(0, len(new_solution) - 1)\n        if source_route_idx != dest_route_idx and len(new_solution[source_route_idx]) > 3:\n            source_route = new_solution[source_route_idx]\n            dest_route = new_solution[dest_route_idx]\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(source_route) - 2)\n            customer = source_route[customer_pos]\n            # Check if adding this customer to dest_route is feasible\n            if sum(demand[dest_route[1:-1]]) + demand[customer] <= capacity:\n                # Remove customer from source route\n                new_source_route = np.delete(source_route, customer_pos)\n                # Insert customer into dest route (after the depot)\n                new_dest_route = np.insert(dest_route, 1, customer)\n                new_solution[source_route_idx] = new_source_route\n                new_solution[dest_route_idx] = new_dest_route\n\n    # Step 3: Capacity-aware swapping - swap two customers between routes if it improves both distance and makespan\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 3 and len(route2) > 3:\n                # Select two random customers (excluding depots)\n                cust1_pos = random.randint(1, len(route1) - 2)\n                cust2_pos = random.randint(1, len(route2) - 2)\n                cust1 = route1[cust1_pos]\n                cust2 = route2[cust2_pos]\n                # Check if swapping is feasible\n                if (sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                    sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n                    # Perform the swap\n                    route1[cust1_pos] = cust2\n                    route2[cust2_pos] = cust1\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.8267810132277675,
            0.1913137435913086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_scores = [(i, (obj[0] + obj[1]) / 2) for i, (_, obj) in enumerate(archive)]\n    archive_scores.sort(key=lambda x: x[1])\n    selected_idx = archive_scores[0][0] if len(archive_scores) > 1 else 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route merging, reallocation, and capacity-aware swapping\n    new_solution = base_solution.copy()\n\n    # Step 1: Route merging - try to merge two short routes if their combined load is feasible\n    if len(new_solution) > 2:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            merged_load = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if merged_load <= capacity:\n                # Merge route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # Step 2: Customer reallocation - move a customer from one route to another if feasible\n    if len(new_solution) > 1:\n        source_route_idx = random.randint(0, len(new_solution) - 1)\n        dest_route_idx = random.randint(0, len(new_solution) - 1)\n        if source_route_idx != dest_route_idx and len(new_solution[source_route_idx]) > 3:\n            source_route = new_solution[source_route_idx]\n            dest_route = new_solution[dest_route_idx]\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(source_route) - 2)\n            customer = source_route[customer_pos]\n            # Check if adding this customer to dest_route is feasible\n            if sum(demand[dest_route[1:-1]]) + demand[customer] <= capacity:\n                # Remove customer from source route\n                new_source_route = np.delete(source_route, customer_pos)\n                # Insert customer into dest route (after the depot)\n                new_dest_route = np.insert(dest_route, 1, customer)\n                new_solution[source_route_idx] = new_source_route\n                new_solution[dest_route_idx] = new_dest_route\n\n    # Step 3: Capacity-aware swapping - swap two customers between routes if it improves both distance and makespan\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 3 and len(route2) > 3:\n                # Select two random customers (excluding depots)\n                cust1_pos = random.randint(1, len(route1) - 2)\n                cust2_pos = random.randint(1, len(route2) - 2)\n                cust1 = route1[cust1_pos]\n                cust2 = route2[cust2_pos]\n                # Check if swapping is feasible\n                if (sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                    sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n                    # Perform the swap\n                    route1[cust1_pos] = cust2\n                    route2[cust2_pos] = cust1\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of normalized objectives, then applies a hybrid local search combining route splitting, customer reallocation, and 3-opt moves to generate a feasible neighbor solution while balancing distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        selected_idx = 0\n    else:\n        # Normalize objectives\n        distances = np.array([sol[1][0] for sol in archive])\n        makespans = np.array([sol[1][1] for sol in archive])\n        normalized_dist = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-8)\n        normalized_make = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n        weights = 0.7 * normalized_dist + 0.3 * normalized_make  # More weight to distance\n        selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    # Step 1: Route splitting (if any route has high load imbalance)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n        total_demand = np.sum(demand[route[1:-1]])\n        if total_demand > 0.7 * capacity:  # If route is heavily loaded\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n            break\n\n    # Step 2: Customer reallocation (move customers between routes)\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 2:\n            continue\n        customer_to_move = random.choice(route1[1:-1])\n        for route2_idx in range(len(new_solution)):\n            if route2_idx == route1_idx:\n                continue\n            route2 = new_solution[route2_idx]\n            # Check capacity constraint\n            if np.sum(demand[route2[1:-1]]) + demand[customer_to_move] <= capacity:\n                # Insert customer into route2\n                best_insert_pos = 1\n                best_insert_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    cost = (distance_matrix[route2[pos-1], customer_to_move] +\n                            distance_matrix[customer_to_move, route2[pos]] -\n                            distance_matrix[route2[pos-1], route2[pos]])\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_insert_pos = pos\n                # Update routes\n                new_route1 = np.concatenate([route1[:np.where(route1 == customer_to_move)[0][0]],\n                                            route1[np.where(route1 == customer_to_move)[0][0]+1:]])\n                new_route2 = np.concatenate([route2[:best_insert_pos], [customer_to_move], route2[best_insert_pos:]])\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n    # Step 3: 3-opt move (for each route)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 4:\n            continue\n        # Select three random edges to reconnect\n        a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n        # Try all possible reconnections (3! = 6 permutations)\n        candidates = [\n            np.concatenate([route[:a], route[a:b][::-1], route[b:c], route[c:]]),\n            np.concatenate([route[:a], route[b:c], route[a:b][::-1], route[c:]]),\n            np.concatenate([route[:a], route[b:c][::-1], route[a:b], route[c:]]),\n            np.concatenate([route[:a], route[a:b], route[c:], route[b:c][::-1]]),\n            np.concatenate([route[:a], route[b:c], route[c:], route[a:b][::-1]]),\n            np.concatenate([route[:a], route[a:b][::-1], route[c:], route[b:c]])\n        ]\n        best_route = route\n        min_cost = distance_matrix[route[-2], route[-1]]\n        for cand in candidates:\n            cost = distance_matrix[cand[-2], cand[-1]]\n            if cost < min_cost:\n                min_cost = cost\n                best_route = cand\n        new_solution[i] = best_route\n\n    return np.array(new_solution, dtype=object)\n\n",
        "score": [
            -0.7216134713635989,
            2.1221086382865906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        selected_idx = 0\n    else:\n        # Normalize objectives\n        distances = np.array([sol[1][0] for sol in archive])\n        makespans = np.array([sol[1][1] for sol in archive])\n        normalized_dist = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-8)\n        normalized_make = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n        weights = 0.7 * normalized_dist + 0.3 * normalized_make  # More weight to distance\n        selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    # Step 1: Route splitting (if any route has high load imbalance)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n        total_demand = np.sum(demand[route[1:-1]])\n        if total_demand > 0.7 * capacity:  # If route is heavily loaded\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n            break\n\n    # Step 2: Customer reallocation (move customers between routes)\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 2:\n            continue\n        customer_to_move = random.choice(route1[1:-1])\n        for route2_idx in range(len(new_solution)):\n            if route2_idx == route1_idx:\n                continue\n            route2 = new_solution[route2_idx]\n            # Check capacity constraint\n            if np.sum(demand[route2[1:-1]]) + demand[customer_to_move] <= capacity:\n                # Insert customer into route2\n                best_insert_pos = 1\n                best_insert_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    cost = (distance_matrix[route2[pos-1], customer_to_move] +\n                            distance_matrix[customer_to_move, route2[pos]] -\n                            distance_matrix[route2[pos-1], route2[pos]])\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_insert_pos = pos\n                # Update routes\n                new_route1 = np.concatenate([route1[:np.where(route1 == customer_to_move)[0][0]],\n                                            route1[np.where(route1 == customer_to_move)[0][0]+1:]])\n                new_route2 = np.concatenate([route2[:best_insert_pos], [customer_to_move], route2[best_insert_pos:]])\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n    # Step 3: 3-opt move (for each route)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 4:\n            continue\n        # Select three random edges to reconnect\n        a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n        # Try all possible reconnections (3! = 6 permutations)\n        candidates = [\n            np.concatenate([route[:a], route[a:b][::-1], route[b:c], route[c:]]),\n            np.concatenate([route[:a], route[b:c], route[a:b][::-1], route[c:]]),\n            np.concatenate([route[:a], route[b:c][::-1], route[a:b], route[c:]]),\n            np.concatenate([route[:a], route[a:b], route[c:], route[b:c][::-1]]),\n            np.concatenate([route[:a], route[b:c], route[c:], route[a:b][::-1]]),\n            np.concatenate([route[:a], route[a:b][::-1], route[c:], route[b:c]])\n        ]\n        best_route = route\n        min_cost = distance_matrix[route[-2], route[-1]]\n        for cand in candidates:\n            cost = distance_matrix[cand[-2], cand[-1]]\n            if cost < min_cost:\n                min_cost = cost\n                best_route = cand\n        new_solution[i] = best_route\n\n    return np.array(new_solution, dtype=object)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to improve\n    route_idx = np.random.randint(len(new_solution))\n    selected_route = new_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    if len(selected_route) > 3:  # Ensure route has at least one customer\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        route1 = selected_route[:split_pos + 1]\n        route2 = selected_route[split_pos:]\n\n        # Check if the split routes are feasible\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution = [r for i, r in enumerate(new_solution) if i != route_idx]\n            new_solution.extend([route1, route2])\n        else:\n            # If split is infeasible, try reallocating a random customer to another route\n            customer = selected_route[split_pos]\n            # Find another route that can accommodate the customer\n            for i, route in enumerate(new_solution):\n                if i != route_idx:\n                    temp_route = np.insert(route[:-1], -1, customer)\n                    temp_demand = np.sum(demand[temp_route[1:-1]])\n                    if temp_demand <= capacity:\n                        new_solution[i] = np.append(temp_route, 0)\n                        selected_route = np.delete(selected_route, split_pos)\n                        new_solution[route_idx] = selected_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7609081179399251,
            0.14377349615097046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to improve\n    route_idx = np.random.randint(len(new_solution))\n    selected_route = new_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    if len(selected_route) > 3:  # Ensure route has at least one customer\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        route1 = selected_route[:split_pos + 1]\n        route2 = selected_route[split_pos:]\n\n        # Check if the split routes are feasible\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution = [r for i, r in enumerate(new_solution) if i != route_idx]\n            new_solution.extend([route1, route2])\n        else:\n            # If split is infeasible, try reallocating a random customer to another route\n            customer = selected_route[split_pos]\n            # Find another route that can accommodate the customer\n            for i, route in enumerate(new_solution):\n                if i != route_idx:\n                    temp_route = np.insert(route[:-1], -1, customer)\n                    temp_demand = np.sum(demand[temp_route[1:-1]])\n                    if temp_demand <= capacity:\n                        new_solution[i] = np.append(temp_route, 0)\n                        selected_route = np.delete(selected_route, split_pos)\n                        new_solution[route_idx] = selected_route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive using a hybrid approach combining weighted Pareto dominance and route diversification, then applies a novel route-splitting and merging operator with capacity-aware demand reallocation to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting and merging with demand reallocation\n    if len(new_solution) > 1:\n        # Select two routes to potentially merge\n        route_indices = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging these routes is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the routes by removing one depot and concatenating\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Remove the two routes and add the merged one\n            new_solution = [route for i, route in enumerate(new_solution) if i not in route_indices]\n            new_solution.append(merged_route)\n        else:\n            # If not feasible, try splitting a long route\n            longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 3:  # Ensure we can split\n                split_pos = random.randint(1, len(longest_route)-2)\n                route1 = np.concatenate([longest_route[:split_pos+1], [0]])\n                route2 = np.concatenate([[0], longest_route[split_pos+1:]])\n\n                # Check capacity constraints for both new routes\n                if (sum(demand[route1[1:-1]]) <= capacity and\n                    sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution.pop(longest_route_idx)\n                    new_solution.extend([route1, route2])\n\n    # Additional diversification: Randomly swap customers between routes if feasible\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers from each route (excluding depots)\n            cust1 = random.choice(route1[1:-1])\n            cust2 = random.choice(route2[1:-1])\n\n            # Check if swapping would violate capacity constraints\n            new_route1 = route1.copy()\n            new_route2 = route2.copy()\n\n            # Swap the customers\n            new_route1[np.where(new_route1 == cust1)[0][0]] = cust2\n            new_route2[np.where(new_route2 == cust2)[0][0]] = cust1\n\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.5357016165451153,
            1.2664412558078766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting and merging with demand reallocation\n    if len(new_solution) > 1:\n        # Select two routes to potentially merge\n        route_indices = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging these routes is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the routes by removing one depot and concatenating\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Remove the two routes and add the merged one\n            new_solution = [route for i, route in enumerate(new_solution) if i not in route_indices]\n            new_solution.append(merged_route)\n        else:\n            # If not feasible, try splitting a long route\n            longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 3:  # Ensure we can split\n                split_pos = random.randint(1, len(longest_route)-2)\n                route1 = np.concatenate([longest_route[:split_pos+1], [0]])\n                route2 = np.concatenate([[0], longest_route[split_pos+1:]])\n\n                # Check capacity constraints for both new routes\n                if (sum(demand[route1[1:-1]]) <= capacity and\n                    sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution.pop(longest_route_idx)\n                    new_solution.extend([route1, route2])\n\n    # Additional diversification: Randomly swap customers between routes if feasible\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers from each route (excluding depots)\n            cust1 = random.choice(route1[1:-1])\n            cust2 = random.choice(route2[1:-1])\n\n            # Check if swapping would violate capacity constraints\n            new_route1 = route1.copy()\n            new_route2 = route2.copy()\n\n            # Swap the customers\n            new_route1[np.where(new_route1 == cust1)[0][0]] = cust2\n            new_route2[np.where(new_route2 == cust2)[0][0]] = cust1\n\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring lower makespan and total distance, then applies a hybrid local search combining route merging, customer reinsertion, and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    if len(new_solution) > 1:\n        # Step 1: Try merging two routes if possible\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                # Check if merging is feasible\n                if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    break\n\n    # Step 2: Try reinserting customers from a route to others\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Randomly select a customer to move\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n            # Remove customer from current route\n            route = np.delete(route, customer_idx)\n            # Try to insert into other routes\n            inserted = False\n            for other_route in new_solution:\n                if other_route is not route:\n                    # Find best insertion point\n                    min_cost = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(other_route)):\n                        # Check capacity constraint\n                        if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate insertion cost\n                            cost = (distance_matrix[other_route[pos-1]][customer] +\n                                   distance_matrix[customer][other_route[pos]] -\n                                   distance_matrix[other_route[pos-1]][other_route[pos]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = pos\n                    if best_pos != -1:\n                        other_route = np.insert(other_route, best_pos, customer)\n                        inserted = True\n                        break\n            if not inserted:\n                # Reinsert into original route if not inserted elsewhere\n                route = np.insert(route, customer_idx, customer)\n\n    # Step 3: Try swapping segments between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random segments\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Check capacity constraints\n            seg1_demand = sum(demand[route1[seg1_start:seg1_end]])\n            seg2_demand = sum(demand[route2[seg2_start:seg2_end]])\n            route1_remaining = sum(demand[route1[1:-1]]) - seg1_demand + seg2_demand\n            route2_remaining = sum(demand[route2[1:-1]]) - seg2_demand + seg1_demand\n\n            if route1_remaining <= capacity and route2_remaining <= capacity:\n                # Perform segment swap\n                seg1 = route1[seg1_start:seg1_end]\n                seg2 = route2[seg2_start:seg2_end]\n                route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n\n    # Ensure all routes are valid (start and end with depot)\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.5182397157620477,
            7.945970416069031
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    if len(new_solution) > 1:\n        # Step 1: Try merging two routes if possible\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                # Check if merging is feasible\n                if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    break\n\n    # Step 2: Try reinserting customers from a route to others\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Randomly select a customer to move\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n            # Remove customer from current route\n            route = np.delete(route, customer_idx)\n            # Try to insert into other routes\n            inserted = False\n            for other_route in new_solution:\n                if other_route is not route:\n                    # Find best insertion point\n                    min_cost = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(other_route)):\n                        # Check capacity constraint\n                        if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate insertion cost\n                            cost = (distance_matrix[other_route[pos-1]][customer] +\n                                   distance_matrix[customer][other_route[pos]] -\n                                   distance_matrix[other_route[pos-1]][other_route[pos]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = pos\n                    if best_pos != -1:\n                        other_route = np.insert(other_route, best_pos, customer)\n                        inserted = True\n                        break\n            if not inserted:\n                # Reinsert into original route if not inserted elsewhere\n                route = np.insert(route, customer_idx, customer)\n\n    # Step 3: Try swapping segments between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random segments\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Check capacity constraints\n            seg1_demand = sum(demand[route1[seg1_start:seg1_end]])\n            seg2_demand = sum(demand[route2[seg2_start:seg2_end]])\n            route1_remaining = sum(demand[route1[1:-1]]) - seg1_demand + seg2_demand\n            route2_remaining = sum(demand[route2[1:-1]]) - seg2_demand + seg1_demand\n\n            if route1_remaining <= capacity and route2_remaining <= capacity:\n                # Perform segment swap\n                seg1 = route1[seg1_start:seg1_end]\n                seg2 = route2[seg2_start:seg2_end]\n                route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n\n    # Ensure all routes are valid (start and end with depot)\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This algorithm selects a high-quality solution from the archive using a weighted random selection based on objective values, then applies a hybrid local search combining route merging and customer reallocation to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([1 / (obj[0] * obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: merge two routes and reallocate customers\n    if len(base_solution) > 1:\n        # Select two random routes to merge\n        route1_idx, route2_idx = np.random.choice(len(base_solution), size=2, replace=False)\n        route1 = base_solution[route1_idx].copy()\n        route2 = base_solution[route2_idx].copy()\n\n        # Merge the two routes (excluding depots)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check capacity feasibility\n        total_demand = np.sum(demand[merged_route[1:-1]])  # Exclude depots\n        if total_demand <= capacity:\n            # Reallocate customers to balance makespan and distance\n            current_distance = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n            for _ in range(10):  # Limit iterations for efficiency\n                # Try moving a random customer to another route\n                if len(base_solution) > 2:\n                    temp_route = merged_route.copy()\n                    customer_idx = np.random.randint(1, len(temp_route) - 1)\n                    customer = temp_route[customer_idx]\n\n                    # Try inserting into another route\n                    for route in base_solution:\n                        if not np.array_equal(route, route1) and not np.array_equal(route, route2):\n                            for i in range(1, len(route)):\n                                new_route = np.insert(route, i, customer)\n                                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                    # Calculate new distances\n                                    old_dist = distance_matrix[temp_route[customer_idx-1], customer] + distance_matrix[customer, temp_route[customer_idx+1]]\n                                    new_dist = distance_matrix[new_route[i-1], customer] + distance_matrix[customer, new_route[i+1]]\n                                    if new_dist < old_dist:\n                                        # Update routes\n                                        temp_route = np.delete(temp_route, customer_idx)\n                                        new_route = np.insert(new_route, i, customer)\n                                        merged_route = temp_route\n                                        break\n\n            # Update the solution with the merged and reallocated routes\n            new_solution = [route for i, route in enumerate(base_solution) if i not in [route1_idx, route2_idx]]\n            new_solution.append(merged_route)\n            return new_solution\n\n    # If merging fails, apply a simple 2-opt on a random route\n    route_idx = np.random.choice(len(base_solution))\n    route = base_solution[route_idx].copy()\n    if len(route) > 4:  # Ensure enough nodes for 2-opt\n        i, j = sorted(np.random.choice(range(1, len(route)-1), size=2, replace=False))\n        new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution = base_solution.copy()\n            new_solution[route_idx] = new_route\n            return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.44940325134722103,
            1.1890627443790436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([1 / (obj[0] * obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: merge two routes and reallocate customers\n    if len(base_solution) > 1:\n        # Select two random routes to merge\n        route1_idx, route2_idx = np.random.choice(len(base_solution), size=2, replace=False)\n        route1 = base_solution[route1_idx].copy()\n        route2 = base_solution[route2_idx].copy()\n\n        # Merge the two routes (excluding depots)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check capacity feasibility\n        total_demand = np.sum(demand[merged_route[1:-1]])  # Exclude depots\n        if total_demand <= capacity:\n            # Reallocate customers to balance makespan and distance\n            current_distance = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n            for _ in range(10):  # Limit iterations for efficiency\n                # Try moving a random customer to another route\n                if len(base_solution) > 2:\n                    temp_route = merged_route.copy()\n                    customer_idx = np.random.randint(1, len(temp_route) - 1)\n                    customer = temp_route[customer_idx]\n\n                    # Try inserting into another route\n                    for route in base_solution:\n                        if not np.array_equal(route, route1) and not np.array_equal(route, route2):\n                            for i in range(1, len(route)):\n                                new_route = np.insert(route, i, customer)\n                                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                                    # Calculate new distances\n                                    old_dist = distance_matrix[temp_route[customer_idx-1], customer] + distance_matrix[customer, temp_route[customer_idx+1]]\n                                    new_dist = distance_matrix[new_route[i-1], customer] + distance_matrix[customer, new_route[i+1]]\n                                    if new_dist < old_dist:\n                                        # Update routes\n                                        temp_route = np.delete(temp_route, customer_idx)\n                                        new_route = np.insert(new_route, i, customer)\n                                        merged_route = temp_route\n                                        break\n\n            # Update the solution with the merged and reallocated routes\n            new_solution = [route for i, route in enumerate(base_solution) if i not in [route1_idx, route2_idx]]\n            new_solution.append(merged_route)\n            return new_solution\n\n    # If merging fails, apply a simple 2-opt on a random route\n    route_idx = np.random.choice(len(base_solution))\n    route = base_solution[route_idx].copy()\n    if len(route) > 4:  # Ensure enough nodes for 2-opt\n        i, j = sorted(np.random.choice(range(1, len(route)-1), size=2, replace=False))\n        new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution = base_solution.copy()\n            new_solution[route_idx] = new_route\n            return new_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Step 1: Route splitting (divide long routes into two)\n        if len(route) > 6:  # Arbitrary threshold for long routes\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n            new_route2[0] = 0  # Ensure new route starts at depot\n\n            # Check feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n        # Step 2: Customer reallocation (move customers between routes)\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j]\n\n            # Try moving a random customer from route i to route j\n            if len(route) > 3:\n                customer_idx = np.random.randint(1, len(route) - 1)\n                customer = route[customer_idx]\n\n                # Check capacity constraint\n                if (sum(demand[other_route[1:-1]]) + demand[customer] <= capacity):\n                    other_route.insert(-1, customer)\n                    route = np.delete(route, customer_idx)\n\n                    # Update routes\n                    new_solution[i] = route\n                    new_solution[j] = other_route\n                    break\n\n        # Step 3: 3-opt move (local optimization)\n        if len(route) >= 4:\n            a, b, c = sorted(np.random.choice(range(1, len(route) - 1), size=3, replace=False))\n            new_route = route.copy()\n            new_route[a:c + 1] = route[b:c + 1] + route[a:b]\n\n            # Check feasibility and improvement\n            if (sum(demand[new_route[1:-1]]) <= capacity and\n                sum(distance_matrix[new_route[:-1], new_route[1:]]) < sum(distance_matrix[route[:-1], route[1:]])):\n                new_solution[i] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6986640735778002,
            0.305742472410202
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Step 1: Route splitting (divide long routes into two)\n        if len(route) > 6:  # Arbitrary threshold for long routes\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n            new_route2[0] = 0  # Ensure new route starts at depot\n\n            # Check feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n        # Step 2: Customer reallocation (move customers between routes)\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j]\n\n            # Try moving a random customer from route i to route j\n            if len(route) > 3:\n                customer_idx = np.random.randint(1, len(route) - 1)\n                customer = route[customer_idx]\n\n                # Check capacity constraint\n                if (sum(demand[other_route[1:-1]]) + demand[customer] <= capacity):\n                    other_route.insert(-1, customer)\n                    route = np.delete(route, customer_idx)\n\n                    # Update routes\n                    new_solution[i] = route\n                    new_solution[j] = other_route\n                    break\n\n        # Step 3: 3-opt move (local optimization)\n        if len(route) >= 4:\n            a, b, c = sorted(np.random.choice(range(1, len(route) - 1), size=3, replace=False))\n            new_route = route.copy()\n            new_route[a:c + 1] = route[b:c + 1] + route[a:b]\n\n            # Check feasibility and improvement\n            if (sum(demand[new_route[1:-1]]) <= capacity and\n                sum(distance_matrix[new_route[:-1], new_route[1:]]) < sum(distance_matrix[route[:-1], route[1:]])):\n                new_solution[i] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{A novel hybrid local search operator combines route-based and customer-based moves, alternating between reinserting entire routes and relocating customers while dynamically adjusting move sizes based on demand and distance to balance the two objectives, ensuring feasibility through capacity checks and distance updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Choose a solution with the smallest makespan or total distance, or randomly with probability\n    if random.random() < 0.7:\n        # Prefer solutions with low makespan or total distance\n        if random.random() < 0.5:\n            selected_idx = np.argmin([obj[1] for obj in archive_objectives])  # makespan\n        else:\n            selected_idx = np.argmin([obj[0] for obj in archive_objectives])  # total distance\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search\n    if random.random() < 0.5:\n        # Route-based move: reinsert an entire route into another position\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution.pop(route_idx)\n            # Find best insertion position for the route\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(len(new_solution) + 1):\n                # Insert route at position i\n                temp_solution = new_solution[:i] + [route] + new_solution[i:]\n                # Check feasibility and cost\n                valid = True\n                total_cost = 0\n                for r in temp_solution:\n                    route_demand = sum(demand[r[1:-1]])  # exclude depot\n                    if route_demand > capacity:\n                        valid = False\n                        break\n                    route_cost = sum(distance_matrix[r[j], r[j+1]] for j in range(len(r)-1))\n                    total_cost += route_cost\n                if valid and total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n            new_solution = new_solution[:best_pos] + [route] + new_solution[best_pos:]\n    else:\n        # Customer-based move: relocate a customer to another route\n        # Select a random route with more than 2 nodes (excluding depot)\n        candidate_routes = [i for i, route in enumerate(new_solution) if len(route) > 3]\n        if candidate_routes:\n            route_idx = random.choice(candidate_routes)\n            route = new_solution[route_idx]\n            # Select a customer to relocate (not depot)\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n            # Remove customer from current route\n            new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n            # Find best insertion position in other routes or new route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n            for i, r in enumerate(new_solution):\n                if i == route_idx:\n                    continue  # skip current route\n                for pos in range(1, len(r)):\n                    # Insert customer into r at pos\n                    temp_route = np.concatenate([r[:pos], [customer], r[pos:]])\n                    temp_demand = sum(demand[temp_route[1:-1]])\n                    if temp_demand <= capacity:\n                        # Calculate cost of new route\n                        new_cost = sum(distance_matrix[temp_route[j], temp_route[j+1]] for j in range(len(temp_route)-1))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_route_idx = i\n                            best_pos = pos\n            if best_route_idx != -1:\n                # Insert into best route\n                r = new_solution[best_route_idx]\n                new_route = np.concatenate([r[:best_pos], [customer], r[best_pos:]])\n                new_solution[best_route_idx] = new_route\n                # Update original route\n                new_solution[route_idx] = new_route if len(new_route) > 2 else None\n                # Remove empty route if any\n                new_solution = [r for r in new_solution if r is not None and len(r) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5584034281331112,
            6.66872051358223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Choose a solution with the smallest makespan or total distance, or randomly with probability\n    if random.random() < 0.7:\n        # Prefer solutions with low makespan or total distance\n        if random.random() < 0.5:\n            selected_idx = np.argmin([obj[1] for obj in archive_objectives])  # makespan\n        else:\n            selected_idx = np.argmin([obj[0] for obj in archive_objectives])  # total distance\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search\n    if random.random() < 0.5:\n        # Route-based move: reinsert an entire route into another position\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution.pop(route_idx)\n            # Find best insertion position for the route\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(len(new_solution) + 1):\n                # Insert route at position i\n                temp_solution = new_solution[:i] + [route] + new_solution[i:]\n                # Check feasibility and cost\n                valid = True\n                total_cost = 0\n                for r in temp_solution:\n                    route_demand = sum(demand[r[1:-1]])  # exclude depot\n                    if route_demand > capacity:\n                        valid = False\n                        break\n                    route_cost = sum(distance_matrix[r[j], r[j+1]] for j in range(len(r)-1))\n                    total_cost += route_cost\n                if valid and total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n            new_solution = new_solution[:best_pos] + [route] + new_solution[best_pos:]\n    else:\n        # Customer-based move: relocate a customer to another route\n        # Select a random route with more than 2 nodes (excluding depot)\n        candidate_routes = [i for i, route in enumerate(new_solution) if len(route) > 3]\n        if candidate_routes:\n            route_idx = random.choice(candidate_routes)\n            route = new_solution[route_idx]\n            # Select a customer to relocate (not depot)\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n            # Remove customer from current route\n            new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n            # Find best insertion position in other routes or new route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n            for i, r in enumerate(new_solution):\n                if i == route_idx:\n                    continue  # skip current route\n                for pos in range(1, len(r)):\n                    # Insert customer into r at pos\n                    temp_route = np.concatenate([r[:pos], [customer], r[pos:]])\n                    temp_demand = sum(demand[temp_route[1:-1]])\n                    if temp_demand <= capacity:\n                        # Calculate cost of new route\n                        new_cost = sum(distance_matrix[temp_route[j], temp_route[j+1]] for j in range(len(temp_route)-1))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_route_idx = i\n                            best_pos = pos\n            if best_route_idx != -1:\n                # Insert into best route\n                r = new_solution[best_route_idx]\n                new_route = np.concatenate([r[:best_pos], [customer], r[best_pos:]])\n                new_solution[best_route_idx] = new_route\n                # Update original route\n                new_solution[route_idx] = new_route if len(new_route) > 2 else None\n                # Remove empty route if any\n                new_solution = [r for r in new_solution if r is not None and len(r) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted trade-off between total distance and makespan, then applies a hybrid local search combining route splitting, inter-route node swapping with capacity checks, and adaptive 2-opt to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]  # Prefer solutions with good trade-off\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Route Splitting (if any route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 5:  # Arbitrary threshold for long routes\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Inter-route Swap with Capacity Check\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random nodes from each route (excluding depot)\n        node1 = random.choice(route1[1:-1])\n        node2 = random.choice(route2[1:-1])\n\n        # Check capacity after swap\n        new_route1 = np.concatenate([[0], [node2], route1[1:-1][route1[1:-1] != node1], [0]])\n        new_route2 = np.concatenate([[0], [node1], route2[1:-1][route2[1:-1] != node2], [0]])\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Adaptive 2-opt with Objective Awareness\n    for route in new_solution:\n        if len(route) > 4:  # Only apply if route has enough nodes\n            # Select two random segments to reverse\n            i, j = sorted(random.sample(range(1, len(route)-1), 2))\n            new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n            # Accept if either distance or makespan improves\n            old_dist = sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n            new_dist = sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1))\n\n            if (new_dist < old_dist or\n                (new_dist == old_dist and np.sum(demand[new_route[1:-1]]) <= capacity)):\n                route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.48466303015450746,
            2.111428201198578
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]  # Prefer solutions with good trade-off\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Route Splitting (if any route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 5:  # Arbitrary threshold for long routes\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Inter-route Swap with Capacity Check\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random nodes from each route (excluding depot)\n        node1 = random.choice(route1[1:-1])\n        node2 = random.choice(route2[1:-1])\n\n        # Check capacity after swap\n        new_route1 = np.concatenate([[0], [node2], route1[1:-1][route1[1:-1] != node1], [0]])\n        new_route2 = np.concatenate([[0], [node1], route2[1:-1][route2[1:-1] != node2], [0]])\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Adaptive 2-opt with Objective Awareness\n    for route in new_solution:\n        if len(route) > 4:  # Only apply if route has enough nodes\n            # Select two random segments to reverse\n            i, j = sorted(random.sample(range(1, len(route)-1), 2))\n            new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n            # Accept if either distance or makespan improves\n            old_dist = sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n            new_dist = sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1))\n\n            if (new_dist < old_dist or\n                (new_dist == old_dist and np.sum(demand[new_route[1:-1]]) <= capacity)):\n                route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search operator that combines route splitting and customer reallocation to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Remove the selected route from the solution\n        new_solution.pop(route_idx)\n\n        # Split the selected route into two parts at a random customer\n        if len(selected_route) > 3:  # Ensure there are customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            part1 = selected_route[:split_pos + 1]\n            part2 = selected_route[split_pos:]\n\n            # Check capacity constraints for the split parts\n            part1_load = sum(demand[node] for node in part1[1:-1])\n            part2_load = sum(demand[node] for node in part2[1:-1])\n\n            if part1_load <= capacity and part2_load <= capacity:\n                # Add the split parts to the solution\n                new_solution.append(part1)\n                new_solution.append(part2)\n            else:\n                # If split is invalid, try reallocating customers from the selected route to other routes\n                for customer in selected_route[1:-1]:\n                    # Find the nearest route that can accommodate the customer\n                    nearest_route_idx = -1\n                    min_distance = float('inf')\n                    for i, route in enumerate(new_solution):\n                        if sum(demand[node] for node in route[1:-1]) + demand[customer] <= capacity:\n                            # Calculate the additional distance if the customer is inserted at the best position\n                            best_pos = 1\n                            min_additional_distance = float('inf')\n                            for pos in range(1, len(route)):\n                                additional_distance = distance_matrix[route[pos-1]][customer] + distance_matrix[customer][route[pos]] - distance_matrix[route[pos-1]][route[pos]]\n                                if additional_distance < min_additional_distance:\n                                    min_additional_distance = additional_distance\n                                    best_pos = pos\n                            if min_additional_distance < min_distance:\n                                min_distance = min_additional_distance\n                                nearest_route_idx = i\n                                best_insert_pos = best_pos\n\n                    if nearest_route_idx != -1:\n                        # Insert the customer into the nearest feasible route\n                        route_to_insert = new_solution[nearest_route_idx]\n                        route_to_insert = np.insert(route_to_insert, best_insert_pos, customer)\n                        new_solution[nearest_route_idx] = route_to_insert\n\n    return new_solution\n\n",
        "score": [
            -0.6304870240146938,
            0.24828138947486877
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Remove the selected route from the solution\n        new_solution.pop(route_idx)\n\n        # Split the selected route into two parts at a random customer\n        if len(selected_route) > 3:  # Ensure there are customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            part1 = selected_route[:split_pos + 1]\n            part2 = selected_route[split_pos:]\n\n            # Check capacity constraints for the split parts\n            part1_load = sum(demand[node] for node in part1[1:-1])\n            part2_load = sum(demand[node] for node in part2[1:-1])\n\n            if part1_load <= capacity and part2_load <= capacity:\n                # Add the split parts to the solution\n                new_solution.append(part1)\n                new_solution.append(part2)\n            else:\n                # If split is invalid, try reallocating customers from the selected route to other routes\n                for customer in selected_route[1:-1]:\n                    # Find the nearest route that can accommodate the customer\n                    nearest_route_idx = -1\n                    min_distance = float('inf')\n                    for i, route in enumerate(new_solution):\n                        if sum(demand[node] for node in route[1:-1]) + demand[customer] <= capacity:\n                            # Calculate the additional distance if the customer is inserted at the best position\n                            best_pos = 1\n                            min_additional_distance = float('inf')\n                            for pos in range(1, len(route)):\n                                additional_distance = distance_matrix[route[pos-1]][customer] + distance_matrix[customer][route[pos]] - distance_matrix[route[pos-1]][route[pos]]\n                                if additional_distance < min_additional_distance:\n                                    min_additional_distance = additional_distance\n                                    best_pos = pos\n                            if min_additional_distance < min_distance:\n                                min_distance = min_additional_distance\n                                nearest_route_idx = i\n                                best_insert_pos = best_pos\n\n                    if nearest_route_idx != -1:\n                        # Insert the customer into the nearest feasible route\n                        route_to_insert = new_solution[nearest_route_idx]\n                        route_to_insert = np.insert(route_to_insert, best_insert_pos, customer)\n                        new_solution[nearest_route_idx] = route_to_insert\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([s[1][0] - s[1][1] for s in archive])  # Prioritize solutions with high distance but low makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Relocate a segment from one route to another while balancing demand\n    if len(new_solution) > 1:\n        # Randomly select two distinct routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot)\n        if len(route1) > 3:  # Ensure segment is not the entire route\n            start, end = sorted(random.sample(range(1, len(route1) - 1), 2))\n            segment = route1[start:end+1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if moving the segment to route2 is feasible\n            if sum(demand[node] for node in route2) + segment_demand <= capacity:\n                # Insert the segment into route2 at a random feasible position\n                possible_positions = [i for i in range(1, len(route2)) if sum(demand[node] for node in route2[:i]) + segment_demand <= capacity]\n                if possible_positions:\n                    insert_pos = random.choice(possible_positions)\n                    new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                    new_solution[route2_idx] = new_route2\n\n                    # Remove the segment from route1\n                    new_route1 = np.concatenate([route1[:start], route1[end+1:]])\n                    new_solution[route1_idx] = new_route1\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7981182825400188,
            0.6998031735420227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([s[1][0] - s[1][1] for s in archive])  # Prioritize solutions with high distance but low makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Relocate a segment from one route to another while balancing demand\n    if len(new_solution) > 1:\n        # Randomly select two distinct routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot)\n        if len(route1) > 3:  # Ensure segment is not the entire route\n            start, end = sorted(random.sample(range(1, len(route1) - 1), 2))\n            segment = route1[start:end+1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if moving the segment to route2 is feasible\n            if sum(demand[node] for node in route2) + segment_demand <= capacity:\n                # Insert the segment into route2 at a random feasible position\n                possible_positions = [i for i in range(1, len(route2)) if sum(demand[node] for node in route2[:i]) + segment_demand <= capacity]\n                if possible_positions:\n                    insert_pos = random.choice(possible_positions)\n                    new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                    new_solution[route2_idx] = new_route2\n\n                    # Remove the segment from route1\n                    new_route1 = np.concatenate([route1[:start], route1[end+1:]])\n                    new_solution[route1_idx] = new_route1\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: route splitting and customer reallocation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random feasible split point\n        split_pos = np.random.randint(1, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = route[split_pos:]\n\n        # Check capacity feasibility\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx + 1, new_route2)\n            break\n\n    # Reallocate customers between routes to balance makespan\n    for _ in range(2):  # Repeat a few times\n        # Find the longest and shortest routes\n        longest_route_idx = np.argmax([np.sum(distance_matrix[np.concatenate([route[:-1], route[1:]])]) for route in new_solution])\n        shortest_route_idx = np.argmin([np.sum(distance_matrix[np.concatenate([route[:-1], route[1:]])]) for route in new_solution])\n\n        if longest_route_idx == shortest_route_idx:\n            break\n\n        longest_route = new_solution[longest_route_idx]\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to move a customer from longest to shortest route\n        for i in range(1, len(longest_route) - 1):\n            customer = longest_route[i]\n            temp_route = np.delete(longest_route, i)\n            if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                temp_shortest = np.append(shortest_route, customer)\n                if np.sum(demand[temp_shortest[1:-1]]) <= capacity:\n                    new_solution[longest_route_idx] = temp_route\n                    new_solution[shortest_route_idx] = temp_shortest\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6488507253651867,
            2.8629774153232574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: route splitting and customer reallocation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random feasible split point\n        split_pos = np.random.randint(1, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = route[split_pos:]\n\n        # Check capacity feasibility\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx + 1, new_route2)\n            break\n\n    # Reallocate customers between routes to balance makespan\n    for _ in range(2):  # Repeat a few times\n        # Find the longest and shortest routes\n        longest_route_idx = np.argmax([np.sum(distance_matrix[np.concatenate([route[:-1], route[1:]])]) for route in new_solution])\n        shortest_route_idx = np.argmin([np.sum(distance_matrix[np.concatenate([route[:-1], route[1:]])]) for route in new_solution])\n\n        if longest_route_idx == shortest_route_idx:\n            break\n\n        longest_route = new_solution[longest_route_idx]\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to move a customer from longest to shortest route\n        for i in range(1, len(longest_route) - 1):\n            customer = longest_route[i]\n            temp_route = np.delete(longest_route, i)\n            if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                temp_shortest = np.append(shortest_route, customer)\n                if np.sum(demand[temp_shortest[1:-1]]) <= capacity:\n                    new_solution[longest_route_idx] = temp_route\n                    new_solution[shortest_route_idx] = temp_shortest\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{The algorithm combines route splitting with customer reallocation to balance makespan and total distance, prioritizing routes with high demand or long travel times while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by combined objective (descending)\n    selected_solution = archive[0][0].copy()\n\n    # Choose a route to split or modify\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Randomly select a route to modify\n    route_idx = random.randint(0, len(selected_solution) - 1)\n    selected_route = selected_solution[route_idx]\n\n    # Split the route into two parts\n    split_point = random.randint(1, len(selected_route) - 2)\n    new_route1 = selected_route[:split_point + 1]\n    new_route2 = selected_route[split_point:]\n\n    # Check capacity constraints for the new routes\n    def check_capacity(route):\n        total_demand = sum(demand[node] for node in route if node != 0)\n        return total_demand <= capacity\n\n    if check_capacity(new_route1) and check_capacity(new_route2):\n        # Replace the original route with the two new routes\n        new_solution = [r for i, r in enumerate(selected_solution) if i != route_idx]\n        new_solution.append(new_route1)\n        new_solution.append(new_route2)\n    else:\n        # If splitting fails, try reallocating a customer to another route\n        if len(selected_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n            other_route = selected_solution[other_route_idx]\n\n            # Find a customer to move from selected_route to other_route\n            for i in range(1, len(selected_route) - 1):\n                candidate = selected_route[i]\n                if demand[candidate] + sum(demand[node] for node in other_route if node != 0) <= capacity:\n                    # Remove customer from selected_route and add to other_route\n                    new_route1 = np.delete(selected_route, i)\n                    new_route2 = np.insert(other_route, -1, candidate)\n\n                    # Update the solution\n                    new_solution = [r for i, r in enumerate(selected_solution) if i != route_idx and i != other_route_idx]\n                    new_solution.append(new_route1)\n                    new_solution.append(new_route2)\n                    break\n            else:\n                new_solution = selected_solution\n        else:\n            new_solution = selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6392908188483124,
            0.252983033657074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by combined objective (descending)\n    selected_solution = archive[0][0].copy()\n\n    # Choose a route to split or modify\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Randomly select a route to modify\n    route_idx = random.randint(0, len(selected_solution) - 1)\n    selected_route = selected_solution[route_idx]\n\n    # Split the route into two parts\n    split_point = random.randint(1, len(selected_route) - 2)\n    new_route1 = selected_route[:split_point + 1]\n    new_route2 = selected_route[split_point:]\n\n    # Check capacity constraints for the new routes\n    def check_capacity(route):\n        total_demand = sum(demand[node] for node in route if node != 0)\n        return total_demand <= capacity\n\n    if check_capacity(new_route1) and check_capacity(new_route2):\n        # Replace the original route with the two new routes\n        new_solution = [r for i, r in enumerate(selected_solution) if i != route_idx]\n        new_solution.append(new_route1)\n        new_solution.append(new_route2)\n    else:\n        # If splitting fails, try reallocating a customer to another route\n        if len(selected_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n            other_route = selected_solution[other_route_idx]\n\n            # Find a customer to move from selected_route to other_route\n            for i in range(1, len(selected_route) - 1):\n                candidate = selected_route[i]\n                if demand[candidate] + sum(demand[node] for node in other_route if node != 0) <= capacity:\n                    # Remove customer from selected_route and add to other_route\n                    new_route1 = np.delete(selected_route, i)\n                    new_route2 = np.insert(other_route, -1, candidate)\n\n                    # Update the solution\n                    new_solution = [r for i, r in enumerate(selected_solution) if i != route_idx and i != other_route_idx]\n                    new_solution.append(new_route1)\n                    new_solution.append(new_route2)\n                    break\n            else:\n                new_solution = selected_solution\n        else:\n            new_solution = selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{A hybrid local search operator that combines route reshuffling, segment swapping, and capacity-aware insertion to intelligently balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1] if np.random.rand() < 0.5 else x[1][0])[0]\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route reshuffling, segment swapping, and capacity-aware insertion\n    if len(new_solution) > 1:\n        # Route reshuffling: Randomly swap two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment swapping: Swap a segment between two routes if feasible\n        for _ in range(2):  # Try a few times\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                # Choose a segment from each route (excluding depot)\n                seg1_start = np.random.randint(1, len(route1)-2)\n                seg1_end = np.random.randint(seg1_start+1, len(route1)-1)\n                seg1 = route1[seg1_start:seg1_end]\n\n                seg2_start = np.random.randint(1, len(route2)-2)\n                seg2_end = np.random.randint(seg2_start+1, len(route2)-1)\n                seg2 = route2[seg2_start:seg2_end]\n\n                # Check capacity constraints\n                if (np.sum(demand[seg1]) + np.sum(demand[route2]) - np.sum(demand[seg2]) <= capacity and\n                    np.sum(demand[seg2]) + np.sum(demand[route1]) - np.sum(demand[seg1]) <= capacity):\n\n                    # Perform the swap\n                    new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                    new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Capacity-aware insertion: Move a customer from one route to another if beneficial\n    for _ in range(3):  # Try a few times\n        # Select a random route with more than 2 customers\n        routes_with_customers = [i for i in range(len(new_solution)) if len(new_solution[i]) > 2]\n        if not routes_with_customers:\n            continue\n\n        route_idx = np.random.choice(routes_with_customers)\n        route = new_solution[route_idx]\n\n        # Select a random customer to move\n        customer_pos = np.random.randint(1, len(route)-1)\n        customer = route[customer_pos]\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            if np.sum(demand[other_route]) + demand[customer] > capacity:\n                continue\n\n            # Find best insertion position in other route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(other_route)):\n                cost = (distance_matrix[other_route[pos-1]][customer] +\n                        distance_matrix[customer][other_route[pos]] -\n                        distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Perform insertion if beneficial\n            if best_cost < 0:  # Only insert if it improves distance\n                new_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n                break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5647506705858567,
            3.616878569126129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1] if np.random.rand() < 0.5 else x[1][0])[0]\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route reshuffling, segment swapping, and capacity-aware insertion\n    if len(new_solution) > 1:\n        # Route reshuffling: Randomly swap two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment swapping: Swap a segment between two routes if feasible\n        for _ in range(2):  # Try a few times\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                # Choose a segment from each route (excluding depot)\n                seg1_start = np.random.randint(1, len(route1)-2)\n                seg1_end = np.random.randint(seg1_start+1, len(route1)-1)\n                seg1 = route1[seg1_start:seg1_end]\n\n                seg2_start = np.random.randint(1, len(route2)-2)\n                seg2_end = np.random.randint(seg2_start+1, len(route2)-1)\n                seg2 = route2[seg2_start:seg2_end]\n\n                # Check capacity constraints\n                if (np.sum(demand[seg1]) + np.sum(demand[route2]) - np.sum(demand[seg2]) <= capacity and\n                    np.sum(demand[seg2]) + np.sum(demand[route1]) - np.sum(demand[seg1]) <= capacity):\n\n                    # Perform the swap\n                    new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                    new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Capacity-aware insertion: Move a customer from one route to another if beneficial\n    for _ in range(3):  # Try a few times\n        # Select a random route with more than 2 customers\n        routes_with_customers = [i for i in range(len(new_solution)) if len(new_solution[i]) > 2]\n        if not routes_with_customers:\n            continue\n\n        route_idx = np.random.choice(routes_with_customers)\n        route = new_solution[route_idx]\n\n        # Select a random customer to move\n        customer_pos = np.random.randint(1, len(route)-1)\n        customer = route[customer_pos]\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            if np.sum(demand[other_route]) + demand[customer] > capacity:\n                continue\n\n            # Find best insertion position in other route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(other_route)):\n                cost = (distance_matrix[other_route[pos-1]][customer] +\n                        distance_matrix[customer][other_route[pos]] -\n                        distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Perform insertion if beneficial\n            if best_cost < 0:  # Only insert if it improves distance\n                new_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n                break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{Our algorithm selects a solution from the archive based on a weighted random choice favoring solutions with lower makespan and total distance, then applies a hybrid local search combining route splitting, customer reinsertion, and adaptive 2-opt to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting (split long routes into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Ensure route has customers\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > capacity * 0.7:  # If route is heavily loaded\n                split_pos = len(route) // 2\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reinsertion (move customers between routes)\n    for _ in range(2):  # Repeat twice\n        if len(new_solution) < 2:\n            break\n        from_route = random.choice(new_solution)\n        if len(from_route) <= 3:\n            continue\n        customer_idx = random.randint(1, len(from_route) - 2)\n        customer = from_route[customer_idx]\n\n        # Find feasible insertion positions in other routes\n        feasible_insertions = []\n        for i, route in enumerate(new_solution):\n            if route is from_route:\n                continue\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    feasible_insertions.append((i, pos))\n\n        if feasible_insertions:\n            i, pos = random.choice(feasible_insertions)\n            # Remove customer from original route\n            from_route = np.concatenate([from_route[:customer_idx], from_route[customer_idx+1:]])\n            # Insert into new route\n            new_solution[i] = np.concatenate([new_solution[i][:pos], [customer], new_solution[i][pos:]])\n\n    # Step 3: Adaptive 2-opt (focus on high-improvement moves)\n    for _ in range(3):  # Repeat 3 times\n        best_improvement = 0\n        best_move = None\n\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 4:\n                continue\n\n            # Consider only edges that are part of the longest arcs\n            sorted_edges = sorted([(i, i+1) for i in range(len(route)-1)],\n                                key=lambda x: -distance_matrix[route[x[0]], route[x[1]]])\n            for i, j in sorted_edges[:min(3, len(sorted_edges))]:  # Check top 3 longest edges\n                # Try reversing between i and j\n                new_route = np.concatenate([route[:i+1], route[j:i:-1], route[j+1:]])\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    old_dist = (distance_matrix[route[i], route[i+1]] +\n                               distance_matrix[route[j], route[(j+1)%len(route)]])\n                    new_dist = (distance_matrix[new_route[i], new_route[i+1]] +\n                               distance_matrix[new_route[j], new_route[(j+1)%len(new_route)]])\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_move = (route_idx, new_route.copy())\n\n        if best_move:\n            route_idx, new_route = best_move\n            new_solution[route_idx] = new_route\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6888371632724672,
            7.292395263910294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting (split long routes into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Ensure route has customers\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > capacity * 0.7:  # If route is heavily loaded\n                split_pos = len(route) // 2\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reinsertion (move customers between routes)\n    for _ in range(2):  # Repeat twice\n        if len(new_solution) < 2:\n            break\n        from_route = random.choice(new_solution)\n        if len(from_route) <= 3:\n            continue\n        customer_idx = random.randint(1, len(from_route) - 2)\n        customer = from_route[customer_idx]\n\n        # Find feasible insertion positions in other routes\n        feasible_insertions = []\n        for i, route in enumerate(new_solution):\n            if route is from_route:\n                continue\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    feasible_insertions.append((i, pos))\n\n        if feasible_insertions:\n            i, pos = random.choice(feasible_insertions)\n            # Remove customer from original route\n            from_route = np.concatenate([from_route[:customer_idx], from_route[customer_idx+1:]])\n            # Insert into new route\n            new_solution[i] = np.concatenate([new_solution[i][:pos], [customer], new_solution[i][pos:]])\n\n    # Step 3: Adaptive 2-opt (focus on high-improvement moves)\n    for _ in range(3):  # Repeat 3 times\n        best_improvement = 0\n        best_move = None\n\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 4:\n                continue\n\n            # Consider only edges that are part of the longest arcs\n            sorted_edges = sorted([(i, i+1) for i in range(len(route)-1)],\n                                key=lambda x: -distance_matrix[route[x[0]], route[x[1]]])\n            for i, j in sorted_edges[:min(3, len(sorted_edges))]:  # Check top 3 longest edges\n                # Try reversing between i and j\n                new_route = np.concatenate([route[:i+1], route[j:i:-1], route[j+1:]])\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    old_dist = (distance_matrix[route[i], route[i+1]] +\n                               distance_matrix[route[j], route[(j+1)%len(route)]])\n                    new_dist = (distance_matrix[new_route[i], new_route[i+1]] +\n                               distance_matrix[new_route[j], new_route[(j+1)%len(new_route)]])\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_move = (route_idx, new_route.copy())\n\n        if best_move:\n            route_idx, new_route = best_move\n            new_solution[route_idx] = new_route\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted combination of the two objectives, then applies a hybrid local search operator that combines route splitting, intra-route insertion, and cross-route exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route, demand, capacity):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting (split long routes into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Avoid trivial splits\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 2: Intra-route insertion (shift customers within a route)\n    for route in new_solution:\n        if len(route) > 3:\n            from_pos = random.randint(1, len(route)-2)\n            to_pos = random.randint(1, len(route)-2)\n            if from_pos != to_pos:\n                customer = route[from_pos]\n                new_route = np.delete(route, from_pos)\n                new_route = np.insert(new_route, to_pos, customer)\n                if is_feasible(new_route, demand, capacity):\n                    route[:] = new_route\n\n    # Step 3: Cross-route exchange (swap customers between routes)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            cust1_pos = random.randint(1, len(route1)-2)\n            cust2_pos = random.randint(1, len(route2)-2)\n\n            new_route1 = np.concatenate([route1[:cust1_pos], [route2[cust2_pos]], route1[cust1_pos+1:]])\n            new_route2 = np.concatenate([route2[:cust2_pos], [route1[cust1_pos]], route2[cust2_pos+1:]])\n\n            if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                route1[:] = new_route1\n                route2[:] = new_route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7250392415957304,
            2.906913697719574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route, demand, capacity):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting (split long routes into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Avoid trivial splits\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 2: Intra-route insertion (shift customers within a route)\n    for route in new_solution:\n        if len(route) > 3:\n            from_pos = random.randint(1, len(route)-2)\n            to_pos = random.randint(1, len(route)-2)\n            if from_pos != to_pos:\n                customer = route[from_pos]\n                new_route = np.delete(route, from_pos)\n                new_route = np.insert(new_route, to_pos, customer)\n                if is_feasible(new_route, demand, capacity):\n                    route[:] = new_route\n\n    # Step 3: Cross-route exchange (swap customers between routes)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            cust1_pos = random.randint(1, len(route1)-2)\n            cust2_pos = random.randint(1, len(route2)-2)\n\n            new_route1 = np.concatenate([route1[:cust1_pos], [route2[cust2_pos]], route1[cust1_pos+1:]])\n            new_route2 = np.concatenate([route2[:cust2_pos], [route1[cust1_pos]], route2[cust2_pos+1:]])\n\n            if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                route1[:] = new_route1\n                route2[:] = new_route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This algorithm selects a promising solution from the archive, then applies a hybrid local search combining route splitting, inter-route insertion, and capacity-aware 2-opt to generate a neighbor solution while balancing total distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by total distance and pick a middle solution (not the best)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        candidate_idx = min(len(archive) // 2, len(archive) - 1)\n        base_solution = sorted_archive[candidate_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, inter-route insertion, and capacity-aware 2-opt\n    for _ in range(3):  # Apply multiple iterations for better exploration\n        # Step 1: Route splitting - split long routes if possible\n        for i, route in enumerate(new_solution):\n            if len(route) > 4:  # Only consider routes with more than 2 customers\n                split_pos = random.randint(1, len(route)-2)\n                new_route1 = route[:split_pos+1]\n                new_route2 = route[split_pos:]\n                new_route2[0] = 0  # Ensure new route starts at depot\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Step 2: Inter-route insertion - move a customer between routes\n        if len(new_solution) > 1:\n            src_route_idx = random.randint(0, len(new_solution)-1)\n            src_route = new_solution[src_route_idx]\n            if len(src_route) > 3:  # Only consider routes with customers to move\n                customer_pos = random.randint(1, len(src_route)-2)\n                customer = src_route[customer_pos]\n\n                # Try to insert into another route\n                for dst_route_idx, dst_route in enumerate(new_solution):\n                    if dst_route_idx != src_route_idx:\n                        # Find best insertion position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(dst_route)):\n                            # Calculate insertion cost\n                            prev_node = dst_route[pos-1]\n                            next_node = dst_route[pos]\n                            new_cost = (distance_matrix[prev_node][customer] +\n                                       distance_matrix[customer][next_node] -\n                                       distance_matrix[prev_node][next_node])\n\n                            if new_cost < best_cost and np.sum(demand[dst_route[1:-1]]) + demand[customer] <= capacity:\n                                best_cost = new_cost\n                                best_pos = pos\n\n                        if best_pos != 1:  # Found a valid insertion\n                            # Remove from source route\n                            new_route = np.delete(src_route, customer_pos)\n                            if len(new_route) > 2:  # Only keep if route has customers\n                                new_solution[src_route_idx] = new_route\n                            else:\n                                new_solution.pop(src_route_idx)\n                                if src_route_idx < len(new_solution):\n                                    src_route_idx -= 1\n\n                            # Insert into destination route\n                            new_route = np.insert(dst_route, best_pos, customer)\n                            new_solution[dst_route_idx] = new_route\n                            break\n\n        # Step 3: Capacity-aware 2-opt - local improvement within routes\n        for route in new_solution:\n            if len(route) > 4:  # Only consider routes with enough customers\n                i = random.randint(1, len(route)-3)\n                j = random.randint(i+1, len(route)-2)\n\n                # Check if swapping i and j improves distance and maintains capacity\n                original_cost = (distance_matrix[route[i-1]][route[i]] +\n                               distance_matrix[route[j]][route[j+1]])\n                new_cost = (distance_matrix[route[i-1]][route[j]] +\n                           distance_matrix[route[i]][route[j+1]])\n\n                # Check if the swap maintains capacity for both segments\n                segment1 = route[i:j+1]\n                segment2 = route[j:i-1:-1]  # Reversed segment\n\n                if (new_cost < original_cost and\n                    np.sum(demand[segment1]) <= capacity and\n                    np.sum(demand[segment2]) <= capacity):\n                    # Perform the swap\n                    route[i:j+1] = route[j:i-1:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7860929674313383,
            3.286868155002594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by total distance and pick a middle solution (not the best)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        candidate_idx = min(len(archive) // 2, len(archive) - 1)\n        base_solution = sorted_archive[candidate_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, inter-route insertion, and capacity-aware 2-opt\n    for _ in range(3):  # Apply multiple iterations for better exploration\n        # Step 1: Route splitting - split long routes if possible\n        for i, route in enumerate(new_solution):\n            if len(route) > 4:  # Only consider routes with more than 2 customers\n                split_pos = random.randint(1, len(route)-2)\n                new_route1 = route[:split_pos+1]\n                new_route2 = route[split_pos:]\n                new_route2[0] = 0  # Ensure new route starts at depot\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Step 2: Inter-route insertion - move a customer between routes\n        if len(new_solution) > 1:\n            src_route_idx = random.randint(0, len(new_solution)-1)\n            src_route = new_solution[src_route_idx]\n            if len(src_route) > 3:  # Only consider routes with customers to move\n                customer_pos = random.randint(1, len(src_route)-2)\n                customer = src_route[customer_pos]\n\n                # Try to insert into another route\n                for dst_route_idx, dst_route in enumerate(new_solution):\n                    if dst_route_idx != src_route_idx:\n                        # Find best insertion position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(dst_route)):\n                            # Calculate insertion cost\n                            prev_node = dst_route[pos-1]\n                            next_node = dst_route[pos]\n                            new_cost = (distance_matrix[prev_node][customer] +\n                                       distance_matrix[customer][next_node] -\n                                       distance_matrix[prev_node][next_node])\n\n                            if new_cost < best_cost and np.sum(demand[dst_route[1:-1]]) + demand[customer] <= capacity:\n                                best_cost = new_cost\n                                best_pos = pos\n\n                        if best_pos != 1:  # Found a valid insertion\n                            # Remove from source route\n                            new_route = np.delete(src_route, customer_pos)\n                            if len(new_route) > 2:  # Only keep if route has customers\n                                new_solution[src_route_idx] = new_route\n                            else:\n                                new_solution.pop(src_route_idx)\n                                if src_route_idx < len(new_solution):\n                                    src_route_idx -= 1\n\n                            # Insert into destination route\n                            new_route = np.insert(dst_route, best_pos, customer)\n                            new_solution[dst_route_idx] = new_route\n                            break\n\n        # Step 3: Capacity-aware 2-opt - local improvement within routes\n        for route in new_solution:\n            if len(route) > 4:  # Only consider routes with enough customers\n                i = random.randint(1, len(route)-3)\n                j = random.randint(i+1, len(route)-2)\n\n                # Check if swapping i and j improves distance and maintains capacity\n                original_cost = (distance_matrix[route[i-1]][route[i]] +\n                               distance_matrix[route[j]][route[j+1]])\n                new_cost = (distance_matrix[route[i-1]][route[j]] +\n                           distance_matrix[route[i]][route[j+1]])\n\n                # Check if the swap maintains capacity for both segments\n                segment1 = route[i:j+1]\n                segment2 = route[j:i-1:-1]  # Reversed segment\n\n                if (new_cost < original_cost and\n                    np.sum(demand[segment1]) <= capacity and\n                    np.sum(demand[segment2]) <= capacity):\n                    # Perform the swap\n                    route[i:j+1] = route[j:i-1:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{A novel hybrid local search operator combines route splitting, demand-based customer reallocation, and adaptive 2-opt with a capacity-aware insertion heuristic to minimize both total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Select solution with highest makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split long routes and reallocate customers\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split route into two parts at a random point\n            split_point = random.randint(1, len(route) - 2)\n            part1 = route[:split_point + 1]\n            part2 = route[split_point:]\n\n            # Check capacity constraint for both parts\n            demand_part1 = np.sum(demand[part1[1:-1]])\n            demand_part2 = np.sum(demand[part2[1:-1]])\n\n            if demand_part1 <= capacity and demand_part2 <= capacity:\n                new_solution[i] = part1\n                new_solution.append(part2)\n                break\n\n    # Adaptive 2-opt for the selected route\n    for route in new_solution:\n        if len(route) > 4:  # Only apply if route has enough nodes\n            # Randomly select two edges to swap\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            new_route = np.concatenate([route[:a], route[b:a-1:-1], route[b+1:]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    # Demand-based reallocation: Move customers between routes if beneficial\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Try moving a random customer from route1 to route2\n            if len(route1) > 3:\n                customer_idx = random.randint(1, len(route1) - 2)\n                customer = route1[customer_idx]\n\n                # Check if moving this customer to route2 is feasible\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion point in route2 (minimizing distance increase)\n                    best_pos = 1\n                    min_increase = float('inf')\n\n                    for pos in range(1, len(route2)):\n                        # Calculate distance increase\n                        prev_node = route2[pos - 1]\n                        next_node = route2[pos]\n                        increase = (distance_matrix[prev_node, customer] +\n                                   distance_matrix[customer, next_node] -\n                                   distance_matrix[prev_node, next_node])\n\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform the move\n                    route1 = np.delete(route1, customer_idx)\n                    route2 = np.insert(route2, best_pos, customer)\n                    new_solution[i] = route1\n                    new_solution[j] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.7957955585595509,
            5.4151391088962555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Select solution with highest makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split long routes and reallocate customers\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split route into two parts at a random point\n            split_point = random.randint(1, len(route) - 2)\n            part1 = route[:split_point + 1]\n            part2 = route[split_point:]\n\n            # Check capacity constraint for both parts\n            demand_part1 = np.sum(demand[part1[1:-1]])\n            demand_part2 = np.sum(demand[part2[1:-1]])\n\n            if demand_part1 <= capacity and demand_part2 <= capacity:\n                new_solution[i] = part1\n                new_solution.append(part2)\n                break\n\n    # Adaptive 2-opt for the selected route\n    for route in new_solution:\n        if len(route) > 4:  # Only apply if route has enough nodes\n            # Randomly select two edges to swap\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            new_route = np.concatenate([route[:a], route[b:a-1:-1], route[b+1:]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    # Demand-based reallocation: Move customers between routes if beneficial\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Try moving a random customer from route1 to route2\n            if len(route1) > 3:\n                customer_idx = random.randint(1, len(route1) - 2)\n                customer = route1[customer_idx]\n\n                # Check if moving this customer to route2 is feasible\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion point in route2 (minimizing distance increase)\n                    best_pos = 1\n                    min_increase = float('inf')\n\n                    for pos in range(1, len(route2)):\n                        # Calculate distance increase\n                        prev_node = route2[pos - 1]\n                        next_node = route2[pos]\n                        increase = (distance_matrix[prev_node, customer] +\n                                   distance_matrix[customer, next_node] -\n                                   distance_matrix[prev_node, next_node])\n\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform the move\n                    route1 = np.delete(route1, customer_idx)\n                    route2 = np.insert(route2, best_pos, customer)\n                    new_solution[i] = route1\n                    new_solution[j] = route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This novel local search strategy combines route splitting and merging with a demand-aware customer reallocation heuristic to balance the trade-off between total distance and makespan, while ensuring feasibility through capacity checks and detour minimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(1/(1 + obj[0])) * (1 + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting + demand-aware reallocation\n    if len(new_solution) > 1:\n        # Select a random route to split\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure route has enough customers to split\n            split_pos = random.randint(2, len(route)-3)\n            route1 = route[:split_pos+1]\n            route2 = route[split_pos:]\n\n            # Reallocate customers between routes to balance demand\n            total_demand_route1 = np.sum(demand[route1[1:-1]])\n            total_demand_route2 = np.sum(demand[route2[1:-1]])\n\n            # If demands are unbalanced, try to reallocate customers\n            if abs(total_demand_route1 - total_demand_route2) > capacity * 0.2:\n                # Find customers that could be moved\n                candidates = route1[1:-1] if total_demand_route1 > total_demand_route2 else route2[1:-1]\n                for customer in candidates:\n                    if demand[customer] <= capacity - total_demand_route2:\n                        # Move customer to the other route\n                        if total_demand_route1 > total_demand_route2:\n                            route1 = np.delete(route1, np.where(route1 == customer))\n                            route2 = np.insert(route2, 1, customer)\n                        else:\n                            route2 = np.delete(route2, np.where(route2 == customer))\n                            route1 = np.insert(route1, 1, customer)\n                        break\n\n            # Update the solution with the new routes\n            new_solution[route_idx] = route1\n            new_solution.append(route2)\n\n            # Verify capacity constraints\n            for route in new_solution:\n                if np.sum(demand[route[1:-1]]) > capacity:\n                    # If infeasible, revert changes\n                    return base_solution\n\n    # Additional improvement: Try to merge routes if possible\n    if len(new_solution) > 2:\n        # Select two random routes to attempt merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Create merged route\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Update solution\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Verify distance doesn't increase too much\n            original_dist = (distance_matrix[route1[-2], 0] +\n                            distance_matrix[route2[0], 0] +\n                            distance_matrix[route2[-2], 0])\n            new_dist = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0]\n\n            if new_dist > original_dist * 1.3:  # If detour too large\n                return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9389441997078487,
            0.6282494962215424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(1/(1 + obj[0])) * (1 + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting + demand-aware reallocation\n    if len(new_solution) > 1:\n        # Select a random route to split\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure route has enough customers to split\n            split_pos = random.randint(2, len(route)-3)\n            route1 = route[:split_pos+1]\n            route2 = route[split_pos:]\n\n            # Reallocate customers between routes to balance demand\n            total_demand_route1 = np.sum(demand[route1[1:-1]])\n            total_demand_route2 = np.sum(demand[route2[1:-1]])\n\n            # If demands are unbalanced, try to reallocate customers\n            if abs(total_demand_route1 - total_demand_route2) > capacity * 0.2:\n                # Find customers that could be moved\n                candidates = route1[1:-1] if total_demand_route1 > total_demand_route2 else route2[1:-1]\n                for customer in candidates:\n                    if demand[customer] <= capacity - total_demand_route2:\n                        # Move customer to the other route\n                        if total_demand_route1 > total_demand_route2:\n                            route1 = np.delete(route1, np.where(route1 == customer))\n                            route2 = np.insert(route2, 1, customer)\n                        else:\n                            route2 = np.delete(route2, np.where(route2 == customer))\n                            route1 = np.insert(route1, 1, customer)\n                        break\n\n            # Update the solution with the new routes\n            new_solution[route_idx] = route1\n            new_solution.append(route2)\n\n            # Verify capacity constraints\n            for route in new_solution:\n                if np.sum(demand[route[1:-1]]) > capacity:\n                    # If infeasible, revert changes\n                    return base_solution\n\n    # Additional improvement: Try to merge routes if possible\n    if len(new_solution) > 2:\n        # Select two random routes to attempt merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Create merged route\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Update solution\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Verify distance doesn't increase too much\n            original_dist = (distance_matrix[route1[-2], 0] +\n                            distance_matrix[route2[0], 0] +\n                            distance_matrix[route2[-2], 0])\n            new_dist = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0]\n\n            if new_dist > original_dist * 1.3:  # If detour too large\n                return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This novel local search strategy combines route splitting and merging with a demand-aware customer reallocation heuristic to balance the trade-off between total distance and makespan, while ensuring feasibility through capacity checks and detour minimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(1/(1 + obj[0])) * (1 + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting + demand-aware reallocation\n    if len(new_solution) > 1:\n        # Select a random route to split\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure route has enough customers to split\n            split_pos = random.randint(2, len(route)-3)\n            route1 = route[:split_pos+1]\n            route2 = route[split_pos:]\n\n            # Reallocate customers between routes to balance demand\n            total_demand_route1 = np.sum(demand[route1[1:-1]])\n            total_demand_route2 = np.sum(demand[route2[1:-1]])\n\n            # If demands are unbalanced, try to reallocate customers\n            if abs(total_demand_route1 - total_demand_route2) > capacity * 0.2:\n                # Find customers that could be moved\n                candidates = route1[1:-1] if total_demand_route1 > total_demand_route2 else route2[1:-1]\n                for customer in candidates:\n                    if demand[customer] <= capacity - total_demand_route2:\n                        # Move customer to the other route\n                        if total_demand_route1 > total_demand_route2:\n                            route1 = np.delete(route1, np.where(route1 == customer))\n                            route2 = np.insert(route2, 1, customer)\n                        else:\n                            route2 = np.delete(route2, np.where(route2 == customer))\n                            route1 = np.insert(route1, 1, customer)\n                        break\n\n            # Update the solution with the new routes\n            new_solution[route_idx] = route1\n            new_solution.append(route2)\n\n            # Verify capacity constraints\n            for route in new_solution:\n                if np.sum(demand[route[1:-1]]) > capacity:\n                    # If infeasible, revert changes\n                    return base_solution\n\n    # Additional improvement: Try to merge routes if possible\n    if len(new_solution) > 2:\n        # Select two random routes to attempt merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Create merged route\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Update solution\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Verify distance doesn't increase too much\n            original_dist = (distance_matrix[route1[-2], 0] +\n                            distance_matrix[route2[0], 0] +\n                            distance_matrix[route2[-2], 0])\n            new_dist = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0]\n\n            if new_dist > original_dist * 1.3:  # If detour too large\n                return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9389441997078487,
            0.6282494962215424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(1/(1 + obj[0])) * (1 + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting + demand-aware reallocation\n    if len(new_solution) > 1:\n        # Select a random route to split\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure route has enough customers to split\n            split_pos = random.randint(2, len(route)-3)\n            route1 = route[:split_pos+1]\n            route2 = route[split_pos:]\n\n            # Reallocate customers between routes to balance demand\n            total_demand_route1 = np.sum(demand[route1[1:-1]])\n            total_demand_route2 = np.sum(demand[route2[1:-1]])\n\n            # If demands are unbalanced, try to reallocate customers\n            if abs(total_demand_route1 - total_demand_route2) > capacity * 0.2:\n                # Find customers that could be moved\n                candidates = route1[1:-1] if total_demand_route1 > total_demand_route2 else route2[1:-1]\n                for customer in candidates:\n                    if demand[customer] <= capacity - total_demand_route2:\n                        # Move customer to the other route\n                        if total_demand_route1 > total_demand_route2:\n                            route1 = np.delete(route1, np.where(route1 == customer))\n                            route2 = np.insert(route2, 1, customer)\n                        else:\n                            route2 = np.delete(route2, np.where(route2 == customer))\n                            route1 = np.insert(route1, 1, customer)\n                        break\n\n            # Update the solution with the new routes\n            new_solution[route_idx] = route1\n            new_solution.append(route2)\n\n            # Verify capacity constraints\n            for route in new_solution:\n                if np.sum(demand[route[1:-1]]) > capacity:\n                    # If infeasible, revert changes\n                    return base_solution\n\n    # Additional improvement: Try to merge routes if possible\n    if len(new_solution) > 2:\n        # Select two random routes to attempt merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Create merged route\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Update solution\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Verify distance doesn't increase too much\n            original_dist = (distance_matrix[route1[-2], 0] +\n                            distance_matrix[route2[0], 0] +\n                            distance_matrix[route2[-2], 0])\n            new_dist = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0]\n\n            if new_dist > original_dist * 1.3:  # If detour too large\n                return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{The algorithm selects a promising solution from the archive, applies a hybrid local search operator that combines route segment swapping with demand-aware route splitting to balance distance and makespan, and ensures feasibility while exploring the solution space more effectively than standard 2-opt.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route segment swapping with demand-aware splitting\n    for _ in range(5):  # Limit iterations for efficiency\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select segments from each route (excluding depot)\n        seg1_start = np.random.randint(1, len(route1) - 1)\n        seg1_end = np.random.randint(seg1_start + 1, len(route1))\n        seg1 = route1[seg1_start:seg1_end]\n\n        seg2_start = np.random.randint(1, len(route2) - 1)\n        seg2_end = np.random.randint(seg2_start + 1, len(route2))\n        seg2 = route2[seg2_start:seg2_end]\n\n        # Check demand feasibility for swapping\n        seg1_demand = sum(demand[seg1])\n        seg2_demand = sum(demand[seg2])\n\n        # Swap only if feasible\n        if (sum(demand[route1]) - seg1_demand + seg2_demand <= capacity and\n            sum(demand[route2]) - seg2_demand + seg1_demand <= capacity):\n\n            # Perform swap\n            new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n            new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n            # Update routes\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Demand-aware route splitting (if any route exceeds capacity)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split route at the point where demand is closest to capacity\n            cumulative_demand = 0\n            split_pos = 1\n            for j in range(1, len(route) - 1):\n                cumulative_demand += demand[route[j]]\n                if cumulative_demand > capacity:\n                    split_pos = j\n                    break\n            if split_pos > 1:\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.7719920150643965,
            1.3853867948055267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route segment swapping with demand-aware splitting\n    for _ in range(5):  # Limit iterations for efficiency\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select segments from each route (excluding depot)\n        seg1_start = np.random.randint(1, len(route1) - 1)\n        seg1_end = np.random.randint(seg1_start + 1, len(route1))\n        seg1 = route1[seg1_start:seg1_end]\n\n        seg2_start = np.random.randint(1, len(route2) - 1)\n        seg2_end = np.random.randint(seg2_start + 1, len(route2))\n        seg2 = route2[seg2_start:seg2_end]\n\n        # Check demand feasibility for swapping\n        seg1_demand = sum(demand[seg1])\n        seg2_demand = sum(demand[seg2])\n\n        # Swap only if feasible\n        if (sum(demand[route1]) - seg1_demand + seg2_demand <= capacity and\n            sum(demand[route2]) - seg2_demand + seg1_demand <= capacity):\n\n            # Perform swap\n            new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n            new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n            # Update routes\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Demand-aware route splitting (if any route exceeds capacity)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split route at the point where demand is closest to capacity\n            cumulative_demand = 0\n            split_pos = 1\n            for j in range(1, len(route) - 1):\n                cumulative_demand += demand[route[j]]\n                if cumulative_demand > capacity:\n                    split_pos = j\n                    break\n            if split_pos > 1:\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and diversity metrics, then applies a novel route-splitting and merging operator that intelligently redistributes customers between routes while preserving feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan and distance, then pick a solution near the Pareto front\n        archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n        selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and merging with demand-based redistribution\n    for _ in range(2):  # Apply operator multiple times\n        # Randomly select a route to split or merge\n        if len(new_solution) > 1 and random.random() < 0.7:\n            # Merge two routes if feasible\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by inserting route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n        else:\n            # Split a route if it's too long\n            if len(new_solution) >= 1:\n                route_idx = random.randint(0, len(new_solution) - 1)\n                route = new_solution[route_idx]\n                if len(route) > 3:  # Ensure route can be split\n                    # Find a split point that balances demand\n                    total_demand = sum(demand[route[1:-1]])\n                    half_demand = total_demand / 2\n                    cumulative_demand = 0\n                    split_pos = 1\n                    for i in range(1, len(route) - 1):\n                        cumulative_demand += demand[route[i]]\n                        if cumulative_demand >= half_demand:\n                            split_pos = i\n                            break\n\n                    # Split the route\n                    route1 = np.concatenate([route[:split_pos + 1], [0]])\n                    route2 = np.concatenate([[0], route[split_pos + 1:]])\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to base solution\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6225137169701555,
            1.2927725911140442
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan and distance, then pick a solution near the Pareto front\n        archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n        selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and merging with demand-based redistribution\n    for _ in range(2):  # Apply operator multiple times\n        # Randomly select a route to split or merge\n        if len(new_solution) > 1 and random.random() < 0.7:\n            # Merge two routes if feasible\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by inserting route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n        else:\n            # Split a route if it's too long\n            if len(new_solution) >= 1:\n                route_idx = random.randint(0, len(new_solution) - 1)\n                route = new_solution[route_idx]\n                if len(route) > 3:  # Ensure route can be split\n                    # Find a split point that balances demand\n                    total_demand = sum(demand[route[1:-1]])\n                    half_demand = total_demand / 2\n                    cumulative_demand = 0\n                    split_pos = 1\n                    for i in range(1, len(route) - 1):\n                        cumulative_demand += demand[route[i]]\n                        if cumulative_demand >= half_demand:\n                            split_pos = i\n                            break\n\n                    # Split the route\n                    route1 = np.concatenate([route[:split_pos + 1], [0]])\n                    route2 = np.concatenate([[0], route[split_pos + 1:]])\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to base solution\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring lower makespan and total distance, then applies a hybrid local search combining route splitting, customer reinsertion with capacity checks, and customer swap operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = 1 - (normalized[:, 0] * 0.4 + normalized[:, 1] * 0.6)  # Prefer lower makespan\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting + customer reinsertion + customer swap\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Route splitting\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n        split_pos = random.randint(1, len(split_route) - 2)\n        new_route1 = split_route[:split_pos + 1]\n        new_route2 = np.concatenate([[0], split_route[split_pos + 1:]])\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[split_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Customer reinsertion\n    if len(new_solution) > 1 and random.random() < 0.5:\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        target_route = new_solution[target_route_idx]\n        if len(target_route) > 3:\n            customer_pos = random.randint(1, len(target_route) - 2)\n            customer = target_route[customer_pos]\n            modified_route = np.concatenate([target_route[:customer_pos], target_route[customer_pos + 1:]])\n\n            if np.sum(demand[modified_route[1:-1]]) <= capacity:\n                new_solution[target_route_idx] = modified_route\n                other_route_idx = random.randint(0, len(new_solution) - 1)\n                other_route = new_solution[other_route_idx]\n                insert_pos = random.randint(1, len(other_route) - 1)\n                new_other_route = np.concatenate([other_route[:insert_pos], [customer], other_route[insert_pos:]])\n\n                if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                    new_solution[other_route_idx] = new_other_route\n\n    # Customer swap between routes\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            cust1_pos = random.randint(1, len(route1) - 2)\n            cust2_pos = random.randint(1, len(route2) - 2)\n            cust1 = route1[cust1_pos]\n            cust2 = route2[cust2_pos]\n\n            new_route1 = np.concatenate([route1[:cust1_pos], [cust2], route1[cust1_pos + 1:]])\n            new_route2 = np.concatenate([route2[:cust2_pos], [cust1], route2[cust2_pos + 1:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5038950735767004,
            0.7321297228336334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = 1 - (normalized[:, 0] * 0.4 + normalized[:, 1] * 0.6)  # Prefer lower makespan\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting + customer reinsertion + customer swap\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Route splitting\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n        split_pos = random.randint(1, len(split_route) - 2)\n        new_route1 = split_route[:split_pos + 1]\n        new_route2 = np.concatenate([[0], split_route[split_pos + 1:]])\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[split_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Customer reinsertion\n    if len(new_solution) > 1 and random.random() < 0.5:\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        target_route = new_solution[target_route_idx]\n        if len(target_route) > 3:\n            customer_pos = random.randint(1, len(target_route) - 2)\n            customer = target_route[customer_pos]\n            modified_route = np.concatenate([target_route[:customer_pos], target_route[customer_pos + 1:]])\n\n            if np.sum(demand[modified_route[1:-1]]) <= capacity:\n                new_solution[target_route_idx] = modified_route\n                other_route_idx = random.randint(0, len(new_solution) - 1)\n                other_route = new_solution[other_route_idx]\n                insert_pos = random.randint(1, len(other_route) - 1)\n                new_other_route = np.concatenate([other_route[:insert_pos], [customer], other_route[insert_pos:]])\n\n                if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                    new_solution[other_route_idx] = new_other_route\n\n    # Customer swap between routes\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            cust1_pos = random.randint(1, len(route1) - 2)\n            cust2_pos = random.randint(1, len(route2) - 2)\n            cust1 = route1[cust1_pos]\n            cust2 = route2[cust2_pos]\n\n            new_route1 = np.concatenate([route1[:cust1_pos], [cust2], route1[cust1_pos + 1:]])\n            new_route2 = np.concatenate([route2[:cust2_pos], [cust1], route2[cust2_pos + 1:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route splitting and partial route reversal\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point]\n        part2 = route[split_point:]\n\n        # Reverse the second part to create a new route\n        new_route = np.concatenate([part1, part2[::-1]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution.append(new_route)\n        else:\n            new_solution.append(route)  # Revert if infeasible\n\n    # Attempt to merge routes if possible\n    if len(new_solution) > 1:\n        i = np.random.randint(0, len(new_solution))\n        j = np.random.randint(0, len(new_solution))\n        if i != j:\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Try to merge by removing overlapping nodes\n            common_nodes = np.intersect1d(route_i[1:-1], route_j[1:-1])\n            if len(common_nodes) > 0:\n                # Remove common nodes from both routes\n                mask_i = ~np.isin(route_i, common_nodes)\n                mask_j = ~np.isin(route_j, common_nodes)\n                merged_route = np.concatenate([route_i[mask_i][:-1], route_j[mask_j][1:]])\n\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution = [merged_route if k == i else r for k, r in enumerate(new_solution) if k != j]\n\n    return new_solution\n\n",
        "score": [
            -0.8264119146132007,
            1.3259813487529755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route splitting and partial route reversal\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point]\n        part2 = route[split_point:]\n\n        # Reverse the second part to create a new route\n        new_route = np.concatenate([part1, part2[::-1]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution.append(new_route)\n        else:\n            new_solution.append(route)  # Revert if infeasible\n\n    # Attempt to merge routes if possible\n    if len(new_solution) > 1:\n        i = np.random.randint(0, len(new_solution))\n        j = np.random.randint(0, len(new_solution))\n        if i != j:\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Try to merge by removing overlapping nodes\n            common_nodes = np.intersect1d(route_i[1:-1], route_j[1:-1])\n            if len(common_nodes) > 0:\n                # Remove common nodes from both routes\n                mask_i = ~np.isin(route_i, common_nodes)\n                mask_j = ~np.isin(route_j, common_nodes)\n                merged_route = np.concatenate([route_i[mask_i][:-1], route_j[mask_j][1:]])\n\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution = [merged_route if k == i else r for k, r in enumerate(new_solution) if k != j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random choice favoring solutions with lower total distance and makespan, then applies a hybrid local search combining route-splitting, node reinsertion with demand-aware positioning, and a novel \"demand-balanced\" 2-opt variant to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for (_, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting with demand balancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough nodes to split\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Demand-aware node reinsertion\n    for _ in range(2):  # Number of reinsertion attempts\n        # Select a random route and a random node to move\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        node_pos = random.randint(1, len(route)-2)\n        node = route[node_pos]\n\n        # Remove node from current route\n        new_route = np.concatenate([route[:node_pos], route[node_pos+1:]])\n        if not is_feasible(new_route):\n            continue\n\n        # Find best insertion position in another route\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n            candidate_route = new_solution[i]\n            for pos in range(1, len(candidate_route)):\n                # Insert node at position pos\n                temp_route = np.insert(candidate_route, pos, node)\n                if is_feasible(temp_route):\n                    # Calculate insertion cost (distance increase)\n                    prev_node = temp_route[pos-1]\n                    next_node = temp_route[pos+1]\n                    cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node] - distance_matrix[prev_node, next_node]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = (i, pos)\n\n        if best_pos != -1:\n            i, pos = best_pos\n            new_solution[route_idx] = new_route\n            new_solution[i] = np.insert(new_solution[i], pos, node)\n\n    # Step 3: Demand-balanced 2-opt\n    for _ in range(3):  # Number of 2-opt attempts\n        # Select two different routes\n        if len(new_solution) < 2:\n            break\n\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 3 or len(route2) <= 3:\n            continue\n\n        # Select two edges to swap (excluding depot connections)\n        edge1_pos = random.randint(1, len(route1)-2)\n        edge2_pos = random.randint(1, len(route2)-2)\n\n        # Create new routes by swapping segments\n        new_route1 = np.concatenate([route1[:edge1_pos], route2[edge2_pos:]])\n        new_route2 = np.concatenate([route2[:edge2_pos], route1[edge1_pos:]])\n\n        # Check feasibility and demand balance\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            # Additional check for balanced demand\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n            if abs(demand1 - demand2) / capacity < 0.3:  # Allow some imbalance\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.6851466482775384,
            11.10556909441948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for (_, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting with demand balancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough nodes to split\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Demand-aware node reinsertion\n    for _ in range(2):  # Number of reinsertion attempts\n        # Select a random route and a random node to move\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        node_pos = random.randint(1, len(route)-2)\n        node = route[node_pos]\n\n        # Remove node from current route\n        new_route = np.concatenate([route[:node_pos], route[node_pos+1:]])\n        if not is_feasible(new_route):\n            continue\n\n        # Find best insertion position in another route\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n            candidate_route = new_solution[i]\n            for pos in range(1, len(candidate_route)):\n                # Insert node at position pos\n                temp_route = np.insert(candidate_route, pos, node)\n                if is_feasible(temp_route):\n                    # Calculate insertion cost (distance increase)\n                    prev_node = temp_route[pos-1]\n                    next_node = temp_route[pos+1]\n                    cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node] - distance_matrix[prev_node, next_node]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = (i, pos)\n\n        if best_pos != -1:\n            i, pos = best_pos\n            new_solution[route_idx] = new_route\n            new_solution[i] = np.insert(new_solution[i], pos, node)\n\n    # Step 3: Demand-balanced 2-opt\n    for _ in range(3):  # Number of 2-opt attempts\n        # Select two different routes\n        if len(new_solution) < 2:\n            break\n\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 3 or len(route2) <= 3:\n            continue\n\n        # Select two edges to swap (excluding depot connections)\n        edge1_pos = random.randint(1, len(route1)-2)\n        edge2_pos = random.randint(1, len(route2)-2)\n\n        # Create new routes by swapping segments\n        new_route1 = np.concatenate([route1[:edge1_pos], route2[edge2_pos:]])\n        new_route2 = np.concatenate([route2[:edge2_pos], route1[edge1_pos:]])\n\n        # Check feasibility and demand balance\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            # Additional check for balanced demand\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n            if abs(demand1 - demand2) / capacity < 0.3:  # Allow some imbalance\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a combined objective score, then applies a hybrid local search strategy combining route swapping and segment relocation with capacity-aware checks to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select two distinct routes for hybrid local search\n    if len(new_solution) >= 2:\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Hybrid local search: segment relocation with capacity check\n        if len(route1) > 3 and len(route2) > 3:\n            # Randomly select a segment from route1 (excluding depot)\n            start_idx = random.randint(1, len(route1) - 3)\n            end_idx = random.randint(start_idx + 1, len(route1) - 2)\n            segment = route1[start_idx:end_idx]\n\n            # Check if segment can be moved to route2 without violating capacity\n            segment_demand = sum(demand[node] for node in segment)\n            if sum(demand[node] for node in route2) + segment_demand <= capacity:\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Remove segment from route1\n                route1 = np.concatenate([route1[:start_idx], route1[end_idx:]])\n\n                # Update the solution\n                new_solution[route_indices[0]] = route1\n                new_solution[route_indices[1]] = route2\n\n    # If the solution is empty (edge case), return the original\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5892074740135272,
            1.2421088516712189
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select two distinct routes for hybrid local search\n    if len(new_solution) >= 2:\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Hybrid local search: segment relocation with capacity check\n        if len(route1) > 3 and len(route2) > 3:\n            # Randomly select a segment from route1 (excluding depot)\n            start_idx = random.randint(1, len(route1) - 3)\n            end_idx = random.randint(start_idx + 1, len(route1) - 2)\n            segment = route1[start_idx:end_idx]\n\n            # Check if segment can be moved to route2 without violating capacity\n            segment_demand = sum(demand[node] for node in segment)\n            if sum(demand[node] for node in route2) + segment_demand <= capacity:\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Remove segment from route1\n                route1 = np.concatenate([route1[:start_idx], route1[end_idx:]])\n\n                # Update the solution\n                new_solution[route_indices[0]] = route1\n                new_solution[route_indices[1]] = route2\n\n    # If the solution is empty (edge case), return the original\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{A novel hybrid local search operator that combines adaptive route segmentation, cross-route insertion with demand-aware feasibility checks, and iterative route balancing to simultaneously optimize total distance and makespan while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])  # Prefer solutions with lower makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Adaptive route segmentation + cross-route insertion\n    if len(new_solution) > 1:\n        # Step 1: Adaptive route segmentation (split long routes)\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Only split if route has enough nodes\n            split_pos = len(longest_route) // 2\n            new_route1 = longest_route[:split_pos + 1].copy()\n            new_route2 = np.concatenate([[0], longest_route[split_pos + 1:]]).copy()\n\n            # Check capacity feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 2: Cross-route insertion with demand-aware feasibility\n    for _ in range(2):  # Perform multiple insertion attempts\n        # Select a random customer from a non-depot route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        if len(new_solution[route_idx]) <= 3:  # Skip if route too short\n            continue\n\n        customer_pos = random.randint(1, len(new_solution[route_idx]) - 2)\n        customer = new_solution[route_idx][customer_pos]\n\n        # Try inserting into another route\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n        if len(target_route) <= 2:  # Skip if target route is empty\n            continue\n\n        # Find insertion position with minimal distance increase\n        min_increase = float('inf')\n        best_pos = -1\n        for pos in range(1, len(target_route)):\n            # Calculate distance increase\n            prev_node = target_route[pos - 1]\n            next_node = target_route[pos]\n            old_dist = distance_matrix[prev_node, next_node]\n            new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n\n            # Check capacity feasibility\n            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                if new_dist - old_dist < min_increase:\n                    min_increase = new_dist - old_dist\n                    best_pos = pos\n\n        if best_pos != -1:\n            # Perform insertion\n            new_route = np.insert(target_route, best_pos, customer)\n            new_solution[target_route_idx] = new_route\n            # Remove from original route\n            new_solution[route_idx] = np.delete(new_solution[route_idx], customer_pos)\n\n    # Step 3: Iterative route balancing (reduce makespan)\n    if len(new_solution) > 1:\n        # Find the route with the longest distance\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n\n        # Try to move a customer from longest to shortest route\n        shortest_route_idx = np.argmin(route_lengths)\n        if longest_route_idx != shortest_route_idx:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n\n            if len(longest_route) > 3:  # Only if longest route has enough nodes\n                # Find customer with minimal distance impact\n                min_move_cost = float('inf')\n                best_customer = -1\n                best_pos = -1\n\n                for customer_pos in range(1, len(longest_route) - 1):\n                    customer = longest_route[customer_pos]\n                    # Check if moving this customer doesn't violate capacity\n                    if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in shortest route\n                        for pos in range(1, len(shortest_route)):\n                            prev_node = shortest_route[pos - 1]\n                            next_node = shortest_route[pos]\n                            old_dist = distance_matrix[prev_node, next_node]\n                            new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n                            move_cost = new_dist - old_dist\n\n                            if move_cost < min_move_cost:\n                                min_move_cost = move_cost\n                                best_customer = customer\n                                best_pos = pos\n\n                if best_customer != -1:\n                    # Perform the move\n                    new_shortest = np.insert(shortest_route, best_pos, best_customer)\n                    new_longest = np.delete(longest_route, np.where(longest_route == best_customer)[0][0])\n\n                    new_solution[shortest_route_idx] = new_shortest\n                    new_solution[longest_route_idx] = new_longest\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.869017267891751,
            1.843377023935318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])  # Prefer solutions with lower makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Adaptive route segmentation + cross-route insertion\n    if len(new_solution) > 1:\n        # Step 1: Adaptive route segmentation (split long routes)\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Only split if route has enough nodes\n            split_pos = len(longest_route) // 2\n            new_route1 = longest_route[:split_pos + 1].copy()\n            new_route2 = np.concatenate([[0], longest_route[split_pos + 1:]]).copy()\n\n            # Check capacity feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 2: Cross-route insertion with demand-aware feasibility\n    for _ in range(2):  # Perform multiple insertion attempts\n        # Select a random customer from a non-depot route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        if len(new_solution[route_idx]) <= 3:  # Skip if route too short\n            continue\n\n        customer_pos = random.randint(1, len(new_solution[route_idx]) - 2)\n        customer = new_solution[route_idx][customer_pos]\n\n        # Try inserting into another route\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n        if len(target_route) <= 2:  # Skip if target route is empty\n            continue\n\n        # Find insertion position with minimal distance increase\n        min_increase = float('inf')\n        best_pos = -1\n        for pos in range(1, len(target_route)):\n            # Calculate distance increase\n            prev_node = target_route[pos - 1]\n            next_node = target_route[pos]\n            old_dist = distance_matrix[prev_node, next_node]\n            new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n\n            # Check capacity feasibility\n            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                if new_dist - old_dist < min_increase:\n                    min_increase = new_dist - old_dist\n                    best_pos = pos\n\n        if best_pos != -1:\n            # Perform insertion\n            new_route = np.insert(target_route, best_pos, customer)\n            new_solution[target_route_idx] = new_route\n            # Remove from original route\n            new_solution[route_idx] = np.delete(new_solution[route_idx], customer_pos)\n\n    # Step 3: Iterative route balancing (reduce makespan)\n    if len(new_solution) > 1:\n        # Find the route with the longest distance\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n\n        # Try to move a customer from longest to shortest route\n        shortest_route_idx = np.argmin(route_lengths)\n        if longest_route_idx != shortest_route_idx:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n\n            if len(longest_route) > 3:  # Only if longest route has enough nodes\n                # Find customer with minimal distance impact\n                min_move_cost = float('inf')\n                best_customer = -1\n                best_pos = -1\n\n                for customer_pos in range(1, len(longest_route) - 1):\n                    customer = longest_route[customer_pos]\n                    # Check if moving this customer doesn't violate capacity\n                    if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in shortest route\n                        for pos in range(1, len(shortest_route)):\n                            prev_node = shortest_route[pos - 1]\n                            next_node = shortest_route[pos]\n                            old_dist = distance_matrix[prev_node, next_node]\n                            new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n                            move_cost = new_dist - old_dist\n\n                            if move_cost < min_move_cost:\n                                min_move_cost = move_cost\n                                best_customer = customer\n                                best_pos = pos\n\n                if best_customer != -1:\n                    # Perform the move\n                    new_shortest = np.insert(shortest_route, best_pos, best_customer)\n                    new_longest = np.delete(longest_route, np.where(longest_route == best_customer)[0][0])\n\n                    new_solution[shortest_route_idx] = new_shortest\n                    new_solution[longest_route_idx] = new_longest\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: first merge two shortest routes, then perturb the longest route\n    if len(base_solution) > 1:\n        # Merge two shortest routes\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in base_solution]\n        shortest_route_idx = np.argmin(route_lengths)\n        second_shortest_route_idx = np.argpartition(route_lengths, 1)[1]\n\n        route1 = base_solution[shortest_route_idx][1:-1]  # Exclude depots\n        route2 = base_solution[second_shortest_route_idx][1:-1]\n\n        # Try to merge route1 into route2\n        merged_route = []\n        current_capacity = 0\n        for node in route2:\n            if current_capacity + demand[node] <= capacity:\n                merged_route.append(node)\n                current_capacity += demand[node]\n\n        # Add remaining nodes from route1\n        for node in route1:\n            if current_capacity + demand[node] <= capacity:\n                merged_route.append(node)\n                current_capacity += demand[node]\n\n        # Create new route with depot\n        new_route = [0] + merged_route + [0]\n\n        # Replace the two routes with the merged one\n        new_solution = base_solution.copy()\n        new_solution.pop(second_shortest_route_idx)\n        new_solution.pop(shortest_route_idx - (1 if shortest_route_idx > second_shortest_route_idx else 0))\n        new_solution.append(np.array(new_route))\n\n        # Perturb the longest route\n        if len(new_solution) > 1:\n            longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n            longest_route = new_solution[longest_route_idx][1:-1]\n\n            # Randomly split and reorder a segment\n            if len(longest_route) > 2:\n                split_pos = np.random.randint(1, len(longest_route)-1)\n                segment = longest_route[split_pos:]\n                np.random.shuffle(segment)\n                longest_route = np.concatenate([longest_route[:split_pos], segment])\n\n                # Rebuild the route with capacity check\n                temp_route = [0]\n                current_capacity = 0\n                for node in longest_route:\n                    if current_capacity + demand[node] <= capacity:\n                        temp_route.append(node)\n                        current_capacity += demand[node]\n                temp_route.append(0)\n\n                new_solution[longest_route_idx] = np.array(temp_route)\n\n        return new_solution\n\n    # If only one route, apply intra-route perturbation\n    route = base_solution[0][1:-1]\n    if len(route) > 2:\n        # Randomly select two non-depot nodes and swap\n        i, j = np.random.choice(len(route), 2, replace=False)\n        route[i], route[j] = route[j], route[i]\n\n        # Rebuild the route with capacity check\n        new_route = [0]\n        current_capacity = 0\n        for node in route:\n            if current_capacity + demand[node] <= capacity:\n                new_route.append(node)\n                current_capacity += demand[node]\n        new_route.append(0)\n\n        return [np.array(new_route)]\n\n    return base_solution\n\n",
        "score": [
            -0.7514277837511043,
            0.8526171445846558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: first merge two shortest routes, then perturb the longest route\n    if len(base_solution) > 1:\n        # Merge two shortest routes\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in base_solution]\n        shortest_route_idx = np.argmin(route_lengths)\n        second_shortest_route_idx = np.argpartition(route_lengths, 1)[1]\n\n        route1 = base_solution[shortest_route_idx][1:-1]  # Exclude depots\n        route2 = base_solution[second_shortest_route_idx][1:-1]\n\n        # Try to merge route1 into route2\n        merged_route = []\n        current_capacity = 0\n        for node in route2:\n            if current_capacity + demand[node] <= capacity:\n                merged_route.append(node)\n                current_capacity += demand[node]\n\n        # Add remaining nodes from route1\n        for node in route1:\n            if current_capacity + demand[node] <= capacity:\n                merged_route.append(node)\n                current_capacity += demand[node]\n\n        # Create new route with depot\n        new_route = [0] + merged_route + [0]\n\n        # Replace the two routes with the merged one\n        new_solution = base_solution.copy()\n        new_solution.pop(second_shortest_route_idx)\n        new_solution.pop(shortest_route_idx - (1 if shortest_route_idx > second_shortest_route_idx else 0))\n        new_solution.append(np.array(new_route))\n\n        # Perturb the longest route\n        if len(new_solution) > 1:\n            longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n            longest_route = new_solution[longest_route_idx][1:-1]\n\n            # Randomly split and reorder a segment\n            if len(longest_route) > 2:\n                split_pos = np.random.randint(1, len(longest_route)-1)\n                segment = longest_route[split_pos:]\n                np.random.shuffle(segment)\n                longest_route = np.concatenate([longest_route[:split_pos], segment])\n\n                # Rebuild the route with capacity check\n                temp_route = [0]\n                current_capacity = 0\n                for node in longest_route:\n                    if current_capacity + demand[node] <= capacity:\n                        temp_route.append(node)\n                        current_capacity += demand[node]\n                temp_route.append(0)\n\n                new_solution[longest_route_idx] = np.array(temp_route)\n\n        return new_solution\n\n    # If only one route, apply intra-route perturbation\n    route = base_solution[0][1:-1]\n    if len(route) > 2:\n        # Randomly select two non-depot nodes and swap\n        i, j = np.random.choice(len(route), 2, replace=False)\n        route[i], route[j] = route[j], route[i]\n\n        # Rebuild the route with capacity check\n        new_route = [0]\n        current_capacity = 0\n        for node in route:\n            if current_capacity + demand[node] <= capacity:\n                new_route.append(node)\n                current_capacity += demand[node]\n        new_route.append(0)\n\n        return [np.array(new_route)]\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])  # Prioritize solutions with higher makespan relative to distance\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and inter-route relocation with capacity checks\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Randomly select a segment to split or relocate\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment = route[split_pos:-1]\n\n        # Check if splitting the segment into a new route is feasible\n        if np.sum(demand[segment]) <= capacity:\n            # Create a new route with the segment\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n            # Remove the segment from the original route\n            new_solution[route_idx] = np.concatenate([route[:split_pos], [0]])\n\n    # Inter-route relocation: move a customer from one route to another if feasible\n    for _ in range(2):  # Limit the number of relocations to avoid excessive computation\n        route1_idx = np.random.randint(0, len(new_solution))\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 3:\n            continue\n\n        customer_pos = np.random.randint(1, len(route1) - 1)\n        customer = route1[customer_pos]\n\n        # Try to insert into another route\n        for route2_idx in range(len(new_solution)):\n            if route1_idx == route2_idx:\n                continue\n            route2 = new_solution[route2_idx]\n\n            # Find the best insertion position in route2\n            best_pos = -1\n            min_increase = float('inf')\n            for pos in range(1, len(route2)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate([route2[:pos], [customer], route2[pos:]])]) <= capacity:\n                    # Calculate the increase in distance\n                    dist_increase = (distance_matrix[route2[pos-1], customer] +\n                                    distance_matrix[customer, route2[pos]] -\n                                    distance_matrix[route2[pos-1], route2[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n            if best_pos != -1:\n                # Perform the relocation\n                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                new_solution[route2_idx] = new_route2\n                new_solution[route1_idx] = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6737022708880364,
            9.21191081404686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])  # Prioritize solutions with higher makespan relative to distance\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and inter-route relocation with capacity checks\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Randomly select a segment to split or relocate\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment = route[split_pos:-1]\n\n        # Check if splitting the segment into a new route is feasible\n        if np.sum(demand[segment]) <= capacity:\n            # Create a new route with the segment\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n            # Remove the segment from the original route\n            new_solution[route_idx] = np.concatenate([route[:split_pos], [0]])\n\n    # Inter-route relocation: move a customer from one route to another if feasible\n    for _ in range(2):  # Limit the number of relocations to avoid excessive computation\n        route1_idx = np.random.randint(0, len(new_solution))\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 3:\n            continue\n\n        customer_pos = np.random.randint(1, len(route1) - 1)\n        customer = route1[customer_pos]\n\n        # Try to insert into another route\n        for route2_idx in range(len(new_solution)):\n            if route1_idx == route2_idx:\n                continue\n            route2 = new_solution[route2_idx]\n\n            # Find the best insertion position in route2\n            best_pos = -1\n            min_increase = float('inf')\n            for pos in range(1, len(route2)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate([route2[:pos], [customer], route2[pos:]])]) <= capacity:\n                    # Calculate the increase in distance\n                    dist_increase = (distance_matrix[route2[pos-1], customer] +\n                                    distance_matrix[customer, route2[pos]] -\n                                    distance_matrix[route2[pos-1], route2[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n            if best_pos != -1:\n                # Perform the relocation\n                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                new_solution[route2_idx] = new_route2\n                new_solution[route1_idx] = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route merging, route splitting, and cross-route relocations to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route merging, splitting, and cross-route relocation\n    def is_feasible(route, demand):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Attempt to merge two routes if their combined load is feasible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n        if is_feasible(merged_route, demand):\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Step 2: Split a long route into two if it's too long\n    for route in new_solution:\n        if len(route) > 5:  # Arbitrary threshold for \"long\"\n            split_pos = random.randint(2, len(route) - 3)\n            part1 = route[:split_pos + 1]\n            part2 = np.concatenate(([0], route[split_pos:-1]))\n            if is_feasible(part1, demand) and is_feasible(part2, demand):\n                new_solution.remove(route)\n                new_solution.append(part1)\n                new_solution.append(part2)\n                break\n\n    # Step 3: Cross-route relocation to improve makespan\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i].copy()\n        route_j = new_solution[j].copy()\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Relocate a segment from route_i to route_j\n            start, end = sorted(random.sample(range(1, len(route_i) - 1), 2))\n            segment = route_i[start:end + 1]\n            if is_feasible(np.concatenate((route_j[:-1], segment, [0])), demand):\n                new_route_j = np.concatenate((route_j[:-1], segment, [0]))\n                new_route_i = np.concatenate((route_i[:start], route_i[end + 1:]))\n                if is_feasible(new_route_i, demand):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    return new_solution\n\n",
        "score": [
            -0.8777442698817767,
            0.3803020417690277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route merging, splitting, and cross-route relocation\n    def is_feasible(route, demand):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Attempt to merge two routes if their combined load is feasible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n        if is_feasible(merged_route, demand):\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Step 2: Split a long route into two if it's too long\n    for route in new_solution:\n        if len(route) > 5:  # Arbitrary threshold for \"long\"\n            split_pos = random.randint(2, len(route) - 3)\n            part1 = route[:split_pos + 1]\n            part2 = np.concatenate(([0], route[split_pos:-1]))\n            if is_feasible(part1, demand) and is_feasible(part2, demand):\n                new_solution.remove(route)\n                new_solution.append(part1)\n                new_solution.append(part2)\n                break\n\n    # Step 3: Cross-route relocation to improve makespan\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i].copy()\n        route_j = new_solution[j].copy()\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Relocate a segment from route_i to route_j\n            start, end = sorted(random.sample(range(1, len(route_i) - 1), 2))\n            segment = route_i[start:end + 1]\n            if is_feasible(np.concatenate((route_j[:-1], segment, [0])), demand):\n                new_route_j = np.concatenate((route_j[:-1], segment, [0]))\n                new_route_i = np.concatenate((route_i[:start], route_i[end + 1:]))\n                if is_feasible(new_route_i, demand):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This function selects a promising solution from the archive, applies a hybrid local search operator combining route splitting and customer reallocation based on demand and distance, and returns a feasible neighbor solution while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Split a long route and reallocate customers to other routes\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route (excluding depot)\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two parts\n    split_point = len(longest_route) // 2\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Check capacity constraints for the split parts\n    if np.sum(demand[part1]) > capacity or np.sum(demand[part2]) > capacity:\n        # If split violates capacity, try reallocating customers to other routes\n        for customer in longest_route[1:-1]:\n            # Find the best route to insert the customer (minimize distance increase)\n            best_route_idx = -1\n            min_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n                for pos in range(1, len(route)):\n                    # Calculate distance increase for inserting customer at position pos\n                    increase = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if increase < min_increase and np.sum(demand[route]) + demand[customer] <= capacity:\n                        min_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                # Insert customer into the best route\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n                # Remove customer from the original route\n                longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n\n        # Update the longest route after reallocation\n        new_solution[longest_route_idx] = longest_route\n\n    else:\n        # If split is feasible, update the solution\n        new_solution[longest_route_idx] = part1\n        new_solution.insert(longest_route_idx + 1, part2)\n\n    # Ensure all routes start and end at the depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    return new_solution\n\n",
        "score": [
            -0.6951346965888234,
            0.7975358963012695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Split a long route and reallocate customers to other routes\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route (excluding depot)\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two parts\n    split_point = len(longest_route) // 2\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Check capacity constraints for the split parts\n    if np.sum(demand[part1]) > capacity or np.sum(demand[part2]) > capacity:\n        # If split violates capacity, try reallocating customers to other routes\n        for customer in longest_route[1:-1]:\n            # Find the best route to insert the customer (minimize distance increase)\n            best_route_idx = -1\n            min_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n                for pos in range(1, len(route)):\n                    # Calculate distance increase for inserting customer at position pos\n                    increase = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if increase < min_increase and np.sum(demand[route]) + demand[customer] <= capacity:\n                        min_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                # Insert customer into the best route\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n                # Remove customer from the original route\n                longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n\n        # Update the longest route after reallocation\n        new_solution[longest_route_idx] = longest_route\n\n    else:\n        # If split is feasible, update the solution\n        new_solution[longest_route_idx] = part1\n        new_solution.insert(longest_route_idx + 1, part2)\n\n    # Ensure all routes start and end at the depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by considering both objective values and route diversity, then applies a hybrid local search combining route swaps and demand-aware insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine route swaps and demand-aware insertions\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route swap between two routes (if possible)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find a feasible swap between routes\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                # Check capacity feasibility\n                if (sum(demand[route1[1:i]]) + sum(demand[route2[j:len(route2)-1]]) <= capacity and\n                    sum(demand[route2[1:j]]) + sum(demand[route1[i:len(route1)-1]]) <= capacity):\n                    # Perform the swap\n                    new_route1 = np.concatenate([route1[:i], route2[j:len(route2)-1], route1[i:]])\n                    new_route2 = np.concatenate([route2[:j], route1[i:len(route1)-1], route2[j:]])\n\n                    # Update solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    # Step 2: Demand-aware insertion (move a customer to a different route if beneficial)\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(route)-2)\n            customer = route[customer_idx]\n            customer_demand = demand[customer]\n\n            # Try to insert into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n                    # Find feasible insertion positions\n                    for pos in range(1, len(other_route)):\n                        if sum(demand[other_route[1:pos]]) + customer_demand <= capacity:\n                            # Perform insertion\n                            new_route = np.concatenate([other_route[:pos], [customer], other_route[pos:]])\n                            new_solution[other_route_idx] = new_route\n                            # Remove from original route\n                            new_solution[route_idx] = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.7940666132614417,
            4.526169061660767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine route swaps and demand-aware insertions\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route swap between two routes (if possible)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find a feasible swap between routes\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                # Check capacity feasibility\n                if (sum(demand[route1[1:i]]) + sum(demand[route2[j:len(route2)-1]]) <= capacity and\n                    sum(demand[route2[1:j]]) + sum(demand[route1[i:len(route1)-1]]) <= capacity):\n                    # Perform the swap\n                    new_route1 = np.concatenate([route1[:i], route2[j:len(route2)-1], route1[i:]])\n                    new_route2 = np.concatenate([route2[:j], route1[i:len(route1)-1], route2[j:]])\n\n                    # Update solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    # Step 2: Demand-aware insertion (move a customer to a different route if beneficial)\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(route)-2)\n            customer = route[customer_idx]\n            customer_demand = demand[customer]\n\n            # Try to insert into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n                    # Find feasible insertion positions\n                    for pos in range(1, len(other_route)):\n                        if sum(demand[other_route[1:pos]]) + customer_demand <= capacity:\n                            # Perform insertion\n                            new_route = np.concatenate([other_route[:pos], [customer], other_route[pos:]])\n                            new_solution[other_route_idx] = new_route\n                            # Remove from original route\n                            new_solution[route_idx] = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan descending\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Split the longest route into two\n        split_pos = len(route) // 2\n        route1 = route[:split_pos + 1]\n        route2 = route[split_pos:]\n        route2[0] = 0  # Ensure route2 starts at depot\n\n        # Check capacity constraints\n        if (np.sum(demand[route1[1:-1]]) <= capacity and\n            np.sum(demand[route2[1:-1]]) <= capacity):\n            new_solution[i] = route1\n            new_solution.insert(i + 1, route2)\n            break\n\n        # Step 2: If splitting fails, try reallocating customers to other routes\n        for customer in route[1:-1]:\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                candidate_route = new_solution[j].copy()\n                candidate_route.insert(-1, customer)\n                if np.sum(demand[candidate_route[1:-1]]) <= capacity:\n                    new_solution[j] = candidate_route\n                    new_solution[i] = np.delete(route, np.where(route == customer)[0])\n                    break\n\n        # Step 3: Merge routes if possible to reduce makespan\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7746401016695521,
            0.28982630372047424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan descending\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Split the longest route into two\n        split_pos = len(route) // 2\n        route1 = route[:split_pos + 1]\n        route2 = route[split_pos:]\n        route2[0] = 0  # Ensure route2 starts at depot\n\n        # Check capacity constraints\n        if (np.sum(demand[route1[1:-1]]) <= capacity and\n            np.sum(demand[route2[1:-1]]) <= capacity):\n            new_solution[i] = route1\n            new_solution.insert(i + 1, route2)\n            break\n\n        # Step 2: If splitting fails, try reallocating customers to other routes\n        for customer in route[1:-1]:\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                candidate_route = new_solution[j].copy()\n                candidate_route.insert(-1, customer)\n                if np.sum(demand[candidate_route[1:-1]]) <= capacity:\n                    new_solution[j] = candidate_route\n                    new_solution[i] = np.delete(route, np.where(route == customer)[0])\n                    break\n\n        # Step 3: Merge routes if possible to reduce makespan\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A novel hybrid local search operator combines route segmentation, inter-route customer swaps, and adaptive capacity-aware route merging to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: adaptive route segmentation + inter-route swaps + capacity-aware merging\n    if len(new_solution) > 1:\n        # Step 1: Adaptive route segmentation (split long routes)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only segment if route is long enough\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = route[:split_pos + 1]\n                new_route2 = [0] + route[split_pos + 1:]\n\n                # Check capacity feasibility\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Inter-route customer swaps (focus on high-demand customers)\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution) - 1)\n            route2_idx = random.randint(0, len(new_solution) - 1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                # Find high-demand customers in each route\n                customers1 = route1[1:-1]\n                customers2 = route2[1:-1]\n                if len(customers1) > 0 and len(customers2) > 0:\n                    # Select a high-demand customer from each route\n                    high_demand1 = max(customers1, key=lambda x: demand[x])\n                    high_demand2 = max(customers2, key=lambda x: demand[x])\n\n                    # Swap them if capacity allows\n                    new_route1 = route1.copy()\n                    new_route2 = route2.copy()\n\n                    # Remove and insert\n                    new_route1 = np.delete(new_route1, np.where(new_route1 == high_demand1)[0])\n                    new_route2 = np.delete(new_route2, np.where(new_route2 == high_demand2)[0])\n\n                    # Insert in opposite positions to maintain order\n                    insert_pos1 = random.randint(1, len(new_route1) - 1)\n                    insert_pos2 = random.randint(1, len(new_route2) - 1)\n\n                    new_route1 = np.insert(new_route1, insert_pos1, high_demand2)\n                    new_route2 = np.insert(new_route2, insert_pos2, high_demand1)\n\n                    # Check capacity feasibility\n                    if (sum(demand[new_route1[1:-1]]) <= capacity and\n                        sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n        # Step 3: Capacity-aware route merging (merge short routes)\n        if len(new_solution) > 1:\n            for i in range(len(new_solution) - 1):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n\n                    # Check if merging is feasible\n                    merged_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                    if merged_demand <= capacity:\n                        # Create merged route\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                        # Update solution\n                        new_solution[i] = merged_route\n                        del new_solution[j]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7550246415579951,
            1.8985233008861542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: adaptive route segmentation + inter-route swaps + capacity-aware merging\n    if len(new_solution) > 1:\n        # Step 1: Adaptive route segmentation (split long routes)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only segment if route is long enough\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = route[:split_pos + 1]\n                new_route2 = [0] + route[split_pos + 1:]\n\n                # Check capacity feasibility\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Inter-route customer swaps (focus on high-demand customers)\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution) - 1)\n            route2_idx = random.randint(0, len(new_solution) - 1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                # Find high-demand customers in each route\n                customers1 = route1[1:-1]\n                customers2 = route2[1:-1]\n                if len(customers1) > 0 and len(customers2) > 0:\n                    # Select a high-demand customer from each route\n                    high_demand1 = max(customers1, key=lambda x: demand[x])\n                    high_demand2 = max(customers2, key=lambda x: demand[x])\n\n                    # Swap them if capacity allows\n                    new_route1 = route1.copy()\n                    new_route2 = route2.copy()\n\n                    # Remove and insert\n                    new_route1 = np.delete(new_route1, np.where(new_route1 == high_demand1)[0])\n                    new_route2 = np.delete(new_route2, np.where(new_route2 == high_demand2)[0])\n\n                    # Insert in opposite positions to maintain order\n                    insert_pos1 = random.randint(1, len(new_route1) - 1)\n                    insert_pos2 = random.randint(1, len(new_route2) - 1)\n\n                    new_route1 = np.insert(new_route1, insert_pos1, high_demand2)\n                    new_route2 = np.insert(new_route2, insert_pos2, high_demand1)\n\n                    # Check capacity feasibility\n                    if (sum(demand[new_route1[1:-1]]) <= capacity and\n                        sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n        # Step 3: Capacity-aware route merging (merge short routes)\n        if len(new_solution) > 1:\n            for i in range(len(new_solution) - 1):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n\n                    # Check if merging is feasible\n                    merged_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                    if merged_demand <= capacity:\n                        # Create merged route\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                        # Update solution\n                        new_solution[i] = merged_route\n                        del new_solution[j]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with the largest makespan (longest route) or total distance, then applies a hybrid local search combining route splitting and customer reallocation to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))  # Prioritize by makespan, then distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route splitting + customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random customer\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Reallocate customers between the two parts while respecting capacity\n        current_load1 = np.sum(demand[part1[1:-1]])\n        current_load2 = np.sum(demand[part2[1:-1]])\n\n        # Try to move customers between parts to balance load\n        for i in range(1, len(part1) - 1):\n            if current_load2 + demand[part1[i]] <= capacity:\n                part2 = np.insert(part2, 1, part1[i])\n                current_load2 += demand[part1[i]]\n                part1 = np.delete(part1, i)\n                current_load1 -= demand[part1[i]]\n                break\n\n        for i in range(1, len(part2) - 1):\n            if current_load1 + demand[part2[i]] <= capacity:\n                part1 = np.insert(part1, -1, part2[i])\n                current_load1 += demand[part2[i]]\n                part2 = np.delete(part2, i)\n                current_load2 -= demand[part2[i]]\n                break\n\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served (fallback to original if needed)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    if served_customers != all_customers:\n        return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.799567191136097,
            3.5586977899074554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))  # Prioritize by makespan, then distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route splitting + customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random customer\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Reallocate customers between the two parts while respecting capacity\n        current_load1 = np.sum(demand[part1[1:-1]])\n        current_load2 = np.sum(demand[part2[1:-1]])\n\n        # Try to move customers between parts to balance load\n        for i in range(1, len(part1) - 1):\n            if current_load2 + demand[part1[i]] <= capacity:\n                part2 = np.insert(part2, 1, part1[i])\n                current_load2 += demand[part1[i]]\n                part1 = np.delete(part1, i)\n                current_load1 -= demand[part1[i]]\n                break\n\n        for i in range(1, len(part2) - 1):\n            if current_load1 + demand[part2[i]] <= capacity:\n                part1 = np.insert(part1, -1, part2[i])\n                current_load1 += demand[part2[i]]\n                part2 = np.delete(part2, i)\n                current_load2 -= demand[part2[i]]\n                break\n\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served (fallback to original if needed)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    if served_customers != all_customers:\n        return selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{A novel hybrid local search operator that combines route segmentation with demand-aware relinking to balance distance and makespan minimization by strategically merging and splitting routes while respecting capacity constraints, using a tournament selection biased towards solutions with high potential for improvement in either objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = random.sample(archive, min(3, len(archive)))\n    selected = min(candidates, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    new_solution = selected.copy()\n    n_routes = len(new_solution)\n\n    # Hybrid local search operator: route segmentation with demand-aware relinking\n    if n_routes > 1:\n        # Select two distinct routes for potential merging\n        route_indices = random.sample(range(n_routes), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Find potential split points in both routes (excluding depots)\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        # Calculate cumulative demand up to split points\n        demand1 = np.sum(demand[route1[1:split1+1]])\n        demand2 = np.sum(demand[route2[1:split2+1]])\n\n        # Check if merging would violate capacity\n        if demand1 + demand2 <= capacity:\n            # Merge segments\n            merged_segment = np.concatenate([route1[1:split1+1], route2[split2:0:-1]])\n            # Create new routes\n            new_route1 = np.concatenate([[0], route1[split1+1:], [0]])\n            new_route2 = np.concatenate([[0], route2[1:split2+1], [0]])\n\n            # Replace original routes with new ones\n            new_solution[route_indices[0]] = new_route1\n            new_solution[route_indices[1]] = new_route2\n\n            # Insert merged segment between the two new routes\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution.insert(insert_pos, np.concatenate([[0], merged_segment, [0]]))\n\n            # Remove empty routes if any\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Additional perturbation: random swap of customers between routes if capacity allows\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers (excluding depots)\n            cust1 = random.randint(1, len(route1)-2)\n            cust2 = random.randint(1, len(route2)-2)\n\n            # Check capacity constraints\n            if (np.sum(demand[route1[1:cust1]]) + demand[route2[cust2]] <= capacity and\n                np.sum(demand[route2[1:cust2]]) + demand[route1[cust1]] <= capacity):\n\n                # Perform swap\n                route1[cust1], route2[cust2] = route2[cust2], route1[cust1]\n\n    return new_solution\n\n",
        "score": [
            -0.7221118787713378,
            0.3630666136741638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = random.sample(archive, min(3, len(archive)))\n    selected = min(candidates, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    new_solution = selected.copy()\n    n_routes = len(new_solution)\n\n    # Hybrid local search operator: route segmentation with demand-aware relinking\n    if n_routes > 1:\n        # Select two distinct routes for potential merging\n        route_indices = random.sample(range(n_routes), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Find potential split points in both routes (excluding depots)\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        # Calculate cumulative demand up to split points\n        demand1 = np.sum(demand[route1[1:split1+1]])\n        demand2 = np.sum(demand[route2[1:split2+1]])\n\n        # Check if merging would violate capacity\n        if demand1 + demand2 <= capacity:\n            # Merge segments\n            merged_segment = np.concatenate([route1[1:split1+1], route2[split2:0:-1]])\n            # Create new routes\n            new_route1 = np.concatenate([[0], route1[split1+1:], [0]])\n            new_route2 = np.concatenate([[0], route2[1:split2+1], [0]])\n\n            # Replace original routes with new ones\n            new_solution[route_indices[0]] = new_route1\n            new_solution[route_indices[1]] = new_route2\n\n            # Insert merged segment between the two new routes\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution.insert(insert_pos, np.concatenate([[0], merged_segment, [0]]))\n\n            # Remove empty routes if any\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Additional perturbation: random swap of customers between routes if capacity allows\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers (excluding depots)\n            cust1 = random.randint(1, len(route1)-2)\n            cust2 = random.randint(1, len(route2)-2)\n\n            # Check capacity constraints\n            if (np.sum(demand[route1[1:cust1]]) + demand[route2[cust2]] <= capacity and\n                np.sum(demand[route2[1:cust2]]) + demand[route1[cust1]] <= capacity):\n\n                # Perform swap\n                route1[cust1], route2[cust2] = route2[cust2], route1[cust1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{The algorithm selects a promising solution from the archive using a tournament selection based on both objective values, then applies a hybrid local search operator combining route fragmentation and customer reinsertion with demand-aware optimizations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    base_solution = selected[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation and demand-aware reinsertion\n    for _ in range(2):  # Number of iterations\n        # Select a random route to fragment\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Find a split point that maintains feasibility\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Calculate demands for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        # Ensure both parts are feasible\n        if demand_part1 > capacity or demand_part2 > capacity:\n            continue\n\n        # Create new routes\n        new_solution[route_idx] = part1\n        new_solution.insert(route_idx + 1, part2)\n\n        # Try to reinsert customers from the new routes\n        for _ in range(3):  # Number of reinsertion attempts\n            # Select a random route to take customers from\n            if len(new_solution) < 2:\n                break\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n\n            if len(from_route) <= 3:\n                continue\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Check if moving this customer would violate capacity\n            from_route_demand = sum(demand[node] for node in from_route[1:-1]) - demand[customer]\n\n            if from_route_demand > capacity:\n                continue\n\n            # Find the best insertion position in other routes\n            best_insertion = None\n            best_cost = float('inf')\n\n            for to_route_idx, to_route in enumerate(new_solution):\n                if to_route_idx == from_route_idx:\n                    continue\n\n                # Calculate demand after insertion\n                to_route_demand = sum(demand[node] for node in to_route[1:-1]) + demand[customer]\n\n                if to_route_demand > capacity:\n                    continue\n\n                # Evaluate all possible insertion positions\n                for pos in range(1, len(to_route)):\n                    # Calculate insertion cost\n                    prev_node = to_route[pos - 1]\n                    next_node = to_route[pos]\n                    cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_insertion = (to_route_idx, pos)\n\n            # Perform the best insertion if found\n            if best_insertion is not None:\n                to_route_idx, pos = best_insertion\n                to_route = new_solution[to_route_idx]\n                new_solution[to_route_idx] = np.concatenate([to_route[:pos], [customer], to_route[pos:]])\n\n                # Update the from_route\n                new_solution[from_route_idx] = np.concatenate([from_route[:customer_pos], from_route[customer_pos + 1:]])\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8361823228840476,
            3.1054877936840057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    base_solution = selected[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation and demand-aware reinsertion\n    for _ in range(2):  # Number of iterations\n        # Select a random route to fragment\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Find a split point that maintains feasibility\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Calculate demands for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        # Ensure both parts are feasible\n        if demand_part1 > capacity or demand_part2 > capacity:\n            continue\n\n        # Create new routes\n        new_solution[route_idx] = part1\n        new_solution.insert(route_idx + 1, part2)\n\n        # Try to reinsert customers from the new routes\n        for _ in range(3):  # Number of reinsertion attempts\n            # Select a random route to take customers from\n            if len(new_solution) < 2:\n                break\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n\n            if len(from_route) <= 3:\n                continue\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Check if moving this customer would violate capacity\n            from_route_demand = sum(demand[node] for node in from_route[1:-1]) - demand[customer]\n\n            if from_route_demand > capacity:\n                continue\n\n            # Find the best insertion position in other routes\n            best_insertion = None\n            best_cost = float('inf')\n\n            for to_route_idx, to_route in enumerate(new_solution):\n                if to_route_idx == from_route_idx:\n                    continue\n\n                # Calculate demand after insertion\n                to_route_demand = sum(demand[node] for node in to_route[1:-1]) + demand[customer]\n\n                if to_route_demand > capacity:\n                    continue\n\n                # Evaluate all possible insertion positions\n                for pos in range(1, len(to_route)):\n                    # Calculate insertion cost\n                    prev_node = to_route[pos - 1]\n                    next_node = to_route[pos]\n                    cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_insertion = (to_route_idx, pos)\n\n            # Perform the best insertion if found\n            if best_insertion is not None:\n                to_route_idx, pos = best_insertion\n                to_route = new_solution[to_route_idx]\n                new_solution[to_route_idx] = np.concatenate([to_route[:pos], [customer], to_route[pos:]])\n\n                # Update the from_route\n                new_solution[from_route_idx] = np.concatenate([from_route[:customer_pos], from_route[customer_pos + 1:]])\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    min_makespan = float('inf')\n    for sol, (total_dist, makespan) in archive:\n        if makespan < min_makespan or (makespan == min_makespan and total_dist < min_makespan):\n            min_makespan = makespan\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 2: Apply a hybrid local search operator\n    # Hybrid of route splitting, customer reallocation, and route merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Step 2.1: Route splitting - Split a long route into two shorter routes\n        if len(route) > 5:\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:-1], [0]])\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n        # Step 2.2: Customer reallocation - Move a customer from this route to another\n        if len(new_solution) > 1 and len(route) > 3:\n            # Select a random customer from this route (excluding depot)\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Try to insert into another route\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n\n                # Find the best insertion position in the other route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate the increase in distance\n                    prev_node = other_route[pos-1]\n                    next_node = other_route[pos]\n                    increase = (distance_matrix[prev_node][customer] +\n                                distance_matrix[customer][next_node] -\n                                distance_matrix[prev_node][next_node])\n\n                    if increase < min_increase and (np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity):\n                        min_increase = increase\n                        best_pos = pos\n\n                if min_increase < float('inf'):\n                    # Perform the move\n                    new_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[j] = new_route\n                    new_solution[i] = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                    break\n\n    # Step 2.3: Route merging - Merge two short routes if possible\n    if len(new_solution) > 2:\n        # Find the two shortest routes\n        route_lengths = [len(route) for route in new_solution]\n        shortest_idx = np.argmin(route_lengths)\n        second_shortest_idx = np.argpartition(route_lengths, 1)[1]\n\n        route1 = new_solution[shortest_idx]\n        route2 = new_solution[second_shortest_idx]\n\n        if len(route1) + len(route2) - 2 <= 10:  # Arbitrary threshold\n            # Try to merge route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[shortest_idx] = merged_route\n                del new_solution[second_shortest_idx]\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route: must start and end with depot\")\n\n    return new_solution\n\n",
        "score": [
            -0.835005212634961,
            2.478811800479889
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    min_makespan = float('inf')\n    for sol, (total_dist, makespan) in archive:\n        if makespan < min_makespan or (makespan == min_makespan and total_dist < min_makespan):\n            min_makespan = makespan\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 2: Apply a hybrid local search operator\n    # Hybrid of route splitting, customer reallocation, and route merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Step 2.1: Route splitting - Split a long route into two shorter routes\n        if len(route) > 5:\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:-1], [0]])\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n        # Step 2.2: Customer reallocation - Move a customer from this route to another\n        if len(new_solution) > 1 and len(route) > 3:\n            # Select a random customer from this route (excluding depot)\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Try to insert into another route\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n\n                # Find the best insertion position in the other route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate the increase in distance\n                    prev_node = other_route[pos-1]\n                    next_node = other_route[pos]\n                    increase = (distance_matrix[prev_node][customer] +\n                                distance_matrix[customer][next_node] -\n                                distance_matrix[prev_node][next_node])\n\n                    if increase < min_increase and (np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity):\n                        min_increase = increase\n                        best_pos = pos\n\n                if min_increase < float('inf'):\n                    # Perform the move\n                    new_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[j] = new_route\n                    new_solution[i] = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                    break\n\n    # Step 2.3: Route merging - Merge two short routes if possible\n    if len(new_solution) > 2:\n        # Find the two shortest routes\n        route_lengths = [len(route) for route in new_solution]\n        shortest_idx = np.argmin(route_lengths)\n        second_shortest_idx = np.argpartition(route_lengths, 1)[1]\n\n        route1 = new_solution[shortest_idx]\n        route2 = new_solution[second_shortest_idx]\n\n        if len(route1) + len(route2) - 2 <= 10:  # Arbitrary threshold\n            # Try to merge route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[shortest_idx] = merged_route\n                del new_solution[second_shortest_idx]\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route: must start and end with depot\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{A novel hybrid local search strategy combines route segment swaps with adaptive capacity-aware customer reinsertions, guided by multi-objective improvement metrics and intelligent selection of critical route segments to balance distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: route segment swap with adaptive reinsertion\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Randomly select two routes for segment swap\n    route1_idx, route2_idx = np.random.choice(n_routes, 2, replace=False)\n    route1 = new_solution[route1_idx].copy()\n    route2 = new_solution[route2_idx].copy()\n\n    # Identify feasible swap segments\n    def find_feasible_segments(route, max_length=5):\n        segments = []\n        for i in range(1, len(route)-1):\n            for j in range(i+1, min(i+max_length, len(route)-1)):\n                segment = route[i:j+1]\n                segment_demand = sum(demand[node] for node in segment)\n                if segment_demand <= capacity:\n                    segments.append((i, j, segment))\n        return segments\n\n    segments1 = find_feasible_segments(route1)\n    segments2 = find_feasible_segments(route2)\n\n    if not segments1 or not segments2:\n        return new_solution\n\n    # Randomly select segments and swap\n    seg1 = segments1[np.random.randint(len(segments1))]\n    seg2 = segments2[np.random.randint(len(segments2))]\n\n    # Create new routes after swap\n    new_route1 = np.concatenate([route1[:seg1[0]], seg2[2], route1[seg1[1]+1:]])\n    new_route2 = np.concatenate([route2[:seg2[0]], seg1[2], route2[seg2[1]+1:]])\n\n    # Check capacity constraints\n    def is_feasible(route):\n        total_demand = sum(demand[node] for node in route[1:-1])  # Exclude depot\n        return total_demand <= capacity\n\n    if not is_feasible(new_route1) or not is_feasible(new_route2):\n        return new_solution\n\n    # Update solution\n    new_solution[route1_idx] = new_route1\n    new_solution[route2_idx] = new_route2\n\n    # Adaptive reinsertion to improve objectives\n    for route in new_solution:\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Identify critical customers (high demand or long detours)\n        critical_nodes = []\n        for i in range(1, len(route)-1):\n            node = route[i]\n            detour = (distance_matrix[route[i-1], node] +\n                      distance_matrix[node, route[i+1]] -\n                      distance_matrix[route[i-1], route[i+1]])\n            if demand[node] > capacity/4 or detour > 1.5 * distance_matrix[route[i-1], route[i+1]]:\n                critical_nodes.append((i, node))\n\n        if not critical_nodes:\n            continue\n\n        # Try reinserting critical customers in better positions\n        for i, node in critical_nodes:\n            # Remove node temporarily\n            removed = np.delete(route, i)\n            best_pos = i\n            best_improvement = 0\n\n            # Evaluate insertion positions\n            for pos in range(1, len(removed)):\n                if pos == i or pos == i+1:\n                    continue\n                # Insert node at position pos\n                candidate = np.insert(removed, pos, node)\n                if not is_feasible(candidate):\n                    continue\n                # Calculate improvement (distance reduction)\n                original_dist = (distance_matrix[removed[pos-1], node] +\n                               distance_matrix[node, removed[pos]])\n                new_dist = (distance_matrix[candidate[pos-1], node] +\n                           distance_matrix[node, candidate[pos+1]])\n                improvement = original_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_improvement > 0:\n                route[:] = np.insert(removed, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7984283465399872,
            5.68807053565979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: route segment swap with adaptive reinsertion\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Randomly select two routes for segment swap\n    route1_idx, route2_idx = np.random.choice(n_routes, 2, replace=False)\n    route1 = new_solution[route1_idx].copy()\n    route2 = new_solution[route2_idx].copy()\n\n    # Identify feasible swap segments\n    def find_feasible_segments(route, max_length=5):\n        segments = []\n        for i in range(1, len(route)-1):\n            for j in range(i+1, min(i+max_length, len(route)-1)):\n                segment = route[i:j+1]\n                segment_demand = sum(demand[node] for node in segment)\n                if segment_demand <= capacity:\n                    segments.append((i, j, segment))\n        return segments\n\n    segments1 = find_feasible_segments(route1)\n    segments2 = find_feasible_segments(route2)\n\n    if not segments1 or not segments2:\n        return new_solution\n\n    # Randomly select segments and swap\n    seg1 = segments1[np.random.randint(len(segments1))]\n    seg2 = segments2[np.random.randint(len(segments2))]\n\n    # Create new routes after swap\n    new_route1 = np.concatenate([route1[:seg1[0]], seg2[2], route1[seg1[1]+1:]])\n    new_route2 = np.concatenate([route2[:seg2[0]], seg1[2], route2[seg2[1]+1:]])\n\n    # Check capacity constraints\n    def is_feasible(route):\n        total_demand = sum(demand[node] for node in route[1:-1])  # Exclude depot\n        return total_demand <= capacity\n\n    if not is_feasible(new_route1) or not is_feasible(new_route2):\n        return new_solution\n\n    # Update solution\n    new_solution[route1_idx] = new_route1\n    new_solution[route2_idx] = new_route2\n\n    # Adaptive reinsertion to improve objectives\n    for route in new_solution:\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Identify critical customers (high demand or long detours)\n        critical_nodes = []\n        for i in range(1, len(route)-1):\n            node = route[i]\n            detour = (distance_matrix[route[i-1], node] +\n                      distance_matrix[node, route[i+1]] -\n                      distance_matrix[route[i-1], route[i+1]])\n            if demand[node] > capacity/4 or detour > 1.5 * distance_matrix[route[i-1], route[i+1]]:\n                critical_nodes.append((i, node))\n\n        if not critical_nodes:\n            continue\n\n        # Try reinserting critical customers in better positions\n        for i, node in critical_nodes:\n            # Remove node temporarily\n            removed = np.delete(route, i)\n            best_pos = i\n            best_improvement = 0\n\n            # Evaluate insertion positions\n            for pos in range(1, len(removed)):\n                if pos == i or pos == i+1:\n                    continue\n                # Insert node at position pos\n                candidate = np.insert(removed, pos, node)\n                if not is_feasible(candidate):\n                    continue\n                # Calculate improvement (distance reduction)\n                original_dist = (distance_matrix[removed[pos-1], node] +\n                               distance_matrix[node, removed[pos]])\n                new_dist = (distance_matrix[candidate[pos-1], node] +\n                           distance_matrix[node, candidate[pos+1]])\n                improvement = original_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_improvement > 0:\n                route[:] = np.insert(removed, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_solution = sorted_archive[0][0]\n    base_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and segment reversal\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Randomly select a segment to reverse or split\n        i = np.random.randint(1, len(route)-1)\n        j = np.random.randint(i+1, len(route))\n\n        # Check if reversing the segment improves both objectives\n        reversed_segment = route[i:j][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j:]])\n\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route = new_route\n\n        # Check if splitting the route at a random point improves makespan\n        split_point = np.random.randint(1, len(route)-1)\n        first_part = np.concatenate([route[:split_point], [0]])\n        second_part = np.concatenate([[0], route[split_point:]])\n\n        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n            np.sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution.extend([first_part, second_part])\n        else:\n            new_solution.append(route)\n\n    # Ensure solution is feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "score": [
            -0.6936787595657298,
            2.712181270122528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    selected_solution = sorted_archive[0][0]\n    base_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and segment reversal\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Randomly select a segment to reverse or split\n        i = np.random.randint(1, len(route)-1)\n        j = np.random.randint(i+1, len(route))\n\n        # Check if reversing the segment improves both objectives\n        reversed_segment = route[i:j][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j:]])\n\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route = new_route\n\n        # Check if splitting the route at a random point improves makespan\n        split_point = np.random.randint(1, len(route)-1)\n        first_part = np.concatenate([route[:split_point], [0]])\n        second_part = np.concatenate([[0], route[split_point:]])\n\n        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n            np.sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution.extend([first_part, second_part])\n        else:\n            new_solution.append(route)\n\n    # Ensure solution is feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the longest route into two\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = route[split_pos:]\n\n        # Check capacity constraints\n        load1 = np.sum(demand[new_route1[1:-1]])\n        load2 = np.sum(demand[new_route2[1:-1]])\n\n        if load1 <= capacity and load2 <= capacity:\n            new_solution[i] = new_route1\n            new_solution.insert(i + 1, new_route2)\n            i += 1  # Skip the newly inserted route\n\n    # Reallocate customers from overloaded routes to feasible routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        current_load = np.sum(demand[route[1:-1]])\n\n        if current_load > capacity:\n            # Find customers to reallocate\n            excess = current_load - capacity\n            candidates = route[1:-1][np.argsort(demand[route[1:-1]])[::-1]]  # Highest demand first\n\n            for customer in candidates:\n                if excess <= 0:\n                    break\n\n                # Try to insert into other routes\n                for j in range(len(new_solution)):\n                    if i == j:\n                        continue\n\n                    temp_route = new_solution[j].tolist()\n                    best_pos = None\n                    min_increase = float('inf')\n\n                    # Find best insertion position\n                    for pos in range(1, len(temp_route)):\n                        temp_route.insert(pos, customer)\n                        new_load = np.sum(demand[temp_route[1:-1]])\n\n                        if new_load <= capacity:\n                            dist_increase = (distance_matrix[temp_route[pos-1], customer] +\n                                            distance_matrix[customer, temp_route[pos+1]] -\n                                            distance_matrix[temp_route[pos-1], temp_route[pos+1]])\n\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        temp_route.pop(pos)\n\n                    if best_pos is not None:\n                        temp_route.insert(best_pos, customer)\n                        new_solution[j] = np.array(temp_route)\n                        route = np.delete(route, np.where(route == customer)[0][0])\n                        excess -= demand[customer]\n\n    return new_solution\n\n",
        "score": [
            -0.8443583306450094,
            0.5798391997814178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the longest route into two\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = route[split_pos:]\n\n        # Check capacity constraints\n        load1 = np.sum(demand[new_route1[1:-1]])\n        load2 = np.sum(demand[new_route2[1:-1]])\n\n        if load1 <= capacity and load2 <= capacity:\n            new_solution[i] = new_route1\n            new_solution.insert(i + 1, new_route2)\n            i += 1  # Skip the newly inserted route\n\n    # Reallocate customers from overloaded routes to feasible routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        current_load = np.sum(demand[route[1:-1]])\n\n        if current_load > capacity:\n            # Find customers to reallocate\n            excess = current_load - capacity\n            candidates = route[1:-1][np.argsort(demand[route[1:-1]])[::-1]]  # Highest demand first\n\n            for customer in candidates:\n                if excess <= 0:\n                    break\n\n                # Try to insert into other routes\n                for j in range(len(new_solution)):\n                    if i == j:\n                        continue\n\n                    temp_route = new_solution[j].tolist()\n                    best_pos = None\n                    min_increase = float('inf')\n\n                    # Find best insertion position\n                    for pos in range(1, len(temp_route)):\n                        temp_route.insert(pos, customer)\n                        new_load = np.sum(demand[temp_route[1:-1]])\n\n                        if new_load <= capacity:\n                            dist_increase = (distance_matrix[temp_route[pos-1], customer] +\n                                            distance_matrix[customer, temp_route[pos+1]] -\n                                            distance_matrix[temp_route[pos-1], temp_route[pos+1]])\n\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        temp_route.pop(pos)\n\n                    if best_pos is not None:\n                        temp_route.insert(best_pos, customer)\n                        new_solution[j] = np.array(temp_route)\n                        route = np.delete(route, np.where(route == customer)[0][0])\n                        excess -= demand[customer]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{The algorithm selects a solution with the smallest makespan from the archive, then applies a hybrid local search combining route swapping and customer reinsertion to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route swapping and customer reinsertion\n    if len(new_solution) >= 2:\n        # Route swapping\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check capacity feasibility after swapping\n        for route in new_solution:\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # If infeasible, undo the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n        # Customer reinsertion for the swapped routes\n        for route_idx in [i, j]:\n            route = new_solution[route_idx]\n            if len(route) > 3:  # Only if route has more than 2 customers\n                # Randomly select a customer to reinsert\n                pos = np.random.randint(1, len(route) - 1)\n                customer = route[pos]\n\n                # Remove the customer from the route\n                new_route = np.concatenate([route[:pos], route[pos+1:]])\n\n                # Find the best position to reinsert the customer\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(new_route)):\n                    # Insert customer between new_route[pos-1] and new_route[pos]\n                    temp_route = np.concatenate([new_route[:pos], [customer], new_route[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[pos-1]][customer] + distance_matrix[customer][temp_route[pos]] - distance_matrix[temp_route[pos-1]][temp_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                # Reinsert the customer at the best position\n                new_solution[route_idx] = np.concatenate([new_route[:best_pos], [customer], new_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.3680914441179316,
            1.6061275601387024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route swapping and customer reinsertion\n    if len(new_solution) >= 2:\n        # Route swapping\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check capacity feasibility after swapping\n        for route in new_solution:\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # If infeasible, undo the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n        # Customer reinsertion for the swapped routes\n        for route_idx in [i, j]:\n            route = new_solution[route_idx]\n            if len(route) > 3:  # Only if route has more than 2 customers\n                # Randomly select a customer to reinsert\n                pos = np.random.randint(1, len(route) - 1)\n                customer = route[pos]\n\n                # Remove the customer from the route\n                new_route = np.concatenate([route[:pos], route[pos+1:]])\n\n                # Find the best position to reinsert the customer\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(new_route)):\n                    # Insert customer between new_route[pos-1] and new_route[pos]\n                    temp_route = np.concatenate([new_route[:pos], [customer], new_route[pos:]])\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[pos-1]][customer] + distance_matrix[customer][temp_route[pos]] - distance_matrix[temp_route[pos-1]][temp_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                # Reinsert the customer at the best position\n                new_solution[route_idx] = np.concatenate([new_route[:best_pos], [customer], new_route[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combined objective score, then applies a hybrid local search that combines route-splitting and intra-route reordering to minimize both total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route-splitting and intra-route reordering\n    if len(new_solution) > 1:\n        # Randomly select a route to split or reorder\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Option 1: Split the route into two if feasible\n        if len(selected_route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check feasibility of both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Option 2: Reorder nodes within the route to reduce distance/makespan\n                nodes_to_reorder = selected_route[1:-1]\n                random.shuffle(nodes_to_reorder)\n                new_route = np.concatenate([[0], nodes_to_reorder, [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n    else:\n        # If only one route, apply reordering\n        if len(new_solution[0]) > 3:\n            nodes_to_reorder = new_solution[0][1:-1]\n            random.shuffle(nodes_to_reorder)\n            new_route = np.concatenate([[0], nodes_to_reorder, [0]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[0] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6251149608648097,
            0.11441078782081604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route-splitting and intra-route reordering\n    if len(new_solution) > 1:\n        # Randomly select a route to split or reorder\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Option 1: Split the route into two if feasible\n        if len(selected_route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check feasibility of both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Option 2: Reorder nodes within the route to reduce distance/makespan\n                nodes_to_reorder = selected_route[1:-1]\n                random.shuffle(nodes_to_reorder)\n                new_route = np.concatenate([[0], nodes_to_reorder, [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n    else:\n        # If only one route, apply reordering\n        if len(new_solution[0]) > 3:\n            nodes_to_reorder = new_solution[0][1:-1]\n            random.shuffle(nodes_to_reorder)\n            new_route = np.concatenate([[0], nodes_to_reorder, [0]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[0] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combined objective score, then applies a hybrid local search that combines route-splitting and intra-route reordering to minimize both total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route-splitting and intra-route reordering\n    if len(new_solution) > 1:\n        # Randomly select a route to split or reorder\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Option 1: Split the route into two if feasible\n        if len(selected_route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check feasibility of both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Option 2: Reorder nodes within the route to reduce distance/makespan\n                nodes_to_reorder = selected_route[1:-1]\n                random.shuffle(nodes_to_reorder)\n                new_route = np.concatenate([[0], nodes_to_reorder, [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n    else:\n        # If only one route, apply reordering\n        if len(new_solution[0]) > 3:\n            nodes_to_reorder = new_solution[0][1:-1]\n            random.shuffle(nodes_to_reorder)\n            new_route = np.concatenate([[0], nodes_to_reorder, [0]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[0] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6251149608648097,
            0.11441078782081604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route-splitting and intra-route reordering\n    if len(new_solution) > 1:\n        # Randomly select a route to split or reorder\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Option 1: Split the route into two if feasible\n        if len(selected_route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check feasibility of both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Option 2: Reorder nodes within the route to reduce distance/makespan\n                nodes_to_reorder = selected_route[1:-1]\n                random.shuffle(nodes_to_reorder)\n                new_route = np.concatenate([[0], nodes_to_reorder, [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n    else:\n        # If only one route, apply reordering\n        if len(new_solution[0]) > 3:\n            nodes_to_reorder = new_solution[0][1:-1]\n            random.shuffle(nodes_to_reorder)\n            new_route = np.concatenate([[0], nodes_to_reorder, [0]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[0] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route splitting, customer relocation, and route merging to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: split, relocate, and merge routes\n    if len(new_solution) > 1:\n        # Step 1: Split a route into two if it's too long\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n        if len(split_route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(split_route) - 2)\n            new_route1 = np.concatenate((split_route[:split_pos + 1], [0]))\n            new_route2 = np.concatenate(([0], split_route[split_pos + 1:]))\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[split_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 2: Relocate a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        from_route = new_solution[from_route_idx]\n        if len(from_route) > 3:  # Ensure we can relocate\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to place the customer in another route\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            while to_route_idx == from_route_idx and len(new_solution) > 1:\n                to_route_idx = random.randint(0, len(new_solution) - 1)\n            to_route = new_solution[to_route_idx]\n\n            # Check capacity constraint\n            if np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity:\n                new_route_from = np.concatenate((from_route[:customer_pos], from_route[customer_pos + 1:]))\n                new_route_to = np.concatenate((to_route[:-1], [customer], [0]))\n\n                new_solution[from_route_idx] = new_route_from\n                new_solution[to_route_idx] = new_route_to\n\n    # Step 3: Merge two routes if possible\n    if len(new_solution) > 1:\n        merge_route1_idx = random.randint(0, len(new_solution) - 1)\n        merge_route2_idx = random.randint(0, len(new_solution) - 1)\n        while merge_route2_idx == merge_route1_idx and len(new_solution) > 1:\n            merge_route2_idx = random.randint(0, len(new_solution) - 1)\n\n        merge_route1 = new_solution[merge_route1_idx]\n        merge_route2 = new_solution[merge_route2_idx]\n\n        # Check capacity constraint\n        if np.sum(demand[merge_route1[1:-1]]) + np.sum(demand[merge_route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate((merge_route1[:-1], merge_route2[1:]))\n            new_solution[merge_route1_idx] = merged_route\n            new_solution.pop(merge_route2_idx)\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6322162526569082,
            1.3112632930278778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: split, relocate, and merge routes\n    if len(new_solution) > 1:\n        # Step 1: Split a route into two if it's too long\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n        if len(split_route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(split_route) - 2)\n            new_route1 = np.concatenate((split_route[:split_pos + 1], [0]))\n            new_route2 = np.concatenate(([0], split_route[split_pos + 1:]))\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[split_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 2: Relocate a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        from_route = new_solution[from_route_idx]\n        if len(from_route) > 3:  # Ensure we can relocate\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to place the customer in another route\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            while to_route_idx == from_route_idx and len(new_solution) > 1:\n                to_route_idx = random.randint(0, len(new_solution) - 1)\n            to_route = new_solution[to_route_idx]\n\n            # Check capacity constraint\n            if np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity:\n                new_route_from = np.concatenate((from_route[:customer_pos], from_route[customer_pos + 1:]))\n                new_route_to = np.concatenate((to_route[:-1], [customer], [0]))\n\n                new_solution[from_route_idx] = new_route_from\n                new_solution[to_route_idx] = new_route_to\n\n    # Step 3: Merge two routes if possible\n    if len(new_solution) > 1:\n        merge_route1_idx = random.randint(0, len(new_solution) - 1)\n        merge_route2_idx = random.randint(0, len(new_solution) - 1)\n        while merge_route2_idx == merge_route1_idx and len(new_solution) > 1:\n            merge_route2_idx = random.randint(0, len(new_solution) - 1)\n\n        merge_route1 = new_solution[merge_route1_idx]\n        merge_route2 = new_solution[merge_route2_idx]\n\n        # Check capacity constraint\n        if np.sum(demand[merge_route1[1:-1]]) + np.sum(demand[merge_route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate((merge_route1[:-1], merge_route2[1:]))\n            new_solution[merge_route1_idx] = merged_route\n            new_solution.pop(merge_route2_idx)\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] + x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Create new routes\n            new_route1 = part1\n            new_route2 = part2\n\n            # Replace the original route with the two new routes\n            new_solution[i] = new_route1\n            new_solution.insert(i + 1, new_route2)\n\n            # Reallocate customers from other routes to balance makespan\n            for j in range(len(new_solution)):\n                if i != j and len(new_solution[j]) > 3:\n                    for k in range(1, len(new_solution[j]) - 1):\n                        node = new_solution[j][k]\n                        # Try moving this node to the current route\n                        temp_route = new_solution[j].copy()\n                        temp_route = np.delete(temp_route, k)\n                        new_route = np.insert(new_route1, -1, node)\n                        new_demand = sum(demand[n] for n in new_route[1:-1])\n\n                        if new_demand <= capacity:\n                            # Update routes\n                            new_solution[j] = temp_route\n                            new_solution[i] = new_route\n                            break\n            break\n\n    # Ensure all routes start and end at depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    return new_solution\n\n",
        "score": [
            -0.7909595107650413,
            1.913664162158966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] + x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Create new routes\n            new_route1 = part1\n            new_route2 = part2\n\n            # Replace the original route with the two new routes\n            new_solution[i] = new_route1\n            new_solution.insert(i + 1, new_route2)\n\n            # Reallocate customers from other routes to balance makespan\n            for j in range(len(new_solution)):\n                if i != j and len(new_solution[j]) > 3:\n                    for k in range(1, len(new_solution[j]) - 1):\n                        node = new_solution[j][k]\n                        # Try moving this node to the current route\n                        temp_route = new_solution[j].copy()\n                        temp_route = np.delete(temp_route, k)\n                        new_route = np.insert(new_route1, -1, node)\n                        new_demand = sum(demand[n] for n in new_route[1:-1])\n\n                        if new_demand <= capacity:\n                            # Update routes\n                            new_solution[j] = temp_route\n                            new_solution[i] = new_route\n                            break\n            break\n\n    # Ensure all routes start and end at depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    crowding_distances = []\n    for i in range(len(archive)):\n        total_distance, makespan = archive[i][1]\n        crowding_distances.append((total_distance + makespan) / 2)  # Simple heuristic for crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Route merging and split with demand-aware swaps\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts\n        split_pos = len(route) // 2\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Demand check for parts\n        demand1 = np.sum(demand[part1[1:-1]])\n        demand2 = np.sum(demand[part2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Valid split, add both parts\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # Try demand-aware swaps to balance demands\n            for i in range(1, len(part1) - 1):\n                for j in range(1, len(part2) - 1):\n                    new_demand1 = demand1 - demand[part1[i]] + demand[part2[j]]\n                    new_demand2 = demand2 - demand[part2[j]] + demand[part1[i]]\n                    if new_demand1 <= capacity and new_demand2 <= capacity:\n                        # Perform swap\n                        part1[i], part2[j] = part2[j], part1[i]\n                        demand1, demand2 = new_demand1, new_demand2\n                        break\n                else:\n                    continue\n                break\n\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n\n    # Apply cross-route demand-aware swaps to reduce makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Find a customer in route1 and a customer in route2 to swap\n            for k in range(1, len(route1) - 1):\n                for l in range(1, len(route2) - 1):\n                    # Check demand feasibility\n                    demand1 = np.sum(demand[route1[1:-1]]) - demand[route1[k]] + demand[route2[l]]\n                    demand2 = np.sum(demand[route2[1:-1]]) - demand[route2[l]] + demand[route1[k]]\n                    if demand1 <= capacity and demand2 <= capacity:\n                        # Perform swap\n                        route1[k], route2[l] = route2[l], route1[k]\n                        break\n                else:\n                    continue\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6172487093201666,
            11.066693514585495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    crowding_distances = []\n    for i in range(len(archive)):\n        total_distance, makespan = archive[i][1]\n        crowding_distances.append((total_distance + makespan) / 2)  # Simple heuristic for crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Route merging and split with demand-aware swaps\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts\n        split_pos = len(route) // 2\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Demand check for parts\n        demand1 = np.sum(demand[part1[1:-1]])\n        demand2 = np.sum(demand[part2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Valid split, add both parts\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # Try demand-aware swaps to balance demands\n            for i in range(1, len(part1) - 1):\n                for j in range(1, len(part2) - 1):\n                    new_demand1 = demand1 - demand[part1[i]] + demand[part2[j]]\n                    new_demand2 = demand2 - demand[part2[j]] + demand[part1[i]]\n                    if new_demand1 <= capacity and new_demand2 <= capacity:\n                        # Perform swap\n                        part1[i], part2[j] = part2[j], part1[i]\n                        demand1, demand2 = new_demand1, new_demand2\n                        break\n                else:\n                    continue\n                break\n\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n\n    # Apply cross-route demand-aware swaps to reduce makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Find a customer in route1 and a customer in route2 to swap\n            for k in range(1, len(route1) - 1):\n                for l in range(1, len(route2) - 1):\n                    # Check demand feasibility\n                    demand1 = np.sum(demand[route1[1:-1]]) - demand[route1[k]] + demand[route2[l]]\n                    demand2 = np.sum(demand[route2[1:-1]]) - demand[route2[l]] + demand[route1[k]]\n                    if demand1 <= capacity and demand2 <= capacity:\n                        # Perform swap\n                        route1[k], route2[l] = route2[l], route1[k]\n                        break\n                else:\n                    continue\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))[:max(3, len(archive)//3)]\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment swap + insertion heuristic\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Extract a random segment from route1 (excluding depot)\n        if len(route1) > 3:\n            start, end = sorted(random.sample(range(1, len(route1)-1), 2))\n            segment = route1[start:end+1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Try inserting the segment into route2\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i in range(1, len(route2)):\n                # Insert before i\n                temp_route = np.concatenate([route2[:i], segment, route2[i:]])\n                if sum(demand[node] for node in temp_route) <= capacity:\n                    cost = (distance_matrix[route2[i-1], segment[0]] +\n                            distance_matrix[segment[-1], route2[i]] -\n                            distance_matrix[route2[i-1], route2[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n            if best_pos != -1:\n                # Perform the insertion\n                new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                # Remove the segment from route1\n                new_route1 = np.concatenate([route1[:start], route1[end+1:]])\n                new_solution[route1_idx] = new_route1\n\n                # If route1 is now empty (only depot), remove it\n                if len(new_route1) == 1:\n                    new_solution = [r for r in new_solution if len(r) > 1]\n\n    # Capacity-aware insertion heuristic for unassigned nodes\n    unassigned = []\n    assigned = set()\n    for route in new_solution:\n        assigned.update(route[1:-1])  # Exclude depots\n\n    for node in range(1, len(demand)):\n        if node not in assigned:\n            unassigned.append(node)\n\n    for node in unassigned:\n        best_route = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            current_demand = sum(demand[n] for n in route)\n            if current_demand + demand[node] > capacity:\n                continue\n\n            for j in range(1, len(route)):\n                cost = (distance_matrix[route[j-1], node] +\n                        distance_matrix[node, route[j]] -\n                        distance_matrix[route[j-1], route[j]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route = i\n                    best_pos = j\n\n        if best_route != -1:\n            new_route = np.concatenate([new_solution[best_route][:best_pos], [node], new_solution[best_route][best_pos:]])\n            new_solution[best_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6283793059671642,
            1.9560385644435883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))[:max(3, len(archive)//3)]\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment swap + insertion heuristic\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Extract a random segment from route1 (excluding depot)\n        if len(route1) > 3:\n            start, end = sorted(random.sample(range(1, len(route1)-1), 2))\n            segment = route1[start:end+1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Try inserting the segment into route2\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i in range(1, len(route2)):\n                # Insert before i\n                temp_route = np.concatenate([route2[:i], segment, route2[i:]])\n                if sum(demand[node] for node in temp_route) <= capacity:\n                    cost = (distance_matrix[route2[i-1], segment[0]] +\n                            distance_matrix[segment[-1], route2[i]] -\n                            distance_matrix[route2[i-1], route2[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n            if best_pos != -1:\n                # Perform the insertion\n                new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                # Remove the segment from route1\n                new_route1 = np.concatenate([route1[:start], route1[end+1:]])\n                new_solution[route1_idx] = new_route1\n\n                # If route1 is now empty (only depot), remove it\n                if len(new_route1) == 1:\n                    new_solution = [r for r in new_solution if len(r) > 1]\n\n    # Capacity-aware insertion heuristic for unassigned nodes\n    unassigned = []\n    assigned = set()\n    for route in new_solution:\n        assigned.update(route[1:-1])  # Exclude depots\n\n    for node in range(1, len(demand)):\n        if node not in assigned:\n            unassigned.append(node)\n\n    for node in unassigned:\n        best_route = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            current_demand = sum(demand[n] for n in route)\n            if current_demand + demand[node] > capacity:\n                continue\n\n            for j in range(1, len(route)):\n                cost = (distance_matrix[route[j-1], node] +\n                        distance_matrix[node, route[j]] -\n                        distance_matrix[route[j-1], route[j]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_route = i\n                    best_pos = j\n\n        if best_route != -1:\n            new_route = np.concatenate([new_solution[best_route][:best_pos], [node], new_solution[best_route][best_pos:]])\n            new_solution[best_route] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route swapping + partial reversal with demand-aware insertion\n    if len(new_solution) >= 2:\n        # Randomly select two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Split routes at random positions, ensuring feasibility\n        split_i = random.randint(1, len(route_i) - 2)\n        split_j = random.randint(1, len(route_j) - 2)\n\n        # Extract segments\n        segment_i = route_i[split_i:-1]\n        segment_j = route_j[split_j:-1]\n\n        # Check demand feasibility for swapping\n        demand_i = np.sum(demand[segment_i])\n        demand_j = np.sum(demand[segment_j])\n\n        if demand_i <= capacity and demand_j <= capacity:\n            # Swap segments and reverse one of them\n            new_route_i = np.concatenate([route_i[:split_i], segment_j, [0]])\n            new_route_j = np.concatenate([route_j[:split_j], segment_i, [0]])\n\n            # Reverse one of the segments to explore new configurations\n            if random.random() > 0.5:\n                new_route_i = np.concatenate([new_route_i[:-1], new_route_i[-2::-1]])\n            else:\n                new_route_j = np.concatenate([new_route_j[:-1], new_route_j[-2::-1]])\n\n            # Update solution\n            new_solution[i] = new_route_i\n            new_solution[j] = new_route_j\n\n            # Remove empty routes (if any)\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Demand-aware insertion: try to insert nodes from long routes into shorter ones\n    long_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    short_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n    if long_route_idx != short_route_idx and len(new_solution[long_route_idx]) > 3:\n        long_route = new_solution[long_route_idx]\n        short_route = new_solution[short_route_idx]\n\n        # Select a node to move from the long route (avoid depot)\n        node_to_move = random.choice(long_route[1:-1])\n        demand_node = demand[node_to_move]\n\n        # Find feasible insertion positions in the short route\n        feasible_positions = []\n        for pos in range(1, len(short_route)):\n            if np.sum(demand[short_route[:pos]]) + demand_node <= capacity:\n                feasible_positions.append(pos)\n\n        if feasible_positions:\n            insert_pos = random.choice(feasible_positions)\n            new_short_route = np.concatenate([short_route[:insert_pos], [node_to_move], short_route[insert_pos:]])\n            new_long_route = np.array([node for node in long_route if node != node_to_move])\n\n            # Ensure long route is not empty\n            if len(new_long_route) >= 2:\n                new_solution[short_route_idx] = new_short_route\n                new_solution[long_route_idx] = np.concatenate([new_long_route, [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7247206277021254,
            1.0071865320205688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route swapping + partial reversal with demand-aware insertion\n    if len(new_solution) >= 2:\n        # Randomly select two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Split routes at random positions, ensuring feasibility\n        split_i = random.randint(1, len(route_i) - 2)\n        split_j = random.randint(1, len(route_j) - 2)\n\n        # Extract segments\n        segment_i = route_i[split_i:-1]\n        segment_j = route_j[split_j:-1]\n\n        # Check demand feasibility for swapping\n        demand_i = np.sum(demand[segment_i])\n        demand_j = np.sum(demand[segment_j])\n\n        if demand_i <= capacity and demand_j <= capacity:\n            # Swap segments and reverse one of them\n            new_route_i = np.concatenate([route_i[:split_i], segment_j, [0]])\n            new_route_j = np.concatenate([route_j[:split_j], segment_i, [0]])\n\n            # Reverse one of the segments to explore new configurations\n            if random.random() > 0.5:\n                new_route_i = np.concatenate([new_route_i[:-1], new_route_i[-2::-1]])\n            else:\n                new_route_j = np.concatenate([new_route_j[:-1], new_route_j[-2::-1]])\n\n            # Update solution\n            new_solution[i] = new_route_i\n            new_solution[j] = new_route_j\n\n            # Remove empty routes (if any)\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Demand-aware insertion: try to insert nodes from long routes into shorter ones\n    long_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    short_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n    if long_route_idx != short_route_idx and len(new_solution[long_route_idx]) > 3:\n        long_route = new_solution[long_route_idx]\n        short_route = new_solution[short_route_idx]\n\n        # Select a node to move from the long route (avoid depot)\n        node_to_move = random.choice(long_route[1:-1])\n        demand_node = demand[node_to_move]\n\n        # Find feasible insertion positions in the short route\n        feasible_positions = []\n        for pos in range(1, len(short_route)):\n            if np.sum(demand[short_route[:pos]]) + demand_node <= capacity:\n                feasible_positions.append(pos)\n\n        if feasible_positions:\n            insert_pos = random.choice(feasible_positions)\n            new_short_route = np.concatenate([short_route[:insert_pos], [node_to_move], short_route[insert_pos:]])\n            new_long_route = np.array([node for node in long_route if node != node_to_move])\n\n            # Ensure long route is not empty\n            if len(new_long_route) >= 2:\n                new_solution[short_route_idx] = new_short_route\n                new_solution[long_route_idx] = np.concatenate([new_long_route, [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{A hybrid route-splitting and demand-balancing local search operator that intelligently splits or merges routes while ensuring capacity constraints are met, and balances demand across routes to improve both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly choose a route to split or merge\n    if len(new_solution) > 1 and random.random() < 0.7:  # 70% chance to split or merge\n        # Try to merge two routes if their total demand is within capacity\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n            if total_demand <= capacity:\n                # Merge route_j into route_i\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j) if j < i else new_solution.pop(j - 1)\n    else:\n        # Split a route into two if possible\n        i = random.randint(0, len(new_solution) - 1)\n        route = new_solution[i]\n        if len(route) > 3:  # At least one customer to split\n            split_idx = random.randint(1, len(route) - 2)\n            route1 = np.concatenate([route[:split_idx + 1], [0]])\n            route2 = np.concatenate([[0], route[split_idx + 1:]])\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[i] = route1\n                new_solution.insert(i + 1, route2)\n\n    # Apply a demand-balancing step to improve makespan\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 1:\n            # Sort customers by demand in descending order\n            sorted_customers = sorted(customers, key=lambda x: -demand[x])\n            # Try to reorder customers to balance demand\n            new_order = [0] + sorted_customers + [0]\n            new_demand = np.sum(demand[new_order[1:-1]])\n            if new_demand <= capacity:\n                route[:] = new_order\n\n    return new_solution\n\n",
        "score": [
            -0.6396962327784633,
            1.2608775198459625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly choose a route to split or merge\n    if len(new_solution) > 1 and random.random() < 0.7:  # 70% chance to split or merge\n        # Try to merge two routes if their total demand is within capacity\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n            if total_demand <= capacity:\n                # Merge route_j into route_i\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j) if j < i else new_solution.pop(j - 1)\n    else:\n        # Split a route into two if possible\n        i = random.randint(0, len(new_solution) - 1)\n        route = new_solution[i]\n        if len(route) > 3:  # At least one customer to split\n            split_idx = random.randint(1, len(route) - 2)\n            route1 = np.concatenate([route[:split_idx + 1], [0]])\n            route2 = np.concatenate([[0], route[split_idx + 1:]])\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[i] = route1\n                new_solution.insert(i + 1, route2)\n\n    # Apply a demand-balancing step to improve makespan\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 1:\n            # Sort customers by demand in descending order\n            sorted_customers = sorted(customers, key=lambda x: -demand[x])\n            # Try to reorder customers to balance demand\n            new_order = [0] + sorted_customers + [0]\n            new_demand = np.sum(demand[new_order[1:-1]])\n            if new_demand <= capacity:\n                route[:] = new_order\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining route segment swapping and demand-balanced route merging to improve both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted objective score (prioritizing solutions with lower makespan)\n    weights = [1.0 / (obj[1] + 1e-6) for _, obj in archive]  # Higher weight for lower makespan\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: segment swap + demand-balanced merge\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i].copy()\n        route_j = new_solution[j].copy()\n\n        # Segment swap between routes (avoid swapping entire routes)\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Find feasible swap segments\n            max_swap = min(len(route_i) - 2, len(route_j) - 2) - 1\n            if max_swap > 1:\n                swap_len = np.random.randint(1, max_swap)\n                pos_i = np.random.randint(1, len(route_i) - swap_len - 1)\n                pos_j = np.random.randint(1, len(route_j) - swap_len - 1)\n\n                # Check demand feasibility\n                segment_i = route_i[pos_i:pos_i+swap_len]\n                segment_j = route_j[pos_j:pos_j+swap_len]\n                total_demand_i = np.sum(demand[segment_i])\n                total_demand_j = np.sum(demand[segment_j])\n\n                if (np.sum(demand[route_i]) - total_demand_i + total_demand_j <= capacity and\n                    np.sum(demand[route_j]) - total_demand_j + total_demand_i <= capacity):\n                    # Perform swap\n                    new_route_i = np.concatenate([route_i[:pos_i], segment_j, route_i[pos_i+swap_len:]])\n                    new_route_j = np.concatenate([route_j[:pos_j], segment_i, route_j[pos_j+swap_len:]])\n\n                    # Update solution if improvement\n                    if (np.sum(distance_matrix[new_route_i[:-1], new_route_i[1:]]) +\n                        np.sum(distance_matrix[new_route_j[:-1], new_route_j[1:]]) <\n                        np.sum(distance_matrix[route_i[:-1], route_i[1:]]) +\n                        np.sum(distance_matrix[route_j[:-1], route_j[1:]])):\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n\n        # Demand-balanced merge (if routes can be merged without exceeding capacity)\n        if len(new_solution) > 1:\n            for _ in range(2):  # Try a few random merges\n                i, j = np.random.choice(len(new_solution), 2, replace=False)\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n                    # Try merging in both directions\n                    merged1 = np.concatenate([route_i[:-1], route_j[1:]])\n                    merged2 = np.concatenate([route_j[:-1], route_i[1:]])\n\n                    # Select the better merge\n                    dist1 = np.sum(distance_matrix[merged1[:-1], merged1[1:]])\n                    dist2 = np.sum(distance_matrix[merged2[:-1], merged2[1:]])\n\n                    if dist1 < dist2:\n                        new_solution[i] = merged1\n                        del new_solution[j]\n                    else:\n                        new_solution[j] = merged2\n                        del new_solution[i]\n\n                    # Break after first successful merge\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4410603041191502,
            1.814456969499588
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted objective score (prioritizing solutions with lower makespan)\n    weights = [1.0 / (obj[1] + 1e-6) for _, obj in archive]  # Higher weight for lower makespan\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: segment swap + demand-balanced merge\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i].copy()\n        route_j = new_solution[j].copy()\n\n        # Segment swap between routes (avoid swapping entire routes)\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Find feasible swap segments\n            max_swap = min(len(route_i) - 2, len(route_j) - 2) - 1\n            if max_swap > 1:\n                swap_len = np.random.randint(1, max_swap)\n                pos_i = np.random.randint(1, len(route_i) - swap_len - 1)\n                pos_j = np.random.randint(1, len(route_j) - swap_len - 1)\n\n                # Check demand feasibility\n                segment_i = route_i[pos_i:pos_i+swap_len]\n                segment_j = route_j[pos_j:pos_j+swap_len]\n                total_demand_i = np.sum(demand[segment_i])\n                total_demand_j = np.sum(demand[segment_j])\n\n                if (np.sum(demand[route_i]) - total_demand_i + total_demand_j <= capacity and\n                    np.sum(demand[route_j]) - total_demand_j + total_demand_i <= capacity):\n                    # Perform swap\n                    new_route_i = np.concatenate([route_i[:pos_i], segment_j, route_i[pos_i+swap_len:]])\n                    new_route_j = np.concatenate([route_j[:pos_j], segment_i, route_j[pos_j+swap_len:]])\n\n                    # Update solution if improvement\n                    if (np.sum(distance_matrix[new_route_i[:-1], new_route_i[1:]]) +\n                        np.sum(distance_matrix[new_route_j[:-1], new_route_j[1:]]) <\n                        np.sum(distance_matrix[route_i[:-1], route_i[1:]]) +\n                        np.sum(distance_matrix[route_j[:-1], route_j[1:]])):\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n\n        # Demand-balanced merge (if routes can be merged without exceeding capacity)\n        if len(new_solution) > 1:\n            for _ in range(2):  # Try a few random merges\n                i, j = np.random.choice(len(new_solution), 2, replace=False)\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n                    # Try merging in both directions\n                    merged1 = np.concatenate([route_i[:-1], route_j[1:]])\n                    merged2 = np.concatenate([route_j[:-1], route_i[1:]])\n\n                    # Select the better merge\n                    dist1 = np.sum(distance_matrix[merged1[:-1], merged1[1:]])\n                    dist2 = np.sum(distance_matrix[merged2[:-1], merged2[1:]])\n\n                    if dist1 < dist2:\n                        new_solution[i] = merged1\n                        del new_solution[j]\n                    else:\n                        new_solution[j] = merged2\n                        del new_solution[i]\n\n                    # Break after first successful merge\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route segmentation and demand-based insertion to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Hybrid local search: segment routes and reinsert nodes based on demand\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Segment the route into two parts\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Reinsert nodes from part2 into part1 based on demand proximity\n        remaining_nodes = part2[1:-1].copy()\n        random.shuffle(remaining_nodes)\n\n        new_route = part1.copy()\n        for node in remaining_nodes:\n            # Find the best insertion position in part1 to minimize total distance\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(new_route)):\n                # Check capacity constraint\n                segment_demand = sum(demand[new_route[i-1:i+1]])\n                if segment_demand + demand[node] <= capacity:\n                    cost = distance_matrix[new_route[i-1], node] + distance_matrix[node, new_route[i]] - distance_matrix[new_route[i-1], new_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            # Insert the node\n            new_route = np.insert(new_route, best_pos, node)\n\n        new_solution.append(new_route)\n\n    # Merge small routes if possible\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        if len(new_solution[i]) <= 3:\n            merged = False\n            for j in range(len(merged_solution)):\n                if sum(demand[merged_solution[j][1:-1]]) + sum(demand[new_solution[i][1:-1]]) <= capacity:\n                    # Merge the routes\n                    merged_route = np.concatenate((merged_solution[j][:-1], new_solution[i][1:]))\n                    merged_solution[j] = merged_route\n                    merged = True\n                    break\n            if not merged:\n                merged_solution.append(new_solution[i].copy())\n        else:\n            merged_solution.append(new_solution[i].copy())\n        i += 1\n\n    return merged_solution\n\n",
        "score": [
            -0.8029067316746724,
            7.0396662056446075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Hybrid local search: segment routes and reinsert nodes based on demand\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Segment the route into two parts\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Reinsert nodes from part2 into part1 based on demand proximity\n        remaining_nodes = part2[1:-1].copy()\n        random.shuffle(remaining_nodes)\n\n        new_route = part1.copy()\n        for node in remaining_nodes:\n            # Find the best insertion position in part1 to minimize total distance\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(new_route)):\n                # Check capacity constraint\n                segment_demand = sum(demand[new_route[i-1:i+1]])\n                if segment_demand + demand[node] <= capacity:\n                    cost = distance_matrix[new_route[i-1], node] + distance_matrix[node, new_route[i]] - distance_matrix[new_route[i-1], new_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            # Insert the node\n            new_route = np.insert(new_route, best_pos, node)\n\n        new_solution.append(new_route)\n\n    # Merge small routes if possible\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        if len(new_solution[i]) <= 3:\n            merged = False\n            for j in range(len(merged_solution)):\n                if sum(demand[merged_solution[j][1:-1]]) + sum(demand[new_solution[i][1:-1]]) <= capacity:\n                    # Merge the routes\n                    merged_route = np.concatenate((merged_solution[j][:-1], new_solution[i][1:]))\n                    merged_solution[j] = merged_route\n                    merged = True\n                    break\n            if not merged:\n                merged_solution.append(new_solution[i].copy())\n        else:\n            merged_solution.append(new_solution[i].copy())\n        i += 1\n\n    return merged_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and route diversity, then applies a hybrid local search operator that combines route merging, cross-exchange, and demand-balanced route splitting to generate a feasible neighbor solution while reducing both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (1 + obj[1]) for sol, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Route merging: combine two routes if their combined demand fits capacity\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if combined_demand <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n    elif len(new_solution) > 1 and random.random() < 0.5:\n        # Cross-exchange: exchange segments between two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to exchange\n            seg1_start, seg1_end = sorted(random.sample(range(1, len(route1)-1), 2))\n            seg2_start, seg2_end = sorted(random.sample(range(1, len(route2)-1), 2))\n            seg1, seg2 = route1[seg1_start:seg1_end+1], route2[seg2_start:seg2_end+1]\n            # Check capacity constraints\n            new_route1_demand = sum(demand[route1[1:seg1_start]]) + sum(demand[seg2]) + sum(demand[route1[seg1_end+1:-1]])\n            new_route2_demand = sum(demand[route2[1:seg2_start]]) + sum(demand[seg1]) + sum(demand[route2[seg2_end+1:-1]])\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end+1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end+1:]])\n                new_solution[i], new_solution[j] = new_route1, new_route2\n    else:\n        # Demand-balanced route splitting: split a long route into two balanced parts\n        longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            split_pos = len(longest_route) // 2\n            first_part = longest_route[:split_pos+1]\n            second_part = np.concatenate([[0], longest_route[split_pos:]])\n            # Check capacity constraints\n            if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = first_part\n                new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.590627484957563,
            1.271294355392456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (1 + obj[1]) for sol, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Route merging: combine two routes if their combined demand fits capacity\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if combined_demand <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n    elif len(new_solution) > 1 and random.random() < 0.5:\n        # Cross-exchange: exchange segments between two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to exchange\n            seg1_start, seg1_end = sorted(random.sample(range(1, len(route1)-1), 2))\n            seg2_start, seg2_end = sorted(random.sample(range(1, len(route2)-1), 2))\n            seg1, seg2 = route1[seg1_start:seg1_end+1], route2[seg2_start:seg2_end+1]\n            # Check capacity constraints\n            new_route1_demand = sum(demand[route1[1:seg1_start]]) + sum(demand[seg2]) + sum(demand[route1[seg1_end+1:-1]])\n            new_route2_demand = sum(demand[route2[1:seg2_start]]) + sum(demand[seg1]) + sum(demand[route2[seg2_end+1:-1]])\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end+1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end+1:]])\n                new_solution[i], new_solution[j] = new_route1, new_route2\n    else:\n        # Demand-balanced route splitting: split a long route into two balanced parts\n        longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            split_pos = len(longest_route) // 2\n            first_part = longest_route[:split_pos+1]\n            second_part = np.concatenate([[0], longest_route[split_pos:]])\n            # Check capacity constraints\n            if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = first_part\n                new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    variances = [(sol, (obj[1] - obj[0])**2) for sol, obj in archive]\n    selected_sol = max(variances, key=lambda x: x[1])[0]\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_sol]\n\n    # Randomly select a route to split\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Find the most distant pair of nodes in the selected route\n    max_dist = -1\n    split_pos = -1\n    for i in range(1, len(selected_route)-1):\n        dist = distance_matrix[selected_route[i-1]][selected_route[i+1]]\n        if dist > max_dist:\n            max_dist = dist\n            split_pos = i\n\n    if split_pos > 0:\n        # Split the route at the identified position\n        split_route = selected_route[split_pos:]\n        new_solution[route_idx] = selected_route[:split_pos+1]\n        new_solution.append(split_route)\n\n        # Attempt to reinsert nodes from the split route into other routes\n        for node in split_route[1:-1]:\n            best_route = None\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                route = new_solution[i]\n\n                # Check all possible insertion positions\n                for j in range(1, len(route)):\n                    # Calculate the cost of inserting the node\n                    cost = (distance_matrix[route[j-1]][node] +\n                            distance_matrix[node][route[j]] -\n                            distance_matrix[route[j-1]][route[j]])\n\n                    # Check capacity constraint\n                    route_capacity = sum(demand[route[1:-1]])\n                    if route_capacity + demand[node] <= capacity and cost < best_cost:\n                        best_route = i\n                        best_pos = j\n                        best_cost = cost\n\n            if best_route is not None:\n                # Perform the insertion\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.751729594715098,
            7.977339506149292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    variances = [(sol, (obj[1] - obj[0])**2) for sol, obj in archive]\n    selected_sol = max(variances, key=lambda x: x[1])[0]\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_sol]\n\n    # Randomly select a route to split\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Find the most distant pair of nodes in the selected route\n    max_dist = -1\n    split_pos = -1\n    for i in range(1, len(selected_route)-1):\n        dist = distance_matrix[selected_route[i-1]][selected_route[i+1]]\n        if dist > max_dist:\n            max_dist = dist\n            split_pos = i\n\n    if split_pos > 0:\n        # Split the route at the identified position\n        split_route = selected_route[split_pos:]\n        new_solution[route_idx] = selected_route[:split_pos+1]\n        new_solution.append(split_route)\n\n        # Attempt to reinsert nodes from the split route into other routes\n        for node in split_route[1:-1]:\n            best_route = None\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                route = new_solution[i]\n\n                # Check all possible insertion positions\n                for j in range(1, len(route)):\n                    # Calculate the cost of inserting the node\n                    cost = (distance_matrix[route[j-1]][node] +\n                            distance_matrix[node][route[j]] -\n                            distance_matrix[route[j-1]][route[j]])\n\n                    # Check capacity constraint\n                    route_capacity = sum(demand[route[1:-1]])\n                    if route_capacity + demand[node] <= capacity and cost < best_cost:\n                        best_route = i\n                        best_pos = j\n                        best_cost = cost\n\n            if best_route is not None:\n                # Perform the insertion\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Attempt to split the route into two parts\n        if len(selected_route) > 3:\n            split_pos = np.random.randint(1, len(selected_route) - 1)\n            new_route1 = selected_route[:split_pos + 1]\n            new_route2 = selected_route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n            else:\n                # If split fails, try to move a random customer to another route\n                move_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                move_route = new_solution[move_route_idx]\n                if len(move_route) < 3:\n                    return new_solution\n\n                # Select a random customer from the selected route (excluding depot)\n                customer_idx = np.random.randint(1, len(selected_route) - 1)\n                customer = selected_route[customer_idx]\n\n                # Check if adding the customer to the target route is feasible\n                if sum(demand[node] for node in move_route[1:-1]) + demand[customer] <= capacity:\n                    # Insert the customer into the target route (random position)\n                    insert_pos = np.random.randint(1, len(move_route))\n                    move_route = np.insert(move_route, insert_pos, customer)\n\n                    # Remove the customer from the original route\n                    selected_route = np.delete(selected_route, customer_idx)\n\n                    # Update the solution\n                    new_solution[route_idx] = selected_route\n                    new_solution[move_route_idx] = move_route\n\n    return new_solution\n\n",
        "score": [
            -0.6946180938972906,
            0.24317339062690735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Attempt to split the route into two parts\n        if len(selected_route) > 3:\n            split_pos = np.random.randint(1, len(selected_route) - 1)\n            new_route1 = selected_route[:split_pos + 1]\n            new_route2 = selected_route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n            else:\n                # If split fails, try to move a random customer to another route\n                move_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                move_route = new_solution[move_route_idx]\n                if len(move_route) < 3:\n                    return new_solution\n\n                # Select a random customer from the selected route (excluding depot)\n                customer_idx = np.random.randint(1, len(selected_route) - 1)\n                customer = selected_route[customer_idx]\n\n                # Check if adding the customer to the target route is feasible\n                if sum(demand[node] for node in move_route[1:-1]) + demand[customer] <= capacity:\n                    # Insert the customer into the target route (random position)\n                    insert_pos = np.random.randint(1, len(move_route))\n                    move_route = np.insert(move_route, insert_pos, customer)\n\n                    # Remove the customer from the original route\n                    selected_route = np.delete(selected_route, customer_idx)\n\n                    # Update the solution\n                    new_solution[route_idx] = selected_route\n                    new_solution[move_route_idx] = move_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{The algorithm selects a promising solution from the archive using a weighted random selection based on normalized objective values, then applies a hybrid local search combining route splitting, intra-route insertion, and cross-route exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to [0, 1] range\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    if len(total_distances) > 1:\n        total_distances = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances))\n        makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans))\n\n    # Combine objectives with weights (adjust weights as needed)\n    scores = 0.5 * total_distances + 0.5 * makespans\n    probabilities = (1.0 - scores) / np.sum(1.0 - scores)  # Higher score gets lower probability\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Step 2: Apply hybrid local search\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, intra-route insertion, and cross-route exchange\n    for _ in range(10):  # Number of local search iterations\n        # Randomly choose one of the three operators\n        operator = random.choice(['split', 'insert', 'exchange'])\n\n        if operator == 'split':\n            # Route splitting: split a long route into two shorter routes\n            if len(new_solution) < 2 * len(archive[0][0]):  # Prevent excessive route splitting\n                route_idx = random.randint(0, len(new_solution) - 1)\n                route = new_solution[route_idx]\n                if len(route) > 4:  # Only split routes with enough customers\n                    split_pos = random.randint(1, len(route) - 2)\n                    new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                        np.sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = new_route1\n                        new_solution.insert(route_idx + 1, new_route2)\n\n        elif operator == 'insert':\n            # Intra-route insertion: move a customer to a different position in the same route\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:  # Only perform if route has enough customers\n                # Choose a customer to move (exclude depot)\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Remove customer from current position\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n\n                # Insert customer at a new position\n                insert_pos = random.randint(1, len(new_route) - 1)\n                new_route = np.concatenate([new_route[:insert_pos], [customer], new_route[insert_pos:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        elif operator == 'exchange':\n            # Cross-route exchange: exchange two customers between two different routes\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 2 and len(route2) > 2:  # Both routes must have at least one customer\n                    # Choose customers to exchange (exclude depot)\n                    customer1_pos = random.randint(1, len(route1) - 2)\n                    customer2_pos = random.randint(1, len(route2) - 2)\n\n                    customer1 = route1[customer1_pos]\n                    customer2 = route2[customer2_pos]\n\n                    # Create new routes after exchange\n                    new_route1 = np.concatenate([route1[:customer1_pos], [customer2], route1[customer1_pos + 1:]])\n                    new_route2 = np.concatenate([route2[:customer2_pos], [customer1], route2[customer2_pos + 1:]])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                        np.sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8171815110336299,
            2.4937921166419983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to [0, 1] range\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    if len(total_distances) > 1:\n        total_distances = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances))\n        makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans))\n\n    # Combine objectives with weights (adjust weights as needed)\n    scores = 0.5 * total_distances + 0.5 * makespans\n    probabilities = (1.0 - scores) / np.sum(1.0 - scores)  # Higher score gets lower probability\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Step 2: Apply hybrid local search\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, intra-route insertion, and cross-route exchange\n    for _ in range(10):  # Number of local search iterations\n        # Randomly choose one of the three operators\n        operator = random.choice(['split', 'insert', 'exchange'])\n\n        if operator == 'split':\n            # Route splitting: split a long route into two shorter routes\n            if len(new_solution) < 2 * len(archive[0][0]):  # Prevent excessive route splitting\n                route_idx = random.randint(0, len(new_solution) - 1)\n                route = new_solution[route_idx]\n                if len(route) > 4:  # Only split routes with enough customers\n                    split_pos = random.randint(1, len(route) - 2)\n                    new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                        np.sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = new_route1\n                        new_solution.insert(route_idx + 1, new_route2)\n\n        elif operator == 'insert':\n            # Intra-route insertion: move a customer to a different position in the same route\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:  # Only perform if route has enough customers\n                # Choose a customer to move (exclude depot)\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Remove customer from current position\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n\n                # Insert customer at a new position\n                insert_pos = random.randint(1, len(new_route) - 1)\n                new_route = np.concatenate([new_route[:insert_pos], [customer], new_route[insert_pos:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        elif operator == 'exchange':\n            # Cross-route exchange: exchange two customers between two different routes\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 2 and len(route2) > 2:  # Both routes must have at least one customer\n                    # Choose customers to exchange (exclude depot)\n                    customer1_pos = random.randint(1, len(route1) - 2)\n                    customer2_pos = random.randint(1, len(route2) - 2)\n\n                    customer1 = route1[customer1_pos]\n                    customer2 = route2[customer2_pos]\n\n                    # Create new routes after exchange\n                    new_route1 = np.concatenate([route1[:customer1_pos], [customer2], route1[customer1_pos + 1:]])\n                    new_route2 = np.concatenate([route2[:customer2_pos], [customer1], route2[customer2_pos + 1:]])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                        np.sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{A novel hybrid local search operator combines route fragmentation and adaptive insertion, where critical segments are dynamically extracted based on makespan and distance contributions, followed by intelligent reinsertion to balance route lengths and reduce total distance while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()  # Select solution with highest makespan\n    new_solution = selected_solution.copy()\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Extract critical segments (nodes contributing most to makespan)\n    segment_lengths = distance_matrix[longest_route[:-1], longest_route[1:]]\n    critical_nodes = np.where(segment_lengths > np.percentile(segment_lengths, 75))[0] + 1  # Nodes with top 25% segment lengths\n    critical_segments = [longest_route[i] for i in critical_nodes]\n\n    # Remove critical segments from the route\n    remaining_nodes = [node for node in longest_route if node not in critical_segments and node != 0]\n    new_solution[longest_route_idx] = np.array([0] + remaining_nodes + [0])\n\n    # Reinsert critical segments into other routes or new routes\n    for node in critical_segments:\n        best_insertion = None\n        best_cost = float('inf')\n\n        for route_idx, route in enumerate(new_solution):\n            for i in range(len(route) - 1):\n                insertion_cost = distance_matrix[route[i], node] + distance_matrix[node, route[i+1]] - distance_matrix[route[i], route[i+1]]\n                if sum(demand[route]) + demand[node] <= capacity:\n                    if insertion_cost < best_cost:\n                        best_cost = insertion_cost\n                        best_insertion = (route_idx, i, node)\n\n        if best_insertion:\n            route_idx, pos, node = best_insertion\n            new_solution[route_idx] = np.insert(new_solution[route_idx], pos + 1, node)\n\n    # Ensure no route exceeds capacity\n    for route in new_solution:\n        if sum(demand[route]) > capacity:\n            # If capacity is exceeded, revert to original solution\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5391932101105531,
            7.191403746604919
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()  # Select solution with highest makespan\n    new_solution = selected_solution.copy()\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Extract critical segments (nodes contributing most to makespan)\n    segment_lengths = distance_matrix[longest_route[:-1], longest_route[1:]]\n    critical_nodes = np.where(segment_lengths > np.percentile(segment_lengths, 75))[0] + 1  # Nodes with top 25% segment lengths\n    critical_segments = [longest_route[i] for i in critical_nodes]\n\n    # Remove critical segments from the route\n    remaining_nodes = [node for node in longest_route if node not in critical_segments and node != 0]\n    new_solution[longest_route_idx] = np.array([0] + remaining_nodes + [0])\n\n    # Reinsert critical segments into other routes or new routes\n    for node in critical_segments:\n        best_insertion = None\n        best_cost = float('inf')\n\n        for route_idx, route in enumerate(new_solution):\n            for i in range(len(route) - 1):\n                insertion_cost = distance_matrix[route[i], node] + distance_matrix[node, route[i+1]] - distance_matrix[route[i], route[i+1]]\n                if sum(demand[route]) + demand[node] <= capacity:\n                    if insertion_cost < best_cost:\n                        best_cost = insertion_cost\n                        best_insertion = (route_idx, i, node)\n\n        if best_insertion:\n            route_idx, pos, node = best_insertion\n            new_solution[route_idx] = np.insert(new_solution[route_idx], pos + 1, node)\n\n    # Ensure no route exceeds capacity\n    for route in new_solution:\n        if sum(demand[route]) > capacity:\n            # If capacity is exceeded, revert to original solution\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{A hybrid local search strategy combines route merging, split insertion, and demand-aware rebalancing to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)  # Sort by makespan descending\n    selected_idx = min(len(archive) // 2, len(archive) - 1)  # Pick from top half\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route merging + split insertion + demand rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Merge two shortest routes if feasible and beneficial\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        sorted_routes = sorted(range(len(route_lengths)), key=lambda x: route_lengths[x])\n\n        if len(sorted_routes) >= 2:\n            i, j = sorted_routes[0], sorted_routes[1]\n            merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n            merged_demand = sum(demand[node] for node in merged_route[1:-1])\n\n            if merged_demand <= capacity:\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    # Step 2: Split insertion - move a customer from a long route to a short route if feasible\n    if len(new_solution) > 1:\n        long_route_idx = np.argmax([len(route) for route in new_solution])\n        short_route_idx = np.argmin([len(route) for route in new_solution])\n\n        if long_route_idx != short_route_idx and len(new_solution[long_route_idx]) > 3:\n            long_route = new_solution[long_route_idx]\n            short_route = new_solution[short_route_idx]\n\n            # Select a random customer from long route (not depot)\n            candidate_idx = random.randint(1, len(long_route)-2)\n            candidate_node = long_route[candidate_idx]\n\n            # Check if insertion is feasible\n            if demand[candidate_node] <= capacity - sum(demand[node] for node in short_route[1:-1]):\n                # Find best insertion position in short route\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(short_route)):\n                    cost = distance_matrix[short_route[pos-1], candidate_node] + \\\n                           distance_matrix[candidate_node, short_route[pos]] - \\\n                           distance_matrix[short_route[pos-1], short_route[pos]]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Perform insertion\n                new_short_route = np.insert(short_route, best_pos, candidate_node)\n                new_solution[short_route_idx] = new_short_route\n                new_long_route = np.delete(long_route, candidate_idx)\n                new_solution[long_route_idx] = new_long_route\n\n    # Step 3: Demand-aware rebalancing - adjust routes to balance demand\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select two customers and swap if beneficial\n            i, j = random.sample(range(1, len(route)-1), 2)\n            node_i, node_j = route[i], route[j]\n\n            # Current cost\n            current_cost = distance_matrix[route[i-1], node_i] + distance_matrix[node_i, route[i+1]] + \\\n                           distance_matrix[route[j-1], node_j] + distance_matrix[node_j, route[j+1]]\n\n            # Swapped cost\n            swapped_cost = distance_matrix[route[i-1], node_j] + distance_matrix[node_j, route[i+1]] + \\\n                           distance_matrix[route[j-1], node_i] + distance_matrix[node_i, route[j+1]]\n\n            if swapped_cost < current_cost:\n                route[i], route[j] = route[j], route[i]\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # If infeasible, revert to original solution\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.31864519897999455,
            1.7183449566364288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)  # Sort by makespan descending\n    selected_idx = min(len(archive) // 2, len(archive) - 1)  # Pick from top half\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route merging + split insertion + demand rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Merge two shortest routes if feasible and beneficial\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        sorted_routes = sorted(range(len(route_lengths)), key=lambda x: route_lengths[x])\n\n        if len(sorted_routes) >= 2:\n            i, j = sorted_routes[0], sorted_routes[1]\n            merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n            merged_demand = sum(demand[node] for node in merged_route[1:-1])\n\n            if merged_demand <= capacity:\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    # Step 2: Split insertion - move a customer from a long route to a short route if feasible\n    if len(new_solution) > 1:\n        long_route_idx = np.argmax([len(route) for route in new_solution])\n        short_route_idx = np.argmin([len(route) for route in new_solution])\n\n        if long_route_idx != short_route_idx and len(new_solution[long_route_idx]) > 3:\n            long_route = new_solution[long_route_idx]\n            short_route = new_solution[short_route_idx]\n\n            # Select a random customer from long route (not depot)\n            candidate_idx = random.randint(1, len(long_route)-2)\n            candidate_node = long_route[candidate_idx]\n\n            # Check if insertion is feasible\n            if demand[candidate_node] <= capacity - sum(demand[node] for node in short_route[1:-1]):\n                # Find best insertion position in short route\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(short_route)):\n                    cost = distance_matrix[short_route[pos-1], candidate_node] + \\\n                           distance_matrix[candidate_node, short_route[pos]] - \\\n                           distance_matrix[short_route[pos-1], short_route[pos]]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Perform insertion\n                new_short_route = np.insert(short_route, best_pos, candidate_node)\n                new_solution[short_route_idx] = new_short_route\n                new_long_route = np.delete(long_route, candidate_idx)\n                new_solution[long_route_idx] = new_long_route\n\n    # Step 3: Demand-aware rebalancing - adjust routes to balance demand\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select two customers and swap if beneficial\n            i, j = random.sample(range(1, len(route)-1), 2)\n            node_i, node_j = route[i], route[j]\n\n            # Current cost\n            current_cost = distance_matrix[route[i-1], node_i] + distance_matrix[node_i, route[i+1]] + \\\n                           distance_matrix[route[j-1], node_j] + distance_matrix[node_j, route[j+1]]\n\n            # Swapped cost\n            swapped_cost = distance_matrix[route[i-1], node_j] + distance_matrix[node_j, route[i+1]] + \\\n                           distance_matrix[route[j-1], node_i] + distance_matrix[node_i, route[j+1]]\n\n            if swapped_cost < current_cost:\n                route[i], route[j] = route[j], route[i]\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # If infeasible, revert to original solution\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Identify the longest route and split it into two shorter routes\n    longest_route = max(selected_solution, key=lambda route: sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)))\n    if len(longest_route) <= 3:  # Cannot split further\n        return selected_solution\n\n    split_idx = len(longest_route) // 2\n    new_route1 = longest_route[:split_idx + 1]\n    new_route2 = [0] + longest_route[split_idx:]\n\n    # Step 3: Reinsert customers from the split routes into other routes or new routes to balance capacity\n    def reinsert_customer(route, customer_idx):\n        for i in range(1, len(route)):\n            if sum(demand[route[i]]) + demand[customer_idx] <= capacity:\n                route.insert(i, customer_idx)\n                return True\n        return False\n\n    customers_to_reinsert = [c for c in longest_route[1:-1] if c not in new_route1 and c not in new_route2]\n    for customer in customers_to_reinsert:\n        reinserted = False\n        for route in selected_solution:\n            if reinserted := reinsert_customer(route, customer):\n                break\n        if not reinserted:\n            new_route = [0, customer, 0]\n            selected_solution.append(new_route)\n\n    # Step 4: Remove empty routes and update the solution\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n    selected_solution.append(new_route1)\n    selected_solution.append(new_route2)\n\n    return selected_solution\n\n",
        "score": [
            -0.8025180682409454,
            0.8231942653656006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Identify the longest route and split it into two shorter routes\n    longest_route = max(selected_solution, key=lambda route: sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)))\n    if len(longest_route) <= 3:  # Cannot split further\n        return selected_solution\n\n    split_idx = len(longest_route) // 2\n    new_route1 = longest_route[:split_idx + 1]\n    new_route2 = [0] + longest_route[split_idx:]\n\n    # Step 3: Reinsert customers from the split routes into other routes or new routes to balance capacity\n    def reinsert_customer(route, customer_idx):\n        for i in range(1, len(route)):\n            if sum(demand[route[i]]) + demand[customer_idx] <= capacity:\n                route.insert(i, customer_idx)\n                return True\n        return False\n\n    customers_to_reinsert = [c for c in longest_route[1:-1] if c not in new_route1 and c not in new_route2]\n    for customer in customers_to_reinsert:\n        reinserted = False\n        for route in selected_solution:\n            if reinserted := reinsert_customer(route, customer):\n                break\n        if not reinserted:\n            new_route = [0, customer, 0]\n            selected_solution.append(new_route)\n\n    # Step 4: Remove empty routes and update the solution\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n    selected_solution.append(new_route1)\n    selected_solution.append(new_route2)\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and intra-route relocation with capacity checks\n    if len(new_solution) > 1:\n        # Randomly select two routes and attempt to merge them if feasible\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route_j into route_i at the best position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(1, len(route_i)):\n                # Insert route_j between pos and pos+1 in route_i\n                temp_route = np.concatenate([route_i[:pos], route_j[1:-1], route_i[pos:]])\n                temp_cost = np.sum(distance_matrix[temp_route[:-1], temp_route[1:]])\n                if temp_cost < best_cost:\n                    best_cost = temp_cost\n                    best_pos = pos\n            # Perform the merge\n            merged_route = np.concatenate([route_i[:best_pos], route_j[1:-1], route_i[best_pos:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n    # Apply intra-route relocation with capacity checks\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route has no customers\n            continue\n\n        # Randomly select a customer to relocate\n        customer_idx = np.random.randint(1, len(route) - 1)\n        customer = route[customer_idx]\n\n        # Try inserting the customer in a different position in the same route\n        for new_pos in range(1, len(route) - 1):\n            if new_pos == customer_idx or new_pos == customer_idx - 1:\n                continue\n\n            # Check capacity constraint for the new position\n            segment = route[1:new_pos] if new_pos > customer_idx else route[new_pos:customer_idx]\n            if np.sum(demand[np.concatenate([segment, [customer]])]) <= capacity:\n                # Perform the relocation\n                new_route = np.delete(route, customer_idx)\n                new_route = np.insert(new_route, new_pos, customer)\n                new_solution[route_idx] = new_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5053281078950861,
            2.470834642648697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and intra-route relocation with capacity checks\n    if len(new_solution) > 1:\n        # Randomly select two routes and attempt to merge them if feasible\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route_j into route_i at the best position\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(1, len(route_i)):\n                # Insert route_j between pos and pos+1 in route_i\n                temp_route = np.concatenate([route_i[:pos], route_j[1:-1], route_i[pos:]])\n                temp_cost = np.sum(distance_matrix[temp_route[:-1], temp_route[1:]])\n                if temp_cost < best_cost:\n                    best_cost = temp_cost\n                    best_pos = pos\n            # Perform the merge\n            merged_route = np.concatenate([route_i[:best_pos], route_j[1:-1], route_i[best_pos:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n    # Apply intra-route relocation with capacity checks\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route has no customers\n            continue\n\n        # Randomly select a customer to relocate\n        customer_idx = np.random.randint(1, len(route) - 1)\n        customer = route[customer_idx]\n\n        # Try inserting the customer in a different position in the same route\n        for new_pos in range(1, len(route) - 1):\n            if new_pos == customer_idx or new_pos == customer_idx - 1:\n                continue\n\n            # Check capacity constraint for the new position\n            segment = route[1:new_pos] if new_pos > customer_idx else route[new_pos:customer_idx]\n            if np.sum(demand[np.concatenate([segment, [customer]])]) <= capacity:\n                # Perform the relocation\n                new_route = np.delete(route, customer_idx)\n                new_route = np.insert(new_route, new_pos, customer)\n                new_solution[route_idx] = new_route\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{A novel hybrid local search operator is designed by combining route splitting, customer exchange, and route merging to intelligently balance distance and makespan objectives, while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_solution = archive[0][0].copy()\n\n    # Make a deep copy to avoid modifying the original\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 5:  # Arbitrary threshold to decide if splitting is needed\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = [0] + route[split_pos + 1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer exchange between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to find a customer in route1 to move to route2\n        for i in range(1, len(route1) - 1):\n            customer = route1[i]\n            # Check if moving this customer to route2 violates capacity\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Find the best insertion position in route2\n                best_pos = 1\n                min_increase = float('inf')\n                for j in range(1, len(route2)):\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[route2[j-1]][customer] +\n                                    distance_matrix[customer][route2[j]] -\n                                    distance_matrix[route2[j-1]][route2[j]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = j\n\n                # Perform the exchange\n                new_route1 = np.delete(route1, i)\n                new_route2 = np.insert(route2, best_pos, customer)\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n    # Step 3: Route merging (if two routes are short)\n    if len(new_solution) > 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is possible without violating capacity\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Find the best way to merge (connecting the end of route1 to the start of route2)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7134675517242732,
            0.45538052916526794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_solution = archive[0][0].copy()\n\n    # Make a deep copy to avoid modifying the original\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 5:  # Arbitrary threshold to decide if splitting is needed\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = [0] + route[split_pos + 1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer exchange between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to find a customer in route1 to move to route2\n        for i in range(1, len(route1) - 1):\n            customer = route1[i]\n            # Check if moving this customer to route2 violates capacity\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Find the best insertion position in route2\n                best_pos = 1\n                min_increase = float('inf')\n                for j in range(1, len(route2)):\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[route2[j-1]][customer] +\n                                    distance_matrix[customer][route2[j]] -\n                                    distance_matrix[route2[j-1]][route2[j]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = j\n\n                # Perform the exchange\n                new_route1 = np.delete(route1, i)\n                new_route2 = np.insert(route2, best_pos, customer)\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n    # Step 3: Route merging (if two routes are short)\n    if len(new_solution) > 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is possible without violating capacity\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Find the best way to merge (connecting the end of route1 to the start of route2)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route splitting and customer reallocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route splitting and customer reallocation\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a route to split\n    if len(new_solution) > 1:\n        route_to_split = random.choice(new_solution)\n\n        # Find a feasible split point (not at the ends)\n        if len(route_to_split) > 3:  # At least depot, one customer, depot\n            split_pos = random.randint(1, len(route_to_split) - 2)\n\n            # Split the route into two parts\n            first_part = route_to_split[:split_pos + 1]\n            second_part = route_to_split[split_pos:]\n\n            # Ensure the new routes are feasible\n            first_demand = sum(demand[node] for node in first_part[1:-1])\n            second_demand = sum(demand[node] for node in second_part[1:-1])\n\n            if first_demand <= capacity and second_demand <= capacity:\n                # Replace the original route with the two new routes\n                new_solution = [route for route in new_solution if not np.array_equal(route, route_to_split)]\n                new_solution.append(first_part)\n                new_solution.append(second_part)\n\n    # Step 2: Randomly reallocate a customer to another route if feasible\n    if len(new_solution) > 1:\n        # Select a random route and a random customer (not depot)\n        source_route = random.choice(new_solution)\n        if len(source_route) > 2:  # More than just depots\n            customer_to_move = random.choice(source_route[1:-1])\n\n            # Find possible insertion positions in other routes\n            for target_route in new_solution:\n                if len(target_route) < 2:\n                    continue  # Skip empty routes\n\n                # Check all possible insertion positions\n                for i in range(1, len(target_route)):\n                    # Insert customer and check feasibility\n                    temp_route = np.insert(target_route, i, customer_to_move)\n                    temp_demand = sum(demand[node] for node in temp_route[1:-1])\n\n                    if temp_demand <= capacity:\n                        # Update routes\n                        new_solution = [route for route in new_solution if not np.array_equal(route, source_route)]\n                        new_solution = [route for route in new_solution if not np.array_equal(route, target_route)]\n\n                        new_source_route = np.delete(source_route, np.where(source_route == customer_to_move))\n                        new_solution.append(new_source_route)\n                        new_solution.append(temp_route)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.789239204728932,
            7.394938737154007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route splitting and customer reallocation\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a route to split\n    if len(new_solution) > 1:\n        route_to_split = random.choice(new_solution)\n\n        # Find a feasible split point (not at the ends)\n        if len(route_to_split) > 3:  # At least depot, one customer, depot\n            split_pos = random.randint(1, len(route_to_split) - 2)\n\n            # Split the route into two parts\n            first_part = route_to_split[:split_pos + 1]\n            second_part = route_to_split[split_pos:]\n\n            # Ensure the new routes are feasible\n            first_demand = sum(demand[node] for node in first_part[1:-1])\n            second_demand = sum(demand[node] for node in second_part[1:-1])\n\n            if first_demand <= capacity and second_demand <= capacity:\n                # Replace the original route with the two new routes\n                new_solution = [route for route in new_solution if not np.array_equal(route, route_to_split)]\n                new_solution.append(first_part)\n                new_solution.append(second_part)\n\n    # Step 2: Randomly reallocate a customer to another route if feasible\n    if len(new_solution) > 1:\n        # Select a random route and a random customer (not depot)\n        source_route = random.choice(new_solution)\n        if len(source_route) > 2:  # More than just depots\n            customer_to_move = random.choice(source_route[1:-1])\n\n            # Find possible insertion positions in other routes\n            for target_route in new_solution:\n                if len(target_route) < 2:\n                    continue  # Skip empty routes\n\n                # Check all possible insertion positions\n                for i in range(1, len(target_route)):\n                    # Insert customer and check feasibility\n                    temp_route = np.insert(target_route, i, customer_to_move)\n                    temp_demand = sum(demand[node] for node in temp_route[1:-1])\n\n                    if temp_demand <= capacity:\n                        # Update routes\n                        new_solution = [route for route in new_solution if not np.array_equal(route, source_route)]\n                        new_solution = [route for route in new_solution if not np.array_equal(route, target_route)]\n\n                        new_source_route = np.delete(source_route, np.where(source_route == customer_to_move))\n                        new_solution.append(new_source_route)\n                        new_solution.append(temp_route)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{A hybrid local search operator that combines route splitting, customer reallocation, and adaptive route merging to intelligently balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive)//3)])[0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting - split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough customers\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reallocation - move customers between routes\n    for _ in range(3):  # Try up to 3 reallocations\n        # Select two different routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a customer from route1 (not depot)\n        if len(route1) <= 2:\n            continue\n        customer_idx = random.randint(1, len(route1)-2)\n        customer = route1[customer_idx]\n\n        # Check if adding to route2 is feasible\n        if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            # Update routes\n            new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n            new_route2 = np.concatenate([route2[:-1], [customer], [0]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Adaptive route merging - merge short routes if beneficial\n    for i in range(len(new_solution)-1):\n        route1 = new_solution[i]\n        route2 = new_solution[i+1]\n\n        # Check if merging would reduce makespan\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Calculate distance reduction\n        original_dist = (distance_matrix[route1[-2], 0] +\n                        distance_matrix[route2[1], 0] +\n                        distance_matrix[0, route1[1]])\n        merged_dist = distance_matrix[route1[-2], route2[1]] + distance_matrix[0, route1[1]]\n\n        if (np.sum(demand[merged_route[1:-1]]) <= capacity and\n            merged_dist < original_dist):\n            new_solution[i] = merged_route\n            del new_solution[i+1]\n            break  # Only merge one pair per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.719662730324139,
            0.453369140625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive)//3)])[0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting - split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough customers\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reallocation - move customers between routes\n    for _ in range(3):  # Try up to 3 reallocations\n        # Select two different routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a customer from route1 (not depot)\n        if len(route1) <= 2:\n            continue\n        customer_idx = random.randint(1, len(route1)-2)\n        customer = route1[customer_idx]\n\n        # Check if adding to route2 is feasible\n        if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            # Update routes\n            new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n            new_route2 = np.concatenate([route2[:-1], [customer], [0]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Adaptive route merging - merge short routes if beneficial\n    for i in range(len(new_solution)-1):\n        route1 = new_solution[i]\n        route2 = new_solution[i+1]\n\n        # Check if merging would reduce makespan\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Calculate distance reduction\n        original_dist = (distance_matrix[route1[-2], 0] +\n                        distance_matrix[route2[1], 0] +\n                        distance_matrix[0, route1[1]])\n        merged_dist = distance_matrix[route1[-2], route2[1]] + distance_matrix[0, route1[1]]\n\n        if (np.sum(demand[merged_route[1:-1]]) <= capacity and\n            merged_dist < original_dist):\n            new_solution[i] = merged_route\n            del new_solution[i+1]\n            break  # Only merge one pair per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combined score of total distance and makespan, then applies a hybrid local search combining route swapping, insertion, and partial route reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combined score (total_distance + makespan)\n    scores = [(total_dist + makespan) for _, (total_dist, makespan) in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search\n    if len(new_solution) >= 2:\n        # Randomly select two routes for swapping or merging\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n\n        # Check if merging is feasible\n        if np.sum(demand[new_solution[r1][1:-1]]) + np.sum(demand[new_solution[r2][1:-1]]) <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([new_solution[r1][:-1], new_solution[r2][1:]])\n            new_solution[r1] = merged_route\n            del new_solution[r2]\n        else:\n            # Swap a segment between two routes if feasible\n            if len(new_solution[r1]) > 3 and len(new_solution[r2]) > 3:\n                # Select a segment from r1 to insert into r2\n                start = random.randint(1, len(new_solution[r1]) - 3)\n                end = random.randint(start + 1, len(new_solution[r1]) - 2)\n                segment = new_solution[r1][start:end]\n\n                # Check if inserting the segment into r2 violates capacity\n                if np.sum(demand[segment]) + np.sum(demand[new_solution[r2][1:-1]]) <= capacity:\n                    # Insert the segment into r2\n                    insert_pos = random.randint(1, len(new_solution[r2]) - 1)\n                    new_solution[r2] = np.concatenate([new_solution[r2][:insert_pos], segment, new_solution[r2][insert_pos:]])\n                    # Remove the segment from r1\n                    new_solution[r1] = np.concatenate([new_solution[r1][:start], new_solution[r1][end:]])\n\n    # Apply partial route reversal to reduce makespan\n    for i in range(len(new_solution)):\n        if len(new_solution[i]) > 4:\n            # Select a random segment to reverse\n            start = random.randint(1, len(new_solution[i]) - 3)\n            end = random.randint(start + 1, len(new_solution[i]) - 2)\n            new_solution[i][start:end] = new_solution[i][start:end][::-1]\n\n    # Ensure all routes are feasible (capacity constraint)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.6144021125712772,
            0.6773910522460938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combined score (total_distance + makespan)\n    scores = [(total_dist + makespan) for _, (total_dist, makespan) in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search\n    if len(new_solution) >= 2:\n        # Randomly select two routes for swapping or merging\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n\n        # Check if merging is feasible\n        if np.sum(demand[new_solution[r1][1:-1]]) + np.sum(demand[new_solution[r2][1:-1]]) <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([new_solution[r1][:-1], new_solution[r2][1:]])\n            new_solution[r1] = merged_route\n            del new_solution[r2]\n        else:\n            # Swap a segment between two routes if feasible\n            if len(new_solution[r1]) > 3 and len(new_solution[r2]) > 3:\n                # Select a segment from r1 to insert into r2\n                start = random.randint(1, len(new_solution[r1]) - 3)\n                end = random.randint(start + 1, len(new_solution[r1]) - 2)\n                segment = new_solution[r1][start:end]\n\n                # Check if inserting the segment into r2 violates capacity\n                if np.sum(demand[segment]) + np.sum(demand[new_solution[r2][1:-1]]) <= capacity:\n                    # Insert the segment into r2\n                    insert_pos = random.randint(1, len(new_solution[r2]) - 1)\n                    new_solution[r2] = np.concatenate([new_solution[r2][:insert_pos], segment, new_solution[r2][insert_pos:]])\n                    # Remove the segment from r1\n                    new_solution[r1] = np.concatenate([new_solution[r1][:start], new_solution[r1][end:]])\n\n    # Apply partial route reversal to reduce makespan\n    for i in range(len(new_solution)):\n        if len(new_solution[i]) > 4:\n            # Select a random segment to reverse\n            start = random.randint(1, len(new_solution[i]) - 3)\n            end = random.randint(start + 1, len(new_solution[i]) - 2)\n            new_solution[i][start:end] = new_solution[i][start:end][::-1]\n\n    # Ensure all routes are feasible (capacity constraint)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route splitting, customer swapping, and route merging to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: split, swap, merge\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Split route_i into two parts\n        split_point = random.randint(1, len(route_i) - 2)\n        part1 = route_i[:split_point + 1]\n        part2 = route_i[split_point:]\n\n        # Check capacity feasibility for split parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            # Replace route_i with part1 and part2\n            new_solution[i] = part1\n            new_solution.append(part2)\n\n            # Try to merge route_j with part2 if possible\n            merged_route = np.concatenate([route_j, part2[1:-1], [0]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                new_solution.pop(j if j < i else j + 1)\n\n            # Swap two customers between new_solution[i] and new_solution[j]\n            if len(new_solution[i]) > 2 and len(new_solution[j]) > 2:\n                pos_i = random.randint(1, len(new_solution[i]) - 2)\n                pos_j = random.randint(1, len(new_solution[j]) - 2)\n                cust_i = new_solution[i][pos_i]\n                cust_j = new_solution[j][pos_j]\n\n                # Check capacity feasibility for swap\n                if (np.sum(demand[new_solution[i][1:-1]]) - demand[cust_i] + demand[cust_j] <= capacity and\n                    np.sum(demand[new_solution[j][1:-1]]) - demand[cust_j] + demand[cust_i] <= capacity):\n                    new_solution[i][pos_i], new_solution[j][pos_j] = cust_j, cust_i\n\n    return new_solution\n\n",
        "score": [
            -0.7171871657892774,
            0.12284210324287415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: split, swap, merge\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Split route_i into two parts\n        split_point = random.randint(1, len(route_i) - 2)\n        part1 = route_i[:split_point + 1]\n        part2 = route_i[split_point:]\n\n        # Check capacity feasibility for split parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            # Replace route_i with part1 and part2\n            new_solution[i] = part1\n            new_solution.append(part2)\n\n            # Try to merge route_j with part2 if possible\n            merged_route = np.concatenate([route_j, part2[1:-1], [0]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                new_solution.pop(j if j < i else j + 1)\n\n            # Swap two customers between new_solution[i] and new_solution[j]\n            if len(new_solution[i]) > 2 and len(new_solution[j]) > 2:\n                pos_i = random.randint(1, len(new_solution[i]) - 2)\n                pos_j = random.randint(1, len(new_solution[j]) - 2)\n                cust_i = new_solution[i][pos_i]\n                cust_j = new_solution[j][pos_j]\n\n                # Check capacity feasibility for swap\n                if (np.sum(demand[new_solution[i][1:-1]]) - demand[cust_i] + demand[cust_j] <= capacity and\n                    np.sum(demand[new_solution[j][1:-1]]) - demand[cust_j] + demand[cust_i] <= capacity):\n                    new_solution[i][pos_i], new_solution[j][pos_j] = cust_j, cust_i\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: adaptive route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split route at a random point to create two new routes\n        split_point = np.random.randint(1, len(route) - 1)\n        new_route1 = np.concatenate((route[:split_point + 1], [0]))\n        new_route2 = np.concatenate(([0], route[split_point:]))\n\n        # Check capacity feasibility for both new routes\n        demand1 = np.sum(demand[new_route1[1:-1]])\n        demand2 = np.sum(demand[new_route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.extend([new_route1, new_route2])\n        else:\n            # If split is infeasible, try reallocating a random customer to another route\n            if len(new_solution) > 1:\n                target_route_idx = np.random.randint(0, len(new_solution))\n                target_route = new_solution[target_route_idx]\n\n                # Find a customer in the current route to reallocate\n                if len(route) > 3:\n                    customer_idx = np.random.randint(1, len(route) - 1)\n                    customer = route[customer_idx]\n\n                    # Check if adding the customer to the target route is feasible\n                    if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into target route (greedy insertion)\n                        best_insert_pos = 1\n                        best_insert_cost = float('inf')\n\n                        for i in range(1, len(target_route)):\n                            insert_cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                            if insert_cost < best_insert_cost:\n                                best_insert_cost = insert_cost\n                                best_insert_pos = i\n\n                        # Update the target route\n                        new_target_route = np.insert(target_route, best_insert_pos, customer)\n                        new_solution[target_route_idx] = new_target_route\n\n                        # Remove customer from original route\n                        new_route = np.delete(route, customer_idx)\n                        if len(new_route) > 2:  # Ensure route remains valid\n                            new_solution.append(new_route)\n            else:\n                new_solution.append(route)\n\n    # Remove any empty routes and ensure all customers are served\n    final_solution = [route for route in new_solution if len(route) > 2]\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n\n    for route in final_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Reconstruct solution if some customers are missing\n        unserved = list(all_customers - served_customers)\n        for customer in unserved:\n            # Find the route with the least increase in distance\n            best_route_idx = -1\n            best_insert_pos = -1\n            best_increase = float('inf')\n\n            for i, route in enumerate(final_solution):\n                if np.sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                for j in range(1, len(route)):\n                    increase = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_route_idx = i\n                        best_insert_pos = j\n\n            if best_route_idx != -1:\n                final_solution[best_route_idx] = np.insert(final_solution[best_route_idx], best_insert_pos, customer)\n\n    return final_solution\n\n",
        "score": [
            -0.7555187075127615,
            1.5265066921710968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: adaptive route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split route at a random point to create two new routes\n        split_point = np.random.randint(1, len(route) - 1)\n        new_route1 = np.concatenate((route[:split_point + 1], [0]))\n        new_route2 = np.concatenate(([0], route[split_point:]))\n\n        # Check capacity feasibility for both new routes\n        demand1 = np.sum(demand[new_route1[1:-1]])\n        demand2 = np.sum(demand[new_route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.extend([new_route1, new_route2])\n        else:\n            # If split is infeasible, try reallocating a random customer to another route\n            if len(new_solution) > 1:\n                target_route_idx = np.random.randint(0, len(new_solution))\n                target_route = new_solution[target_route_idx]\n\n                # Find a customer in the current route to reallocate\n                if len(route) > 3:\n                    customer_idx = np.random.randint(1, len(route) - 1)\n                    customer = route[customer_idx]\n\n                    # Check if adding the customer to the target route is feasible\n                    if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into target route (greedy insertion)\n                        best_insert_pos = 1\n                        best_insert_cost = float('inf')\n\n                        for i in range(1, len(target_route)):\n                            insert_cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                            if insert_cost < best_insert_cost:\n                                best_insert_cost = insert_cost\n                                best_insert_pos = i\n\n                        # Update the target route\n                        new_target_route = np.insert(target_route, best_insert_pos, customer)\n                        new_solution[target_route_idx] = new_target_route\n\n                        # Remove customer from original route\n                        new_route = np.delete(route, customer_idx)\n                        if len(new_route) > 2:  # Ensure route remains valid\n                            new_solution.append(new_route)\n            else:\n                new_solution.append(route)\n\n    # Remove any empty routes and ensure all customers are served\n    final_solution = [route for route in new_solution if len(route) > 2]\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n\n    for route in final_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Reconstruct solution if some customers are missing\n        unserved = list(all_customers - served_customers)\n        for customer in unserved:\n            # Find the route with the least increase in distance\n            best_route_idx = -1\n            best_insert_pos = -1\n            best_increase = float('inf')\n\n            for i, route in enumerate(final_solution):\n                if np.sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                for j in range(1, len(route)):\n                    increase = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_route_idx = i\n                        best_insert_pos = j\n\n            if best_route_idx != -1:\n                final_solution[best_route_idx] = np.insert(final_solution[best_route_idx], best_insert_pos, customer)\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply route splitting to balance makespan and distance\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route at a point that balances demand and distance\n        split_idx = len(route) // 2\n        while split_idx > 1 and split_idx < len(route) - 1:\n            left_demand = sum(demand[route[1:split_idx]])\n            right_demand = sum(demand[route[split_idx:-1]])\n\n            if left_demand <= capacity and right_demand <= capacity:\n                # Create two new routes\n                new_route1 = np.concatenate(([0], route[1:split_idx], [0]))\n                new_route2 = np.concatenate(([0], route[split_idx:-1], [0]))\n\n                # Replace the original route with the two new routes\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n            split_idx -= 1\n\n    # Apply a distance-optimizing 2-opt within each route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        improved = True\n        while improved:\n            improved = False\n            for j in range(1, len(route) - 2):\n                for k in range(j + 1, len(route) - 1):\n                    # Calculate current and potential new distances\n                    current_dist = distance_matrix[route[j-1]][route[j]] + distance_matrix[route[k]][route[k+1]]\n                    new_dist = distance_matrix[route[j-1]][route[k]] + distance_matrix[route[j]][route[k+1]]\n\n                    if new_dist < current_dist:\n                        # Reverse the segment between j and k\n                        route[j:k+1] = route[j:k+1][::-1]\n                        improved = True\n\n    # Verify feasibility and return\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "score": [
            -0.32775963119070317,
            5.3550607562065125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply route splitting to balance makespan and distance\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route at a point that balances demand and distance\n        split_idx = len(route) // 2\n        while split_idx > 1 and split_idx < len(route) - 1:\n            left_demand = sum(demand[route[1:split_idx]])\n            right_demand = sum(demand[route[split_idx:-1]])\n\n            if left_demand <= capacity and right_demand <= capacity:\n                # Create two new routes\n                new_route1 = np.concatenate(([0], route[1:split_idx], [0]))\n                new_route2 = np.concatenate(([0], route[split_idx:-1], [0]))\n\n                # Replace the original route with the two new routes\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n            split_idx -= 1\n\n    # Apply a distance-optimizing 2-opt within each route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        improved = True\n        while improved:\n            improved = False\n            for j in range(1, len(route) - 2):\n                for k in range(j + 1, len(route) - 1):\n                    # Calculate current and potential new distances\n                    current_dist = distance_matrix[route[j-1]][route[j]] + distance_matrix[route[k]][route[k+1]]\n                    new_dist = distance_matrix[route[j-1]][route[k]] + distance_matrix[route[j]][route[k+1]]\n\n                    if new_dist < current_dist:\n                        # Reverse the segment between j and k\n                        route[j:k+1] = route[j:k+1][::-1]\n                        improved = True\n\n    # Verify feasibility and return\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{A hybrid local search operator that combines route splitting and demand-based customer reallocation to balance distance and makespan while ensuring feasibility, using a probabilistic selection of high-potential routes from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    base_solution = [route.copy() for route in selected_solution]\n\n    # Randomly choose a route to modify (prioritize longer routes)\n    route_indices = list(range(len(base_solution)))\n    route_probs = [len(route) / sum(len(r) for r in base_solution) for route in base_solution]\n    selected_route_idx = np.random.choice(route_indices, p=route_probs)\n    selected_route = base_solution[selected_route_idx]\n\n    # Split the selected route into two parts at a random customer\n    if len(selected_route) > 3:  # Ensure route has at least one customer\n        split_point = random.randint(1, len(selected_route) - 2)\n        new_route1 = selected_route[:split_point + 1]\n        new_route2 = selected_route[split_point:]\n\n        # Reinsert customers from the split route into existing routes if feasible\n        customers_to_reinsert = new_route2[1:-1]\n        base_solution.pop(selected_route_idx)\n\n        # Try to reinsert customers into other routes\n        for customer in customers_to_reinsert:\n            inserted = False\n            for i, route in enumerate(base_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer at the best position (minimizing detour)\n                    best_pos = 1\n                    min_detour = float('inf')\n                    for pos in range(1, len(route)):\n                        detour = (distance_matrix[route[pos-1]][customer] +\n                                  distance_matrix[customer][route[pos]] -\n                                  distance_matrix[route[pos-1]][route[pos]])\n                        if detour < min_detour:\n                            min_detour = detour\n                            best_pos = pos\n                    new_route = np.insert(route, best_pos, customer)\n                    base_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                # If not inserted, create a new route\n                base_solution.append(np.array([0, customer, 0]))\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n    for customer in missing_customers:\n        # Add missing customers to the shortest feasible route\n        best_route_idx = None\n        min_increase = float('inf')\n        for i, route in enumerate(base_solution):\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                # Calculate the increase in total distance if added to this route\n                detour = min(distance_matrix[route[-2]][customer] + distance_matrix[customer][0] -\n                             distance_matrix[route[-2]][0],\n                             distance_matrix[0][customer] + distance_matrix[customer][route[1]] -\n                             distance_matrix[0][route[1]])\n                if detour < min_increase:\n                    min_increase = detour\n                    best_route_idx = i\n        if best_route_idx is not None:\n            # Insert at the best position\n            best_pos = 1\n            min_detour = float('inf')\n            route = base_solution[best_route_idx]\n            for pos in range(1, len(route)):\n                detour = (distance_matrix[route[pos-1]][customer] +\n                          distance_matrix[customer][route[pos]] -\n                          distance_matrix[route[pos-1]][route[pos]])\n                if detour < min_detour:\n                    min_detour = detour\n                    best_pos = pos\n            new_route = np.insert(route, best_pos, customer)\n            base_solution[best_route_idx] = new_route\n        else:\n            # Create a new route if no feasible insertion\n            base_solution.append(np.array([0, customer, 0]))\n\n    return base_solution\n\n",
        "score": [
            -0.8725460494859147,
            3.816188097000122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    base_solution = [route.copy() for route in selected_solution]\n\n    # Randomly choose a route to modify (prioritize longer routes)\n    route_indices = list(range(len(base_solution)))\n    route_probs = [len(route) / sum(len(r) for r in base_solution) for route in base_solution]\n    selected_route_idx = np.random.choice(route_indices, p=route_probs)\n    selected_route = base_solution[selected_route_idx]\n\n    # Split the selected route into two parts at a random customer\n    if len(selected_route) > 3:  # Ensure route has at least one customer\n        split_point = random.randint(1, len(selected_route) - 2)\n        new_route1 = selected_route[:split_point + 1]\n        new_route2 = selected_route[split_point:]\n\n        # Reinsert customers from the split route into existing routes if feasible\n        customers_to_reinsert = new_route2[1:-1]\n        base_solution.pop(selected_route_idx)\n\n        # Try to reinsert customers into other routes\n        for customer in customers_to_reinsert:\n            inserted = False\n            for i, route in enumerate(base_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer at the best position (minimizing detour)\n                    best_pos = 1\n                    min_detour = float('inf')\n                    for pos in range(1, len(route)):\n                        detour = (distance_matrix[route[pos-1]][customer] +\n                                  distance_matrix[customer][route[pos]] -\n                                  distance_matrix[route[pos-1]][route[pos]])\n                        if detour < min_detour:\n                            min_detour = detour\n                            best_pos = pos\n                    new_route = np.insert(route, best_pos, customer)\n                    base_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                # If not inserted, create a new route\n                base_solution.append(np.array([0, customer, 0]))\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n    for customer in missing_customers:\n        # Add missing customers to the shortest feasible route\n        best_route_idx = None\n        min_increase = float('inf')\n        for i, route in enumerate(base_solution):\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                # Calculate the increase in total distance if added to this route\n                detour = min(distance_matrix[route[-2]][customer] + distance_matrix[customer][0] -\n                             distance_matrix[route[-2]][0],\n                             distance_matrix[0][customer] + distance_matrix[customer][route[1]] -\n                             distance_matrix[0][route[1]])\n                if detour < min_increase:\n                    min_increase = detour\n                    best_route_idx = i\n        if best_route_idx is not None:\n            # Insert at the best position\n            best_pos = 1\n            min_detour = float('inf')\n            route = base_solution[best_route_idx]\n            for pos in range(1, len(route)):\n                detour = (distance_matrix[route[pos-1]][customer] +\n                          distance_matrix[customer][route[pos]] -\n                          distance_matrix[route[pos-1]][route[pos]])\n                if detour < min_detour:\n                    min_detour = detour\n                    best_pos = pos\n            new_route = np.insert(route, best_pos, customer)\n            base_solution[best_route_idx] = new_route\n        else:\n            # Create a new route if no feasible insertion\n            base_solution.append(np.array([0, customer, 0]))\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{A hybrid local search strategy combining route segmentation and demand-aware insertion, where segments of high-demand customers are reallocated to underutilized vehicles while balancing distance and makespan objectives through adaptive perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segmentation and demand-aware insertion\n    if len(new_solution) > 1:\n        # Step 1: Identify underutilized and overutilized routes\n        route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n        avg_load = sum(route_loads) / len(route_loads)\n        underutilized = [i for i, load in enumerate(route_loads) if load < 0.7 * avg_load]\n        overutilized = [i for i, load in enumerate(route_loads) if load > 1.3 * avg_load]\n\n        if underutilized and overutilized:\n            # Step 2: Extract a segment from an overutilized route\n            over_route_idx = random.choice(overutilized)\n            over_route = new_solution[over_route_idx]\n            if len(over_route) > 4:  # Ensure we can split meaningfully\n                split_pos = random.randint(1, len(over_route) - 3)\n                segment = over_route[split_pos:-1]\n                segment_load = sum(demand[segment])\n\n                # Step 3: Insert segment into an underutilized route\n                under_route_idx = random.choice(underutilized)\n                under_route = new_solution[under_route_idx]\n                under_load = sum(demand[under_route[1:-1]])\n\n                if under_load + segment_load <= capacity:\n                    # Insert segment at a position that minimizes distance increase\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(under_route)):\n                        insert_dist = distance_matrix[under_route[pos-1], segment[0]] + \\\n                                      distance_matrix[segment[-1], under_route[pos]] - \\\n                                      distance_matrix[under_route[pos-1], under_route[pos]]\n                        if insert_dist < min_increase:\n                            min_increase = insert_dist\n                            best_pos = pos\n\n                    # Perform the insertion\n                    new_under_route = np.concatenate([\n                        under_route[:best_pos],\n                        segment,\n                        under_route[best_pos:]\n                    ])\n                    new_solution[under_route_idx] = new_under_route\n\n                    # Update the overutilized route by removing the segment\n                    new_over_route = np.concatenate([\n                        over_route[:split_pos],\n                        np.array([0])\n                    ])\n                    new_solution[over_route_idx] = new_over_route\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Additional perturbation: Randomly swap two customers between routes if feasible\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select two customers (excluding depots)\n            cust1 = random.randint(1, len(route1) - 2)\n            cust2 = random.randint(1, len(route2) - 2)\n\n            # Check capacity constraints\n            route1_load = sum(demand[route1[1:-1]])\n            route2_load = sum(demand[route2[1:-1]])\n\n            if (route1_load - demand[route1[cust1]] + demand[route2[cust2]] <= capacity and\n                route2_load - demand[route2[cust2]] + demand[route1[cust1]] <= capacity):\n\n                # Perform the swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[cust1], new_route2[cust2] = new_route2[cust2], new_route1[cust1]\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.4829241858299602,
            0.9400849342346191
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segmentation and demand-aware insertion\n    if len(new_solution) > 1:\n        # Step 1: Identify underutilized and overutilized routes\n        route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n        avg_load = sum(route_loads) / len(route_loads)\n        underutilized = [i for i, load in enumerate(route_loads) if load < 0.7 * avg_load]\n        overutilized = [i for i, load in enumerate(route_loads) if load > 1.3 * avg_load]\n\n        if underutilized and overutilized:\n            # Step 2: Extract a segment from an overutilized route\n            over_route_idx = random.choice(overutilized)\n            over_route = new_solution[over_route_idx]\n            if len(over_route) > 4:  # Ensure we can split meaningfully\n                split_pos = random.randint(1, len(over_route) - 3)\n                segment = over_route[split_pos:-1]\n                segment_load = sum(demand[segment])\n\n                # Step 3: Insert segment into an underutilized route\n                under_route_idx = random.choice(underutilized)\n                under_route = new_solution[under_route_idx]\n                under_load = sum(demand[under_route[1:-1]])\n\n                if under_load + segment_load <= capacity:\n                    # Insert segment at a position that minimizes distance increase\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(under_route)):\n                        insert_dist = distance_matrix[under_route[pos-1], segment[0]] + \\\n                                      distance_matrix[segment[-1], under_route[pos]] - \\\n                                      distance_matrix[under_route[pos-1], under_route[pos]]\n                        if insert_dist < min_increase:\n                            min_increase = insert_dist\n                            best_pos = pos\n\n                    # Perform the insertion\n                    new_under_route = np.concatenate([\n                        under_route[:best_pos],\n                        segment,\n                        under_route[best_pos:]\n                    ])\n                    new_solution[under_route_idx] = new_under_route\n\n                    # Update the overutilized route by removing the segment\n                    new_over_route = np.concatenate([\n                        over_route[:split_pos],\n                        np.array([0])\n                    ])\n                    new_solution[over_route_idx] = new_over_route\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Additional perturbation: Randomly swap two customers between routes if feasible\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select two customers (excluding depots)\n            cust1 = random.randint(1, len(route1) - 2)\n            cust2 = random.randint(1, len(route2) - 2)\n\n            # Check capacity constraints\n            route1_load = sum(demand[route1[1:-1]])\n            route2_load = sum(demand[route2[1:-1]])\n\n            if (route1_load - demand[route1[cust1]] + demand[route2[cust2]] <= capacity and\n                route2_load - demand[route2[cust2]] + demand[route1[cust1]] <= capacity):\n\n                # Perform the swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[cust1], new_route2[cust2] = new_route2[cust2], new_route1[cust1]\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted combination of distance and makespan, then applies a hybrid local search strategy combining route merging, customer reallocation, and capacity-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Route Merging - attempt to merge two routes if feasible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n        if total_demand <= capacity:\n            # Find insertion point that minimizes additional distance\n            min_cost = float('inf')\n            best_insertion = None\n\n            for pos1 in range(1, len(route1)):\n                for pos2 in range(1, len(route2)):\n                    # Calculate cost of inserting route2 into route1 at pos1\n                    cost = distance_matrix[route1[pos1-1], route2[1]] + \\\n                           distance_matrix[route2[-2], route1[pos1]] - \\\n                           distance_matrix[route1[pos1-1], route1[pos1]]\n\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_insertion = (pos1, pos2)\n\n            if best_insertion:\n                pos1, pos2 = best_insertion\n                merged_route = np.concatenate([route1[:pos1], route2[1:-1], route1[pos1:]])\n                new_solution[i] = merged_route\n                new_solution = [route for k, route in enumerate(new_solution) if k != j]\n\n    # Step 2: Customer Reallocation - move customers between routes if beneficial\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            for _ in range(2):  # Try a few reallocations\n                # Select a random customer to move\n                customer_idx = random.randint(1, len(route)-2)\n                customer = route[customer_idx]\n\n                # Find target route (different from current)\n                other_routes = [r for r in new_solution if not np.array_equal(r, route)]\n                if not other_routes:\n                    continue\n\n                target_route = random.choice(other_routes)\n                if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion point in target route\n                min_cost = float('inf')\n                best_pos = None\n\n                for pos in range(1, len(target_route)):\n                    cost = distance_matrix[target_route[pos-1], customer] + \\\n                           distance_matrix[customer, target_route[pos]] - \\\n                           distance_matrix[target_route[pos-1], target_route[pos]]\n\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = pos\n\n                if best_pos and min_cost < 0:  # Only move if it improves distance\n                    # Remove from current route\n                    route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n\n                    # Add to target route\n                    target_route = np.insert(target_route, best_pos, customer)\n\n    # Step 3: Capacity-Aware Swaps - swap customers between routes if feasible\n    if len(new_solution) > 1:\n        for _ in range(3):  # Try a few swaps\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Select random customers from each route\n            cust1 = random.choice(route1[1:-1])\n            cust2 = random.choice(route2[1:-1])\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n\n                # Find positions\n                pos1 = np.where(route1 == cust1)[0][0]\n                pos2 = np.where(route2 == cust2)[0][0]\n\n                # Calculate cost difference\n                cost_diff = (distance_matrix[route1[pos1-1], cust2] + distance_matrix[cust2, route1[pos1+1]] +\n                            distance_matrix[route2[pos2-1], cust1] + distance_matrix[cust1, route2[pos2+1]]) - \\\n                           (distance_matrix[route1[pos1-1], cust1] + distance_matrix[cust1, route1[pos1+1]] +\n                            distance_matrix[route2[pos2-1], cust2] + distance_matrix[cust2, route2[pos2+1]])\n\n                if cost_diff < 0:  # Only swap if it improves distance\n                    route1[pos1] = cust2\n                    route2[pos2] = cust1\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i]])\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([new_solution[i], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.5437452180196601,
            4.055228978395462
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Route Merging - attempt to merge two routes if feasible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n        if total_demand <= capacity:\n            # Find insertion point that minimizes additional distance\n            min_cost = float('inf')\n            best_insertion = None\n\n            for pos1 in range(1, len(route1)):\n                for pos2 in range(1, len(route2)):\n                    # Calculate cost of inserting route2 into route1 at pos1\n                    cost = distance_matrix[route1[pos1-1], route2[1]] + \\\n                           distance_matrix[route2[-2], route1[pos1]] - \\\n                           distance_matrix[route1[pos1-1], route1[pos1]]\n\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_insertion = (pos1, pos2)\n\n            if best_insertion:\n                pos1, pos2 = best_insertion\n                merged_route = np.concatenate([route1[:pos1], route2[1:-1], route1[pos1:]])\n                new_solution[i] = merged_route\n                new_solution = [route for k, route in enumerate(new_solution) if k != j]\n\n    # Step 2: Customer Reallocation - move customers between routes if beneficial\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            for _ in range(2):  # Try a few reallocations\n                # Select a random customer to move\n                customer_idx = random.randint(1, len(route)-2)\n                customer = route[customer_idx]\n\n                # Find target route (different from current)\n                other_routes = [r for r in new_solution if not np.array_equal(r, route)]\n                if not other_routes:\n                    continue\n\n                target_route = random.choice(other_routes)\n                if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion point in target route\n                min_cost = float('inf')\n                best_pos = None\n\n                for pos in range(1, len(target_route)):\n                    cost = distance_matrix[target_route[pos-1], customer] + \\\n                           distance_matrix[customer, target_route[pos]] - \\\n                           distance_matrix[target_route[pos-1], target_route[pos]]\n\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = pos\n\n                if best_pos and min_cost < 0:  # Only move if it improves distance\n                    # Remove from current route\n                    route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n\n                    # Add to target route\n                    target_route = np.insert(target_route, best_pos, customer)\n\n    # Step 3: Capacity-Aware Swaps - swap customers between routes if feasible\n    if len(new_solution) > 1:\n        for _ in range(3):  # Try a few swaps\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Select random customers from each route\n            cust1 = random.choice(route1[1:-1])\n            cust2 = random.choice(route2[1:-1])\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n\n                # Find positions\n                pos1 = np.where(route1 == cust1)[0][0]\n                pos2 = np.where(route2 == cust2)[0][0]\n\n                # Calculate cost difference\n                cost_diff = (distance_matrix[route1[pos1-1], cust2] + distance_matrix[cust2, route1[pos1+1]] +\n                            distance_matrix[route2[pos2-1], cust1] + distance_matrix[cust1, route2[pos2+1]]) - \\\n                           (distance_matrix[route1[pos1-1], cust1] + distance_matrix[cust1, route1[pos1+1]] +\n                            distance_matrix[route2[pos2-1], cust2] + distance_matrix[cust2, route2[pos2+1]])\n\n                if cost_diff < 0:  # Only swap if it improves distance\n                    route1[pos1] = cust2\n                    route2[pos2] = cust1\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i]])\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([new_solution[i], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted score combining normalized total distance and makespan, then applies a hybrid local search operator combining route splitting, customer reinsertion with demand-aware position selection, and adaptive route merging to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(-obj[0] / (obj[1] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route splitting (if makespan is too large)\n        if distance_matrix[route[1:-1], route[:-2]].sum() > 1.2 * np.mean([distance_matrix[r[1:-1], r[:-2]].sum() for r in base_solution]):\n            # Split into two routes\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([[0], route[1:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:], [0]])\n            if (demand[new_route1[1:-1]].sum() <= capacity and\n                demand[new_route2[1:-1]].sum() <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # Step 2: Customer reinsertion with demand-aware position selection\n            modified_route = route.copy()\n            for _ in range(2):  # Try moving 2 customers\n                if len(modified_route) <= 3:\n                    break\n                # Select a random customer to move\n                cust_idx = np.random.randint(1, len(modified_route)-1)\n                cust = modified_route[cust_idx]\n                # Remove customer\n                modified_route = np.concatenate([modified_route[:cust_idx], modified_route[cust_idx+1:]])\n\n                # Find best insertion position considering demand and distance\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(modified_route)):\n                    # Insert before position i\n                    temp_route = np.concatenate([modified_route[:i], [cust], modified_route[i:]])\n                    if demand[temp_route[1:-1]].sum() > capacity:\n                        continue\n                    # Calculate insertion cost (distance increase)\n                    cost = (distance_matrix[temp_route[i-1], cust] +\n                            distance_matrix[cust, temp_route[i]] -\n                            distance_matrix[temp_route[i-1], temp_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                modified_route = np.concatenate([modified_route[:best_pos], [cust], modified_route[best_pos:]])\n\n            new_solution.append(modified_route)\n\n    # Step 3: Adaptive route merging (if total distance is too large)\n    if sum(len(r) for r in new_solution) > 1.2 * sum(len(r) for r in base_solution):\n        # Try to merge routes\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if (demand[new_solution[i][1:-1]].sum() +\n                    demand[new_solution[j][1:-1]].sum() <= capacity):\n                    # Check if merging reduces total distance\n                    dist_before = (distance_matrix[new_solution[i][-2], 0] +\n                                  distance_matrix[new_solution[j][1], 0])\n                    dist_after = distance_matrix[new_solution[i][-2], new_solution[j][1]]\n                    if dist_after < dist_before:\n                        merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        merged = True\n                        break\n            if merged:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7750833618554075,
            8.938083171844482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(-obj[0] / (obj[1] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route splitting (if makespan is too large)\n        if distance_matrix[route[1:-1], route[:-2]].sum() > 1.2 * np.mean([distance_matrix[r[1:-1], r[:-2]].sum() for r in base_solution]):\n            # Split into two routes\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([[0], route[1:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:], [0]])\n            if (demand[new_route1[1:-1]].sum() <= capacity and\n                demand[new_route2[1:-1]].sum() <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # Step 2: Customer reinsertion with demand-aware position selection\n            modified_route = route.copy()\n            for _ in range(2):  # Try moving 2 customers\n                if len(modified_route) <= 3:\n                    break\n                # Select a random customer to move\n                cust_idx = np.random.randint(1, len(modified_route)-1)\n                cust = modified_route[cust_idx]\n                # Remove customer\n                modified_route = np.concatenate([modified_route[:cust_idx], modified_route[cust_idx+1:]])\n\n                # Find best insertion position considering demand and distance\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(modified_route)):\n                    # Insert before position i\n                    temp_route = np.concatenate([modified_route[:i], [cust], modified_route[i:]])\n                    if demand[temp_route[1:-1]].sum() > capacity:\n                        continue\n                    # Calculate insertion cost (distance increase)\n                    cost = (distance_matrix[temp_route[i-1], cust] +\n                            distance_matrix[cust, temp_route[i]] -\n                            distance_matrix[temp_route[i-1], temp_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                modified_route = np.concatenate([modified_route[:best_pos], [cust], modified_route[best_pos:]])\n\n            new_solution.append(modified_route)\n\n    # Step 3: Adaptive route merging (if total distance is too large)\n    if sum(len(r) for r in new_solution) > 1.2 * sum(len(r) for r in base_solution):\n        # Try to merge routes\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if (demand[new_solution[i][1:-1]].sum() +\n                    demand[new_solution[j][1:-1]].sum() <= capacity):\n                    # Check if merging reduces total distance\n                    dist_before = (distance_matrix[new_solution[i][-2], 0] +\n                                  distance_matrix[new_solution[j][1], 0])\n                    dist_after = distance_matrix[new_solution[i][-2], new_solution[j][1]]\n                    if dist_after < dist_before:\n                        merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        merged = True\n                        break\n            if merged:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{The algorithm selects a solution from the archive using a weighted random choice based on normalized objective values, then applies a hybrid local search combining route-splitting and cross-exchange operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (normalized.sum(axis=1) + 1e-8)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-splitting and cross-exchange\n    for _ in range(2):  # Repeat for multiple attempts\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Try route-splitting\n        if len(route1) > 3:\n            split_pos = np.random.randint(1, len(route1)-1)\n            new_route1 = route1[:split_pos+1]\n            new_route2 = np.concatenate([[0], route1[split_pos:]])\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                continue\n\n        # Try cross-exchange\n        if len(route1) > 2 and len(route2) > 2:\n            pos1 = np.random.randint(1, len(route1)-1)\n            pos2 = np.random.randint(1, len(route2)-1)\n            node1, node2 = route1[pos1], route2[pos2]\n\n            # Swap nodes\n            new_route1 = np.concatenate([route1[:pos1], [node2], route1[pos1+1:]])\n            new_route2 = np.concatenate([route2[:pos2], [node1], route2[pos2+1:]])\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution[j] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.7249776428035954,
            0.7903812825679779
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (normalized.sum(axis=1) + 1e-8)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-splitting and cross-exchange\n    for _ in range(2):  # Repeat for multiple attempts\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Try route-splitting\n        if len(route1) > 3:\n            split_pos = np.random.randint(1, len(route1)-1)\n            new_route1 = route1[:split_pos+1]\n            new_route2 = np.concatenate([[0], route1[split_pos:]])\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                continue\n\n        # Try cross-exchange\n        if len(route1) > 2 and len(route2) > 2:\n            pos1 = np.random.randint(1, len(route1)-1)\n            pos2 = np.random.randint(1, len(route2)-1)\n            node1, node2 = route1[pos1], route2[pos2]\n\n            # Swap nodes\n            new_route1 = np.concatenate([route1[:pos1], [node2], route1[pos1+1:]])\n            new_route2 = np.concatenate([route2[:pos2], [node1], route2[pos2+1:]])\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution[j] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This algorithm selects a solution from the archive with the highest potential for improvement based on the ratio of total distance to makespan, then applies a hybrid local search combining route splitting, customer reallocation, and route merging to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] / (x[1][1] + 1e-6))  # Avoid division by zero\n    selected_solution = random.choice(archive[:max(1, len(archive) // 3)])[0].copy()\n\n    # Hybrid local search: route splitting, reallocation, and merging\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for split parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    for _ in range(2):  # Perform multiple reallocations\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes for potential merging or reallocation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try merging routes if total demand is within capacity\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n            continue\n\n        # Try reallocating a customer between routes\n        if len(route1) > 3 and len(route2) > 3:\n            # Select a customer to move from route1 to route2\n            customer = random.choice(route1[1:-1])\n            if demand[customer] + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Insert customer into route2 at the best position\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route2)):\n                    # Calculate increase in distance for inserting customer\n                    distance_increase = (distance_matrix[route2[pos-1], customer] +\n                                        distance_matrix[customer, route2[pos]] -\n                                        distance_matrix[route2[pos-1], route2[pos]])\n                    if distance_increase < min_increase:\n                        min_increase = distance_increase\n                        best_pos = pos\n\n                # Update routes\n                new_route1 = np.delete(route1, np.where(route1 == customer))\n                new_route2 = np.insert(route2, best_pos, customer)\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.683209192107133,
            0.8429780006408691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] / (x[1][1] + 1e-6))  # Avoid division by zero\n    selected_solution = random.choice(archive[:max(1, len(archive) // 3)])[0].copy()\n\n    # Hybrid local search: route splitting, reallocation, and merging\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for split parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    for _ in range(2):  # Perform multiple reallocations\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes for potential merging or reallocation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try merging routes if total demand is within capacity\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n            continue\n\n        # Try reallocating a customer between routes\n        if len(route1) > 3 and len(route2) > 3:\n            # Select a customer to move from route1 to route2\n            customer = random.choice(route1[1:-1])\n            if demand[customer] + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Insert customer into route2 at the best position\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route2)):\n                    # Calculate increase in distance for inserting customer\n                    distance_increase = (distance_matrix[route2[pos-1], customer] +\n                                        distance_matrix[customer, route2[pos]] -\n                                        distance_matrix[route2[pos-1], route2[pos]])\n                    if distance_increase < min_increase:\n                        min_increase = distance_increase\n                        best_pos = pos\n\n                # Update routes\n                new_route1 = np.delete(route1, np.where(route1 == customer))\n                new_route2 = np.insert(route2, best_pos, customer)\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{The algorithm selects a promising solution from the archive using a weighted random selection based on Pareto dominance and objective values, then applies a hybrid local search combining route splitting, customer reinsertion with demand-aware swaps, and makespan-balancing perturbations to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive using weighted random selection\n    weights = []\n    for sol, obj in archive:\n        # Weight is inversely proportional to normalized sum of objectives\n        total_obj = obj[0] + obj[1]\n        if total_obj == 0:\n            weight = 1.0\n        else:\n            weight = 1.0 / (1 + total_obj)\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Hybrid local search\n    # Apply route splitting if makespan is too large\n    if len(new_solution) < len(base_solution) * 1.5:  # Threshold for splitting\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:  # Only split if route has enough nodes\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    # Step 3: Demand-aware customer reinsertion\n    for _ in range(2):  # Number of reinsertion attempts\n        # Select a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip too short routes\n            continue\n\n        # Remove a random customer\n        remove_pos = random.randint(1, len(route) - 2)\n        removed_customer = route[remove_pos]\n        new_route = np.concatenate([route[:remove_pos], route[remove_pos+1:]])\n        new_solution[route_idx] = new_route\n\n        # Find best insertion position in the same route\n        best_pos = 1\n        best_cost = float('inf')\n        for pos in range(1, len(new_route)):\n            candidate_route = np.concatenate([new_route[:pos], [removed_customer], new_route[pos:]])\n            if np.sum(demand[candidate_route[1:-1]]) > capacity:\n                continue\n            cost = distance_matrix[candidate_route[pos-1], removed_customer] + distance_matrix[removed_customer, candidate_route[pos]]\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        # Insert back\n        new_route = np.concatenate([new_route[:best_pos], [removed_customer], new_route[best_pos:]])\n        new_solution[route_idx] = new_route\n\n    # Step 4: Makespan balancing perturbation\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            # Try to transfer a customer from longest to shortest route\n            for pos in range(1, len(longest_route) - 1):\n                customer = longest_route[pos]\n                new_longest = np.concatenate([longest_route[:pos], longest_route[pos+1:]])\n                new_shortest = np.concatenate([shortest_route[:-1], [customer], [0]])\n\n                if (np.sum(demand[new_longest[1:-1]]) <= capacity and\n                    np.sum(demand[new_shortest[1:-1]]) <= capacity):\n                    new_solution[longest_idx] = new_longest\n                    new_solution[shortest_idx] = new_shortest\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8966755737622716,
            3.789700835943222
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive using weighted random selection\n    weights = []\n    for sol, obj in archive:\n        # Weight is inversely proportional to normalized sum of objectives\n        total_obj = obj[0] + obj[1]\n        if total_obj == 0:\n            weight = 1.0\n        else:\n            weight = 1.0 / (1 + total_obj)\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Hybrid local search\n    # Apply route splitting if makespan is too large\n    if len(new_solution) < len(base_solution) * 1.5:  # Threshold for splitting\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:  # Only split if route has enough nodes\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    # Step 3: Demand-aware customer reinsertion\n    for _ in range(2):  # Number of reinsertion attempts\n        # Select a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip too short routes\n            continue\n\n        # Remove a random customer\n        remove_pos = random.randint(1, len(route) - 2)\n        removed_customer = route[remove_pos]\n        new_route = np.concatenate([route[:remove_pos], route[remove_pos+1:]])\n        new_solution[route_idx] = new_route\n\n        # Find best insertion position in the same route\n        best_pos = 1\n        best_cost = float('inf')\n        for pos in range(1, len(new_route)):\n            candidate_route = np.concatenate([new_route[:pos], [removed_customer], new_route[pos:]])\n            if np.sum(demand[candidate_route[1:-1]]) > capacity:\n                continue\n            cost = distance_matrix[candidate_route[pos-1], removed_customer] + distance_matrix[removed_customer, candidate_route[pos]]\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        # Insert back\n        new_route = np.concatenate([new_route[:best_pos], [removed_customer], new_route[best_pos:]])\n        new_solution[route_idx] = new_route\n\n    # Step 4: Makespan balancing perturbation\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            # Try to transfer a customer from longest to shortest route\n            for pos in range(1, len(longest_route) - 1):\n                customer = longest_route[pos]\n                new_longest = np.concatenate([longest_route[:pos], longest_route[pos+1:]])\n                new_shortest = np.concatenate([shortest_route[:-1], [customer], [0]])\n\n                if (np.sum(demand[new_longest[1:-1]]) <= capacity and\n                    np.sum(demand[new_shortest[1:-1]]) <= capacity):\n                    new_solution[longest_idx] = new_longest\n                    new_solution[shortest_idx] = new_shortest\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{A hybrid local search strategy combining route segmentation, demand-aware customer reallocation, and adaptive capacity adjustment to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Segment the route into two parts at a random customer\n        if len(selected_route) > 3:  # Ensure at least one customer is left\n            split_pos = np.random.randint(1, len(selected_route) - 1)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity constraints for both segments\n            first_demand = np.sum(demand[first_part[1:-1]])\n            second_demand = np.sum(demand[second_part[1:-1]])\n\n            if first_demand <= capacity and second_demand <= capacity:\n                # Replace the original route with the two new segments\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Try to reallocate customers to other routes\n                for customer in selected_route[1:-1]:\n                    # Find a route with enough remaining capacity\n                    for i, route in enumerate(new_solution):\n                        if i != route_idx:\n                            route_demand = np.sum(demand[route[1:-1]])\n                            if route_demand + demand[customer] <= capacity:\n                                # Insert the customer into this route\n                                best_pos = 1\n                                best_cost = float('inf')\n                                # Find the best insertion position\n                                for pos in range(1, len(route)):\n                                    cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_pos = pos\n                                # Insert the customer\n                                route.insert(best_pos, customer)\n                                break\n        else:\n            # If route is too short, try to merge with another route\n            if len(new_solution) > 1:\n                other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx]\n\n                # Check if merging is feasible\n                merged_demand = np.sum(demand[selected_route[1:-1]]) + np.sum(demand[other_route[1:-1]])\n                if merged_demand <= capacity:\n                    # Find best merge position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        cost = distance_matrix[other_route[pos-1], selected_route[1]] + \\\n                               distance_matrix[selected_route[-2], other_route[pos]] - \\\n                               distance_matrix[other_route[pos-1], other_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Merge the routes\n                    merged_route = other_route[:best_pos] + selected_route[1:-1] + other_route[best_pos:]\n                    new_solution[other_route_idx] = merged_route\n                    new_solution.pop(route_idx)\n    else:\n        # For single-route solutions, try to split it\n        route = new_solution[0]\n        if len(route) > 3:\n            # Find the best split point that balances demand\n            total_demand = np.sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            best_split = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if abs(current_demand - target_demand) < abs((current_demand - demand[route[i]]) - target_demand):\n                    best_split = i\n\n            first_part = route[:best_split + 1]\n            second_part = [route[0]] + route[best_split + 1:]\n\n            # Check capacity constraints\n            if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n                new_solution = [first_part, second_part]\n\n    return new_solution\n\n",
        "score": [
            -0.6869855402820801,
            0.23133283853530884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Segment the route into two parts at a random customer\n        if len(selected_route) > 3:  # Ensure at least one customer is left\n            split_pos = np.random.randint(1, len(selected_route) - 1)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity constraints for both segments\n            first_demand = np.sum(demand[first_part[1:-1]])\n            second_demand = np.sum(demand[second_part[1:-1]])\n\n            if first_demand <= capacity and second_demand <= capacity:\n                # Replace the original route with the two new segments\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Try to reallocate customers to other routes\n                for customer in selected_route[1:-1]:\n                    # Find a route with enough remaining capacity\n                    for i, route in enumerate(new_solution):\n                        if i != route_idx:\n                            route_demand = np.sum(demand[route[1:-1]])\n                            if route_demand + demand[customer] <= capacity:\n                                # Insert the customer into this route\n                                best_pos = 1\n                                best_cost = float('inf')\n                                # Find the best insertion position\n                                for pos in range(1, len(route)):\n                                    cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_pos = pos\n                                # Insert the customer\n                                route.insert(best_pos, customer)\n                                break\n        else:\n            # If route is too short, try to merge with another route\n            if len(new_solution) > 1:\n                other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx]\n\n                # Check if merging is feasible\n                merged_demand = np.sum(demand[selected_route[1:-1]]) + np.sum(demand[other_route[1:-1]])\n                if merged_demand <= capacity:\n                    # Find best merge position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        cost = distance_matrix[other_route[pos-1], selected_route[1]] + \\\n                               distance_matrix[selected_route[-2], other_route[pos]] - \\\n                               distance_matrix[other_route[pos-1], other_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Merge the routes\n                    merged_route = other_route[:best_pos] + selected_route[1:-1] + other_route[best_pos:]\n                    new_solution[other_route_idx] = merged_route\n                    new_solution.pop(route_idx)\n    else:\n        # For single-route solutions, try to split it\n        route = new_solution[0]\n        if len(route) > 3:\n            # Find the best split point that balances demand\n            total_demand = np.sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            best_split = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if abs(current_demand - target_demand) < abs((current_demand - demand[route[i]]) - target_demand):\n                    best_split = i\n\n            first_part = route[:best_split + 1]\n            second_part = [route[0]] + route[best_split + 1:]\n\n            # Check capacity constraints\n            if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n                new_solution = [first_part, second_part]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route splitting, customer reinsertion with capacity checks, and adaptive 2-opt to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by total distance\n    selected_idx = min(5, len(archive) - 1)  # Select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting + reinsertion + adaptive 2-opt\n    for _ in range(3):  # Perform multiple iterations\n        # Step 1: Route splitting - split long routes into smaller ones\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only split if route is long enough\n                split_pos = random.randint(2, len(route) - 2)\n                new_route1 = np.append(route[:split_pos], 0)\n                new_route2 = np.append([0], route[split_pos:])\n\n                # Check capacity constraints\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break  # Only split one route per iteration\n\n        # Step 2: Customer reinsertion - move customers between routes with capacity checks\n        for _ in range(2):  # Try multiple reinsertions\n            if len(new_solution) < 2:\n                break\n\n            # Select a random route and customer to move\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) <= 3:  # Skip if route is too small\n                continue\n\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Try to insert into another route\n            other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n            if not other_routes:\n                continue\n\n            target_route_idx = random.choice(other_routes)\n            target_route = new_solution[target_route_idx]\n\n            # Find best insertion position in target route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(target_route)):\n                # Calculate cost of inserting customer at this position\n                prev_node = target_route[pos - 1]\n                next_node = target_route[pos]\n                new_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                if new_cost < best_cost:\n                    best_pos = pos\n                    best_cost = new_cost\n\n            # Check capacity constraint\n            if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                # Perform the move\n                new_route = np.insert(target_route, best_pos, customer)\n                new_solution[target_route_idx] = new_route\n                new_solution[route_idx] = np.delete(route, customer_pos)\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Step 3: Adaptive 2-opt - only perform if makespan is high\n        makespan = max([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        total_distance = sum([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n        if makespan / total_distance > 0.3:  # If makespan is significant relative to total distance\n            for i in range(len(new_solution)):\n                route = new_solution[i]\n                if len(route) < 5:  # Skip short routes\n                    continue\n\n                # Select two random edges to swap\n                pos1 = random.randint(1, len(route) - 3)\n                pos2 = random.randint(pos1 + 1, len(route) - 2)\n\n                # Create new route by reversing the segment between pos1 and pos2\n                new_route = np.concatenate([\n                    route[:pos1],\n                    route[pos1:pos2][::-1],\n                    route[pos2:]\n                ])\n\n                # Check capacity constraint (should be same as original)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[i] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.44998222789069064,
            6.462726593017578
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by total distance\n    selected_idx = min(5, len(archive) - 1)  # Select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting + reinsertion + adaptive 2-opt\n    for _ in range(3):  # Perform multiple iterations\n        # Step 1: Route splitting - split long routes into smaller ones\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only split if route is long enough\n                split_pos = random.randint(2, len(route) - 2)\n                new_route1 = np.append(route[:split_pos], 0)\n                new_route2 = np.append([0], route[split_pos:])\n\n                # Check capacity constraints\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break  # Only split one route per iteration\n\n        # Step 2: Customer reinsertion - move customers between routes with capacity checks\n        for _ in range(2):  # Try multiple reinsertions\n            if len(new_solution) < 2:\n                break\n\n            # Select a random route and customer to move\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) <= 3:  # Skip if route is too small\n                continue\n\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Try to insert into another route\n            other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n            if not other_routes:\n                continue\n\n            target_route_idx = random.choice(other_routes)\n            target_route = new_solution[target_route_idx]\n\n            # Find best insertion position in target route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(target_route)):\n                # Calculate cost of inserting customer at this position\n                prev_node = target_route[pos - 1]\n                next_node = target_route[pos]\n                new_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                if new_cost < best_cost:\n                    best_pos = pos\n                    best_cost = new_cost\n\n            # Check capacity constraint\n            if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                # Perform the move\n                new_route = np.insert(target_route, best_pos, customer)\n                new_solution[target_route_idx] = new_route\n                new_solution[route_idx] = np.delete(route, customer_pos)\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Step 3: Adaptive 2-opt - only perform if makespan is high\n        makespan = max([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        total_distance = sum([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n        if makespan / total_distance > 0.3:  # If makespan is significant relative to total distance\n            for i in range(len(new_solution)):\n                route = new_solution[i]\n                if len(route) < 5:  # Skip short routes\n                    continue\n\n                # Select two random edges to swap\n                pos1 = random.randint(1, len(route) - 3)\n                pos2 = random.randint(pos1 + 1, len(route) - 2)\n\n                # Create new route by reversing the segment between pos1 and pos2\n                new_route = np.concatenate([\n                    route[:pos1],\n                    route[pos1:pos2][::-1],\n                    route[pos2:]\n                ])\n\n                # Check capacity constraint (should be same as original)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[i] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Step 2: Randomly select a route for perturbation\n    if len(selected_solution) > 1:\n        route_idx = np.random.choice(len(selected_solution))\n        selected_route = selected_solution[route_idx].copy()\n    else:\n        route_idx = 0\n        selected_route = selected_solution[0].copy()\n\n    # Step 3: Apply a hybrid local search operator (combination of 2-opt and route splitting)\n    new_route = selected_route.copy()\n\n    # 2-opt improvement within the route\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, len(new_route) - 2):\n            for j in range(i + 1, len(new_route) - 1):\n                # Check if swapping edges (i, i+1) and (j, j+1) improves the route\n                original_dist = (distance_matrix[new_route[i-1], new_route[i]] +\n                                 distance_matrix[new_route[j], new_route[j+1]])\n                new_dist = (distance_matrix[new_route[i-1], new_route[j]] +\n                            distance_matrix[new_route[i], new_route[j+1]])\n                if new_dist < original_dist:\n                    # Perform the 2-opt swap\n                    new_route[i:j+1] = new_route[i:j+1][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Check if splitting the route into two improves makespan\n    total_demand = sum(demand[new_route[1:-1]])\n    if len(new_route) > 3 and total_demand <= 2 * capacity:\n        # Find the best split point to balance demands\n        min_diff = float('inf')\n        best_split = 1\n        for i in range(1, len(new_route) - 2):\n            demand1 = sum(demand[new_route[1:i+1]])\n            demand2 = total_demand - demand1\n            if demand1 <= capacity and demand2 <= capacity:\n                diff = abs(demand1 - demand2)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_split = i\n\n        # Split the route if it improves makespan\n        if best_split > 1 and best_split < len(new_route) - 2:\n            route1 = np.concatenate([[0], new_route[1:best_split+1], [0]])\n            route2 = np.concatenate([[0], new_route[best_split+1:-1], [0]])\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                selected_solution.pop(route_idx)\n                selected_solution.append(route1)\n                selected_solution.append(route2)\n\n    # Step 4: Ensure feasibility and return the new solution\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # Revert to original route if capacity is violated\n            selected_solution[route_idx] = selected_route\n\n    return selected_solution\n\n",
        "score": [
            -0.6878929003946574,
            4.207361727952957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Step 2: Randomly select a route for perturbation\n    if len(selected_solution) > 1:\n        route_idx = np.random.choice(len(selected_solution))\n        selected_route = selected_solution[route_idx].copy()\n    else:\n        route_idx = 0\n        selected_route = selected_solution[0].copy()\n\n    # Step 3: Apply a hybrid local search operator (combination of 2-opt and route splitting)\n    new_route = selected_route.copy()\n\n    # 2-opt improvement within the route\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, len(new_route) - 2):\n            for j in range(i + 1, len(new_route) - 1):\n                # Check if swapping edges (i, i+1) and (j, j+1) improves the route\n                original_dist = (distance_matrix[new_route[i-1], new_route[i]] +\n                                 distance_matrix[new_route[j], new_route[j+1]])\n                new_dist = (distance_matrix[new_route[i-1], new_route[j]] +\n                            distance_matrix[new_route[i], new_route[j+1]])\n                if new_dist < original_dist:\n                    # Perform the 2-opt swap\n                    new_route[i:j+1] = new_route[i:j+1][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Check if splitting the route into two improves makespan\n    total_demand = sum(demand[new_route[1:-1]])\n    if len(new_route) > 3 and total_demand <= 2 * capacity:\n        # Find the best split point to balance demands\n        min_diff = float('inf')\n        best_split = 1\n        for i in range(1, len(new_route) - 2):\n            demand1 = sum(demand[new_route[1:i+1]])\n            demand2 = total_demand - demand1\n            if demand1 <= capacity and demand2 <= capacity:\n                diff = abs(demand1 - demand2)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_split = i\n\n        # Split the route if it improves makespan\n        if best_split > 1 and best_split < len(new_route) - 2:\n            route1 = np.concatenate([[0], new_route[1:best_split+1], [0]])\n            route2 = np.concatenate([[0], new_route[best_split+1:-1], [0]])\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                selected_solution.pop(route_idx)\n                selected_solution.append(route1)\n                selected_solution.append(route2)\n\n    # Step 4: Ensure feasibility and return the new solution\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # Revert to original route if capacity is violated\n            selected_solution[route_idx] = selected_route\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan descending\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route_indices = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route_indices[0]] = merged_route\n            new_solution = np.delete(new_solution, route_indices[1])\n\n            # Reallocate customers to balance makespan\n            for route in new_solution:\n                if len(route) > 3:  # Only split if route has more than 2 customers\n                    split_point = np.random.randint(1, len(route)-1)\n                    if np.sum(demand[route[1:split_point+1]]) <= capacity:\n                        new_route = np.concatenate([[0], route[1:split_point+1], [0]])\n                        route[1:split_point+1] = [0]\n                        route = np.concatenate([[0], route[split_point+1:], [0]])\n                        new_solution = np.append(new_solution, [new_route])\n\n    # Ensure feasibility by checking capacity constraints\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7409648495748693,
            0.9635007381439209
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan descending\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route_indices = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route_indices[0]] = merged_route\n            new_solution = np.delete(new_solution, route_indices[1])\n\n            # Reallocate customers to balance makespan\n            for route in new_solution:\n                if len(route) > 3:  # Only split if route has more than 2 customers\n                    split_point = np.random.randint(1, len(route)-1)\n                    if np.sum(demand[route[1:split_point+1]]) <= capacity:\n                        new_route = np.concatenate([[0], route[1:split_point+1], [0]])\n                        route[1:split_point+1] = [0]\n                        route = np.concatenate([[0], route[split_point+1:], [0]])\n                        new_solution = np.append(new_solution, [new_route])\n\n    # Ensure feasibility by checking capacity constraints\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{The algorithm selects a solution from the archive with the smallest total distance, then applies a hybrid local search combining route merging and customer reinsertion to balance distance and makespan, ensuring feasibility through capacity checks and depot constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: merge routes if possible, then reinsert customers\n    if len(new_solution) > 1:\n        # Try to merge two routes if their total demand is within capacity\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n                if total_demand <= capacity:\n                    # Merge route2 into route1\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    break\n\n    # Reinsert customers from the longest route to balance makespan\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Remove customers from the longest route and reinsert them\n        customers_to_reinsert = longest_route[1:-1]\n        del new_solution[longest_route_idx]\n\n        for customer in customers_to_reinsert:\n            best_insertion = None\n            best_insertion_cost = float('inf')\n\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                current_demand = sum(demand[route[1:-1]])\n\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                for i in range(len(route) - 1):\n                    # Calculate insertion cost\n                    insertion_cost = (\n                        distance_matrix[route[i], customer] +\n                        distance_matrix[customer, route[i+1]] -\n                        distance_matrix[route[i], route[i+1]]\n                    )\n\n                    if insertion_cost < best_insertion_cost:\n                        best_insertion_cost = insertion_cost\n                        best_insertion = (route_idx, i, customer)\n\n            if best_insertion is not None:\n                route_idx, i, customer = best_insertion\n                route = new_solution[route_idx]\n                new_route = np.insert(route, i + 1, customer)\n                new_solution[route_idx] = new_route\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Route does not start and end with depot\")\n\n    return new_solution\n\n",
        "score": [
            -0.7477005837547331,
            6.4443039894104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: merge routes if possible, then reinsert customers\n    if len(new_solution) > 1:\n        # Try to merge two routes if their total demand is within capacity\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n                if total_demand <= capacity:\n                    # Merge route2 into route1\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    break\n\n    # Reinsert customers from the longest route to balance makespan\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Remove customers from the longest route and reinsert them\n        customers_to_reinsert = longest_route[1:-1]\n        del new_solution[longest_route_idx]\n\n        for customer in customers_to_reinsert:\n            best_insertion = None\n            best_insertion_cost = float('inf')\n\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                current_demand = sum(demand[route[1:-1]])\n\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                for i in range(len(route) - 1):\n                    # Calculate insertion cost\n                    insertion_cost = (\n                        distance_matrix[route[i], customer] +\n                        distance_matrix[customer, route[i+1]] -\n                        distance_matrix[route[i], route[i+1]]\n                    )\n\n                    if insertion_cost < best_insertion_cost:\n                        best_insertion_cost = insertion_cost\n                        best_insertion = (route_idx, i, customer)\n\n            if best_insertion is not None:\n                route_idx, i, customer = best_insertion\n                route = new_solution[route_idx]\n                new_route = np.insert(route, i + 1, customer)\n                new_solution[route_idx] = new_route\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Route does not start and end with depot\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This algorithm selects a promising solution from the archive, applies a hybrid local search that combines route splitting, intra-route relocation, and inter-route exchange to balance distance and makespan objectives, while ensuring feasibility through capacity checks and distance updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol, obj in archive if obj[0] > np.percentile([o[0] for _, o in archive], 75) or obj[1] > np.percentile([o[1] for _, o in archive], 75)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates).copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, intra-route relocation, inter-route exchange\n    if len(new_solution) > 1:\n        # Route splitting: split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        split_pos = len(longest_route) // 2\n        new_route1 = longest_route[:split_pos + 1]\n        new_route2 = np.concatenate(([0], longest_route[split_pos:]))\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in new_route1) <= capacity and\n            sum(demand[node] for node in new_route2) <= capacity):\n            new_solution[longest_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Intra-route relocation: move a customer to a better position in the same route\n    for route in new_solution:\n        if len(route) > 3:\n            i = random.randint(1, len(route)-2)\n            j = random.randint(1, len(route)-2)\n            if i != j:\n                new_route = route.copy()\n                new_route[i], new_route[j] = new_route[j], new_route[i]\n                if sum(demand[node] for node in new_route) <= capacity:\n                    route[:] = new_route\n\n    # Inter-route exchange: swap two customers between two routes\n    if len(new_solution) > 1:\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[r1], new_solution[r2]\n        if len(route1) > 2 and len(route2) > 2:\n            i = random.randint(1, len(route1)-2)\n            j = random.randint(1, len(route2)-2)\n            new_route1 = np.concatenate((route1[:i], [route2[j]], route1[i+1:]))\n            new_route2 = np.concatenate((route2[:j], [route1[i]], route2[j+1:]))\n            if (sum(demand[node] for node in new_route1) <= capacity and\n                sum(demand[node] for node in new_route2) <= capacity):\n                new_solution[r1] = new_route1\n                new_solution[r2] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.6699388011774277,
            8.20154333114624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol, obj in archive if obj[0] > np.percentile([o[0] for _, o in archive], 75) or obj[1] > np.percentile([o[1] for _, o in archive], 75)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates).copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, intra-route relocation, inter-route exchange\n    if len(new_solution) > 1:\n        # Route splitting: split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        split_pos = len(longest_route) // 2\n        new_route1 = longest_route[:split_pos + 1]\n        new_route2 = np.concatenate(([0], longest_route[split_pos:]))\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in new_route1) <= capacity and\n            sum(demand[node] for node in new_route2) <= capacity):\n            new_solution[longest_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Intra-route relocation: move a customer to a better position in the same route\n    for route in new_solution:\n        if len(route) > 3:\n            i = random.randint(1, len(route)-2)\n            j = random.randint(1, len(route)-2)\n            if i != j:\n                new_route = route.copy()\n                new_route[i], new_route[j] = new_route[j], new_route[i]\n                if sum(demand[node] for node in new_route) <= capacity:\n                    route[:] = new_route\n\n    # Inter-route exchange: swap two customers between two routes\n    if len(new_solution) > 1:\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[r1], new_solution[r2]\n        if len(route1) > 2 and len(route2) > 2:\n            i = random.randint(1, len(route1)-2)\n            j = random.randint(1, len(route2)-2)\n            new_route1 = np.concatenate((route1[:i], [route2[j]], route1[i+1:]))\n            new_route2 = np.concatenate((route2[:j], [route1[i]], route2[j+1:]))\n            if (sum(demand[node] for node in new_route1) <= capacity and\n                sum(demand[node] for node in new_route2) <= capacity):\n                new_solution[r1] = new_route1\n                new_solution[r2] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high total distance or makespan, then applies a hybrid local search combining route segmentation and demand-aware insertion to create a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    max_total_distance = max(s[1][0] for s in archive)\n    max_makespan = max(s[1][1] for s in archive)\n    candidates = [s for s in archive if s[1][0] >= 0.9 * max_total_distance or s[1][1] >= 0.9 * max_makespan]\n    if not candidates:\n        candidates = archive\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation and demand-aware insertion\n    for _ in range(2):  # Apply the operator a few times\n        if len(new_solution) < 2:\n            break\n\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Segment route1 into two parts\n        split_pos = random.randint(1, len(route1) - 2)\n        segment = route1[split_pos:-1]\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Check if segment can be inserted into route2 without exceeding capacity\n        if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n            # Insert segment into route2 at the best position\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(route2)):\n                # Evaluate insertion cost\n                cost = (distance_matrix[route2[i-1], segment[0]] +\n                        distance_matrix[segment[-1], route2[i]] -\n                        distance_matrix[route2[i-1], route2[i]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            # Perform insertion\n            new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n            new_solution[route2_idx] = new_route2\n\n            # Update route1 by removing the segment\n            new_route1 = np.concatenate([route1[:split_pos], route1[-1:]])\n            new_solution[route1_idx] = new_route1\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5972777129604202,
            1.752854734659195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    max_total_distance = max(s[1][0] for s in archive)\n    max_makespan = max(s[1][1] for s in archive)\n    candidates = [s for s in archive if s[1][0] >= 0.9 * max_total_distance or s[1][1] >= 0.9 * max_makespan]\n    if not candidates:\n        candidates = archive\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation and demand-aware insertion\n    for _ in range(2):  # Apply the operator a few times\n        if len(new_solution) < 2:\n            break\n\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Segment route1 into two parts\n        split_pos = random.randint(1, len(route1) - 2)\n        segment = route1[split_pos:-1]\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Check if segment can be inserted into route2 without exceeding capacity\n        if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n            # Insert segment into route2 at the best position\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(route2)):\n                # Evaluate insertion cost\n                cost = (distance_matrix[route2[i-1], segment[0]] +\n                        distance_matrix[segment[-1], route2[i]] -\n                        distance_matrix[route2[i-1], route2[i]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            # Perform insertion\n            new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n            new_solution[route2_idx] = new_route2\n\n            # Update route1 by removing the segment\n            new_route1 = np.concatenate([route1[:split_pos], route1[-1:]])\n            new_solution[route1_idx] = new_route1\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search operator that combines route segment swapping with demand-aware customer reinsertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: route segment swapping with demand-aware reinsertion\n    if len(new_solution) >= 2:\n        # Randomly select two routes\n        route_idx1, route_idx2 = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route_idx1]\n        route2 = new_solution[route_idx2]\n\n        # Select a random segment from each route (excluding depot)\n        if len(route1) > 2:\n            start1 = np.random.randint(1, len(route1)-1)\n            end1 = np.random.randint(start1, len(route1)-1)\n            segment1 = route1[start1:end1+1]\n            demand1 = np.sum(demand[segment1])\n\n            if len(route2) > 2:\n                start2 = np.random.randint(1, len(route2)-1)\n                end2 = np.random.randint(start2, len(route2)-1)\n                segment2 = route2[start2:end2+1]\n                demand2 = np.sum(demand[segment2])\n\n                # Check capacity constraints\n                if (np.sum(demand[route1]) - demand1 + demand2 <= capacity and\n                    np.sum(demand[route2]) - demand2 + demand1 <= capacity):\n\n                    # Swap segments\n                    new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                    new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                    # Update routes\n                    new_solution[route_idx1] = new_route1\n                    new_solution[route_idx2] = new_route2\n\n    # Demand-aware customer reinsertion\n    for route in new_solution:\n        if len(route) > 2:\n            # Randomly select a customer to reinsert\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Remove customer from route\n            new_route = np.delete(route, customer_idx)\n            if np.sum(demand[new_route]) <= capacity:\n                # Try to reinsert at best position\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(new_route)):\n                    # Insert after position i\n                    temp_route = np.insert(new_route, i, customer)\n                    cost = (distance_matrix[temp_route[i-1], customer] +\n                           distance_matrix[customer, temp_route[i+1]] -\n                           distance_matrix[temp_route[i-1], temp_route[i+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n                # Insert at best position\n                route[:] = np.insert(new_route, best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.2752039591518872,
            10.219443202018738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: route segment swapping with demand-aware reinsertion\n    if len(new_solution) >= 2:\n        # Randomly select two routes\n        route_idx1, route_idx2 = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route_idx1]\n        route2 = new_solution[route_idx2]\n\n        # Select a random segment from each route (excluding depot)\n        if len(route1) > 2:\n            start1 = np.random.randint(1, len(route1)-1)\n            end1 = np.random.randint(start1, len(route1)-1)\n            segment1 = route1[start1:end1+1]\n            demand1 = np.sum(demand[segment1])\n\n            if len(route2) > 2:\n                start2 = np.random.randint(1, len(route2)-1)\n                end2 = np.random.randint(start2, len(route2)-1)\n                segment2 = route2[start2:end2+1]\n                demand2 = np.sum(demand[segment2])\n\n                # Check capacity constraints\n                if (np.sum(demand[route1]) - demand1 + demand2 <= capacity and\n                    np.sum(demand[route2]) - demand2 + demand1 <= capacity):\n\n                    # Swap segments\n                    new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                    new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                    # Update routes\n                    new_solution[route_idx1] = new_route1\n                    new_solution[route_idx2] = new_route2\n\n    # Demand-aware customer reinsertion\n    for route in new_solution:\n        if len(route) > 2:\n            # Randomly select a customer to reinsert\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Remove customer from route\n            new_route = np.delete(route, customer_idx)\n            if np.sum(demand[new_route]) <= capacity:\n                # Try to reinsert at best position\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(new_route)):\n                    # Insert after position i\n                    temp_route = np.insert(new_route, i, customer)\n                    cost = (distance_matrix[temp_route[i-1], customer] +\n                           distance_matrix[customer, temp_route[i+1]] -\n                           distance_matrix[temp_route[i-1], temp_route[i+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n                # Insert at best position\n                route[:] = np.insert(new_route, best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Combine route balancing with partial route reversal\n    for i in range(len(new_solution)):\n        if len(new_solution[i]) <= 3:\n            continue  # Skip trivial routes\n\n        # Randomly select a segment to reverse within the route\n        start = np.random.randint(1, len(new_solution[i]) - 2)\n        end = np.random.randint(start + 1, len(new_solution[i]) - 1)\n\n        # Check capacity constraint for the reversed segment\n        segment_demand = sum(demand[new_solution[i][start:end+1]])\n        if segment_demand <= capacity:\n            new_solution[i][start:end+1] = new_solution[i][start:end+1][::-1]\n\n    # Optionally merge two shortest routes if their combined demand fits capacity\n    if len(new_solution) > 1:\n        shortest_route_idx = np.argmin([len(route) for route in new_solution])\n        second_shortest_idx = np.argmin([len(route) if i != shortest_route_idx else float('inf') for i, route in enumerate(new_solution)])\n\n        combined_demand = sum(demand[new_solution[shortest_route_idx][1:-1]]) + sum(demand[new_solution[second_shortest_idx][1:-1]])\n        if combined_demand <= capacity:\n            merged_route = new_solution[shortest_route_idx][1:-1] + new_solution[second_shortest_idx][1:-1]\n            new_solution.append(np.array([0] + list(merged_route) + [0]))\n            del new_solution[max(shortest_route_idx, second_shortest_idx)]\n            del new_solution[min(shortest_route_idx, second_shortest_idx)]\n\n    return new_solution\n\n",
        "score": [
            -0.5025993614665477,
            1.1604894399642944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Combine route balancing with partial route reversal\n    for i in range(len(new_solution)):\n        if len(new_solution[i]) <= 3:\n            continue  # Skip trivial routes\n\n        # Randomly select a segment to reverse within the route\n        start = np.random.randint(1, len(new_solution[i]) - 2)\n        end = np.random.randint(start + 1, len(new_solution[i]) - 1)\n\n        # Check capacity constraint for the reversed segment\n        segment_demand = sum(demand[new_solution[i][start:end+1]])\n        if segment_demand <= capacity:\n            new_solution[i][start:end+1] = new_solution[i][start:end+1][::-1]\n\n    # Optionally merge two shortest routes if their combined demand fits capacity\n    if len(new_solution) > 1:\n        shortest_route_idx = np.argmin([len(route) for route in new_solution])\n        second_shortest_idx = np.argmin([len(route) if i != shortest_route_idx else float('inf') for i, route in enumerate(new_solution)])\n\n        combined_demand = sum(demand[new_solution[shortest_route_idx][1:-1]]) + sum(demand[new_solution[second_shortest_idx][1:-1]])\n        if combined_demand <= capacity:\n            merged_route = new_solution[shortest_route_idx][1:-1] + new_solution[second_shortest_idx][1:-1]\n            new_solution.append(np.array([0] + list(merged_route) + [0]))\n            del new_solution[max(shortest_route_idx, second_shortest_idx)]\n            del new_solution[min(shortest_route_idx, second_shortest_idx)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{A novel hybrid local search operator combines route segmentation and inter-route insertion with capacity-aware demand balancing, iteratively refining solutions by strategically reallocating segments while ensuring feasibility and multi-objective improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice([sol for sol, _ in archive])\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Segment and reinsert with demand balancing\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find a segment in route1 to move\n        if len(route1) > 3:  # Need at least one customer to move\n            # Random segment selection\n            start = random.randint(1, len(route1) - 2)\n            end = random.randint(start, len(route1) - 2)\n            segment = route1[start:end]\n\n            # Calculate segment demand\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be inserted into route2 without exceeding capacity\n            current_demand_route2 = sum(demand[node] for node in route2[1:-1])\n            if current_demand_route2 + segment_demand <= capacity:\n                # Insert segment into route2 at a random position\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start], route1[end:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5556531895146284,
            1.1908259987831116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice([sol for sol, _ in archive])\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Segment and reinsert with demand balancing\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find a segment in route1 to move\n        if len(route1) > 3:  # Need at least one customer to move\n            # Random segment selection\n            start = random.randint(1, len(route1) - 2)\n            end = random.randint(start, len(route1) - 2)\n            segment = route1[start:end]\n\n            # Calculate segment demand\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be inserted into route2 without exceeding capacity\n            current_demand_route2 = sum(demand[node] for node in route2[1:-1])\n            if current_demand_route2 + segment_demand <= capacity:\n                # Insert segment into route2 at a random position\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start], route1[end:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Randomly choose one of the hybrid strategies\n    strategy = np.random.choice(['split_and_reinsert', 'merge_and_rebalance', 'cross_route_swap'])\n\n    if strategy == 'split_and_reinsert':\n        # Split a long route into two and reinsert customers to balance makespan\n        longest_route_idx = np.argmax([len(route) for route in selected_solution])\n        if len(selected_solution[longest_route_idx]) > 3:\n            route = selected_solution[longest_route_idx]\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:-1]))\n            selected_solution[longest_route_idx] = new_route1\n            selected_solution.append(new_route2)\n\n            # Reinsert customers from the new route back into the archive\n            for customer in new_route2[1:-1]:\n                # Find the best insertion point in any route (greedy)\n                best_route_idx = -1\n                best_pos = -1\n                min_increase = float('inf')\n                for i, r in enumerate(selected_solution):\n                    if i == len(selected_solution) - 1:\n                        continue  # Skip the newly created route\n                    for j in range(1, len(r)):\n                        if sum(demand[r[k]] for k in range(1, j+1)) + demand[customer] <= capacity:\n                            increase = distance_matrix[r[j-1], customer] + distance_matrix[customer, r[j]] - distance_matrix[r[j-1], r[j]]\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_route_idx = i\n                                best_pos = j\n                if best_route_idx != -1:\n                    selected_solution[best_route_idx] = np.insert(selected_solution[best_route_idx], best_pos, customer)\n                    new_route2 = np.delete(new_route2, np.where(new_route2 == customer)[0][0])\n                    selected_solution[-1] = new_route2\n\n    elif strategy == 'merge_and_rebalance':\n        # Merge two short routes and rebalance demand\n        if len(selected_solution) > 1:\n            shortest_route_idx = np.argmin([len(route) for route in selected_solution])\n            other_route_idx = (shortest_route_idx + 1) % len(selected_solution)\n            route1 = selected_solution[shortest_route_idx]\n            route2 = selected_solution[other_route_idx]\n\n            if len(route1) + len(route2) - 2 <= 10:  # Limit route length to avoid excessive merging\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                if sum(demand[merged_route[1:-1]]) <= capacity:\n                    selected_solution[shortest_route_idx] = merged_route\n                    del selected_solution[other_route_idx]\n\n    elif strategy == 'cross_route_swap':\n        # Swap customers between routes to reduce makespan\n        if len(selected_solution) > 1:\n            route1_idx = np.random.randint(0, len(selected_solution))\n            route2_idx = np.random.randint(0, len(selected_solution))\n            if route1_idx != route2_idx:\n                route1 = selected_solution[route1_idx]\n                route2 = selected_solution[route2_idx]\n                if len(route1) > 2 and len(route2) > 2:\n                    cust1 = np.random.choice(route1[1:-1])\n                    cust2 = np.random.choice(route2[1:-1])\n                    if (sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                        sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n                        # Perform swap\n                        route1[np.where(route1 == cust1)[0][0]] = cust2\n                        route2[np.where(route2 == cust2)[0][0]] = cust1\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n",
        "score": [
            -0.7786251958186718,
            3.753801017999649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Randomly choose one of the hybrid strategies\n    strategy = np.random.choice(['split_and_reinsert', 'merge_and_rebalance', 'cross_route_swap'])\n\n    if strategy == 'split_and_reinsert':\n        # Split a long route into two and reinsert customers to balance makespan\n        longest_route_idx = np.argmax([len(route) for route in selected_solution])\n        if len(selected_solution[longest_route_idx]) > 3:\n            route = selected_solution[longest_route_idx]\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:-1]))\n            selected_solution[longest_route_idx] = new_route1\n            selected_solution.append(new_route2)\n\n            # Reinsert customers from the new route back into the archive\n            for customer in new_route2[1:-1]:\n                # Find the best insertion point in any route (greedy)\n                best_route_idx = -1\n                best_pos = -1\n                min_increase = float('inf')\n                for i, r in enumerate(selected_solution):\n                    if i == len(selected_solution) - 1:\n                        continue  # Skip the newly created route\n                    for j in range(1, len(r)):\n                        if sum(demand[r[k]] for k in range(1, j+1)) + demand[customer] <= capacity:\n                            increase = distance_matrix[r[j-1], customer] + distance_matrix[customer, r[j]] - distance_matrix[r[j-1], r[j]]\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_route_idx = i\n                                best_pos = j\n                if best_route_idx != -1:\n                    selected_solution[best_route_idx] = np.insert(selected_solution[best_route_idx], best_pos, customer)\n                    new_route2 = np.delete(new_route2, np.where(new_route2 == customer)[0][0])\n                    selected_solution[-1] = new_route2\n\n    elif strategy == 'merge_and_rebalance':\n        # Merge two short routes and rebalance demand\n        if len(selected_solution) > 1:\n            shortest_route_idx = np.argmin([len(route) for route in selected_solution])\n            other_route_idx = (shortest_route_idx + 1) % len(selected_solution)\n            route1 = selected_solution[shortest_route_idx]\n            route2 = selected_solution[other_route_idx]\n\n            if len(route1) + len(route2) - 2 <= 10:  # Limit route length to avoid excessive merging\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                if sum(demand[merged_route[1:-1]]) <= capacity:\n                    selected_solution[shortest_route_idx] = merged_route\n                    del selected_solution[other_route_idx]\n\n    elif strategy == 'cross_route_swap':\n        # Swap customers between routes to reduce makespan\n        if len(selected_solution) > 1:\n            route1_idx = np.random.randint(0, len(selected_solution))\n            route2_idx = np.random.randint(0, len(selected_solution))\n            if route1_idx != route2_idx:\n                route1 = selected_solution[route1_idx]\n                route2 = selected_solution[route2_idx]\n                if len(route1) > 2 and len(route2) > 2:\n                    cust1 = np.random.choice(route1[1:-1])\n                    cust2 = np.random.choice(route2[1:-1])\n                    if (sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                        sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n                        # Perform swap\n                        route1[np.where(route1 == cust1)[0][0]] = cust2\n                        route2[np.where(route2 == cust2)[0][0]] = cust1\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{A novel hybrid local search operator that combines route segment relocation with dynamic route merging and splitting, guided by a multi-objective improvement heuristic to balance distance and makespan minimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = random.choices(\n        archive,\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],  # Prefer lower objectives\n        k=1\n    )[0][0]\n\n    new_solution = [route.copy() for route in selected]\n\n    # Apply hybrid local search: segment relocation with dynamic merging/splitting\n    for _ in range(2):  # Repeat for multiple opportunities\n        # Randomly select a route and a segment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too small\n            continue\n\n        # Choose a random segment\n        start = random.randint(1, len(route) - 2)\n        end = random.randint(start + 1, len(route) - 1)\n        segment = route[start:end]\n\n        # Calculate segment demand\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Try inserting into another route or creating a new one\n        candidates = []\n        for i, candidate_route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n\n            # Check if insertion is feasible\n            for pos in range(1, len(candidate_route)):\n                # Check capacity constraint\n                if sum(demand[node] for node in candidate_route[1:-1]) + segment_demand <= capacity:\n                    candidates.append((i, pos, segment_demand))\n\n        # Also consider creating a new route\n        if segment_demand <= capacity:\n            candidates.append((-1, 0, segment_demand))\n\n        if not candidates:\n            continue\n\n        # Select a random candidate\n        target_route_idx, insert_pos, _ = random.choice(candidates)\n\n        # Perform the move\n        if target_route_idx == -1:\n            # Create new route\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n        else:\n            # Insert into existing route\n            target_route = new_solution[target_route_idx]\n            new_route = np.concatenate([target_route[:insert_pos], segment, target_route[insert_pos:]])\n            new_solution[target_route_idx] = new_route\n\n        # Remove segment from original route\n        new_solution[route_idx] = np.concatenate([route[:start], route[end:]])\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served (sanity check)\n    all_nodes = set(range(1, len(coords)))\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n    assert served_nodes == all_nodes, \"Not all customers are served\"\n\n    return new_solution\n\n",
        "score": [
            -0.48044357124135073,
            4.136166006326675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = random.choices(\n        archive,\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],  # Prefer lower objectives\n        k=1\n    )[0][0]\n\n    new_solution = [route.copy() for route in selected]\n\n    # Apply hybrid local search: segment relocation with dynamic merging/splitting\n    for _ in range(2):  # Repeat for multiple opportunities\n        # Randomly select a route and a segment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too small\n            continue\n\n        # Choose a random segment\n        start = random.randint(1, len(route) - 2)\n        end = random.randint(start + 1, len(route) - 1)\n        segment = route[start:end]\n\n        # Calculate segment demand\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Try inserting into another route or creating a new one\n        candidates = []\n        for i, candidate_route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n\n            # Check if insertion is feasible\n            for pos in range(1, len(candidate_route)):\n                # Check capacity constraint\n                if sum(demand[node] for node in candidate_route[1:-1]) + segment_demand <= capacity:\n                    candidates.append((i, pos, segment_demand))\n\n        # Also consider creating a new route\n        if segment_demand <= capacity:\n            candidates.append((-1, 0, segment_demand))\n\n        if not candidates:\n            continue\n\n        # Select a random candidate\n        target_route_idx, insert_pos, _ = random.choice(candidates)\n\n        # Perform the move\n        if target_route_idx == -1:\n            # Create new route\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n        else:\n            # Insert into existing route\n            target_route = new_solution[target_route_idx]\n            new_route = np.concatenate([target_route[:insert_pos], segment, target_route[insert_pos:]])\n            new_solution[target_route_idx] = new_route\n\n        # Remove segment from original route\n        new_solution[route_idx] = np.concatenate([route[:start], route[end:]])\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served (sanity check)\n    all_nodes = set(range(1, len(coords)))\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n    assert served_nodes == all_nodes, \"Not all customers are served\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Split the route at the customer with the highest demand\n        demands = demand[route[1:-1]]\n        if len(demands) == 0:\n            continue\n        split_pos = np.argmax(demands) + 1  # +1 to account for depot\n\n        # Create two new routes\n        new_route1 = np.concatenate([[0], route[1:split_pos+1], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos+1:-1], [0]])\n\n        # Check feasibility\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Step 2: Reallocate the farthest customer from the depot to the new route\n            farthest_customer = np.argmax(distance_matrix[0][route[1:-1]]) + 1  # +1 for depot\n            if farthest_customer not in new_route1 and farthest_customer not in new_route2:\n                new_route2 = np.concatenate([[0], [farthest_customer], [0]])\n\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6593161889653485,
            0.5581663250923157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Split the route at the customer with the highest demand\n        demands = demand[route[1:-1]]\n        if len(demands) == 0:\n            continue\n        split_pos = np.argmax(demands) + 1  # +1 to account for depot\n\n        # Create two new routes\n        new_route1 = np.concatenate([[0], route[1:split_pos+1], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos+1:-1], [0]])\n\n        # Check feasibility\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Step 2: Reallocate the farthest customer from the depot to the new route\n            farthest_customer = np.argmax(distance_matrix[0][route[1:-1]]) + 1  # +1 for depot\n            if farthest_customer not in new_route1 and farthest_customer not in new_route2:\n                new_route2 = np.concatenate([[0], [farthest_customer], [0]])\n\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combined objective score (weighted by normalized objective values) and applies a hybrid local search operator that combines route merging, customer reallocation, and adaptive 2-opt to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives (minimization)\n    norm_total = (total_distances - total_distances.min()) / (total_distances.max() - total_distances.min() + 1e-10)\n    norm_makespan = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-10)\n\n    # Combine scores (weighted sum)\n    combined_scores = 0.6 * norm_total + 0.4 * norm_makespan\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly choose between route merging or customer reallocation\n    if random.random() < 0.5:\n        # Route merging: try to merge two routes if beneficial\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution) - 1)\n            route2_idx = random.randint(0, len(new_solution) - 1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                # Check if merging is feasible\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge the two routes\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution = [merged_route if i == route1_idx else route for i, route in enumerate(new_solution) if i != route2_idx]\n    else:\n        # Customer reallocation: move a customer from one route to another\n        if len(new_solution) > 1:\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if from_route_idx != to_route_idx and len(new_solution[from_route_idx]) > 3:  # Ensure route has customers to move\n                from_route = new_solution[from_route_idx]\n                to_route = new_solution[to_route_idx]\n\n                # Select a random customer from from_route (excluding depot)\n                customer_idx = random.randint(1, len(from_route) - 2)\n                customer = from_route[customer_idx]\n\n                # Check if moving customer to to_route is feasible\n                if sum(demand[to_route[1:-1]]) + demand[customer] <= capacity:\n                    # Remove customer from from_route\n                    from_route = np.delete(from_route, customer_idx)\n\n                    # Insert customer into to_route (optimally)\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n                    for pos in range(1, len(to_route)):\n                        # Calculate insertion cost\n                        prev_node = to_route[pos - 1]\n                        next_node = to_route[pos]\n                        cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = pos\n\n                    # Insert customer into to_route\n                    to_route = np.insert(to_route, best_insert_pos, customer)\n\n                    # Update solution\n                    new_solution[from_route_idx] = from_route\n                    new_solution[to_route_idx] = to_route\n\n    # Step 3: Apply adaptive 2-opt to reduce distance for each route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        improved = True\n        while improved:\n            improved = False\n            for j in range(1, len(route) - 2):\n                for k in range(j + 1, len(route) - 1):\n                    # Check if reversing segment [j, k] improves distance\n                    original_dist = (\n                        distance_matrix[route[j - 1], route[j]] +\n                        distance_matrix[route[k], route[k + 1]]\n                    )\n                    new_dist = (\n                        distance_matrix[route[j - 1], route[k]] +\n                        distance_matrix[route[j], route[k + 1]]\n                    )\n                    if new_dist < original_dist:\n                        # Reverse the segment\n                        route[j:k + 1] = route[j:k + 1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3760818150516263,
            5.18598997592926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives (minimization)\n    norm_total = (total_distances - total_distances.min()) / (total_distances.max() - total_distances.min() + 1e-10)\n    norm_makespan = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-10)\n\n    # Combine scores (weighted sum)\n    combined_scores = 0.6 * norm_total + 0.4 * norm_makespan\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly choose between route merging or customer reallocation\n    if random.random() < 0.5:\n        # Route merging: try to merge two routes if beneficial\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution) - 1)\n            route2_idx = random.randint(0, len(new_solution) - 1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                # Check if merging is feasible\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge the two routes\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution = [merged_route if i == route1_idx else route for i, route in enumerate(new_solution) if i != route2_idx]\n    else:\n        # Customer reallocation: move a customer from one route to another\n        if len(new_solution) > 1:\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if from_route_idx != to_route_idx and len(new_solution[from_route_idx]) > 3:  # Ensure route has customers to move\n                from_route = new_solution[from_route_idx]\n                to_route = new_solution[to_route_idx]\n\n                # Select a random customer from from_route (excluding depot)\n                customer_idx = random.randint(1, len(from_route) - 2)\n                customer = from_route[customer_idx]\n\n                # Check if moving customer to to_route is feasible\n                if sum(demand[to_route[1:-1]]) + demand[customer] <= capacity:\n                    # Remove customer from from_route\n                    from_route = np.delete(from_route, customer_idx)\n\n                    # Insert customer into to_route (optimally)\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n                    for pos in range(1, len(to_route)):\n                        # Calculate insertion cost\n                        prev_node = to_route[pos - 1]\n                        next_node = to_route[pos]\n                        cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = pos\n\n                    # Insert customer into to_route\n                    to_route = np.insert(to_route, best_insert_pos, customer)\n\n                    # Update solution\n                    new_solution[from_route_idx] = from_route\n                    new_solution[to_route_idx] = to_route\n\n    # Step 3: Apply adaptive 2-opt to reduce distance for each route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        improved = True\n        while improved:\n            improved = False\n            for j in range(1, len(route) - 2):\n                for k in range(j + 1, len(route) - 1):\n                    # Check if reversing segment [j, k] improves distance\n                    original_dist = (\n                        distance_matrix[route[j - 1], route[j]] +\n                        distance_matrix[route[k], route[k + 1]]\n                    )\n                    new_dist = (\n                        distance_matrix[route[j - 1], route[k]] +\n                        distance_matrix[route[j], route[k + 1]]\n                    )\n                    if new_dist < original_dist:\n                        # Reverse the segment\n                        route[j:k + 1] = route[j:k + 1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n\n    # Find the longest route in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Attempt to split the longest route by inserting the depot at a demand-balanced point\n    total_demand = sum(demand[longest_route[1:-1]])\n    current_demand = 0\n    split_pos = 1\n    for i in range(1, len(longest_route) - 1):\n        current_demand += demand[longest_route[i]]\n        if current_demand <= capacity and (total_demand - current_demand) <= capacity:\n            split_pos = i\n            break\n\n    if split_pos > 1:\n        # Split the route into two at the split_pos\n        new_route1 = np.concatenate([longest_route[:split_pos + 1], [0]])\n        new_route2 = np.concatenate([[0], longest_route[split_pos + 1:]])\n        new_solution = [route for route in selected_solution if route is not longest_route]\n        new_solution.extend([new_route1, new_route2])\n    else:\n        # If splitting is not feasible, perform a demand-balanced route swap\n        new_solution = selected_solution.copy()\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                # Find a segment in route_i to swap with route_j\n                for k in range(1, len(route_i) - 1):\n                    segment = route_i[k:-1]\n                    if sum(demand[segment]) <= capacity:\n                        # Check if swapping the segment into route_j is feasible\n                        if sum(demand[route_j[1:-1]]) + sum(demand[segment]) <= capacity:\n                            new_route_i = np.concatenate([route_i[:k], [0]])\n                            new_route_j = np.concatenate([route_j[:-1], segment, [0]])\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n                            break\n                else:\n                    continue\n                break\n            else:\n                continue\n            break\n\n    # Ensure all routes are valid (start and end at depot, no capacity violations)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route: must start and end at depot\")\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Capacity violation in route\")\n\n    return new_solution\n\n",
        "score": [
            -0.7971907983817228,
            1.8292061388492584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n\n    # Find the longest route in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Attempt to split the longest route by inserting the depot at a demand-balanced point\n    total_demand = sum(demand[longest_route[1:-1]])\n    current_demand = 0\n    split_pos = 1\n    for i in range(1, len(longest_route) - 1):\n        current_demand += demand[longest_route[i]]\n        if current_demand <= capacity and (total_demand - current_demand) <= capacity:\n            split_pos = i\n            break\n\n    if split_pos > 1:\n        # Split the route into two at the split_pos\n        new_route1 = np.concatenate([longest_route[:split_pos + 1], [0]])\n        new_route2 = np.concatenate([[0], longest_route[split_pos + 1:]])\n        new_solution = [route for route in selected_solution if route is not longest_route]\n        new_solution.extend([new_route1, new_route2])\n    else:\n        # If splitting is not feasible, perform a demand-balanced route swap\n        new_solution = selected_solution.copy()\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                # Find a segment in route_i to swap with route_j\n                for k in range(1, len(route_i) - 1):\n                    segment = route_i[k:-1]\n                    if sum(demand[segment]) <= capacity:\n                        # Check if swapping the segment into route_j is feasible\n                        if sum(demand[route_j[1:-1]]) + sum(demand[segment]) <= capacity:\n                            new_route_i = np.concatenate([route_i[:k], [0]])\n                            new_route_j = np.concatenate([route_j[:-1], segment, [0]])\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n                            break\n                else:\n                    continue\n                break\n            else:\n                continue\n            break\n\n    # Ensure all routes are valid (start and end at depot, no capacity violations)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route: must start and end at depot\")\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Capacity violation in route\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route fragmentation and demand-aware customer reallocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route fragmentation and demand-aware reallocation\n    if len(new_solution) > 1:\n        # Randomly select a route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Split the route into two parts at a random customer\n        split_pos = random.randint(1, len(selected_route) - 2)\n        first_part = selected_route[:split_pos + 1]\n        second_part = selected_route[split_pos:]\n\n        # Reassign customers from the second part to other routes or create a new route\n        for customer in second_part[1:-1]:\n            # Calculate the demand of the current second part\n            current_demand = sum(demand[c] for c in second_part[1:-1])\n\n            # Find a suitable route to insert the customer\n            inserted = False\n            for i, route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                route_demand = sum(demand[c] for c in route[1:-1])\n                if route_demand + demand[customer] <= capacity:\n                    # Insert the customer into the route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    # Find the best insertion position in the route\n                    for pos in range(1, len(route)):\n                        # Calculate the increase in distance\n                        increase = (distance_matrix[route[pos-1]][customer] +\n                                   distance_matrix[customer][route[pos]] -\n                                   distance_matrix[route[pos-1]][route[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    # Insert the customer\n                    new_route = np.insert(route, best_pos, customer)\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n\n            if not inserted:\n                # If no suitable route found, create a new route\n                new_route = np.array([0, customer, 0])\n                new_solution.append(new_route)\n\n        # Update the fragmented route\n        new_solution[route_idx] = first_part\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Reassign missing customers to feasible routes\n    for customer in missing_customers:\n        best_route = None\n        best_pos = None\n        min_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            route_demand = sum(demand[c] for c in route[1:-1])\n            if route_demand + demand[customer] <= capacity:\n                for pos in range(1, len(route)):\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_route = i\n                        best_pos = pos\n\n        if best_route is not None:\n            new_route = np.insert(new_solution[best_route], best_pos, customer)\n            new_solution[best_route] = new_route\n        else:\n            # If no feasible route found, create a new route\n            new_route = np.array([0, customer, 0])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.4850095646731228,
            1.6601694524288177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route fragmentation and demand-aware reallocation\n    if len(new_solution) > 1:\n        # Randomly select a route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Split the route into two parts at a random customer\n        split_pos = random.randint(1, len(selected_route) - 2)\n        first_part = selected_route[:split_pos + 1]\n        second_part = selected_route[split_pos:]\n\n        # Reassign customers from the second part to other routes or create a new route\n        for customer in second_part[1:-1]:\n            # Calculate the demand of the current second part\n            current_demand = sum(demand[c] for c in second_part[1:-1])\n\n            # Find a suitable route to insert the customer\n            inserted = False\n            for i, route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                route_demand = sum(demand[c] for c in route[1:-1])\n                if route_demand + demand[customer] <= capacity:\n                    # Insert the customer into the route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    # Find the best insertion position in the route\n                    for pos in range(1, len(route)):\n                        # Calculate the increase in distance\n                        increase = (distance_matrix[route[pos-1]][customer] +\n                                   distance_matrix[customer][route[pos]] -\n                                   distance_matrix[route[pos-1]][route[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    # Insert the customer\n                    new_route = np.insert(route, best_pos, customer)\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n\n            if not inserted:\n                # If no suitable route found, create a new route\n                new_route = np.array([0, customer, 0])\n                new_solution.append(new_route)\n\n        # Update the fragmented route\n        new_solution[route_idx] = first_part\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Reassign missing customers to feasible routes\n    for customer in missing_customers:\n        best_route = None\n        best_pos = None\n        min_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            route_demand = sum(demand[c] for c in route[1:-1])\n            if route_demand + demand[customer] <= capacity:\n                for pos in range(1, len(route)):\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_route = i\n                        best_pos = pos\n\n        if best_route is not None:\n            new_route = np.insert(new_solution[best_route], best_pos, customer)\n            new_solution[best_route] = new_route\n        else:\n            # If no feasible route found, create a new route\n            new_route = np.array([0, customer, 0])\n            new_solution.append(new_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search: route splitting and demand-aware merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split route into two parts at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        route1 = route[:split_pos+1]\n        route2 = route[split_pos:]\n\n        # Check capacity constraints for the split routes\n        def check_capacity(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if check_capacity(route1) and check_capacity(route2):\n            new_solution[i] = route1\n            new_solution.insert(i+1, route2)\n\n            # Attempt demand-aware merging of adjacent routes\n            if i+1 < len(new_solution) and len(new_solution[i+1]) > 2:\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[i+1][1:]])\n                if check_capacity(merged_route):\n                    new_solution[i] = merged_route\n                    del new_solution[i+1]\n            break\n\n    # Apply novel demand-aware insertion heuristic\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Find the customer with the highest demand in the route\n        customers = route[1:-1]\n        if len(customers) == 0:\n            continue\n\n        max_demand_node = customers[np.argmax(demand[customers])]\n\n        # Try to move this high-demand node to a different route\n        for other_route in new_solution:\n            if other_route is route:\n                continue\n\n            # Check if moving the node would violate capacity\n            if np.sum(demand[other_route[1:-1]]) + demand[max_demand_node] <= capacity:\n                # Find the best insertion position in the other route\n                min_cost = float('inf')\n                best_pos = -1\n                for pos in range(1, len(other_route)):\n                    cost = distance_matrix[other_route[pos-1], max_demand_node] + distance_matrix[max_demand_node, other_route[pos]] - distance_matrix[other_route[pos-1], other_route[pos]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = pos\n\n                if best_pos != -1:\n                    # Perform the move\n                    other_route = np.insert(other_route, best_pos, max_demand_node)\n                    route = np.delete(route, np.where(route == max_demand_node)[0][0])\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7849025775364491,
            3.6182425916194916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search: route splitting and demand-aware merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split route into two parts at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        route1 = route[:split_pos+1]\n        route2 = route[split_pos:]\n\n        # Check capacity constraints for the split routes\n        def check_capacity(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if check_capacity(route1) and check_capacity(route2):\n            new_solution[i] = route1\n            new_solution.insert(i+1, route2)\n\n            # Attempt demand-aware merging of adjacent routes\n            if i+1 < len(new_solution) and len(new_solution[i+1]) > 2:\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[i+1][1:]])\n                if check_capacity(merged_route):\n                    new_solution[i] = merged_route\n                    del new_solution[i+1]\n            break\n\n    # Apply novel demand-aware insertion heuristic\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Find the customer with the highest demand in the route\n        customers = route[1:-1]\n        if len(customers) == 0:\n            continue\n\n        max_demand_node = customers[np.argmax(demand[customers])]\n\n        # Try to move this high-demand node to a different route\n        for other_route in new_solution:\n            if other_route is route:\n                continue\n\n            # Check if moving the node would violate capacity\n            if np.sum(demand[other_route[1:-1]]) + demand[max_demand_node] <= capacity:\n                # Find the best insertion position in the other route\n                min_cost = float('inf')\n                best_pos = -1\n                for pos in range(1, len(other_route)):\n                    cost = distance_matrix[other_route[pos-1], max_demand_node] + distance_matrix[max_demand_node, other_route[pos]] - distance_matrix[other_route[pos-1], other_route[pos]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = pos\n\n                if best_pos != -1:\n                    # Perform the move\n                    other_route = np.insert(other_route, best_pos, max_demand_node)\n                    route = np.delete(route, np.where(route == max_demand_node)[0][0])\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{The algorithm selects a solution from the archive with the shortest total distance, then applies a hybrid local search combining route-shaking and partial route reversal to escape local optima while preserving feasibility, ensuring the neighbor solution maintains capacity constraints and improves both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: route-shaking and partial route reversal\n    new_solution = []\n    for route in selected_solution:\n        route = route.copy()\n        if len(route) <= 3:  # Skip if route is too short\n            new_solution.append(route)\n            continue\n\n        # Randomly select a segment to shake\n        shake_start = random.randint(1, len(route) - 3)\n        shake_end = random.randint(shake_start + 1, len(route) - 2)\n        segment = route[shake_start:shake_end]\n\n        # Reverse the segment to create a partial reversal\n        reversed_segment = segment[::-1]\n\n        # Check capacity feasibility of the reversed segment\n        segment_demand = sum(demand[reversed_segment])\n        if segment_demand <= capacity:\n            route[shake_start:shake_end] = reversed_segment\n\n        # Apply route-shaking by swapping adjacent nodes in the segment\n        for i in range(shake_start, shake_end - 1):\n            if random.random() < 0.5:  # Randomly decide to swap\n                route[i], route[i+1] = route[i+1], route[i]\n\n        new_solution.append(route)\n\n    return new_solution\n\n",
        "score": [
            -0.45649637209537053,
            0.7544548213481903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: route-shaking and partial route reversal\n    new_solution = []\n    for route in selected_solution:\n        route = route.copy()\n        if len(route) <= 3:  # Skip if route is too short\n            new_solution.append(route)\n            continue\n\n        # Randomly select a segment to shake\n        shake_start = random.randint(1, len(route) - 3)\n        shake_end = random.randint(shake_start + 1, len(route) - 2)\n        segment = route[shake_start:shake_end]\n\n        # Reverse the segment to create a partial reversal\n        reversed_segment = segment[::-1]\n\n        # Check capacity feasibility of the reversed segment\n        segment_demand = sum(demand[reversed_segment])\n        if segment_demand <= capacity:\n            route[shake_start:shake_end] = reversed_segment\n\n        # Apply route-shaking by swapping adjacent nodes in the segment\n        for i in range(shake_start, shake_end - 1):\n            if random.random() < 0.5:  # Randomly decide to swap\n                route[i], route[i+1] = route[i+1], route[i]\n\n        new_solution.append(route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], -x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(2, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check if the split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If not feasible, try reallocating customers to other routes\n            for customer in route[1:-1]:\n                best_route = -1\n                min_increase = float('inf')\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    # Check if adding the customer to route j is feasible\n                    if np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity:\n                        # Calculate the increase in total distance\n                        last_node = new_solution[j][-2]\n                        insert_dist = distance_matrix[last_node][customer] + distance_matrix[customer][0] - distance_matrix[last_node][0]\n                        if insert_dist < min_increase:\n                            min_increase = insert_dist\n                            best_route = j\n                if best_route != -1:\n                    # Insert customer into the best feasible route\n                    new_solution[best_route] = np.append(new_solution[best_route][:-1], [customer, 0])\n                    # Remove customer from the original route\n                    route = np.delete(route, np.where(route == customer)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.7183581819228373,
            0.462475061416626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], -x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(2, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check if the split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If not feasible, try reallocating customers to other routes\n            for customer in route[1:-1]:\n                best_route = -1\n                min_increase = float('inf')\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    # Check if adding the customer to route j is feasible\n                    if np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity:\n                        # Calculate the increase in total distance\n                        last_node = new_solution[j][-2]\n                        insert_dist = distance_matrix[last_node][customer] + distance_matrix[customer][0] - distance_matrix[last_node][0]\n                        if insert_dist < min_increase:\n                            min_increase = insert_dist\n                            best_route = j\n                if best_route != -1:\n                    # Insert customer into the best feasible route\n                    new_solution[best_route] = np.append(new_solution[best_route][:-1], [customer, 0])\n                    # Remove customer from the original route\n                    route = np.delete(route, np.where(route == customer)[0][0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combination of route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Identify the most distant customer in the route\n        max_dist = -1\n        split_pos = 1\n        for j in range(1, len(route)-1):\n            dist = distance_matrix[route[j-1]][route[j]] + distance_matrix[route[j]][route[j+1]]\n            if dist > max_dist:\n                max_dist = dist\n                split_pos = j\n\n        # Split the route at the identified position\n        new_route1 = np.concatenate([route[:split_pos+1], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n        # Check capacity feasibility for both new routes\n        def check_capacity(r):\n            total_demand = sum(demand[node] for node in r[1:-1])\n            return total_demand <= capacity\n\n        if check_capacity(new_route1) and check_capacity(new_route2):\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n            break\n\n    # Reallocate customers between routes to balance makespan\n    if len(new_solution) >= 2:\n        # Find the route with the smallest makespan\n        min_makespan_route = min(new_solution, key=lambda r: sum(distance_matrix[r[j]][r[j+1]] for j in range(len(r)-1)))\n\n        # Try to move a customer from the longest route to the smallest makespan route\n        longest_route = max(new_solution, key=lambda r: sum(distance_matrix[r[j]][r[j+1]] for j in range(len(r)-1)))\n        if len(longest_route) > 3 and longest_route is not min_makespan_route:\n            # Find the customer with the smallest demand in the longest route\n            min_demand_node = min(longest_route[1:-1], key=lambda x: demand[x])\n\n            # Insert this customer into the smallest makespan route\n            best_pos = 1\n            min_increase = float('inf')\n\n            for i in range(1, len(min_makespan_route)):\n                # Calculate the increase in distance if we insert the node here\n                dist_increase = (distance_matrix[min_makespan_route[i-1]][min_demand_node] +\n                                distance_matrix[min_demand_node][min_makespan_route[i]] -\n                                distance_matrix[min_makespan_route[i-1]][min_makespan_route[i]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = i\n\n            # Check capacity constraint\n            if sum(demand[node] for node in min_makespan_route[1:-1]) + demand[min_demand_node] <= capacity:\n                # Perform the insertion\n                min_makespan_route = np.concatenate([min_makespan_route[:best_pos], [min_demand_node], min_makespan_route[best_pos:]])\n\n                # Remove the node from the longest route\n                longest_route = np.delete(longest_route, np.where(longest_route == min_demand_node)[0][0])\n\n                # Update the solution\n                new_solution = [r for r in new_solution if len(r) > 2]  # Remove empty routes\n                if len(min_makespan_route) > 2:\n                    new_solution.append(min_makespan_route)\n                if len(longest_route) > 2:\n                    new_solution.append(longest_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7386959896224857,
            1.3713756501674652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combination of route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Identify the most distant customer in the route\n        max_dist = -1\n        split_pos = 1\n        for j in range(1, len(route)-1):\n            dist = distance_matrix[route[j-1]][route[j]] + distance_matrix[route[j]][route[j+1]]\n            if dist > max_dist:\n                max_dist = dist\n                split_pos = j\n\n        # Split the route at the identified position\n        new_route1 = np.concatenate([route[:split_pos+1], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n        # Check capacity feasibility for both new routes\n        def check_capacity(r):\n            total_demand = sum(demand[node] for node in r[1:-1])\n            return total_demand <= capacity\n\n        if check_capacity(new_route1) and check_capacity(new_route2):\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n            break\n\n    # Reallocate customers between routes to balance makespan\n    if len(new_solution) >= 2:\n        # Find the route with the smallest makespan\n        min_makespan_route = min(new_solution, key=lambda r: sum(distance_matrix[r[j]][r[j+1]] for j in range(len(r)-1)))\n\n        # Try to move a customer from the longest route to the smallest makespan route\n        longest_route = max(new_solution, key=lambda r: sum(distance_matrix[r[j]][r[j+1]] for j in range(len(r)-1)))\n        if len(longest_route) > 3 and longest_route is not min_makespan_route:\n            # Find the customer with the smallest demand in the longest route\n            min_demand_node = min(longest_route[1:-1], key=lambda x: demand[x])\n\n            # Insert this customer into the smallest makespan route\n            best_pos = 1\n            min_increase = float('inf')\n\n            for i in range(1, len(min_makespan_route)):\n                # Calculate the increase in distance if we insert the node here\n                dist_increase = (distance_matrix[min_makespan_route[i-1]][min_demand_node] +\n                                distance_matrix[min_demand_node][min_makespan_route[i]] -\n                                distance_matrix[min_makespan_route[i-1]][min_makespan_route[i]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = i\n\n            # Check capacity constraint\n            if sum(demand[node] for node in min_makespan_route[1:-1]) + demand[min_demand_node] <= capacity:\n                # Perform the insertion\n                min_makespan_route = np.concatenate([min_makespan_route[:best_pos], [min_demand_node], min_makespan_route[best_pos:]])\n\n                # Remove the node from the longest route\n                longest_route = np.delete(longest_route, np.where(longest_route == min_demand_node)[0][0])\n\n                # Update the solution\n                new_solution = [r for r in new_solution if len(r) > 2]  # Remove empty routes\n                if len(min_makespan_route) > 2:\n                    new_solution.append(min_makespan_route)\n                if len(longest_route) > 2:\n                    new_solution.append(longest_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{The algorithm selects a solution with the highest total distance and makespan from the archive, then applies a hybrid local search combining route splitting, customer reinsertion, and route merging to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: archive[i][1][0] + archive[i][1][1])\n    selected_solution = archive[selected_idx][0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search\n    # Step 1: Route splitting - split long routes into smaller ones\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only split if route has more than just depot and one customer\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate((route[:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:]))\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Step 2: Customer reinsertion - try to move customers between routes\n    if len(new_solution) > 1:\n        # Select a random route to remove a customer from\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Can remove a customer\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n\n            # Try to insert into another route\n            for other_idx in range(len(new_solution)):\n                if other_idx == route_idx:\n                    continue\n\n                other_route = new_solution[other_idx]\n                for insert_pos in range(1, len(other_route)):\n                    # Create new route with inserted customer\n                    new_route = np.concatenate((\n                        other_route[:insert_pos],\n                        [customer],\n                        other_route[insert_pos:]\n                    ))\n\n                    # Check feasibility\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[other_idx] = new_route\n                        new_solution[route_idx] = np.concatenate((\n                            route[:customer_pos],\n                            route[customer_pos+1:]\n                        ))\n                        break\n\n    # Step 3: Route merging - try to merge short routes\n    if len(new_solution) > 1:\n        # Find the shortest route\n        shortest_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route = new_solution[shortest_idx]\n\n        for other_idx in range(len(new_solution)):\n            if other_idx == shortest_idx:\n                continue\n\n            other_route = new_solution[other_idx]\n            # Try to merge at the end of the shortest route\n            merged_route = np.concatenate((\n                shortest_route[:-1],\n                other_route[1:]\n            ))\n\n            # Check feasibility\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[shortest_idx] = merged_route\n                new_solution.pop(other_idx)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7813095189126575,
            1.8813503980636597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: archive[i][1][0] + archive[i][1][1])\n    selected_solution = archive[selected_idx][0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search\n    # Step 1: Route splitting - split long routes into smaller ones\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only split if route has more than just depot and one customer\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate((route[:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:]))\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Step 2: Customer reinsertion - try to move customers between routes\n    if len(new_solution) > 1:\n        # Select a random route to remove a customer from\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Can remove a customer\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n\n            # Try to insert into another route\n            for other_idx in range(len(new_solution)):\n                if other_idx == route_idx:\n                    continue\n\n                other_route = new_solution[other_idx]\n                for insert_pos in range(1, len(other_route)):\n                    # Create new route with inserted customer\n                    new_route = np.concatenate((\n                        other_route[:insert_pos],\n                        [customer],\n                        other_route[insert_pos:]\n                    ))\n\n                    # Check feasibility\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[other_idx] = new_route\n                        new_solution[route_idx] = np.concatenate((\n                            route[:customer_pos],\n                            route[customer_pos+1:]\n                        ))\n                        break\n\n    # Step 3: Route merging - try to merge short routes\n    if len(new_solution) > 1:\n        # Find the shortest route\n        shortest_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route = new_solution[shortest_idx]\n\n        for other_idx in range(len(new_solution)):\n            if other_idx == shortest_idx:\n                continue\n\n            other_route = new_solution[other_idx]\n            # Try to merge at the end of the shortest route\n            merged_route = np.concatenate((\n                shortest_route[:-1],\n                other_route[1:]\n            ))\n\n            # Check feasibility\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[shortest_idx] = merged_route\n                new_solution.pop(other_idx)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    new_solution = selected_solution.copy()\n\n    # Step 1: Identify the longest route (makespan)\n    longest_route_idx = np.argmax([np.sum(distance_matrix[np.concatenate([route[:-1], route[1:]])]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Step 2: Attempt to merge with another route\n    for i, route in enumerate(new_solution):\n        if i != longest_route_idx:\n            # Check if merging is feasible (capacity constraint)\n            total_demand = sum(demand[longest_route[1:-1]]) + sum(demand[route[1:-1]])\n            if total_demand <= capacity:\n                # Merge the two routes by inserting the longest route's customers into the other route\n                merged_route = route.copy()\n                for customer in longest_route[1:-1]:\n                    # Insert at the position that minimizes additional distance\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(merged_route)):\n                        cost = distance_matrix[merged_route[pos-1], customer] + distance_matrix[customer, merged_route[pos]] - distance_matrix[merged_route[pos-1], merged_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    merged_route = np.insert(merged_route, best_pos, customer)\n\n                # Update the solution\n                new_solution[i] = merged_route\n                del new_solution[longest_route_idx]\n                break\n\n    # Step 3: If merging didn't work, try reallocating a customer from the longest route\n    if len(new_solution) == len(selected_solution):\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:  # Ensure there's a customer to reallocate\n            # Select a random customer from the longest route\n            customer_idx = np.random.randint(1, len(longest_route)-1)\n            customer = longest_route[customer_idx]\n\n            # Try to reallocate this customer to another route\n            for i, route in enumerate(new_solution):\n                if i != longest_route_idx:\n                    # Check capacity constraint\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find the best insertion position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(route)):\n                            cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Update the routes\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        new_solution[longest_route_idx] = np.delete(longest_route, customer_idx)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.5525004619327176,
            2.0439677834510803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    new_solution = selected_solution.copy()\n\n    # Step 1: Identify the longest route (makespan)\n    longest_route_idx = np.argmax([np.sum(distance_matrix[np.concatenate([route[:-1], route[1:]])]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Step 2: Attempt to merge with another route\n    for i, route in enumerate(new_solution):\n        if i != longest_route_idx:\n            # Check if merging is feasible (capacity constraint)\n            total_demand = sum(demand[longest_route[1:-1]]) + sum(demand[route[1:-1]])\n            if total_demand <= capacity:\n                # Merge the two routes by inserting the longest route's customers into the other route\n                merged_route = route.copy()\n                for customer in longest_route[1:-1]:\n                    # Insert at the position that minimizes additional distance\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(merged_route)):\n                        cost = distance_matrix[merged_route[pos-1], customer] + distance_matrix[customer, merged_route[pos]] - distance_matrix[merged_route[pos-1], merged_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    merged_route = np.insert(merged_route, best_pos, customer)\n\n                # Update the solution\n                new_solution[i] = merged_route\n                del new_solution[longest_route_idx]\n                break\n\n    # Step 3: If merging didn't work, try reallocating a customer from the longest route\n    if len(new_solution) == len(selected_solution):\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:  # Ensure there's a customer to reallocate\n            # Select a random customer from the longest route\n            customer_idx = np.random.randint(1, len(longest_route)-1)\n            customer = longest_route[customer_idx]\n\n            # Try to reallocate this customer to another route\n            for i, route in enumerate(new_solution):\n                if i != longest_route_idx:\n                    # Check capacity constraint\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find the best insertion position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(route)):\n                            cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Update the routes\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        new_solution[longest_route_idx] = np.delete(longest_route, customer_idx)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route balancing with cross-route 2-opt\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split long routes into two balanced segments\n        total_demand = sum(demand[route[1:-1]])\n        half_capacity = total_demand / 2\n        split_point = 1\n        current_demand = 0\n\n        for i in range(1, len(route)-1):\n            current_demand += demand[route[i]]\n            if current_demand >= half_capacity:\n                split_point = i\n                break\n\n        # Create two new routes\n        route1 = np.concatenate([route[:split_point+1], [0]])\n        route2 = np.concatenate([[0], route[split_point+1:]])\n\n        # Perform cross-route 2-opt between these new routes\n        if len(route1) > 2 and len(route2) > 2:\n            # Find best swap between routes\n            best_improvement = 0\n            best_swap = None\n\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Calculate potential improvement\n                    a, b = route1[i], route2[j]\n                    old_dist = (distance_matrix[route1[i-1]][a] + distance_matrix[a][route1[i+1]] +\n                               distance_matrix[route2[j-1]][b] + distance_matrix[b][route2[j+1]])\n                    new_dist = (distance_matrix[route1[i-1]][b] + distance_matrix[b][route1[i+1]] +\n                               distance_matrix[route2[j-1]][a] + distance_matrix[a][route2[j+1]])\n\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (i, j)\n\n            if best_swap is not None:\n                i, j = best_swap\n                route1[i], route2[j] = route2[j], route1[i]\n\n        # Add valid routes to solution\n        if sum(demand[route1[1:-1]]) <= capacity:\n            new_solution.append(route1)\n        if sum(demand[route2[1:-1]]) <= capacity:\n            new_solution.append(route2)\n\n    # Ensure all customers are served (fallback to original route if needed)\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n\n    missing = set(range(1, len(demand))) - served\n    if missing:\n        for route in base_solution:\n            if any(node in missing for node in route[1:-1]):\n                new_solution.append(route.copy())\n\n    return new_solution\n\n",
        "score": [
            -0.9289335710875177,
            8.152914106845856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route balancing with cross-route 2-opt\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split long routes into two balanced segments\n        total_demand = sum(demand[route[1:-1]])\n        half_capacity = total_demand / 2\n        split_point = 1\n        current_demand = 0\n\n        for i in range(1, len(route)-1):\n            current_demand += demand[route[i]]\n            if current_demand >= half_capacity:\n                split_point = i\n                break\n\n        # Create two new routes\n        route1 = np.concatenate([route[:split_point+1], [0]])\n        route2 = np.concatenate([[0], route[split_point+1:]])\n\n        # Perform cross-route 2-opt between these new routes\n        if len(route1) > 2 and len(route2) > 2:\n            # Find best swap between routes\n            best_improvement = 0\n            best_swap = None\n\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Calculate potential improvement\n                    a, b = route1[i], route2[j]\n                    old_dist = (distance_matrix[route1[i-1]][a] + distance_matrix[a][route1[i+1]] +\n                               distance_matrix[route2[j-1]][b] + distance_matrix[b][route2[j+1]])\n                    new_dist = (distance_matrix[route1[i-1]][b] + distance_matrix[b][route1[i+1]] +\n                               distance_matrix[route2[j-1]][a] + distance_matrix[a][route2[j+1]])\n\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (i, j)\n\n            if best_swap is not None:\n                i, j = best_swap\n                route1[i], route2[j] = route2[j], route1[i]\n\n        # Add valid routes to solution\n        if sum(demand[route1[1:-1]]) <= capacity:\n            new_solution.append(route1)\n        if sum(demand[route2[1:-1]]) <= capacity:\n            new_solution.append(route2)\n\n    # Ensure all customers are served (fallback to original route if needed)\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n\n    missing = set(range(1, len(demand))) - served\n    if missing:\n        for route in base_solution:\n            if any(node in missing for node in route[1:-1]):\n                new_solution.append(route.copy())\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{A hybrid local search operator that combines route segment swaps with demand-aware route splitting to balance total distance and makespan while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segment swap + demand-aware split\n    for i in range(len(new_solution)):\n        route1 = new_solution[i]\n        if len(route1) <= 4:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment from route1\n        start1, end1 = sorted(np.random.choice(range(1, len(route1)-1), 2, replace=False))\n        segment1 = route1[start1:end1]\n\n        # Find another route to swap with\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route2 = new_solution[j]\n            if len(route2) <= 4:\n                continue\n\n            # Randomly select a segment from route2\n            start2, end2 = sorted(np.random.choice(range(1, len(route2)-1), 2, replace=False))\n            segment2 = route2[start2:end2]\n\n            # Check feasibility after swap\n            new_route1 = np.concatenate([route1[:start1], segment2, route1[end1:]])\n            new_route2 = np.concatenate([route2[:start2], segment1, route2[end2:]])\n\n            # Verify capacity constraints\n            def is_feasible(route):\n                route_demand = sum(demand[node] for node in route[1:-1])\n                return route_demand <= capacity\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution[j] = new_route2\n                break\n\n    # Demand-aware route splitting (if any route exceeds capacity)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # Split the route into two parts\n            split_pos = len(route) // 2\n            route1 = np.concatenate([route[:split_pos], [0]])\n            route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Verify feasibility\n            if (sum(demand[node] for node in route1[1:-1]) <= capacity and\n                sum(demand[node] for node in route2[1:-1]) <= capacity):\n                new_solution[i] = route1\n                new_solution.insert(i+1, route2)\n\n    return new_solution\n\n",
        "score": [
            -0.8356077485895966,
            8.097501784563065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segment swap + demand-aware split\n    for i in range(len(new_solution)):\n        route1 = new_solution[i]\n        if len(route1) <= 4:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment from route1\n        start1, end1 = sorted(np.random.choice(range(1, len(route1)-1), 2, replace=False))\n        segment1 = route1[start1:end1]\n\n        # Find another route to swap with\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route2 = new_solution[j]\n            if len(route2) <= 4:\n                continue\n\n            # Randomly select a segment from route2\n            start2, end2 = sorted(np.random.choice(range(1, len(route2)-1), 2, replace=False))\n            segment2 = route2[start2:end2]\n\n            # Check feasibility after swap\n            new_route1 = np.concatenate([route1[:start1], segment2, route1[end1:]])\n            new_route2 = np.concatenate([route2[:start2], segment1, route2[end2:]])\n\n            # Verify capacity constraints\n            def is_feasible(route):\n                route_demand = sum(demand[node] for node in route[1:-1])\n                return route_demand <= capacity\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution[j] = new_route2\n                break\n\n    # Demand-aware route splitting (if any route exceeds capacity)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # Split the route into two parts\n            split_pos = len(route) // 2\n            route1 = np.concatenate([route[:split_pos], [0]])\n            route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Verify feasibility\n            if (sum(demand[node] for node in route1[1:-1]) <= capacity and\n                sum(demand[node] for node in route2[1:-1]) <= capacity):\n                new_solution[i] = route1\n                new_solution.insert(i+1, route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, customer reinsertion, and capacity-aware swaps to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    normalized_objs = []\n    for sol in archive:\n        total_dist, makespan = sol[1]\n        # Normalize objectives (assuming minimization)\n        if len(archive) > 1:\n            max_dist = max(s[1][0] for s in archive)\n            min_dist = min(s[1][0] for s in archive)\n            max_makespan = max(s[1][1] for s in archive)\n            min_makespan = min(s[1][1] for s in archive)\n            if max_dist != min_dist:\n                norm_dist = (total_dist - min_dist) / (max_dist - min_dist)\n            else:\n                norm_dist = 0.5\n            if max_makespan != min_makespan:\n                norm_makespan = (makespan - min_makespan) / (max_makespan - min_makespan)\n            else:\n                norm_makespan = 0.5\n        else:\n            norm_dist = norm_makespan = 0.5\n        # Weighted objective (0.7 distance, 0.3 makespan)\n        weighted_obj = 0.7 * norm_dist + 0.3 * norm_makespan\n        normalized_objs.append(weighted_obj)\n\n    # Select solution with lowest weighted objective (best potential)\n    selected_idx = np.argmin(normalized_objs)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # 1. Route splitting: split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Only split if route has enough customers\n            split_pos = random.randint(2, len(longest_route)-3)\n            first_part = longest_route[:split_pos+1]\n            second_part = [0] + longest_route[split_pos+1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = first_part\n                new_solution.append(second_part)\n\n    # 2. Customer reinsertion: move a customer to another route\n    if len(new_solution) > 1:\n        target_route_idx = random.randint(0, len(new_solution)-1)\n        target_route = new_solution[target_route_idx]\n\n        if len(target_route) > 3:  # Only reinsert if route has customers to move\n            customer_pos = random.randint(1, len(target_route)-2)\n            customer = target_route[customer_pos]\n\n            # Try to insert into another route\n            for i, route in enumerate(new_solution):\n                if i != target_route_idx:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[route[pos-1], customer] +\n                                distance_matrix[customer, route[pos]] -\n                                distance_matrix[route[pos-1], route[pos]])\n                        if cost < best_cost and (np.sum(demand[route[1:-1]]) + demand[customer] <= capacity):\n                            best_cost = cost\n                            best_pos = pos\n\n                    if best_cost < float('inf'):\n                        # Perform insertion\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        new_solution[target_route_idx] = np.delete(target_route, customer_pos)\n                        break\n\n    # 3. Capacity-aware swap: swap customers between routes if beneficial\n    if len(new_solution) > 1:\n        for _ in range(2):  # Try up to 2 swaps\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select customers to swap\n                cust1_pos = random.randint(1, len(route1)-2)\n                cust2_pos = random.randint(1, len(route2)-2)\n                cust1, cust2 = route1[cust1_pos], route2[cust2_pos]\n\n                # Check capacity constraints\n                if ((np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity) and\n                    (np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity)):\n\n                    # Calculate cost difference\n                    old_cost = (distance_matrix[route1[cust1_pos-1], route1[cust1_pos]] +\n                                distance_matrix[route1[cust1_pos], route1[cust1_pos+1]] +\n                                distance_matrix[route2[cust2_pos-1], route2[cust2_pos]] +\n                                distance_matrix[route2[cust2_pos], route2[cust2_pos+1]])\n\n                    new_cost = (distance_matrix[route1[cust1_pos-1], cust2] +\n                                 distance_matrix[cust2, route1[cust1_pos+1]] +\n                                 distance_matrix[route2[cust2_pos-1], cust1] +\n                                 distance_matrix[cust1, route2[cust2_pos+1]])\n\n                    if new_cost < old_cost:\n                        # Perform swap\n                        route1[cust1_pos] = cust2\n                        route2[cust2_pos] = cust1\n                        new_solution[route1_idx] = route1\n                        new_solution[route2_idx] = route2\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7915900538796105,
            2.051096647977829
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    normalized_objs = []\n    for sol in archive:\n        total_dist, makespan = sol[1]\n        # Normalize objectives (assuming minimization)\n        if len(archive) > 1:\n            max_dist = max(s[1][0] for s in archive)\n            min_dist = min(s[1][0] for s in archive)\n            max_makespan = max(s[1][1] for s in archive)\n            min_makespan = min(s[1][1] for s in archive)\n            if max_dist != min_dist:\n                norm_dist = (total_dist - min_dist) / (max_dist - min_dist)\n            else:\n                norm_dist = 0.5\n            if max_makespan != min_makespan:\n                norm_makespan = (makespan - min_makespan) / (max_makespan - min_makespan)\n            else:\n                norm_makespan = 0.5\n        else:\n            norm_dist = norm_makespan = 0.5\n        # Weighted objective (0.7 distance, 0.3 makespan)\n        weighted_obj = 0.7 * norm_dist + 0.3 * norm_makespan\n        normalized_objs.append(weighted_obj)\n\n    # Select solution with lowest weighted objective (best potential)\n    selected_idx = np.argmin(normalized_objs)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # 1. Route splitting: split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Only split if route has enough customers\n            split_pos = random.randint(2, len(longest_route)-3)\n            first_part = longest_route[:split_pos+1]\n            second_part = [0] + longest_route[split_pos+1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = first_part\n                new_solution.append(second_part)\n\n    # 2. Customer reinsertion: move a customer to another route\n    if len(new_solution) > 1:\n        target_route_idx = random.randint(0, len(new_solution)-1)\n        target_route = new_solution[target_route_idx]\n\n        if len(target_route) > 3:  # Only reinsert if route has customers to move\n            customer_pos = random.randint(1, len(target_route)-2)\n            customer = target_route[customer_pos]\n\n            # Try to insert into another route\n            for i, route in enumerate(new_solution):\n                if i != target_route_idx:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[route[pos-1], customer] +\n                                distance_matrix[customer, route[pos]] -\n                                distance_matrix[route[pos-1], route[pos]])\n                        if cost < best_cost and (np.sum(demand[route[1:-1]]) + demand[customer] <= capacity):\n                            best_cost = cost\n                            best_pos = pos\n\n                    if best_cost < float('inf'):\n                        # Perform insertion\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        new_solution[target_route_idx] = np.delete(target_route, customer_pos)\n                        break\n\n    # 3. Capacity-aware swap: swap customers between routes if beneficial\n    if len(new_solution) > 1:\n        for _ in range(2):  # Try up to 2 swaps\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select customers to swap\n                cust1_pos = random.randint(1, len(route1)-2)\n                cust2_pos = random.randint(1, len(route2)-2)\n                cust1, cust2 = route1[cust1_pos], route2[cust2_pos]\n\n                # Check capacity constraints\n                if ((np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity) and\n                    (np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity)):\n\n                    # Calculate cost difference\n                    old_cost = (distance_matrix[route1[cust1_pos-1], route1[cust1_pos]] +\n                                distance_matrix[route1[cust1_pos], route1[cust1_pos+1]] +\n                                distance_matrix[route2[cust2_pos-1], route2[cust2_pos]] +\n                                distance_matrix[route2[cust2_pos], route2[cust2_pos+1]])\n\n                    new_cost = (distance_matrix[route1[cust1_pos-1], cust2] +\n                                 distance_matrix[cust2, route1[cust1_pos+1]] +\n                                 distance_matrix[route2[cust2_pos-1], cust1] +\n                                 distance_matrix[cust1, route2[cust2_pos+1]])\n\n                    if new_cost < old_cost:\n                        # Perform swap\n                        route1[cust1_pos] = cust2\n                        route2[cust2_pos] = cust1\n                        new_solution[route1_idx] = route1\n                        new_solution[route2_idx] = route2\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: 1) Relocate a customer to another route, 2) Reverse a segment of the route\n    if len(selected_route) > 3:  # Ensure route has customers to relocate\n        # Step 1: Relocate a customer to another route\n        customer_pos = np.random.randint(1, len(selected_route) - 1)\n        customer = selected_route[customer_pos]\n\n        # Find another route that can accommodate the customer's demand\n        feasible_routes = []\n        for i, route in enumerate(selected_solution):\n            if i != route_idx:\n                route_demand = sum(demand[route[1:-1]])\n                if route_demand + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n\n        if feasible_routes:\n            target_route_idx = np.random.choice(feasible_routes)\n            target_route = selected_solution[target_route_idx].copy()\n\n            # Insert customer into the target route (nearest neighbor insertion)\n            min_dist = float('inf')\n            best_pos = 1\n            for i in range(1, len(target_route)):\n                dist = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pos = i\n\n            new_target_route = np.insert(target_route, best_pos, customer)\n            selected_solution[target_route_idx] = new_target_route\n\n            # Remove customer from original route\n            new_selected_route = np.delete(selected_route, customer_pos)\n            selected_solution[route_idx] = new_selected_route\n\n        # Step 2: Reverse a segment of the selected route to reduce distance\n        if len(selected_route) > 4:\n            start = np.random.randint(1, len(selected_route) - 2)\n            end = np.random.randint(start + 1, len(selected_route))\n            selected_route[start:end] = selected_route[start:end][::-1]\n            selected_solution[route_idx] = selected_route\n\n    return selected_solution\n\n",
        "score": [
            -0.7715673923335349,
            0.74941286444664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: 1) Relocate a customer to another route, 2) Reverse a segment of the route\n    if len(selected_route) > 3:  # Ensure route has customers to relocate\n        # Step 1: Relocate a customer to another route\n        customer_pos = np.random.randint(1, len(selected_route) - 1)\n        customer = selected_route[customer_pos]\n\n        # Find another route that can accommodate the customer's demand\n        feasible_routes = []\n        for i, route in enumerate(selected_solution):\n            if i != route_idx:\n                route_demand = sum(demand[route[1:-1]])\n                if route_demand + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n\n        if feasible_routes:\n            target_route_idx = np.random.choice(feasible_routes)\n            target_route = selected_solution[target_route_idx].copy()\n\n            # Insert customer into the target route (nearest neighbor insertion)\n            min_dist = float('inf')\n            best_pos = 1\n            for i in range(1, len(target_route)):\n                dist = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pos = i\n\n            new_target_route = np.insert(target_route, best_pos, customer)\n            selected_solution[target_route_idx] = new_target_route\n\n            # Remove customer from original route\n            new_selected_route = np.delete(selected_route, customer_pos)\n            selected_solution[route_idx] = new_selected_route\n\n        # Step 2: Reverse a segment of the selected route to reduce distance\n        if len(selected_route) > 4:\n            start = np.random.randint(1, len(selected_route) - 2)\n            end = np.random.randint(start + 1, len(selected_route))\n            selected_route[start:end] = selected_route[start:end][::-1]\n            selected_solution[route_idx] = selected_route\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route merging, customer reallocation, and capacity-aware route swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 or all if archive is small\n    selected_solution = archive_sorted[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge, reallocate, and swap\n    if len(new_solution) > 1:\n        # 1. Route merging: merge two routes if their total demand fits in capacity\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n        total_demand = sum(demand[node] for node in route_i) + sum(demand[node] for node in route_j)\n\n        if total_demand <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n        # 2. Customer reallocation: move a customer from a long route to a short route if feasible\n        long_route_idx = max(range(len(new_solution)), key=lambda x: len(new_solution[x]))\n        short_route_idx = min(range(len(new_solution)), key=lambda x: len(new_solution[x]))\n\n        if long_route_idx != short_route_idx:\n            long_route = new_solution[long_route_idx]\n            short_route = new_solution[short_route_idx]\n\n            for node in long_route[1:-1]:\n                if sum(demand[node] for node in short_route) + demand[node] <= capacity:\n                    # Remove from long route\n                    new_solution[long_route_idx] = np.delete(long_route, np.where(long_route == node)[0])\n                    # Insert into short route (after depot)\n                    new_solution[short_route_idx] = np.insert(short_route, 1, node)\n                    break\n\n        # 3. Capacity-aware route swapping: swap segments between routes if feasible\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Select random segments (excluding depots)\n            start_i, end_i = sorted(random.sample(range(1, len(route_i) - 1), 2))\n            start_j, end_j = sorted(random.sample(range(1, len(route_j) - 1), 2))\n\n            segment_i = route_i[start_i:end_i + 1]\n            segment_j = route_j[start_j:end_j + 1]\n\n            # Check capacity constraints\n            demand_i = sum(demand[node] for node in route_i) - sum(demand[node] for node in segment_i) + sum(demand[node] for node in segment_j)\n            demand_j = sum(demand[node] for node in route_j) - sum(demand[node] for node in segment_j) + sum(demand[node] for node in segment_i)\n\n            if demand_i <= capacity and demand_j <= capacity:\n                # Perform swap\n                new_route_i = np.concatenate([route_i[:start_i], segment_j, route_i[end_i + 1:]])\n                new_route_j = np.concatenate([route_j[:start_j], segment_i, route_j[end_j + 1:]])\n\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    return new_solution\n\n",
        "score": [
            -0.8255471908389411,
            1.0677742063999176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 or all if archive is small\n    selected_solution = archive_sorted[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge, reallocate, and swap\n    if len(new_solution) > 1:\n        # 1. Route merging: merge two routes if their total demand fits in capacity\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n        total_demand = sum(demand[node] for node in route_i) + sum(demand[node] for node in route_j)\n\n        if total_demand <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n        # 2. Customer reallocation: move a customer from a long route to a short route if feasible\n        long_route_idx = max(range(len(new_solution)), key=lambda x: len(new_solution[x]))\n        short_route_idx = min(range(len(new_solution)), key=lambda x: len(new_solution[x]))\n\n        if long_route_idx != short_route_idx:\n            long_route = new_solution[long_route_idx]\n            short_route = new_solution[short_route_idx]\n\n            for node in long_route[1:-1]:\n                if sum(demand[node] for node in short_route) + demand[node] <= capacity:\n                    # Remove from long route\n                    new_solution[long_route_idx] = np.delete(long_route, np.where(long_route == node)[0])\n                    # Insert into short route (after depot)\n                    new_solution[short_route_idx] = np.insert(short_route, 1, node)\n                    break\n\n        # 3. Capacity-aware route swapping: swap segments between routes if feasible\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Select random segments (excluding depots)\n            start_i, end_i = sorted(random.sample(range(1, len(route_i) - 1), 2))\n            start_j, end_j = sorted(random.sample(range(1, len(route_j) - 1), 2))\n\n            segment_i = route_i[start_i:end_i + 1]\n            segment_j = route_j[start_j:end_j + 1]\n\n            # Check capacity constraints\n            demand_i = sum(demand[node] for node in route_i) - sum(demand[node] for node in segment_i) + sum(demand[node] for node in segment_j)\n            demand_j = sum(demand[node] for node in route_j) - sum(demand[node] for node in segment_j) + sum(demand[node] for node in segment_i)\n\n            if demand_i <= capacity and demand_j <= capacity:\n                # Perform swap\n                new_route_i = np.concatenate([route_i[:start_i], segment_j, route_i[end_i + 1:]])\n                new_route_j = np.concatenate([route_j[:start_j], segment_i, route_j[end_j + 1:]])\n\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Iterate over each route in the selected solution\n    for route_idx, route in enumerate(selected_solution):\n        if len(route) > 3:  # Only consider routes with at least one customer\n            # Randomly select two non-depot nodes to swap\n            swap_indices = random.sample(range(1, len(route) - 1), 2)\n            i, j = swap_indices[0], swap_indices[1]\n\n            # Check if swapping these nodes would violate capacity constraints\n            current_load = sum(demand[route[1:-1]])\n            new_load = current_load - demand[route[i]] + demand[route[j]]\n\n            if new_load <= capacity:\n                # Perform the swap\n                route[i], route[j] = route[j], route[i]\n\n                # Check if the swap improved the makespan (reduced route length)\n                original_length = sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))\n                new_length = sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))\n\n                if new_length < original_length:\n                    break  # Accept the swap if it improves the makespan\n\n    return selected_solution\n\n",
        "score": [
            -0.7278803931289338,
            1.538705825805664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Iterate over each route in the selected solution\n    for route_idx, route in enumerate(selected_solution):\n        if len(route) > 3:  # Only consider routes with at least one customer\n            # Randomly select two non-depot nodes to swap\n            swap_indices = random.sample(range(1, len(route) - 1), 2)\n            i, j = swap_indices[0], swap_indices[1]\n\n            # Check if swapping these nodes would violate capacity constraints\n            current_load = sum(demand[route[1:-1]])\n            new_load = current_load - demand[route[i]] + demand[route[j]]\n\n            if new_load <= capacity:\n                # Perform the swap\n                route[i], route[j] = route[j], route[i]\n\n                # Check if the swap improved the makespan (reduced route length)\n                original_length = sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))\n                new_length = sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))\n\n                if new_length < original_length:\n                    break  # Accept the swap if it improves the makespan\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with low makespan or total distance, then applies a hybrid local search combining route merging and k-opt moves with demand-aware capacity checks to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if random.random() < 0.5:\n        # Prefer solutions with low makespan\n        archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    else:\n        # Prefer solutions with low total distance\n        archive_sorted = sorted(archive, key=lambda x: x[1][0])\n\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route merging and k-opt with demand checks\n    if len(new_solution) > 1 and random.random() < 0.7:\n        # Try merging two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Create a new route by merging and try a k-opt move\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            k = random.randint(2, min(4, len(merged_route)-2))  # Random k between 2 and 4\n\n            # Apply k-opt on the merged route\n            if len(merged_route) > k + 2:\n                indices = sorted(random.sample(range(1, len(merged_route)-1), k))\n                new_route = merged_route.copy()\n                for idx in indices:\n                    new_route[idx] = merged_route[len(merged_route)-1 - (idx-1)]\n                # Ensure feasibility\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[i] = new_route\n                    del new_solution[j]\n    else:\n        # Apply k-opt on a single route\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        k = random.randint(2, min(4, len(route)-2))  # Random k between 2 and 4\n\n        if len(route) > k + 2:\n            indices = sorted(random.sample(range(1, len(route)-1), k))\n            new_route = route.copy()\n            for idx in indices:\n                new_route[idx] = route[len(route)-1 - (idx-1)]\n            # Ensure feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5703398307648064,
            1.739624798297882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if random.random() < 0.5:\n        # Prefer solutions with low makespan\n        archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    else:\n        # Prefer solutions with low total distance\n        archive_sorted = sorted(archive, key=lambda x: x[1][0])\n\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route merging and k-opt with demand checks\n    if len(new_solution) > 1 and random.random() < 0.7:\n        # Try merging two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Create a new route by merging and try a k-opt move\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            k = random.randint(2, min(4, len(merged_route)-2))  # Random k between 2 and 4\n\n            # Apply k-opt on the merged route\n            if len(merged_route) > k + 2:\n                indices = sorted(random.sample(range(1, len(merged_route)-1), k))\n                new_route = merged_route.copy()\n                for idx in indices:\n                    new_route[idx] = merged_route[len(merged_route)-1 - (idx-1)]\n                # Ensure feasibility\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[i] = new_route\n                    del new_solution[j]\n    else:\n        # Apply k-opt on a single route\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        k = random.randint(2, min(4, len(route)-2))  # Random k between 2 and 4\n\n        if len(route) > k + 2:\n            indices = sorted(random.sample(range(1, len(route)-1), k))\n            new_route = route.copy()\n            for idx in indices:\n                new_route[idx] = route[len(route)-1 - (idx-1)]\n            # Ensure feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high total distance or makespan, then applies a hybrid local search combining route splitting, demand-based reinsertion, and adaptive 2-opt to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([max(obj[0], obj[1]) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Demand-based reinsertion (move high-demand nodes to new routes)\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Find high-demand nodes to reinsert\n        nodes = route[1:-1]\n        high_demand_nodes = nodes[demand[nodes] > capacity / 3]\n\n        if len(high_demand_nodes) > 0:\n            node_to_move = random.choice(high_demand_nodes)\n            pos_in_route = np.where(route == node_to_move)[0][0]\n\n            # Create a new route with this node\n            new_route = np.array([0, node_to_move, 0])\n            new_solution.append(new_route)\n\n            # Remove from original route\n            route = np.delete(route, pos_in_route)\n            break\n\n    # Step 3: Adaptive 2-opt (focus on high-distance edges)\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Find the two most expensive edges in the route\n        edges = []\n        for i in range(len(route)-1):\n            edges.append((i, i+1, distance_matrix[route[i], route[i+1]]))\n\n        edges.sort(key=lambda x: -x[2])\n        best_i, best_j = edges[0][:2]\n\n        # Try reversing the segment between best_i and best_j\n        new_route = route.copy()\n        new_route[best_i:best_j+1] = route[best_i:best_j+1][::-1]\n\n        if is_feasible(new_route):\n            route[:] = new_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if not is_feasible(route):\n            # Fallback: greedy reinsertion if infeasible\n            nodes = route[1:-1]\n            route[:] = [0]\n            for node in nodes:\n                inserted = False\n                for i in range(len(route)):\n                    if np.sum(demand[route[1:i]]) + demand[node] <= capacity:\n                        route.insert(i, node)\n                        inserted = True\n                        break\n                if not inserted:\n                    route.append(node)\n            route.append(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8236238117930315,
            1.5314260125160217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([max(obj[0], obj[1]) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Demand-based reinsertion (move high-demand nodes to new routes)\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Find high-demand nodes to reinsert\n        nodes = route[1:-1]\n        high_demand_nodes = nodes[demand[nodes] > capacity / 3]\n\n        if len(high_demand_nodes) > 0:\n            node_to_move = random.choice(high_demand_nodes)\n            pos_in_route = np.where(route == node_to_move)[0][0]\n\n            # Create a new route with this node\n            new_route = np.array([0, node_to_move, 0])\n            new_solution.append(new_route)\n\n            # Remove from original route\n            route = np.delete(route, pos_in_route)\n            break\n\n    # Step 3: Adaptive 2-opt (focus on high-distance edges)\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Find the two most expensive edges in the route\n        edges = []\n        for i in range(len(route)-1):\n            edges.append((i, i+1, distance_matrix[route[i], route[i+1]]))\n\n        edges.sort(key=lambda x: -x[2])\n        best_i, best_j = edges[0][:2]\n\n        # Try reversing the segment between best_i and best_j\n        new_route = route.copy()\n        new_route[best_i:best_j+1] = route[best_i:best_j+1][::-1]\n\n        if is_feasible(new_route):\n            route[:] = new_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if not is_feasible(route):\n            # Fallback: greedy reinsertion if infeasible\n            nodes = route[1:-1]\n            route[:] = [0]\n            for node in nodes:\n                inserted = False\n                for i in range(len(route)):\n                    if np.sum(demand[route[1:i]]) + demand[node] <= capacity:\n                        route.insert(i, node)\n                        inserted = True\n                        break\n                if not inserted:\n                    route.append(node)\n            route.append(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Randomly select a split point (not at depot)\n        split_points = np.where(route != 0)[0]\n        if len(split_points) <= 1:\n            new_solution.append(route.copy())\n            continue\n\n        split_idx = np.random.choice(split_points)\n        route1 = route[:split_idx + 1]\n        route2 = np.array([0] + route[split_idx + 1:].tolist())\n\n        # Check capacity constraints\n        if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n            new_solution.extend([route1, route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Randomly reallocate a customer between routes if beneficial\n    if len(new_solution) >= 2:\n        route1_idx = np.random.randint(len(new_solution))\n        route2_idx = np.random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find customers in route1 that can be moved to route2\n        customers_in_route1 = route1[1:-1]\n        if len(customers_in_route1) > 0:\n            customer = np.random.choice(customers_in_route1)\n            new_route1 = np.array([x for x in route1 if x != customer])\n            new_route2 = np.insert(route2, -1, customer)\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.7712397125884447,
            1.716416358947754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Randomly select a split point (not at depot)\n        split_points = np.where(route != 0)[0]\n        if len(split_points) <= 1:\n            new_solution.append(route.copy())\n            continue\n\n        split_idx = np.random.choice(split_points)\n        route1 = route[:split_idx + 1]\n        route2 = np.array([0] + route[split_idx + 1:].tolist())\n\n        # Check capacity constraints\n        if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n            new_solution.extend([route1, route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Randomly reallocate a customer between routes if beneficial\n    if len(new_solution) >= 2:\n        route1_idx = np.random.randint(len(new_solution))\n        route2_idx = np.random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find customers in route1 that can be moved to route2\n        customers_in_route1 = route1[1:-1]\n        if len(customers_in_route1) > 0:\n            customer = np.random.choice(customers_in_route1)\n            new_route1 = np.array([x for x in route1 if x != customer])\n            new_route2 = np.insert(route2, -1, customer)\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, inter-route insertion, and capacity-aware swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a weighted combination of objectives\n    weights = np.array([0.7, 0.3])  # More weight on total distance\n    scores = np.array([w[1][0] * weights[0] + w[1][1] * weights[1] for w in archive])\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (just depot)\n            new_solution.append(route.copy())\n            continue\n\n        # Hybrid local search: split, insert, and swap\n        modified_route = route.copy()\n        n = len(modified_route)\n\n        # Step 1: Randomly split the route if it's too long\n        if np.random.rand() < 0.3 and len(route) > 5:\n            split_pos = np.random.randint(2, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n                continue\n\n        # Step 2: Randomly insert a node from another route\n        if len(base_solution) > 1 and np.random.rand() < 0.5:\n            other_route_idx = np.random.choice([i for i in range(len(base_solution)) if i != selected_idx])\n            other_route = base_solution[other_route_idx]\n            if len(other_route) > 3:\n                # Select a random node from other route (not depot)\n                node_to_insert = np.random.choice(other_route[1:-1])\n                insert_pos = np.random.randint(1, len(modified_route)-1)\n\n                # Check capacity\n                if np.sum(demand[modified_route[1:-1]]) + demand[node_to_insert] <= capacity:\n                    modified_route = np.concatenate([modified_route[:insert_pos], [node_to_insert], modified_route[insert_pos:]])\n\n        # Step 3: Randomly swap two nodes within the route\n        if len(modified_route) > 4 and np.random.rand() < 0.5:\n            i, j = np.random.choice(range(1, len(modified_route)-1), 2, replace=False)\n            # Ensure capacity constraint after swap\n            if (np.sum(demand[modified_route[1:-1]]) - demand[modified_route[i]] + demand[modified_route[j]]) <= capacity:\n                modified_route[i], modified_route[j] = modified_route[j], modified_route[i]\n\n        new_solution.append(modified_route)\n\n    # Ensure all customers are served and no route exceeds capacity\n    all_nodes = set(range(1, len(coords)))\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated invalid solution (capacity exceeded)\")\n\n    if served_nodes != all_nodes:\n        raise ValueError(\"Generated invalid solution (not all customers served)\")\n\n    return new_solution\n\n",
        "score": [
            -0.6681281145945828,
            3.0297290086746216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a weighted combination of objectives\n    weights = np.array([0.7, 0.3])  # More weight on total distance\n    scores = np.array([w[1][0] * weights[0] + w[1][1] * weights[1] for w in archive])\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (just depot)\n            new_solution.append(route.copy())\n            continue\n\n        # Hybrid local search: split, insert, and swap\n        modified_route = route.copy()\n        n = len(modified_route)\n\n        # Step 1: Randomly split the route if it's too long\n        if np.random.rand() < 0.3 and len(route) > 5:\n            split_pos = np.random.randint(2, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n                continue\n\n        # Step 2: Randomly insert a node from another route\n        if len(base_solution) > 1 and np.random.rand() < 0.5:\n            other_route_idx = np.random.choice([i for i in range(len(base_solution)) if i != selected_idx])\n            other_route = base_solution[other_route_idx]\n            if len(other_route) > 3:\n                # Select a random node from other route (not depot)\n                node_to_insert = np.random.choice(other_route[1:-1])\n                insert_pos = np.random.randint(1, len(modified_route)-1)\n\n                # Check capacity\n                if np.sum(demand[modified_route[1:-1]]) + demand[node_to_insert] <= capacity:\n                    modified_route = np.concatenate([modified_route[:insert_pos], [node_to_insert], modified_route[insert_pos:]])\n\n        # Step 3: Randomly swap two nodes within the route\n        if len(modified_route) > 4 and np.random.rand() < 0.5:\n            i, j = np.random.choice(range(1, len(modified_route)-1), 2, replace=False)\n            # Ensure capacity constraint after swap\n            if (np.sum(demand[modified_route[1:-1]]) - demand[modified_route[i]] + demand[modified_route[j]]) <= capacity:\n                modified_route[i], modified_route[j] = modified_route[j], modified_route[i]\n\n        new_solution.append(modified_route)\n\n    # Ensure all customers are served and no route exceeds capacity\n    all_nodes = set(range(1, len(coords)))\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated invalid solution (capacity exceeded)\")\n\n    if served_nodes != all_nodes:\n        raise ValueError(\"Generated invalid solution (not all customers served)\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{The algorithm selects a promising solution from the archive using a tournament selection based on a weighted sum of normalized objective values, then applies a hybrid local search combining route swapping and partial route reversal to generate a feasible neighbor solution while balancing distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: (x[1][0] + x[1][1]))  # Simple sum for tournament\n    base_solution = selected[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping and partial reversal\n    if len(new_solution) > 1:\n        # Select two random routes\n        i, j = random.sample(range(len(new_solution)), 2)\n\n        # Try swapping segments between routes\n        route1, route2 = new_solution[i], new_solution[j]\n        if len(route1) > 3 and len(route2) > 3:\n            # Find feasible swap points\n            max_len = min(len(route1) - 2, len(route2) - 2)\n            if max_len > 1:\n                k1 = random.randint(1, max_len - 1)\n                k2 = random.randint(1, max_len - 1)\n\n                # Check capacity constraints\n                demand1 = sum(demand[route1[k1:-1]])\n                demand2 = sum(demand[route2[k2:-1]])\n                if demand1 + sum(demand[route2[1:k2]]) <= capacity and \\\n                   demand2 + sum(demand[route1[1:k1]]) <= capacity:\n\n                    # Perform the swap\n                    new_route1 = np.concatenate([route1[:k1], route2[k2:-1], route1[-1:]])\n                    new_route2 = np.concatenate([route2[:k2], route1[k1:-1], route2[-1:]])\n\n                    # Update solution\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n        # Try partial reversal on a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            reversed_segment = route[a:b+1][::-1]\n\n            # Check capacity constraint\n            if sum(demand[reversed_segment[1:-1]]) <= capacity:\n                new_route = np.concatenate([route[:a], reversed_segment, route[b+1:]])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5186881893919525,
            0.7837680578231812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: (x[1][0] + x[1][1]))  # Simple sum for tournament\n    base_solution = selected[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping and partial reversal\n    if len(new_solution) > 1:\n        # Select two random routes\n        i, j = random.sample(range(len(new_solution)), 2)\n\n        # Try swapping segments between routes\n        route1, route2 = new_solution[i], new_solution[j]\n        if len(route1) > 3 and len(route2) > 3:\n            # Find feasible swap points\n            max_len = min(len(route1) - 2, len(route2) - 2)\n            if max_len > 1:\n                k1 = random.randint(1, max_len - 1)\n                k2 = random.randint(1, max_len - 1)\n\n                # Check capacity constraints\n                demand1 = sum(demand[route1[k1:-1]])\n                demand2 = sum(demand[route2[k2:-1]])\n                if demand1 + sum(demand[route2[1:k2]]) <= capacity and \\\n                   demand2 + sum(demand[route1[1:k1]]) <= capacity:\n\n                    # Perform the swap\n                    new_route1 = np.concatenate([route1[:k1], route2[k2:-1], route1[-1:]])\n                    new_route2 = np.concatenate([route2[:k2], route1[k1:-1], route2[-1:]])\n\n                    # Update solution\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n        # Try partial reversal on a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            reversed_segment = route[a:b+1][::-1]\n\n            # Check capacity constraint\n            if sum(demand[reversed_segment[1:-1]]) <= capacity:\n                new_route = np.concatenate([route[:a], reversed_segment, route[b+1:]])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a weighted combination of objective values and applies a hybrid local search that combines route splitting, customer reallocation, and adaptive 2-opt to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distance_weights = np.array([1.0 / (obj[0] + 1e-6) for _, obj in archive])\n    makespan_weights = np.array([1.0 / (obj[1] + 1e-6) for _, obj in archive])\n    combined_weights = 0.5 * total_distance_weights + 0.5 * makespan_weights\n    combined_weights /= combined_weights.sum()\n    selected_idx = np.random.choice(len(archive), p=combined_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Perform multiple iterations\n        # Step 1: Route splitting (if a route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only consider splitting if route has enough customers\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i + 1, new_route2)\n                    break  # Only split one route per iteration\n\n        # Step 2: Customer reallocation (move a customer from one route to another)\n        if len(new_solution) > 1:\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if from_route_idx != to_route_idx:\n                from_route = new_solution[from_route_idx]\n                to_route = new_solution[to_route_idx]\n\n                if len(from_route) > 2:  # Ensure there's a customer to move\n                    customer_pos = random.randint(1, len(from_route) - 2)\n                    customer = from_route[customer_pos]\n\n                    # Check feasibility for to_route\n                    if np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into to_route (random position)\n                        insert_pos = random.randint(1, len(to_route) - 1)\n                        new_to_route = np.concatenate((to_route[:insert_pos], [customer], to_route[insert_pos:]))\n                        new_solution[to_route_idx] = new_to_route\n\n                        # Remove customer from from_route\n                        new_from_route = np.concatenate((from_route[:customer_pos], from_route[customer_pos + 1:]))\n                        new_solution[from_route_idx] = new_from_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Step 3: Adaptive 2-opt (focus on improving the longest route)\n        if len(new_solution) > 0:\n            # Find the longest route\n            longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 3:  # Only perform 2-opt if route has enough customers\n                # Select two random edges to swap\n                i = random.randint(1, len(longest_route) - 3)\n                j = random.randint(i + 1, len(longest_route) - 2)\n\n                # Create new route with swapped edges\n                new_route = np.concatenate((\n                    longest_route[:i],\n                    longest_route[j:j + 1],\n                    longest_route[i + 1:j],\n                    longest_route[i:i + 1],\n                    longest_route[j + 1:]\n                ))\n\n                # Check feasibility (no capacity check needed as we're not changing customers)\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8429248211902431,
            4.262689054012299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distance_weights = np.array([1.0 / (obj[0] + 1e-6) for _, obj in archive])\n    makespan_weights = np.array([1.0 / (obj[1] + 1e-6) for _, obj in archive])\n    combined_weights = 0.5 * total_distance_weights + 0.5 * makespan_weights\n    combined_weights /= combined_weights.sum()\n    selected_idx = np.random.choice(len(archive), p=combined_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Perform multiple iterations\n        # Step 1: Route splitting (if a route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only consider splitting if route has enough customers\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i + 1, new_route2)\n                    break  # Only split one route per iteration\n\n        # Step 2: Customer reallocation (move a customer from one route to another)\n        if len(new_solution) > 1:\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if from_route_idx != to_route_idx:\n                from_route = new_solution[from_route_idx]\n                to_route = new_solution[to_route_idx]\n\n                if len(from_route) > 2:  # Ensure there's a customer to move\n                    customer_pos = random.randint(1, len(from_route) - 2)\n                    customer = from_route[customer_pos]\n\n                    # Check feasibility for to_route\n                    if np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into to_route (random position)\n                        insert_pos = random.randint(1, len(to_route) - 1)\n                        new_to_route = np.concatenate((to_route[:insert_pos], [customer], to_route[insert_pos:]))\n                        new_solution[to_route_idx] = new_to_route\n\n                        # Remove customer from from_route\n                        new_from_route = np.concatenate((from_route[:customer_pos], from_route[customer_pos + 1:]))\n                        new_solution[from_route_idx] = new_from_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Step 3: Adaptive 2-opt (focus on improving the longest route)\n        if len(new_solution) > 0:\n            # Find the longest route\n            longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 3:  # Only perform 2-opt if route has enough customers\n                # Select two random edges to swap\n                i = random.randint(1, len(longest_route) - 3)\n                j = random.randint(i + 1, len(longest_route) - 2)\n\n                # Create new route with swapped edges\n                new_route = np.concatenate((\n                    longest_route[:i],\n                    longest_route[j:j + 1],\n                    longest_route[i + 1:j],\n                    longest_route[i:i + 1],\n                    longest_route[j + 1:]\n                ))\n\n                # Check feasibility (no capacity check needed as we're not changing customers)\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        # Try to split the route into two parts\n        split_pos = np.random.randint(1, len(route) - 1)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = np.concatenate(([0], route[split_pos:]))\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity) and (np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx + 1, new_route2)\n        else:\n            # If split fails, try relocating a random customer to another route\n            if len(new_solution) > 1:\n                other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx].copy()\n                customer_pos = np.random.randint(1, len(route) - 1)\n                customer = route[customer_pos]\n\n                # Check capacity for both routes\n                if (np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity):\n                    new_route = route.copy()\n                    new_route = np.concatenate((new_route[:customer_pos], new_route[customer_pos + 1:]))\n                    other_route = np.concatenate((other_route[:-1], [customer], [0]))\n\n                    # Update solution\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = other_route\n    else:\n        # If only one route, try relocating a customer\n        route = new_solution[0].copy()\n        if len(route) > 3:\n            customer_pos = np.random.randint(1, len(route) - 1)\n            customer = route[customer_pos]\n            new_route = np.concatenate((route[:customer_pos], route[customer_pos + 1:]))\n            new_route2 = np.array([0, customer, 0])\n\n            # Check capacity\n            if (np.sum(demand[new_route[1:-1]]) <= capacity) and (np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[0] = new_route\n                new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.5835902530920906,
            0.23114946484565735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        # Try to split the route into two parts\n        split_pos = np.random.randint(1, len(route) - 1)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = np.concatenate(([0], route[split_pos:]))\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity) and (np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx + 1, new_route2)\n        else:\n            # If split fails, try relocating a random customer to another route\n            if len(new_solution) > 1:\n                other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx].copy()\n                customer_pos = np.random.randint(1, len(route) - 1)\n                customer = route[customer_pos]\n\n                # Check capacity for both routes\n                if (np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity):\n                    new_route = route.copy()\n                    new_route = np.concatenate((new_route[:customer_pos], new_route[customer_pos + 1:]))\n                    other_route = np.concatenate((other_route[:-1], [customer], [0]))\n\n                    # Update solution\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = other_route\n    else:\n        # If only one route, try relocating a customer\n        route = new_solution[0].copy()\n        if len(route) > 3:\n            customer_pos = np.random.randint(1, len(route) - 1)\n            customer = route[customer_pos]\n            new_route = np.concatenate((route[:customer_pos], route[customer_pos + 1:]))\n            new_route2 = np.array([0, customer, 0])\n\n            # Check capacity\n            if (np.sum(demand[new_route[1:-1]]) <= capacity) and (np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[0] = new_route\n                new_solution.append(new_route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with high makespan or total distance, then applies a hybrid local search combining route merging, customer reallocation, and capacity-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (high makespan or total distance)\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging, customer reallocation, and capacity-aware swaps\n    if len(new_solution) > 1 and random.random() < 0.3:\n        # Route merging: randomly merge two routes if their combined demand <= capacity\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Remove depot (0) from routes for merging\n        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n\n        # Check capacity constraint\n        total_demand = sum(demand[node] for node in merged_route if node != 0)\n        if total_demand <= capacity:\n            # Replace routes with merged route\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n            new_solution.append(merged_route)\n\n    elif random.random() < 0.5:\n        # Customer reallocation: move a random customer from one route to another if feasible\n        if len(new_solution) >= 1:\n            source_route_idx = random.randint(0, len(new_solution) - 1)\n            source_route = new_solution[source_route_idx]\n\n            if len(source_route) > 3:  # Ensure route has at least one customer to move\n                # Select a random customer (excluding depot)\n                customer_to_move = random.choice(source_route[1:-1])\n\n                # Try to insert into another route\n                for target_route_idx in range(len(new_solution)):\n                    if target_route_idx == source_route_idx:\n                        continue\n\n                    target_route = new_solution[target_route_idx]\n                    # Check capacity constraint\n                    current_demand = sum(demand[node] for node in target_route if node != 0)\n                    if current_demand + demand[customer_to_move] <= capacity:\n                        # Insert customer into target route\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target_route = np.insert(target_route, insert_pos, customer_to_move)\n                        new_solution[target_route_idx] = new_target_route\n\n                        # Remove customer from source route\n                        new_source_route = np.delete(source_route, np.where(source_route == customer_to_move)[0][0])\n                        new_solution[source_route_idx] = new_source_route\n                        break\n\n    else:\n        # Capacity-aware swap: swap two customers between two routes if feasible\n        if len(new_solution) >= 2:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            if len(route_i) > 2 and len(route_j) > 2:\n                # Select two random customers (excluding depot)\n                customer_i = random.choice(route_i[1:-1])\n                customer_j = random.choice(route_j[1:-1])\n\n                # Check capacity constraints for both routes after swap\n                demand_i = sum(demand[node] for node in route_i if node != 0)\n                demand_j = sum(demand[node] for node in route_j if node != 0)\n\n                if (demand_i - demand[customer_i] + demand[customer_j] <= capacity and\n                    demand_j - demand[customer_j] + demand[customer_i] <= capacity):\n                    # Perform swap\n                    new_route_i = route_i.copy()\n                    new_route_j = route_j.copy()\n\n                    # Replace customer_i in route_i with customer_j\n                    idx_i = np.where(new_route_i == customer_i)[0][0]\n                    new_route_i[idx_i] = customer_j\n\n                    # Replace customer_j in route_j with customer_i\n                    idx_j = np.where(new_route_j == customer_j)[0][0]\n                    new_route_j[idx_j] = customer_i\n\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    return new_solution\n\n",
        "score": [
            -0.6578791149007222,
            0.7287306785583496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (high makespan or total distance)\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging, customer reallocation, and capacity-aware swaps\n    if len(new_solution) > 1 and random.random() < 0.3:\n        # Route merging: randomly merge two routes if their combined demand <= capacity\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Remove depot (0) from routes for merging\n        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n\n        # Check capacity constraint\n        total_demand = sum(demand[node] for node in merged_route if node != 0)\n        if total_demand <= capacity:\n            # Replace routes with merged route\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n            new_solution.append(merged_route)\n\n    elif random.random() < 0.5:\n        # Customer reallocation: move a random customer from one route to another if feasible\n        if len(new_solution) >= 1:\n            source_route_idx = random.randint(0, len(new_solution) - 1)\n            source_route = new_solution[source_route_idx]\n\n            if len(source_route) > 3:  # Ensure route has at least one customer to move\n                # Select a random customer (excluding depot)\n                customer_to_move = random.choice(source_route[1:-1])\n\n                # Try to insert into another route\n                for target_route_idx in range(len(new_solution)):\n                    if target_route_idx == source_route_idx:\n                        continue\n\n                    target_route = new_solution[target_route_idx]\n                    # Check capacity constraint\n                    current_demand = sum(demand[node] for node in target_route if node != 0)\n                    if current_demand + demand[customer_to_move] <= capacity:\n                        # Insert customer into target route\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target_route = np.insert(target_route, insert_pos, customer_to_move)\n                        new_solution[target_route_idx] = new_target_route\n\n                        # Remove customer from source route\n                        new_source_route = np.delete(source_route, np.where(source_route == customer_to_move)[0][0])\n                        new_solution[source_route_idx] = new_source_route\n                        break\n\n    else:\n        # Capacity-aware swap: swap two customers between two routes if feasible\n        if len(new_solution) >= 2:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            if len(route_i) > 2 and len(route_j) > 2:\n                # Select two random customers (excluding depot)\n                customer_i = random.choice(route_i[1:-1])\n                customer_j = random.choice(route_j[1:-1])\n\n                # Check capacity constraints for both routes after swap\n                demand_i = sum(demand[node] for node in route_i if node != 0)\n                demand_j = sum(demand[node] for node in route_j if node != 0)\n\n                if (demand_i - demand[customer_i] + demand[customer_j] <= capacity and\n                    demand_j - demand[customer_j] + demand[customer_i] <= capacity):\n                    # Perform swap\n                    new_route_i = route_i.copy()\n                    new_route_j = route_j.copy()\n\n                    # Replace customer_i in route_i with customer_j\n                    idx_i = np.where(new_route_i == customer_i)[0][0]\n                    new_route_i[idx_i] = customer_j\n\n                    # Replace customer_j in route_j with customer_i\n                    idx_j = np.where(new_route_j == customer_j)[0][0]\n                    new_route_j[idx_j] = customer_i\n\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and route splitting\n    for i in range(len(new_solution)):\n        route_i = new_solution[i]\n        if len(route_i) <= 3:  # Skip trivial routes\n            continue\n\n        # Try to split the route into two\n        split_pos = len(route_i) // 2\n        route1 = route_i[:split_pos + 1]\n        route2 = route_i[split_pos:]\n\n        # Check feasibility of split\n        if (sum(demand[route1[1:-1]]) <= capacity and\n            sum(demand[route2[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution[i] = route1\n            new_solution.append(route2)\n            break\n\n    # Try to merge two routes if they are short\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            if len(route_i) + len(route_j) - 2 <= 10:  # Arbitrary threshold\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                if sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8130100523636371,
            0.18117275834083557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and route splitting\n    for i in range(len(new_solution)):\n        route_i = new_solution[i]\n        if len(route_i) <= 3:  # Skip trivial routes\n            continue\n\n        # Try to split the route into two\n        split_pos = len(route_i) // 2\n        route1 = route_i[:split_pos + 1]\n        route2 = route_i[split_pos:]\n\n        # Check feasibility of split\n        if (sum(demand[route1[1:-1]]) <= capacity and\n            sum(demand[route2[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution[i] = route1\n            new_solution.append(route2)\n            break\n\n    # Try to merge two routes if they are short\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            if len(route_i) + len(route_j) - 2 <= 10:  # Arbitrary threshold\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                if sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan descending\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: Merge, split, and reallocate with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split long routes into two\n        split_pos = len(route) // 2\n        new_route1 = np.hstack([route[:split_pos], [0]])\n        new_route2 = np.hstack([[0], route[split_pos:-1]])\n\n        # Check capacity constraints\n        def is_valid(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if is_valid(new_route1) and is_valid(new_route2):\n            new_solution.extend([new_route1, new_route2])\n        else:\n            # Reallocate customers if split fails\n            for node in route[1:-1]:\n                # Find the least loaded route with capacity\n                best_route = None\n                min_load = float('inf')\n                for r in new_solution:\n                    if np.sum(demand[r[1:-1]]) + demand[node] <= capacity:\n                        if len(r) < min_load:\n                            min_load = len(r)\n                            best_route = r\n                if best_route is not None:\n                    best_route = np.hstack([best_route[:-1], [node], [0]])\n                    new_solution[new_solution.index(best_route)] = best_route\n                else:\n                    new_solution.append(np.array([0, node, 0]))\n\n    # Merge short routes if possible\n    merged_solution = []\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:\n            continue\n        merged = False\n        for j, other_route in enumerate(new_solution[i+1:]):\n            if len(other_route) <= 3:\n                continue\n            combined = np.hstack([route[:-1], other_route[1:]])\n            if np.sum(demand[combined[1:-1]]) <= capacity:\n                merged_solution.append(combined)\n                merged = True\n                break\n        if not merged:\n            merged_solution.append(route)\n\n    # Final validation\n    for route in merged_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Capacity constraint violated in neighbor solution\")\n\n    return merged_solution\n\n",
        "score": [
            -0.7577799113287715,
            2.2101607024669647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan descending\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: Merge, split, and reallocate with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split long routes into two\n        split_pos = len(route) // 2\n        new_route1 = np.hstack([route[:split_pos], [0]])\n        new_route2 = np.hstack([[0], route[split_pos:-1]])\n\n        # Check capacity constraints\n        def is_valid(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if is_valid(new_route1) and is_valid(new_route2):\n            new_solution.extend([new_route1, new_route2])\n        else:\n            # Reallocate customers if split fails\n            for node in route[1:-1]:\n                # Find the least loaded route with capacity\n                best_route = None\n                min_load = float('inf')\n                for r in new_solution:\n                    if np.sum(demand[r[1:-1]]) + demand[node] <= capacity:\n                        if len(r) < min_load:\n                            min_load = len(r)\n                            best_route = r\n                if best_route is not None:\n                    best_route = np.hstack([best_route[:-1], [node], [0]])\n                    new_solution[new_solution.index(best_route)] = best_route\n                else:\n                    new_solution.append(np.array([0, node, 0]))\n\n    # Merge short routes if possible\n    merged_solution = []\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:\n            continue\n        merged = False\n        for j, other_route in enumerate(new_solution[i+1:]):\n            if len(other_route) <= 3:\n                continue\n            combined = np.hstack([route[:-1], other_route[1:]])\n            if np.sum(demand[combined[1:-1]]) <= capacity:\n                merged_solution.append(combined)\n                merged = True\n                break\n        if not merged:\n            merged_solution.append(route)\n\n    # Final validation\n    for route in merged_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Capacity constraint violated in neighbor solution\")\n\n    return merged_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combined score of distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (low distance and high makespan)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: split, reallocate, and adaptive 2-opt\n    new_solution = base_solution.copy()\n\n    # Step 1: Split long routes probabilistically\n    for i, route in enumerate(new_solution):\n        if len(route) > 3 and random.random() < 0.7:  # 70% chance for long routes\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = [0] + route[split_pos + 1:]\n\n            # Check feasibility\n            if (sum(demand[route[1:split_pos + 1]]) <= capacity and\n                sum(demand[route[split_pos + 1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n    # Step 2: Reallocate customers between routes\n    for _ in range(2):  # Try twice\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 2:\n            continue\n\n        customer_idx = random.randint(1, len(route1) - 2)\n        customer = route1[customer_idx]\n\n        # Find best insertion position in another route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == route1_idx:\n                continue\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if sum(demand[route[1:pos]]) + demand[customer] + sum(demand[route[pos:-1]]) <= capacity:\n                    # Calculate insertion cost\n                    cost = (distance_matrix[route[pos - 1]][customer] +\n                            distance_matrix[customer][route[pos]] -\n                            distance_matrix[route[pos - 1]][route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Perform reallocation\n            new_solution[route1_idx] = np.delete(route1, customer_idx)\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    # Step 3: Adaptive 2-opt on selected routes\n    for route in new_solution:\n        if len(route) > 4 and random.random() < 0.5:  # 50% chance for routes >4 nodes\n            i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n            # Check capacity constraint for the reversed segment\n            if sum(demand[route[i:j + 1][::-1]]) <= capacity:\n                route[i:j + 1] = route[i:j + 1][::-1]\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 1]\n\n    return new_solution\n\n",
        "score": [
            -0.7745413328608236,
            5.090172499418259
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (low distance and high makespan)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: split, reallocate, and adaptive 2-opt\n    new_solution = base_solution.copy()\n\n    # Step 1: Split long routes probabilistically\n    for i, route in enumerate(new_solution):\n        if len(route) > 3 and random.random() < 0.7:  # 70% chance for long routes\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = [0] + route[split_pos + 1:]\n\n            # Check feasibility\n            if (sum(demand[route[1:split_pos + 1]]) <= capacity and\n                sum(demand[route[split_pos + 1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n    # Step 2: Reallocate customers between routes\n    for _ in range(2):  # Try twice\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 2:\n            continue\n\n        customer_idx = random.randint(1, len(route1) - 2)\n        customer = route1[customer_idx]\n\n        # Find best insertion position in another route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == route1_idx:\n                continue\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if sum(demand[route[1:pos]]) + demand[customer] + sum(demand[route[pos:-1]]) <= capacity:\n                    # Calculate insertion cost\n                    cost = (distance_matrix[route[pos - 1]][customer] +\n                            distance_matrix[customer][route[pos]] -\n                            distance_matrix[route[pos - 1]][route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Perform reallocation\n            new_solution[route1_idx] = np.delete(route1, customer_idx)\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    # Step 3: Adaptive 2-opt on selected routes\n    for route in new_solution:\n        if len(route) > 4 and random.random() < 0.5:  # 50% chance for routes >4 nodes\n            i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n            # Check capacity constraint for the reversed segment\n            if sum(demand[route[i:j + 1][::-1]]) <= capacity:\n                route[i:j + 1] = route[i:j + 1][::-1]\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with the lowest makespan and then applies a hybrid local search combining route-splitting and inter-route insertion, ensuring feasibility through capacity checks and distance updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Route-splitting and inter-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two at a random point\n        split_idx = random.randint(1, len(route) - 2)\n        route1 = route[:split_idx + 1]\n        route2 = np.concatenate([[0], route[split_idx:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n            new_solution.extend([route1, route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Inter-route insertion: Move a random customer to another route if feasible\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 2:  # Can remove a customer\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n\n            # Try inserting into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Find best insertion position\n                best_pos = -1\n                best_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate distance increase\n                    prev_node = other_route[pos - 1]\n                    next_node = other_route[pos]\n                    new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    if np.sum(demand[np.concatenate([other_route[1:-1], [customer]])]) <= capacity and new_dist < best_increase:\n                        best_pos = pos\n                        best_increase = new_dist\n\n                if best_pos != -1:\n                    # Insert customer\n                    other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[other_route_idx] = other_route\n\n                    # Remove customer from original route\n                    route = np.concatenate([route[:customer_idx], route[customer_idx + 1:]])\n                    new_solution[route_idx] = route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6996868649547434,
            0.8883176445960999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Route-splitting and inter-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two at a random point\n        split_idx = random.randint(1, len(route) - 2)\n        route1 = route[:split_idx + 1]\n        route2 = np.concatenate([[0], route[split_idx:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n            new_solution.extend([route1, route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Inter-route insertion: Move a random customer to another route if feasible\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 2:  # Can remove a customer\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n\n            # Try inserting into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Find best insertion position\n                best_pos = -1\n                best_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate distance increase\n                    prev_node = other_route[pos - 1]\n                    next_node = other_route[pos]\n                    new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    if np.sum(demand[np.concatenate([other_route[1:-1], [customer]])]) <= capacity and new_dist < best_increase:\n                        best_pos = pos\n                        best_increase = new_dist\n\n                if best_pos != -1:\n                    # Insert customer\n                    other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[other_route_idx] = other_route\n\n                    # Remove customer from original route\n                    route = np.concatenate([route[:customer_idx], route[customer_idx + 1:]])\n                    new_solution[route_idx] = route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Identify the longest route (potential target for improvement)\n    longest_route_idx = np.argmax([np.sum([distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Apply a hybrid local search: split the longest route into two parts and reinsert nodes into other routes\n    if len(longest_route) > 3:  # Ensure the route has enough nodes to split\n        split_pos = len(longest_route) // 2\n        part1 = longest_route[:split_pos + 1]\n        part2 = longest_route[split_pos:]\n\n        # Remove the original longest route\n        new_solution.pop(longest_route_idx)\n\n        # Try to reinsert part1 and part2 into other routes or as new routes\n        for part in [part1, part2]:\n            inserted = False\n            for i, route in enumerate(new_solution):\n                # Check if adding the part to this route is feasible\n                new_route = np.concatenate([route[:-1], part[1:-1], route[-1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                # If not inserted, add as a new route\n                new_solution.append(part.copy())\n\n    return new_solution\n\n",
        "score": [
            -0.709187180939412,
            1.4543168544769287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Identify the longest route (potential target for improvement)\n    longest_route_idx = np.argmax([np.sum([distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Apply a hybrid local search: split the longest route into two parts and reinsert nodes into other routes\n    if len(longest_route) > 3:  # Ensure the route has enough nodes to split\n        split_pos = len(longest_route) // 2\n        part1 = longest_route[:split_pos + 1]\n        part2 = longest_route[split_pos:]\n\n        # Remove the original longest route\n        new_solution.pop(longest_route_idx)\n\n        # Try to reinsert part1 and part2 into other routes or as new routes\n        for part in [part1, part2]:\n            inserted = False\n            for i, route in enumerate(new_solution):\n                # Check if adding the part to this route is feasible\n                new_route = np.concatenate([route[:-1], part[1:-1], route[-1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                # If not inserted, add as a new route\n                new_solution.append(part.copy())\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This algorithm selects a solution from the archive with high total distance and low makespan, then applies a hybrid local search combining route splitting, customer reallocation, and 2-opt with capacity checks to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and 2-opt\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select a route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Only split if route has enough customers\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos]\n            new_route2 = route[split_pos-1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1 and len(route) > 3:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer from the current route (not depot)\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Try to insert into the other route\n            for insert_pos in range(1, len(other_route)):\n                temp_route = np.insert(other_route, insert_pos, customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Update both routes\n                    new_solution[route_idx] = np.delete(route, customer_pos)\n                    new_solution[other_route_idx] = temp_route\n                    break\n\n        # 2-opt with capacity check\n        if len(route) > 4:\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n\n            # Create the reversed segment\n            reversed_segment = route[i:j+1][::-1]\n\n            # Check capacity constraint for the modified route\n            new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.724299829106948,
            0.3464793562889099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and 2-opt\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select a route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Only split if route has enough customers\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos]\n            new_route2 = route[split_pos-1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1 and len(route) > 3:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer from the current route (not depot)\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Try to insert into the other route\n            for insert_pos in range(1, len(other_route)):\n                temp_route = np.insert(other_route, insert_pos, customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Update both routes\n                    new_solution[route_idx] = np.delete(route, customer_pos)\n                    new_solution[other_route_idx] = temp_route\n                    break\n\n        # 2-opt with capacity check\n        if len(route) > 4:\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n\n            # Create the reversed segment\n            reversed_segment = route[i:j+1][::-1]\n\n            # Check capacity constraint for the modified route\n            new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with lower makespan, then applies a hybrid local search that combines route splitting and inter-route customer swaps to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split long routes and swap customers between routes\n    new_solution = []\n    for route in selected_solution:\n        # Split the route if it's too long (makespan reduction)\n        if len(route) > 3:  # Only split if route has more than 3 nodes (depot + 2+ customers)\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check feasibility of split routes\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Swap customers between routes to improve distance\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Find feasible swaps\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                # Try swapping route1[i] and route2[j]\n                new_route1 = route1.copy()\n                new_route1[i] = route2[j]\n                new_route2 = route2.copy()\n                new_route2[j] = route1[i]\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8810699239039712,
            5.375005602836609
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split long routes and swap customers between routes\n    new_solution = []\n    for route in selected_solution:\n        # Split the route if it's too long (makespan reduction)\n        if len(route) > 3:  # Only split if route has more than 3 nodes (depot + 2+ customers)\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check feasibility of split routes\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Swap customers between routes to improve distance\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Find feasible swaps\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                # Try swapping route1[i] and route2[j]\n                new_route1 = route1.copy()\n                new_route1[i] = route2[j]\n                new_route2 = route2.copy()\n                new_route2[j] = route1[i]\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest makespan (promising for improvement)\n    _, (_, makespan) = max(archive, key=lambda x: x[1][1])\n    candidates = [sol for sol in archive if sol[1][1] == makespan]\n    selected_solution = random.choice(candidates)[0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if (sum(demand[part1[1:-1]]) <= capacity) and (sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Attempt to reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Try moving a random customer from route_i to route_j\n            if len(route_i) > 3:\n                customer_idx = random.randint(1, len(route_i) - 2)\n                customer = route_i[customer_idx]\n\n                # Check if moving this customer to route_j is feasible\n                if sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx + 1:]])\n                    new_route_j = np.concatenate([route_j[:-1], [customer], [0]])\n\n                    # Replace routes if they are valid\n                    if len(new_route_i) >= 3 and len(new_route_j) >= 3:\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n                        break\n\n    # Ensure all customers are served (sanity check)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Fallback: use original solution if something went wrong\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7538054843717215,
            1.649636059999466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest makespan (promising for improvement)\n    _, (_, makespan) = max(archive, key=lambda x: x[1][1])\n    candidates = [sol for sol in archive if sol[1][1] == makespan]\n    selected_solution = random.choice(candidates)[0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if (sum(demand[part1[1:-1]]) <= capacity) and (sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Attempt to reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Try moving a random customer from route_i to route_j\n            if len(route_i) > 3:\n                customer_idx = random.randint(1, len(route_i) - 2)\n                customer = route_i[customer_idx]\n\n                # Check if moving this customer to route_j is feasible\n                if sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx + 1:]])\n                    new_route_j = np.concatenate([route_j[:-1], [customer], [0]])\n\n                    # Replace routes if they are valid\n                    if len(new_route_i) >= 3 and len(new_route_j) >= 3:\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n                        break\n\n    # Ensure all customers are served (sanity check)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Fallback: use original solution if something went wrong\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select two routes to merge or split\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Attempt to merge the two routes if their total demand is within capacity\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route_j into route_i at the closest possible point\n            best_pos = 0\n            min_dist = float('inf')\n            for k in range(1, len(route_i) - 1):\n                dist = distance_matrix[route_i[k]][route_j[1]] + distance_matrix[route_j[-2]][route_i[k+1]] - distance_matrix[route_i[k]][route_i[k+1]]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pos = k\n\n            # Insert route_j into route_i\n            merged_route = np.concatenate([route_i[:best_pos+1], route_j[1:-1], route_i[best_pos+1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n        else:\n            # If merging is not feasible, try splitting a route\n            if len(route_i) > 3:\n                split_pos = np.random.randint(1, len(route_i) - 2)\n                split_route = np.concatenate([[0], route_i[1:split_pos+1], [0]])\n                remaining_route = np.concatenate([[0], route_i[split_pos+1:-1], [0]])\n\n                # Check capacity constraints\n                if np.sum(demand[split_route[1:-1]]) <= capacity and np.sum(demand[remaining_route[1:-1]]) <= capacity:\n                    new_solution[i] = split_route\n                    new_solution.insert(i+1, remaining_route)\n\n    # Verify feasibility and return the new solution\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution violates capacity constraints.\")\n\n    return new_solution\n\n",
        "score": [
            -0.5481596423158497,
            1.229970932006836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select two routes to merge or split\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Attempt to merge the two routes if their total demand is within capacity\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route_j into route_i at the closest possible point\n            best_pos = 0\n            min_dist = float('inf')\n            for k in range(1, len(route_i) - 1):\n                dist = distance_matrix[route_i[k]][route_j[1]] + distance_matrix[route_j[-2]][route_i[k+1]] - distance_matrix[route_i[k]][route_i[k+1]]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pos = k\n\n            # Insert route_j into route_i\n            merged_route = np.concatenate([route_i[:best_pos+1], route_j[1:-1], route_i[best_pos+1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n        else:\n            # If merging is not feasible, try splitting a route\n            if len(route_i) > 3:\n                split_pos = np.random.randint(1, len(route_i) - 2)\n                split_route = np.concatenate([[0], route_i[1:split_pos+1], [0]])\n                remaining_route = np.concatenate([[0], route_i[split_pos+1:-1], [0]])\n\n                # Check capacity constraints\n                if np.sum(demand[split_route[1:-1]]) <= capacity and np.sum(demand[remaining_route[1:-1]]) <= capacity:\n                    new_solution[i] = split_route\n                    new_solution.insert(i+1, remaining_route)\n\n    # Verify feasibility and return the new solution\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution violates capacity constraints.\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    solution_weights = [1 / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(solution_weights) / sum(solution_weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [r for k, r in enumerate(new_solution) if k not in (i, j)]\n            new_solution.append(merged_route)\n\n            # Reallocate customers from the longest route to balance makespan\n            if len(new_solution) > 1:\n                longest_route_idx = np.argmax([sum(distance_matrix[r[:-1], r[1:]]) for r in new_solution])\n                longest_route = new_solution[longest_route_idx]\n                customers = longest_route[1:-1]\n\n                # Try to move customers to other routes if feasible\n                for customer in customers:\n                    for k, route in enumerate(new_solution):\n                        if k != longest_route_idx and sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                            # Insert customer into route\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(route)):\n                                cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n                            new_route = np.insert(route, best_pos, customer)\n                            new_solution[k] = new_route\n                            new_solution[longest_route_idx] = np.delete(longest_route, np.where(longest_route == customer)[0])\n                            break\n\n    # Randomly swap two customers between routes if feasible\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Select random customers from each route (excluding depots)\n            cust_i = np.random.choice(route_i[1:-1])\n            cust_j = np.random.choice(route_j[1:-1])\n\n            # Check feasibility\n            if (sum(demand[route_i[1:-1]]) - demand[cust_i] + demand[cust_j] <= capacity and\n                sum(demand[route_j[1:-1]]) - demand[cust_j] + demand[cust_i] <= capacity):\n                # Perform swap\n                new_solution[i] = np.where(route_i == cust_i, cust_j, route_i)\n                new_solution[j] = np.where(route_j == cust_j, cust_i, route_j)\n\n    return new_solution\n\n",
        "score": [
            -0.4968578484478431,
            1.3010910153388977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    solution_weights = [1 / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(solution_weights) / sum(solution_weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [r for k, r in enumerate(new_solution) if k not in (i, j)]\n            new_solution.append(merged_route)\n\n            # Reallocate customers from the longest route to balance makespan\n            if len(new_solution) > 1:\n                longest_route_idx = np.argmax([sum(distance_matrix[r[:-1], r[1:]]) for r in new_solution])\n                longest_route = new_solution[longest_route_idx]\n                customers = longest_route[1:-1]\n\n                # Try to move customers to other routes if feasible\n                for customer in customers:\n                    for k, route in enumerate(new_solution):\n                        if k != longest_route_idx and sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                            # Insert customer into route\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(route)):\n                                cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n                            new_route = np.insert(route, best_pos, customer)\n                            new_solution[k] = new_route\n                            new_solution[longest_route_idx] = np.delete(longest_route, np.where(longest_route == customer)[0])\n                            break\n\n    # Randomly swap two customers between routes if feasible\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Select random customers from each route (excluding depots)\n            cust_i = np.random.choice(route_i[1:-1])\n            cust_j = np.random.choice(route_j[1:-1])\n\n            # Check feasibility\n            if (sum(demand[route_i[1:-1]]) - demand[cust_i] + demand[cust_j] <= capacity and\n                sum(demand[route_j[1:-1]]) - demand[cust_j] + demand[cust_i] <= capacity):\n                # Perform swap\n                new_solution[i] = np.where(route_i == cust_i, cust_j, route_i)\n                new_solution[j] = np.where(route_j == cust_j, cust_i, route_j)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random choice favoring solutions with lower makespan and total distance, then applies a hybrid local search combining route splitting, customer reinsertion with capacity checks, and a novel \"route-merge-and-rebalance\" operator to explore trade-offs between distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search operator\n    new_solution = []\n\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route splitting with capacity check\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = np.concatenate([route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity for new routes\n        def is_feasible(r):\n            total_demand = sum(demand[int(node)] for node in r[1:-1])\n            return total_demand <= capacity\n\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            new_solution.extend([new_route1, new_route2])\n            continue\n\n        # Step 2: Customer reinsertion with capacity check\n        if random.random() < 0.5:\n            route_copy = route.copy()\n            candidates = list(range(1, len(route_copy) - 1))\n            if len(candidates) > 0:\n                node_idx = random.choice(candidates)\n                node = route_copy[node_idx]\n                del route_copy[node_idx]\n\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route_copy)):\n                    new_route = np.insert(route_copy, pos, node)\n                    if is_feasible(new_route):\n                        cost = distance_matrix[int(new_route[pos-1]), int(node)] + distance_matrix[int(node), int(new_route[pos+1])]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    new_route = np.insert(route_copy, best_pos, node)\n                    new_solution.append(new_route)\n                    continue\n\n        # Step 3: Route-merge-and-rebalance operator\n        if len(base_solution) > 1 and random.random() < 0.3:\n            other_routes = [r for r in base_solution if not np.array_equal(r, route)]\n            if len(other_routes) > 0:\n                target_route = random.choice(other_routes)\n                # Try to merge with target route\n                merged_route = np.concatenate([route[1:-1], target_route[1:-1], [0]])\n                if is_feasible(merged_route):\n                    new_solution.append(merged_route)\n                    base_solution.remove(target_route)\n                    continue\n\n        new_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n\n    if missing:\n        # Reinsert missing customers using a greedy approach\n        for node in missing:\n            best_route = None\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                for pos in range(1, len(route)):\n                    new_route = np.insert(route, pos, node)\n                    if is_feasible(new_route):\n                        cost = distance_matrix[int(new_route[pos-1]), node] + distance_matrix[node, int(new_route[pos+1])]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = i\n                            best_pos = pos\n\n            if best_route is not None:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9758700257875014,
            4.795662879943848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search operator\n    new_solution = []\n\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route splitting with capacity check\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = np.concatenate([route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity for new routes\n        def is_feasible(r):\n            total_demand = sum(demand[int(node)] for node in r[1:-1])\n            return total_demand <= capacity\n\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            new_solution.extend([new_route1, new_route2])\n            continue\n\n        # Step 2: Customer reinsertion with capacity check\n        if random.random() < 0.5:\n            route_copy = route.copy()\n            candidates = list(range(1, len(route_copy) - 1))\n            if len(candidates) > 0:\n                node_idx = random.choice(candidates)\n                node = route_copy[node_idx]\n                del route_copy[node_idx]\n\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route_copy)):\n                    new_route = np.insert(route_copy, pos, node)\n                    if is_feasible(new_route):\n                        cost = distance_matrix[int(new_route[pos-1]), int(node)] + distance_matrix[int(node), int(new_route[pos+1])]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    new_route = np.insert(route_copy, best_pos, node)\n                    new_solution.append(new_route)\n                    continue\n\n        # Step 3: Route-merge-and-rebalance operator\n        if len(base_solution) > 1 and random.random() < 0.3:\n            other_routes = [r for r in base_solution if not np.array_equal(r, route)]\n            if len(other_routes) > 0:\n                target_route = random.choice(other_routes)\n                # Try to merge with target route\n                merged_route = np.concatenate([route[1:-1], target_route[1:-1], [0]])\n                if is_feasible(merged_route):\n                    new_solution.append(merged_route)\n                    base_solution.remove(target_route)\n                    continue\n\n        new_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n\n    if missing:\n        # Reinsert missing customers using a greedy approach\n        for node in missing:\n            best_route = None\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                for pos in range(1, len(route)):\n                    new_route = np.insert(route, pos, node)\n                    if is_feasible(new_route):\n                        cost = distance_matrix[int(new_route[pos-1]), node] + distance_matrix[node, int(new_route[pos+1])]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = i\n                            best_pos = pos\n\n            if best_route is not None:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random choice favoring solutions with lower makespan and total distance, then applies a hybrid local search combining route splitting, customer reinsertion with capacity checks, and a novel \"route-merge-and-rebalance\" operator to explore trade-offs between distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search operator\n    new_solution = []\n\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route splitting with capacity check\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = np.concatenate([route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity for new routes\n        def is_feasible(r):\n            total_demand = sum(demand[int(node)] for node in r[1:-1])\n            return total_demand <= capacity\n\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            new_solution.extend([new_route1, new_route2])\n            continue\n\n        # Step 2: Customer reinsertion with capacity check\n        if random.random() < 0.5:\n            route_copy = route.copy()\n            candidates = list(range(1, len(route_copy) - 1))\n            if len(candidates) > 0:\n                node_idx = random.choice(candidates)\n                node = route_copy[node_idx]\n                del route_copy[node_idx]\n\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route_copy)):\n                    new_route = np.insert(route_copy, pos, node)\n                    if is_feasible(new_route):\n                        cost = distance_matrix[int(new_route[pos-1]), int(node)] + distance_matrix[int(node), int(new_route[pos+1])]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    new_route = np.insert(route_copy, best_pos, node)\n                    new_solution.append(new_route)\n                    continue\n\n        # Step 3: Route-merge-and-rebalance operator\n        if len(base_solution) > 1 and random.random() < 0.3:\n            other_routes = [r for r in base_solution if not np.array_equal(r, route)]\n            if len(other_routes) > 0:\n                target_route = random.choice(other_routes)\n                # Try to merge with target route\n                merged_route = np.concatenate([route[1:-1], target_route[1:-1], [0]])\n                if is_feasible(merged_route):\n                    new_solution.append(merged_route)\n                    base_solution.remove(target_route)\n                    continue\n\n        new_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n\n    if missing:\n        # Reinsert missing customers using a greedy approach\n        for node in missing:\n            best_route = None\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                for pos in range(1, len(route)):\n                    new_route = np.insert(route, pos, node)\n                    if is_feasible(new_route):\n                        cost = distance_matrix[int(new_route[pos-1]), node] + distance_matrix[node, int(new_route[pos+1])]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = i\n                            best_pos = pos\n\n            if best_route is not None:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9758700257875014,
            4.795662879943848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search operator\n    new_solution = []\n\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route splitting with capacity check\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = np.concatenate([route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity for new routes\n        def is_feasible(r):\n            total_demand = sum(demand[int(node)] for node in r[1:-1])\n            return total_demand <= capacity\n\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            new_solution.extend([new_route1, new_route2])\n            continue\n\n        # Step 2: Customer reinsertion with capacity check\n        if random.random() < 0.5:\n            route_copy = route.copy()\n            candidates = list(range(1, len(route_copy) - 1))\n            if len(candidates) > 0:\n                node_idx = random.choice(candidates)\n                node = route_copy[node_idx]\n                del route_copy[node_idx]\n\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route_copy)):\n                    new_route = np.insert(route_copy, pos, node)\n                    if is_feasible(new_route):\n                        cost = distance_matrix[int(new_route[pos-1]), int(node)] + distance_matrix[int(node), int(new_route[pos+1])]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    new_route = np.insert(route_copy, best_pos, node)\n                    new_solution.append(new_route)\n                    continue\n\n        # Step 3: Route-merge-and-rebalance operator\n        if len(base_solution) > 1 and random.random() < 0.3:\n            other_routes = [r for r in base_solution if not np.array_equal(r, route)]\n            if len(other_routes) > 0:\n                target_route = random.choice(other_routes)\n                # Try to merge with target route\n                merged_route = np.concatenate([route[1:-1], target_route[1:-1], [0]])\n                if is_feasible(merged_route):\n                    new_solution.append(merged_route)\n                    base_solution.remove(target_route)\n                    continue\n\n        new_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n\n    if missing:\n        # Reinsert missing customers using a greedy approach\n        for node in missing:\n            best_route = None\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                for pos in range(1, len(route)):\n                    new_route = np.insert(route, pos, node)\n                    if is_feasible(new_route):\n                        cost = distance_matrix[int(new_route[pos-1]), node] + distance_matrix[node, int(new_route[pos+1])]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = i\n                            best_pos = pos\n\n            if best_route is not None:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route merging, customer reinsertion, and capacity-aware swaps to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route merging, reinsertion, and capacity-aware swaps\n    def is_feasible(route, demand, capacity):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Try to merge two routes if feasible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n        if is_feasible(merged_route, demand, capacity):\n            del new_solution[max(i, j)]\n            del new_solution[min(i, j)]\n            new_solution.append(merged_route)\n\n    # Step 2: Apply reinsertion of a random customer to a random position in a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route has customers to remove\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n            new_route = np.delete(route, customer_pos)\n            if is_feasible(new_route, demand, capacity):\n                new_solution[route_idx] = new_route\n                # Insert customer into another route or new route\n                target_route_idx = random.randint(0, len(new_solution) - 1)\n                target_route = new_solution[target_route_idx]\n                insert_pos = random.randint(1, len(target_route) - 1)\n                new_target_route = np.insert(target_route, insert_pos, customer)\n                if is_feasible(new_target_route, demand, capacity):\n                    new_solution[target_route_idx] = new_target_route\n\n    # Step 3: Apply capacity-aware swaps between two routes\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n        if len(route_i) > 2 and len(route_j) > 2:\n            pos_i = random.randint(1, len(route_i) - 2)\n            pos_j = random.randint(1, len(route_j) - 2)\n            customer_i, customer_j = route_i[pos_i], route_j[pos_j]\n            # Swap customers if feasible\n            new_route_i = np.delete(route_i, pos_i)\n            new_route_i = np.insert(new_route_i, pos_i, customer_j)\n            new_route_j = np.delete(route_j, pos_j)\n            new_route_j = np.insert(new_route_j, pos_j, customer_i)\n            if is_feasible(new_route_i, demand, capacity) and is_feasible(new_route_j, demand, capacity):\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    return new_solution\n\n",
        "score": [
            -0.4710711974816194,
            0.7103926241397858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route merging, reinsertion, and capacity-aware swaps\n    def is_feasible(route, demand, capacity):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Try to merge two routes if feasible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n        if is_feasible(merged_route, demand, capacity):\n            del new_solution[max(i, j)]\n            del new_solution[min(i, j)]\n            new_solution.append(merged_route)\n\n    # Step 2: Apply reinsertion of a random customer to a random position in a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route has customers to remove\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n            new_route = np.delete(route, customer_pos)\n            if is_feasible(new_route, demand, capacity):\n                new_solution[route_idx] = new_route\n                # Insert customer into another route or new route\n                target_route_idx = random.randint(0, len(new_solution) - 1)\n                target_route = new_solution[target_route_idx]\n                insert_pos = random.randint(1, len(target_route) - 1)\n                new_target_route = np.insert(target_route, insert_pos, customer)\n                if is_feasible(new_target_route, demand, capacity):\n                    new_solution[target_route_idx] = new_target_route\n\n    # Step 3: Apply capacity-aware swaps between two routes\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n        if len(route_i) > 2 and len(route_j) > 2:\n            pos_i = random.randint(1, len(route_i) - 2)\n            pos_j = random.randint(1, len(route_j) - 2)\n            customer_i, customer_j = route_i[pos_i], route_j[pos_j]\n            # Swap customers if feasible\n            new_route_i = np.delete(route_i, pos_i)\n            new_route_i = np.insert(new_route_i, pos_i, customer_j)\n            new_route_j = np.delete(route_j, pos_j)\n            new_route_j = np.insert(new_route_j, pos_j, customer_i)\n            if is_feasible(new_route_i, demand, capacity) and is_feasible(new_route_j, demand, capacity):\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and route diversity, then applies a hybrid local search combining route splitting, customer reinsertion, and partial route reversal to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Prefer solutions with lower makespan and total distance, but with some randomness\n        weights = np.array([1 / (obj[0] * obj[1]) for _, obj in archive])\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, reinsertion, and partial reversal\n    if len(new_solution) > 1:\n        # 1. Route splitting: split a long route into two\n        long_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        split_pos = len(long_route) // 2\n        route1 = long_route[:split_pos + 1]\n        route2 = long_route[split_pos:]\n        if len(route1) > 1 and len(route2) > 1:\n            new_solution[long_route_idx] = route1\n            new_solution.insert(long_route_idx + 1, route2)\n\n        # 2. Customer reinsertion: move a customer from one route to another\n        if len(new_solution) > 1:\n            from_route = random.choice(new_solution)\n            if len(from_route) > 2:\n                customer_pos = random.randint(1, len(from_route) - 2)\n                customer = from_route[customer_pos]\n                # Remove customer from its current route\n                from_route = np.delete(from_route, customer_pos)\n                # Find a target route to insert the customer\n                target_route = random.choice([r for r in new_solution if r is not from_route])\n                # Find the best insertion position in the target route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(target_route)):\n                    new_route = np.insert(target_route, pos, customer)\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        increase = (distance_matrix[new_route[pos-1], customer] +\n                                    distance_matrix[customer, new_route[pos+1]] -\n                                    distance_matrix[new_route[pos-1], new_route[pos+1]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                # Insert the customer at the best position\n                target_route = np.insert(target_route, best_pos, customer)\n                # Update the solution\n                new_solution = [r for r in new_solution if len(r) > 1]\n                if len(from_route) > 1:\n                    new_solution.append(from_route)\n                if len(target_route) > 1:\n                    new_solution.append(target_route)\n\n    # 3. Partial route reversal: reverse a segment of a route to reduce distance\n    for route in new_solution:\n        if len(route) > 3:\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            reversed_segment = route[start:end+1][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end+1:]])\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7878435554880727,
            1.7765180468559265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Prefer solutions with lower makespan and total distance, but with some randomness\n        weights = np.array([1 / (obj[0] * obj[1]) for _, obj in archive])\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, reinsertion, and partial reversal\n    if len(new_solution) > 1:\n        # 1. Route splitting: split a long route into two\n        long_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        split_pos = len(long_route) // 2\n        route1 = long_route[:split_pos + 1]\n        route2 = long_route[split_pos:]\n        if len(route1) > 1 and len(route2) > 1:\n            new_solution[long_route_idx] = route1\n            new_solution.insert(long_route_idx + 1, route2)\n\n        # 2. Customer reinsertion: move a customer from one route to another\n        if len(new_solution) > 1:\n            from_route = random.choice(new_solution)\n            if len(from_route) > 2:\n                customer_pos = random.randint(1, len(from_route) - 2)\n                customer = from_route[customer_pos]\n                # Remove customer from its current route\n                from_route = np.delete(from_route, customer_pos)\n                # Find a target route to insert the customer\n                target_route = random.choice([r for r in new_solution if r is not from_route])\n                # Find the best insertion position in the target route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(target_route)):\n                    new_route = np.insert(target_route, pos, customer)\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        increase = (distance_matrix[new_route[pos-1], customer] +\n                                    distance_matrix[customer, new_route[pos+1]] -\n                                    distance_matrix[new_route[pos-1], new_route[pos+1]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                # Insert the customer at the best position\n                target_route = np.insert(target_route, best_pos, customer)\n                # Update the solution\n                new_solution = [r for r in new_solution if len(r) > 1]\n                if len(from_route) > 1:\n                    new_solution.append(from_route)\n                if len(target_route) > 1:\n                    new_solution.append(target_route)\n\n    # 3. Partial route reversal: reverse a segment of a route to reduce distance\n    for route in new_solution:\n        if len(route) > 3:\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            reversed_segment = route[start:end+1][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end+1:]])\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This algorithm selects a high-quality solution from the archive using a tournament selection based on a combination of total distance and makespan, then applies a hybrid local search operator that combines route merging and customer reallocation to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: (x[1][0] + x[1][1]))  # Combine objectives for selection\n    base_solution = selected[0][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: merge short routes and reallocate customers to balance makespan\n    if len(new_solution) > 1:\n        # Identify the longest and shortest routes\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: sum(distance_matrix[new_solution[i][:-1], new_solution[i][1:]]))\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: sum(distance_matrix[new_solution[i][:-1], new_solution[i][1:]]))\n\n        # Try to merge shortest route into longest route if feasible\n        shortest_route = new_solution[shortest_route_idx]\n        customers = shortest_route[1:-1]\n        total_demand = sum(demand[customers])\n\n        if total_demand <= capacity:\n            # Check if insertion is feasible\n            best_insert_pos = -1\n            best_insert_cost = float('inf')\n            longest_route = new_solution[longest_route_idx]\n\n            for i in range(1, len(longest_route)):\n                # Try inserting after position i\n                prev_node = longest_route[i-1]\n                next_node = longest_route[i]\n                insert_cost = distance_matrix[prev_node, customers[0]] + distance_matrix[customers[-1], next_node] - distance_matrix[prev_node, next_node]\n\n                if insert_cost < best_insert_cost:\n                    # Check capacity constraint\n                    current_load = sum(demand[longest_route[1:i]]) + sum(demand[customers])\n                    if current_load <= capacity:\n                        best_insert_cost = insert_cost\n                        best_insert_pos = i\n\n            if best_insert_pos != -1:\n                # Perform the merge\n                new_longest_route = np.concatenate([longest_route[:best_insert_pos], customers, longest_route[best_insert_pos:]])\n                new_solution[longest_route_idx] = new_longest_route\n                del new_solution[shortest_route_idx]\n\n        # If merge not possible, try reallocating customers between routes\n        else:\n            # Find the most promising customer to reallocate\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                for i in range(1, len(route)-1):\n                    customer = route[i]\n                    current_load = sum(demand[route[1:i]]) + sum(demand[route[i+1:-1]])\n\n                    # Try inserting into other routes\n                    for other_route_idx in range(len(new_solution)):\n                        if other_route_idx == route_idx:\n                            continue\n                        other_route = new_solution[other_route_idx]\n                        other_load = sum(demand[other_route[1:-1]])\n\n                        if other_load + demand[customer] <= capacity:\n                            # Find best insertion position\n                            best_pos = -1\n                            best_cost = float('inf')\n                            for j in range(1, len(other_route)):\n                                prev_node = other_route[j-1]\n                                next_node = other_route[j]\n                                cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = j\n\n                            if best_pos != -1:\n                                # Perform the reallocation\n                                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                                new_solution[other_route_idx] = new_other_route\n                                new_solution[route_idx] = np.concatenate([route[:i], route[i+1:]])\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.6928010180061746,
            0.8077448904514313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: (x[1][0] + x[1][1]))  # Combine objectives for selection\n    base_solution = selected[0][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: merge short routes and reallocate customers to balance makespan\n    if len(new_solution) > 1:\n        # Identify the longest and shortest routes\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: sum(distance_matrix[new_solution[i][:-1], new_solution[i][1:]]))\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: sum(distance_matrix[new_solution[i][:-1], new_solution[i][1:]]))\n\n        # Try to merge shortest route into longest route if feasible\n        shortest_route = new_solution[shortest_route_idx]\n        customers = shortest_route[1:-1]\n        total_demand = sum(demand[customers])\n\n        if total_demand <= capacity:\n            # Check if insertion is feasible\n            best_insert_pos = -1\n            best_insert_cost = float('inf')\n            longest_route = new_solution[longest_route_idx]\n\n            for i in range(1, len(longest_route)):\n                # Try inserting after position i\n                prev_node = longest_route[i-1]\n                next_node = longest_route[i]\n                insert_cost = distance_matrix[prev_node, customers[0]] + distance_matrix[customers[-1], next_node] - distance_matrix[prev_node, next_node]\n\n                if insert_cost < best_insert_cost:\n                    # Check capacity constraint\n                    current_load = sum(demand[longest_route[1:i]]) + sum(demand[customers])\n                    if current_load <= capacity:\n                        best_insert_cost = insert_cost\n                        best_insert_pos = i\n\n            if best_insert_pos != -1:\n                # Perform the merge\n                new_longest_route = np.concatenate([longest_route[:best_insert_pos], customers, longest_route[best_insert_pos:]])\n                new_solution[longest_route_idx] = new_longest_route\n                del new_solution[shortest_route_idx]\n\n        # If merge not possible, try reallocating customers between routes\n        else:\n            # Find the most promising customer to reallocate\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                for i in range(1, len(route)-1):\n                    customer = route[i]\n                    current_load = sum(demand[route[1:i]]) + sum(demand[route[i+1:-1]])\n\n                    # Try inserting into other routes\n                    for other_route_idx in range(len(new_solution)):\n                        if other_route_idx == route_idx:\n                            continue\n                        other_route = new_solution[other_route_idx]\n                        other_load = sum(demand[other_route[1:-1]])\n\n                        if other_load + demand[customer] <= capacity:\n                            # Find best insertion position\n                            best_pos = -1\n                            best_cost = float('inf')\n                            for j in range(1, len(other_route)):\n                                prev_node = other_route[j-1]\n                                next_node = other_route[j]\n                                cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = j\n\n                            if best_pos != -1:\n                                # Perform the reallocation\n                                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                                new_solution[other_route_idx] = new_other_route\n                                new_solution[route_idx] = np.concatenate([route[:i], route[i+1:]])\n                                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by analyzing both objectives and then applies a hybrid local search combining route splitting, intra-route 2-opt with demand-aware swaps, and inter-route cross-exchange to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] * 0.7 + x[1][0] * 0.3)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search steps\n    # Step 1: Route Splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 5:  # Arbitrary threshold for long routes\n            split_pos = random.randint(2, len(route)-2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Step 2: Demand-aware 2-opt with swaps\n    for route in new_solution:\n        if len(route) > 4:\n            a, b = sorted(random.sample(range(1, len(route)-1), 2))\n            if (demand[route[a]] + demand[route[b]] <= capacity and\n                np.sum(demand[route[1:a]]) + demand[route[b]] <= capacity and\n                np.sum(demand[route[a+1:b]]) + demand[route[a]] <= capacity and\n                np.sum(demand[route[b+1:-1]]) + demand[route[a]] <= capacity):\n                route[a], route[b] = route[b], route[a]\n\n    # Step 3: Inter-route cross-exchange\n    if len(new_solution) > 1:\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[r1], new_solution[r2]\n        if len(route1) > 3 and len(route2) > 3:\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n            if (np.sum(demand[route1[1:pos1]]) + demand[route2[pos2]] <= capacity and\n                np.sum(demand[route2[1:pos2]]) + demand[route1[pos1]] <= capacity):\n                temp = route1[pos1]\n                route1[pos1] = route2[pos2]\n                route2[pos2] = temp\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Revert or fix by moving excess demand to another route\n            excess = np.sum(demand[route[1:-1]]) - capacity\n            for i in range(1, len(route)-1):\n                if demand[route[i]] <= excess:\n                    excess -= demand[route[i]]\n                    new_route = np.concatenate(([0], [route[i]], [0]))\n                    new_solution.append(new_route)\n                    route = np.delete(route, i)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6807646018955209,
            1.7583132982254028
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] * 0.7 + x[1][0] * 0.3)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search steps\n    # Step 1: Route Splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 5:  # Arbitrary threshold for long routes\n            split_pos = random.randint(2, len(route)-2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Step 2: Demand-aware 2-opt with swaps\n    for route in new_solution:\n        if len(route) > 4:\n            a, b = sorted(random.sample(range(1, len(route)-1), 2))\n            if (demand[route[a]] + demand[route[b]] <= capacity and\n                np.sum(demand[route[1:a]]) + demand[route[b]] <= capacity and\n                np.sum(demand[route[a+1:b]]) + demand[route[a]] <= capacity and\n                np.sum(demand[route[b+1:-1]]) + demand[route[a]] <= capacity):\n                route[a], route[b] = route[b], route[a]\n\n    # Step 3: Inter-route cross-exchange\n    if len(new_solution) > 1:\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[r1], new_solution[r2]\n        if len(route1) > 3 and len(route2) > 3:\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n            if (np.sum(demand[route1[1:pos1]]) + demand[route2[pos2]] <= capacity and\n                np.sum(demand[route2[1:pos2]]) + demand[route1[pos1]] <= capacity):\n                temp = route1[pos1]\n                route1[pos1] = route2[pos2]\n                route2[pos2] = temp\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Revert or fix by moving excess demand to another route\n            excess = np.sum(demand[route[1:-1]]) - capacity\n            for i in range(1, len(route)-1):\n                if demand[route[i]] <= excess:\n                    excess -= demand[route[i]]\n                    new_route = np.concatenate(([0], [route[i]], [0]))\n                    new_solution.append(new_route)\n                    route = np.delete(route, i)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This algorithm selects a solution from the archive with the highest potential for improvement by combining a probabilistic selection based on normalized objective values with a novel hybrid local search that integrates route swapping, partial route reversal, and demand-aware relocations to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    norm_dist = (total_distances - total_distances.min()) / (total_distances.max() - total_distances.min() + 1e-6)\n    norm_makespan = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-6)\n    scores = norm_dist + norm_makespan  # Combine objectives\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping, partial reversal, and demand-aware relocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Partial route reversal (random segment)\n        if len(route1) > 3:\n            start, end = sorted(random.sample(range(1, len(route1) - 1), 2))\n            route1[start:end+1] = route1[start:end+1][::-1]\n\n        # Step 3: Demand-aware relocation (move a customer from one route to another)\n        if len(route1) > 2 and len(route2) > 1:\n            # Find a customer in route1 that can be moved to route2 without exceeding capacity\n            for i in range(1, len(route1) - 1):\n                customer = route1[i]\n                new_route2_demand = sum(demand[route2[1:-1]]) + demand[customer]\n                if new_route2_demand <= capacity:\n                    # Insert customer into route2 (random position)\n                    insert_pos = random.randint(1, len(route2) - 1)\n                    route2 = np.insert(route2, insert_pos, customer)\n                    route1 = np.delete(route1, i)\n                    break\n\n        # Update routes\n        new_solution[route1_idx] = route1\n        new_solution[route2_idx] = route2\n\n    # Step 4: Check and fix feasibility (if any route exceeds capacity)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split the route if capacity is exceeded\n            split_pos = 1\n            current_load = 0\n            for j in range(1, len(route) - 1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_pos = j\n                    break\n            new_solution[i] = np.concatenate([route[:split_pos], [0]])\n            new_solution.insert(i + 1, np.concatenate([[0], route[split_pos:], [0]]))\n\n    return np.array(new_solution, dtype=object)\n\n",
        "score": [
            -0.8256198755895614,
            1.1638385951519012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    norm_dist = (total_distances - total_distances.min()) / (total_distances.max() - total_distances.min() + 1e-6)\n    norm_makespan = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-6)\n    scores = norm_dist + norm_makespan  # Combine objectives\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping, partial reversal, and demand-aware relocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Partial route reversal (random segment)\n        if len(route1) > 3:\n            start, end = sorted(random.sample(range(1, len(route1) - 1), 2))\n            route1[start:end+1] = route1[start:end+1][::-1]\n\n        # Step 3: Demand-aware relocation (move a customer from one route to another)\n        if len(route1) > 2 and len(route2) > 1:\n            # Find a customer in route1 that can be moved to route2 without exceeding capacity\n            for i in range(1, len(route1) - 1):\n                customer = route1[i]\n                new_route2_demand = sum(demand[route2[1:-1]]) + demand[customer]\n                if new_route2_demand <= capacity:\n                    # Insert customer into route2 (random position)\n                    insert_pos = random.randint(1, len(route2) - 1)\n                    route2 = np.insert(route2, insert_pos, customer)\n                    route1 = np.delete(route1, i)\n                    break\n\n        # Update routes\n        new_solution[route1_idx] = route1\n        new_solution[route2_idx] = route2\n\n    # Step 4: Check and fix feasibility (if any route exceeds capacity)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split the route if capacity is exceeded\n            split_pos = 1\n            current_load = 0\n            for j in range(1, len(route) - 1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_pos = j\n                    break\n            new_solution[i] = np.concatenate([route[:split_pos], [0]])\n            new_solution.insert(i + 1, np.concatenate([[0], route[split_pos:], [0]]))\n\n    return np.array(new_solution, dtype=object)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: iterate through routes and apply transformations\n    for i in range(len(selected_solution)):\n        route = selected_solution[i].copy()\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route splitting (if a long route can be split into two balanced routes)\n        if len(route) > 5:\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate((route[:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                selected_solution[i] = new_route1\n                selected_solution.append(new_route2)\n                continue\n\n        # Step 2: Customer reallocation (move a customer from this route to another)\n        for j in range(len(selected_solution)):\n            if i == j:\n                continue\n            other_route = selected_solution[j].copy()\n            for k in range(1, len(route)-1):\n                customer = route[k]\n                # Insert customer into other route (greedy best position)\n                best_pos = 1\n                min_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    new_route = np.insert(other_route, pos, customer)\n                    cost = (distance_matrix[new_route[pos-1], customer] +\n                            distance_matrix[customer, new_route[pos+1]] -\n                            distance_matrix[new_route[pos-1], new_route[pos+1]])\n                    if cost < min_cost and np.sum(demand[new_route[1:-1]]) <= capacity:\n                        min_cost = cost\n                        best_pos = pos\n                if min_cost < float('inf'):\n                    selected_solution[j] = np.insert(other_route, best_pos, customer)\n                    selected_solution[i] = np.delete(route, k)\n                    break\n\n        # Step 3: 2-opt with capacity checks (only if no reallocation occurred)\n        for k in range(1, len(route)-2):\n            for l in range(k+1, len(route)-1):\n                new_route = route.copy()\n                new_route[k:l+1] = route[k:l+1][::-1]  # Reverse segment\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    selected_solution[i] = new_route\n                    break\n\n    return selected_solution\n\n",
        "score": [
            -0.7819494668516465,
            3.975475490093231
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: iterate through routes and apply transformations\n    for i in range(len(selected_solution)):\n        route = selected_solution[i].copy()\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route splitting (if a long route can be split into two balanced routes)\n        if len(route) > 5:\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate((route[:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                selected_solution[i] = new_route1\n                selected_solution.append(new_route2)\n                continue\n\n        # Step 2: Customer reallocation (move a customer from this route to another)\n        for j in range(len(selected_solution)):\n            if i == j:\n                continue\n            other_route = selected_solution[j].copy()\n            for k in range(1, len(route)-1):\n                customer = route[k]\n                # Insert customer into other route (greedy best position)\n                best_pos = 1\n                min_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    new_route = np.insert(other_route, pos, customer)\n                    cost = (distance_matrix[new_route[pos-1], customer] +\n                            distance_matrix[customer, new_route[pos+1]] -\n                            distance_matrix[new_route[pos-1], new_route[pos+1]])\n                    if cost < min_cost and np.sum(demand[new_route[1:-1]]) <= capacity:\n                        min_cost = cost\n                        best_pos = pos\n                if min_cost < float('inf'):\n                    selected_solution[j] = np.insert(other_route, best_pos, customer)\n                    selected_solution[i] = np.delete(route, k)\n                    break\n\n        # Step 3: 2-opt with capacity checks (only if no reallocation occurred)\n        for k in range(1, len(route)-2):\n            for l in range(k+1, len(route)-1):\n                new_route = route.copy()\n                new_route[k:l+1] = route[k:l+1][::-1]  # Reverse segment\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    selected_solution[i] = new_route\n                    break\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted objective score, then applies a hybrid local search combining route merging, segment reversal, and demand-aware insertion to generate a feasible neighbor solution while balancing travel distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest weighted objective score)\n    def objective_score(sol):\n        total_dist, makespan = sol[1]\n        return total_dist * 0.6 + makespan * 0.4  # Weighted sum of objectives\n\n    archive_sorted = sorted(archive, key=objective_score)\n    selected_sol = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route merging, segment reversal, and demand-aware insertion\n    new_solution = []\n\n    # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n    if len(selected_sol) > 1:\n        merged = False\n        for i in range(len(selected_sol)):\n            for j in range(i + 1, len(selected_sol)):\n                route1 = selected_sol[i]\n                route2 = selected_sol[j]\n                if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                    # Merge route2 into route1\n                    merged_route = np.concatenate((route1[:-1], route2[1:]))\n                    new_solution.append(merged_route)\n                    merged = True\n                    break\n            if merged:\n                break\n        if not merged:\n            new_solution.extend(selected_sol)\n    else:\n        new_solution.extend(selected_sol)\n\n    # Step 2: Segment reversal with demand check\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with enough nodes\n            # Randomly select a segment to reverse\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end+1]\n            reversed_segment = segment[::-1]\n            # Check capacity constraint\n            if np.sum(demand[reversed_segment[1:-1]]) <= capacity:\n                new_route = np.concatenate((route[:start], reversed_segment, route[end+1:]))\n                route = new_route\n\n    # Step 3: Demand-aware insertion (move a node from one route to another if beneficial)\n    for _ in range(3):  # Perform 3 insertions\n        if len(new_solution) > 1:\n            # Select a random route to remove a node from\n            src_route_idx = random.randint(0, len(new_solution) - 1)\n            src_route = new_solution[src_route_idx]\n            if len(src_route) > 3:  # Must have at least one customer\n                # Select a random customer to move\n                customer_pos = random.randint(1, len(src_route) - 2)\n                customer = src_route[customer_pos]\n                # Remove customer from source route\n                new_src_route = np.concatenate((src_route[:customer_pos], src_route[customer_pos+1:]))\n                # Try to insert into another route\n                for dst_route_idx in range(len(new_solution)):\n                    if dst_route_idx != src_route_idx:\n                        dst_route = new_solution[dst_route_idx]\n                        # Find best insertion position\n                        best_pos = -1\n                        best_cost = float('inf')\n                        for pos in range(1, len(dst_route)):\n                            # Check capacity constraint\n                            if np.sum(demand[dst_route[1:pos]]) + demand[customer] + np.sum(demand[dst_route[pos:-1]]) <= capacity:\n                                # Calculate insertion cost\n                                cost = (distance_matrix[dst_route[pos-1]][customer] +\n                                       distance_matrix[customer][dst_route[pos]] -\n                                       distance_matrix[dst_route[pos-1]][dst_route[pos]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n                        if best_pos != -1:\n                            # Perform insertion\n                            new_dst_route = np.concatenate((dst_route[:best_pos], [customer], dst_route[best_pos:]))\n                            new_solution[dst_route_idx] = new_dst_route\n                            new_solution[src_route_idx] = new_src_route\n                            break\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if route[0] != 0 or route[-1] != 0:\n            new_solution[i] = np.concatenate(([0], route[1:-1], [0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7354828138359392,
            7.126745849847794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest weighted objective score)\n    def objective_score(sol):\n        total_dist, makespan = sol[1]\n        return total_dist * 0.6 + makespan * 0.4  # Weighted sum of objectives\n\n    archive_sorted = sorted(archive, key=objective_score)\n    selected_sol = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route merging, segment reversal, and demand-aware insertion\n    new_solution = []\n\n    # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n    if len(selected_sol) > 1:\n        merged = False\n        for i in range(len(selected_sol)):\n            for j in range(i + 1, len(selected_sol)):\n                route1 = selected_sol[i]\n                route2 = selected_sol[j]\n                if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                    # Merge route2 into route1\n                    merged_route = np.concatenate((route1[:-1], route2[1:]))\n                    new_solution.append(merged_route)\n                    merged = True\n                    break\n            if merged:\n                break\n        if not merged:\n            new_solution.extend(selected_sol)\n    else:\n        new_solution.extend(selected_sol)\n\n    # Step 2: Segment reversal with demand check\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with enough nodes\n            # Randomly select a segment to reverse\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end+1]\n            reversed_segment = segment[::-1]\n            # Check capacity constraint\n            if np.sum(demand[reversed_segment[1:-1]]) <= capacity:\n                new_route = np.concatenate((route[:start], reversed_segment, route[end+1:]))\n                route = new_route\n\n    # Step 3: Demand-aware insertion (move a node from one route to another if beneficial)\n    for _ in range(3):  # Perform 3 insertions\n        if len(new_solution) > 1:\n            # Select a random route to remove a node from\n            src_route_idx = random.randint(0, len(new_solution) - 1)\n            src_route = new_solution[src_route_idx]\n            if len(src_route) > 3:  # Must have at least one customer\n                # Select a random customer to move\n                customer_pos = random.randint(1, len(src_route) - 2)\n                customer = src_route[customer_pos]\n                # Remove customer from source route\n                new_src_route = np.concatenate((src_route[:customer_pos], src_route[customer_pos+1:]))\n                # Try to insert into another route\n                for dst_route_idx in range(len(new_solution)):\n                    if dst_route_idx != src_route_idx:\n                        dst_route = new_solution[dst_route_idx]\n                        # Find best insertion position\n                        best_pos = -1\n                        best_cost = float('inf')\n                        for pos in range(1, len(dst_route)):\n                            # Check capacity constraint\n                            if np.sum(demand[dst_route[1:pos]]) + demand[customer] + np.sum(demand[dst_route[pos:-1]]) <= capacity:\n                                # Calculate insertion cost\n                                cost = (distance_matrix[dst_route[pos-1]][customer] +\n                                       distance_matrix[customer][dst_route[pos]] -\n                                       distance_matrix[dst_route[pos-1]][dst_route[pos]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n                        if best_pos != -1:\n                            # Perform insertion\n                            new_dst_route = np.concatenate((dst_route[:best_pos], [customer], dst_route[best_pos:]))\n                            new_solution[dst_route_idx] = new_dst_route\n                            new_solution[src_route_idx] = new_src_route\n                            break\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if route[0] != 0 or route[-1] != 0:\n            new_solution[i] = np.concatenate(([0], route[1:-1], [0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] / x[1][1]))[0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Try merging two routes if their combined capacity is feasible\n    # 2. Reallocate customers between routes to balance makespan\n    # 3. Split long routes if they exceed a threshold capacity utilization\n\n    # Step 1: Route merging\n    merged = False\n    for i in range(len(selected_solution)):\n        for j in range(i + 1, len(selected_solution)):\n            route1, route2 = selected_solution[i], selected_solution[j]\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by concatenating them (excluding the second depot)\n                new_route = np.concatenate([route1[:-1], route2[1:]])\n                selected_solution[i] = new_route\n                selected_solution.pop(j)\n                merged = True\n                break\n        if merged:\n            break\n\n    # Step 2: Customer reallocation to balance makespan\n    if not merged:\n        # Find the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n        longest_route = selected_solution[longest_route_idx]\n\n        # Try moving customers to other routes if feasible\n        for customer in longest_route[1:-1]:\n            for k in range(len(selected_solution)):\n                if k != longest_route_idx:\n                    temp_route = np.insert(selected_solution[k], -1, customer)\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Remove from original route\n                        selected_solution[longest_route_idx] = np.delete(selected_solution[longest_route_idx],\n                                                                         np.where(selected_solution[longest_route_idx] == customer)[0][0])\n                        # Add to new route\n                        selected_solution[k] = temp_route\n                        break\n\n    # Step 3: Route splitting if capacity utilization is too high\n    for route_idx in range(len(selected_solution)):\n        route = selected_solution[route_idx]\n        route_demand = sum(demand[route[1:-1]])\n        if route_demand > 0.8 * capacity:  # Threshold for splitting\n            # Find a split point that balances the demands\n            cumulative_demand = np.cumsum(demand[route[1:-1]])\n            split_idx = np.argmin(np.abs(cumulative_demand - route_demand / 2)) + 1\n\n            # Create two new routes\n            new_route1 = np.concatenate([route[:split_idx], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:-1], [0]])\n\n            # Replace the original route with the two new routes\n            selected_solution[route_idx] = new_route1\n            selected_solution.insert(route_idx + 1, new_route2)\n\n    # Ensure all routes are feasible\n    for route in selected_solution:\n        assert sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated\"\n\n    return selected_solution\n\n",
        "score": [
            -0.7621196107705813,
            3.6600857973098755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] / x[1][1]))[0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Try merging two routes if their combined capacity is feasible\n    # 2. Reallocate customers between routes to balance makespan\n    # 3. Split long routes if they exceed a threshold capacity utilization\n\n    # Step 1: Route merging\n    merged = False\n    for i in range(len(selected_solution)):\n        for j in range(i + 1, len(selected_solution)):\n            route1, route2 = selected_solution[i], selected_solution[j]\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by concatenating them (excluding the second depot)\n                new_route = np.concatenate([route1[:-1], route2[1:]])\n                selected_solution[i] = new_route\n                selected_solution.pop(j)\n                merged = True\n                break\n        if merged:\n            break\n\n    # Step 2: Customer reallocation to balance makespan\n    if not merged:\n        # Find the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n        longest_route = selected_solution[longest_route_idx]\n\n        # Try moving customers to other routes if feasible\n        for customer in longest_route[1:-1]:\n            for k in range(len(selected_solution)):\n                if k != longest_route_idx:\n                    temp_route = np.insert(selected_solution[k], -1, customer)\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Remove from original route\n                        selected_solution[longest_route_idx] = np.delete(selected_solution[longest_route_idx],\n                                                                         np.where(selected_solution[longest_route_idx] == customer)[0][0])\n                        # Add to new route\n                        selected_solution[k] = temp_route\n                        break\n\n    # Step 3: Route splitting if capacity utilization is too high\n    for route_idx in range(len(selected_solution)):\n        route = selected_solution[route_idx]\n        route_demand = sum(demand[route[1:-1]])\n        if route_demand > 0.8 * capacity:  # Threshold for splitting\n            # Find a split point that balances the demands\n            cumulative_demand = np.cumsum(demand[route[1:-1]])\n            split_idx = np.argmin(np.abs(cumulative_demand - route_demand / 2)) + 1\n\n            # Create two new routes\n            new_route1 = np.concatenate([route[:split_idx], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:-1], [0]])\n\n            # Replace the original route with the two new routes\n            selected_solution[route_idx] = new_route1\n            selected_solution.insert(route_idx + 1, new_route2)\n\n    # Ensure all routes are feasible\n    for route in selected_solution:\n        assert sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated\"\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route merging and insertion heuristics to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def evaluate_solution(solution, objectives):\n        # Normalize objectives and combine with weights\n        total_distance, makespan = objectives\n        norm_total = total_distance / (max(obj[0] for _, obj in archive) + 1e-6)\n        norm_makespan = makespan / (max(obj[1] for _, obj in archive) + 1e-6)\n        return 0.6 * norm_total + 0.4 * norm_makespan\n\n    evaluated = [(sol, evaluate_solution(sol, obj)) for sol, obj in archive]\n    evaluated.sort(key=lambda x: x[1])\n    selected_solution = evaluated[0][0]\n\n    # Hybrid local search: combine route merging and insertion\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 1: Attempt route merging if possible\n    if len(new_solution) > 1:\n        # Find two routes with the least total demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = np.argsort(demands)\n        i, j = sorted_indices[0], sorted_indices[1]\n\n        if demands[i] + demands[j] <= capacity:\n            merged_route = new_solution[i][:-1].tolist() + new_solution[j][1:].tolist()\n            # Check if merged route is feasible\n            if sum(demand[route[1:-1]]) <= capacity:\n                del new_solution[max(i, j)]\n                del new_solution[min(i, j)]\n                new_solution.append(np.array(merged_route))\n\n    # Step 2: Apply insertion heuristic with demand check\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        # Randomly select two nodes to swap\n        a, b = random.sample(range(1, len(route)-1), 2)\n        # Check if swap maintains feasibility\n        if (demand[route[a]] <= capacity and demand[route[b]] <= capacity):\n            route[a], route[b] = route[b], route[a]\n\n    return new_solution\n\n",
        "score": [
            -0.663289987889313,
            1.02785062789917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def evaluate_solution(solution, objectives):\n        # Normalize objectives and combine with weights\n        total_distance, makespan = objectives\n        norm_total = total_distance / (max(obj[0] for _, obj in archive) + 1e-6)\n        norm_makespan = makespan / (max(obj[1] for _, obj in archive) + 1e-6)\n        return 0.6 * norm_total + 0.4 * norm_makespan\n\n    evaluated = [(sol, evaluate_solution(sol, obj)) for sol, obj in archive]\n    evaluated.sort(key=lambda x: x[1])\n    selected_solution = evaluated[0][0]\n\n    # Hybrid local search: combine route merging and insertion\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 1: Attempt route merging if possible\n    if len(new_solution) > 1:\n        # Find two routes with the least total demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = np.argsort(demands)\n        i, j = sorted_indices[0], sorted_indices[1]\n\n        if demands[i] + demands[j] <= capacity:\n            merged_route = new_solution[i][:-1].tolist() + new_solution[j][1:].tolist()\n            # Check if merged route is feasible\n            if sum(demand[route[1:-1]]) <= capacity:\n                del new_solution[max(i, j)]\n                del new_solution[min(i, j)]\n                new_solution.append(np.array(merged_route))\n\n    # Step 2: Apply insertion heuristic with demand check\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        # Randomly select two nodes to swap\n        a, b = random.sample(range(1, len(route)-1), 2)\n        # Check if swap maintains feasibility\n        if (demand[route[a]] <= capacity and demand[route[b]] <= capacity):\n            route[a], route[b] = route[b], route[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{A novel hybrid local search operator that combines route segmentation, segment reinsertion with capacity checks, and adaptive segment length adjustment to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n    else:\n        route_idx = 0\n\n    route = new_solution[route_idx].copy()\n\n    # Randomly determine segment length (adaptive based on route length)\n    max_segment = min(5, len(route) - 2)  # Ensure at least 1 customer in segment\n    if max_segment <= 1:\n        return new_solution  # No modification possible\n\n    segment_length = random.randint(1, max_segment)\n\n    # Randomly select a segment to remove\n    start_idx = random.randint(1, len(route) - segment_length - 1)\n    segment = route[start_idx:start_idx + segment_length]\n\n    # Remove the segment from the route\n    modified_route = np.concatenate([route[:start_idx], route[start_idx + segment_length:]])\n\n    # Calculate current load of the modified route\n    current_load = sum(demand[node] for node in modified_route[1:-1])\n\n    # Try to reinsert the segment in a different position or another route\n    best_insertion = None\n    best_score = float('inf')\n\n    # Evaluate reinsertion in the same route\n    for i in range(1, len(modified_route)):\n        # Calculate new load if segment is inserted here\n        new_load = current_load + sum(demand[node] for node in segment)\n        if new_load > capacity:\n            continue\n\n        # Calculate insertion cost (distance increase)\n        prev_node = modified_route[i - 1]\n        next_node = modified_route[i]\n        segment_start = segment[0]\n        segment_end = segment[-1]\n\n        cost = (distance_matrix[prev_node, segment_start] +\n                sum(distance_matrix[segment[j], segment[j+1]] for j in range(len(segment)-1)) +\n                distance_matrix[segment_end, next_node] -\n                distance_matrix[prev_node, next_node])\n\n        if cost < best_score:\n            best_score = cost\n            best_insertion = (i, segment, 'same')\n\n    # Evaluate reinsertion in other routes\n    for other_route_idx in range(len(new_solution)):\n        if other_route_idx == route_idx:\n            continue\n\n        other_route = new_solution[other_route_idx]\n        other_load = sum(demand[node] for node in other_route[1:-1])\n\n        for i in range(1, len(other_route)):\n            new_load = other_load + sum(demand[node] for node in segment)\n            if new_load > capacity:\n                continue\n\n            prev_node = other_route[i - 1]\n            next_node = other_route[i]\n            segment_start = segment[0]\n            segment_end = segment[-1]\n\n            cost = (distance_matrix[prev_node, segment_start] +\n                    sum(distance_matrix[segment[j], segment[j+1]] for j in range(len(segment)-1)) +\n                    distance_matrix[segment_end, next_node] -\n                    distance_matrix[prev_node, next_node])\n\n            if cost < best_score:\n                best_score = cost\n                best_insertion = (i, segment, other_route_idx)\n\n    # Apply the best insertion\n    if best_insertion is not None:\n        pos, segment, target = best_insertion\n        if target == 'same':\n            modified_route = np.concatenate([modified_route[:pos], segment, modified_route[pos:]])\n            new_solution[route_idx] = modified_route\n        else:\n            other_route = new_solution[target].copy()\n            new_other_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n            new_solution[target] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.49363128264619577,
            2.842486411333084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n    else:\n        route_idx = 0\n\n    route = new_solution[route_idx].copy()\n\n    # Randomly determine segment length (adaptive based on route length)\n    max_segment = min(5, len(route) - 2)  # Ensure at least 1 customer in segment\n    if max_segment <= 1:\n        return new_solution  # No modification possible\n\n    segment_length = random.randint(1, max_segment)\n\n    # Randomly select a segment to remove\n    start_idx = random.randint(1, len(route) - segment_length - 1)\n    segment = route[start_idx:start_idx + segment_length]\n\n    # Remove the segment from the route\n    modified_route = np.concatenate([route[:start_idx], route[start_idx + segment_length:]])\n\n    # Calculate current load of the modified route\n    current_load = sum(demand[node] for node in modified_route[1:-1])\n\n    # Try to reinsert the segment in a different position or another route\n    best_insertion = None\n    best_score = float('inf')\n\n    # Evaluate reinsertion in the same route\n    for i in range(1, len(modified_route)):\n        # Calculate new load if segment is inserted here\n        new_load = current_load + sum(demand[node] for node in segment)\n        if new_load > capacity:\n            continue\n\n        # Calculate insertion cost (distance increase)\n        prev_node = modified_route[i - 1]\n        next_node = modified_route[i]\n        segment_start = segment[0]\n        segment_end = segment[-1]\n\n        cost = (distance_matrix[prev_node, segment_start] +\n                sum(distance_matrix[segment[j], segment[j+1]] for j in range(len(segment)-1)) +\n                distance_matrix[segment_end, next_node] -\n                distance_matrix[prev_node, next_node])\n\n        if cost < best_score:\n            best_score = cost\n            best_insertion = (i, segment, 'same')\n\n    # Evaluate reinsertion in other routes\n    for other_route_idx in range(len(new_solution)):\n        if other_route_idx == route_idx:\n            continue\n\n        other_route = new_solution[other_route_idx]\n        other_load = sum(demand[node] for node in other_route[1:-1])\n\n        for i in range(1, len(other_route)):\n            new_load = other_load + sum(demand[node] for node in segment)\n            if new_load > capacity:\n                continue\n\n            prev_node = other_route[i - 1]\n            next_node = other_route[i]\n            segment_start = segment[0]\n            segment_end = segment[-1]\n\n            cost = (distance_matrix[prev_node, segment_start] +\n                    sum(distance_matrix[segment[j], segment[j+1]] for j in range(len(segment)-1)) +\n                    distance_matrix[segment_end, next_node] -\n                    distance_matrix[prev_node, next_node])\n\n            if cost < best_score:\n                best_score = cost\n                best_insertion = (i, segment, other_route_idx)\n\n    # Apply the best insertion\n    if best_insertion is not None:\n        pos, segment, target = best_insertion\n        if target == 'same':\n            modified_route = np.concatenate([modified_route[:pos], segment, modified_route[pos:]])\n            new_solution[route_idx] = modified_route\n        else:\n            other_route = new_solution[target].copy()\n            new_other_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n            new_solution[target] = new_other_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring lower makespan and total distance, then applies a hybrid local search combining route splitting and partial reinsertion to balance the objectives by reducing long routes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (normalized.sum(axis=1) + 1e-8)\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Split long routes and reinsert nodes\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route if it's too long\n        if distance_matrix[route[:-1], route[1:]].sum() > 2 * distance_matrix[route[:-1], route[1:]].mean():\n            split_pos = len(route) // 2\n            part1 = np.concatenate([route[:split_pos], [0]])\n            part2 = np.concatenate([[0], route[split_pos:]])\n\n            # Reinsert nodes from part2 into part1 if feasible\n            part2_nodes = part2[1:-1]\n            part1_demand = demand[route[1:-1]].sum()\n            for node in part2_nodes:\n                if part1_demand + demand[node] <= capacity:\n                    # Insert node into part1 at best position\n                    best_pos = 1\n                    min_cost = float('inf')\n                    for i in range(1, len(part1)-1):\n                        cost = (distance_matrix[part1[i-1], node] + distance_matrix[node, part1[i]] -\n                                distance_matrix[part1[i-1], part1[i]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = i\n                    part1 = np.insert(part1, best_pos, node)\n                    part1_demand += demand[node]\n\n            new_solution.append(part1)\n            if len(part2) > 3:\n                new_solution.append(part2)\n        else:\n            new_solution.append(route.copy())\n\n    # Ensure all customers are covered\n    covered = set()\n    for route in new_solution:\n        covered.update(route[1:-1])\n    missing = set(range(1, len(coords))) - covered\n    if missing:\n        # Greedily assign missing nodes to routes with capacity\n        for node in missing:\n            best_route = -1\n            best_pos = -1\n            min_cost = float('inf')\n            for i, route in enumerate(new_solution):\n                if demand[route[1:-1]].sum() + demand[node] <= capacity:\n                    for j in range(1, len(route)-1):\n                        cost = (distance_matrix[route[j-1], node] + distance_matrix[node, route[j]] -\n                                distance_matrix[route[j-1], route[j]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_route = i\n                            best_pos = j\n            if best_route != -1:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7076496108069301,
            3.877481997013092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (normalized.sum(axis=1) + 1e-8)\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Split long routes and reinsert nodes\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route if it's too long\n        if distance_matrix[route[:-1], route[1:]].sum() > 2 * distance_matrix[route[:-1], route[1:]].mean():\n            split_pos = len(route) // 2\n            part1 = np.concatenate([route[:split_pos], [0]])\n            part2 = np.concatenate([[0], route[split_pos:]])\n\n            # Reinsert nodes from part2 into part1 if feasible\n            part2_nodes = part2[1:-1]\n            part1_demand = demand[route[1:-1]].sum()\n            for node in part2_nodes:\n                if part1_demand + demand[node] <= capacity:\n                    # Insert node into part1 at best position\n                    best_pos = 1\n                    min_cost = float('inf')\n                    for i in range(1, len(part1)-1):\n                        cost = (distance_matrix[part1[i-1], node] + distance_matrix[node, part1[i]] -\n                                distance_matrix[part1[i-1], part1[i]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = i\n                    part1 = np.insert(part1, best_pos, node)\n                    part1_demand += demand[node]\n\n            new_solution.append(part1)\n            if len(part2) > 3:\n                new_solution.append(part2)\n        else:\n            new_solution.append(route.copy())\n\n    # Ensure all customers are covered\n    covered = set()\n    for route in new_solution:\n        covered.update(route[1:-1])\n    missing = set(range(1, len(coords))) - covered\n    if missing:\n        # Greedily assign missing nodes to routes with capacity\n        for node in missing:\n            best_route = -1\n            best_pos = -1\n            min_cost = float('inf')\n            for i, route in enumerate(new_solution):\n                if demand[route[1:-1]].sum() + demand[node] <= capacity:\n                    for j in range(1, len(route)-1):\n                        cost = (distance_matrix[route[j-1], node] + distance_matrix[node, route[j]] -\n                                distance_matrix[route[j-1], route[j]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_route = i\n                            best_pos = j\n            if best_route != -1:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: a combination of route splitting and intra-route 3-opt\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Splitting (if the route is too long)\n    if len(selected_route) > 5:\n        # Split the route into two parts\n        split_point = np.random.randint(1, len(selected_route) - 1)\n        new_route1 = selected_route[:split_point + 1]\n        new_route2 = np.concatenate([[0], selected_route[split_point:-1]])\n\n        # Check feasibility of the new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx + 1, new_route2)\n\n    # Step 2: Intra-route 3-opt (if the route is not split)\n    else:\n        # Randomly select three distinct positions in the route (excluding depot)\n        if len(selected_route) > 4:\n            a, b, c = sorted(np.random.choice(range(1, len(selected_route) - 1), 3, replace=False))\n\n            # Generate all possible permutations of the selected segment\n            segment = selected_route[a:c + 1]\n            permutations = [segment, segment[::-1], np.concatenate([segment[1:], [segment[0]]])]\n\n            # Evaluate all permutations and keep the best one\n            best_perm = segment\n            best_cost = np.sum(distance_matrix[selected_route[a-1], selected_route[a]]) + \\\n                        np.sum(distance_matrix[selected_route[c], selected_route[c+1]])\n\n            for perm in permutations:\n                cost = np.sum(distance_matrix[selected_route[a-1], perm[0]]) + \\\n                       np.sum(distance_matrix[perm[-1], selected_route[c+1]]) + \\\n                       np.sum(distance_matrix[perm[:-1], perm[1:]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_perm = perm\n\n            # Apply the best permutation\n            if not np.array_equal(best_perm, segment):\n                selected_route[a:c + 1] = best_perm\n                new_solution[route_idx] = selected_route\n\n    return new_solution\n\n",
        "score": [
            -0.7580030198399375,
            0.1273919939994812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: a combination of route splitting and intra-route 3-opt\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Splitting (if the route is too long)\n    if len(selected_route) > 5:\n        # Split the route into two parts\n        split_point = np.random.randint(1, len(selected_route) - 1)\n        new_route1 = selected_route[:split_point + 1]\n        new_route2 = np.concatenate([[0], selected_route[split_point:-1]])\n\n        # Check feasibility of the new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx + 1, new_route2)\n\n    # Step 2: Intra-route 3-opt (if the route is not split)\n    else:\n        # Randomly select three distinct positions in the route (excluding depot)\n        if len(selected_route) > 4:\n            a, b, c = sorted(np.random.choice(range(1, len(selected_route) - 1), 3, replace=False))\n\n            # Generate all possible permutations of the selected segment\n            segment = selected_route[a:c + 1]\n            permutations = [segment, segment[::-1], np.concatenate([segment[1:], [segment[0]]])]\n\n            # Evaluate all permutations and keep the best one\n            best_perm = segment\n            best_cost = np.sum(distance_matrix[selected_route[a-1], selected_route[a]]) + \\\n                        np.sum(distance_matrix[selected_route[c], selected_route[c+1]])\n\n            for perm in permutations:\n                cost = np.sum(distance_matrix[selected_route[a-1], perm[0]]) + \\\n                       np.sum(distance_matrix[perm[-1], selected_route[c+1]]) + \\\n                       np.sum(distance_matrix[perm[:-1], perm[1:]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_perm = perm\n\n            # Apply the best permutation\n            if not np.array_equal(best_perm, segment):\n                selected_route[a:c + 1] = best_perm\n                new_solution[route_idx] = selected_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{A hybrid local search strategy combining route segmentation, demand-aware insertion, and makespan-balancing swaps to generate high-quality neighbors by intelligently balancing distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])  # Prefer solutions where makespan dominates distance\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Segmentation - Split long routes into smaller segments\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Only consider routes with more than 3 customers\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity feasibility\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Demand-Aware Insertion - Move customers between routes to balance loads\n    for _ in range(3):  # Try 3 random insertions\n        if len(new_solution) < 2:\n            break\n\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Randomly select a customer from route1\n        customer_pos = random.randint(1, len(route1) - 2)\n        customer = route1[customer_pos]\n\n        # Check if moving to route2 is feasible\n        if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            # Insert customer into route2 at a random position\n            insert_pos = random.randint(1, len(route2) - 1)\n            new_route2 = np.concatenate([route2[:insert_pos], [customer], route2[insert_pos:]])\n\n            # Remove customer from route1\n            new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Makespan-Balancing Swap - Swap customers between routes to reduce makespan\n    if len(new_solution) > 1:\n        # Find the two routes with the longest and shortest makespans\n        route_lengths = [np.sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx, shortest_idx = np.argmax(route_lengths), np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route, shortest_route = new_solution[longest_idx], new_solution[shortest_idx]\n\n            # Try to move a customer from longest to shortest route\n            for customer_pos in range(1, len(longest_route) - 1):\n                customer = longest_route[customer_pos]\n\n                # Check capacity feasibility\n                if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into shortest route at a random position\n                    insert_pos = random.randint(1, len(shortest_route) - 1)\n                    new_shortest = np.concatenate([shortest_route[:insert_pos], [customer], shortest_route[insert_pos:]])\n\n                    # Remove customer from longest route\n                    new_longest = np.concatenate([longest_route[:customer_pos], longest_route[customer_pos+1:]])\n\n                    # Update solution\n                    new_solution[longest_idx] = new_longest\n                    new_solution[shortest_idx] = new_shortest\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4548178095692438,
            2.7238683998584747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])  # Prefer solutions where makespan dominates distance\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Segmentation - Split long routes into smaller segments\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Only consider routes with more than 3 customers\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity feasibility\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Demand-Aware Insertion - Move customers between routes to balance loads\n    for _ in range(3):  # Try 3 random insertions\n        if len(new_solution) < 2:\n            break\n\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Randomly select a customer from route1\n        customer_pos = random.randint(1, len(route1) - 2)\n        customer = route1[customer_pos]\n\n        # Check if moving to route2 is feasible\n        if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            # Insert customer into route2 at a random position\n            insert_pos = random.randint(1, len(route2) - 1)\n            new_route2 = np.concatenate([route2[:insert_pos], [customer], route2[insert_pos:]])\n\n            # Remove customer from route1\n            new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Makespan-Balancing Swap - Swap customers between routes to reduce makespan\n    if len(new_solution) > 1:\n        # Find the two routes with the longest and shortest makespans\n        route_lengths = [np.sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx, shortest_idx = np.argmax(route_lengths), np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route, shortest_route = new_solution[longest_idx], new_solution[shortest_idx]\n\n            # Try to move a customer from longest to shortest route\n            for customer_pos in range(1, len(longest_route) - 1):\n                customer = longest_route[customer_pos]\n\n                # Check capacity feasibility\n                if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into shortest route at a random position\n                    insert_pos = random.randint(1, len(shortest_route) - 1)\n                    new_shortest = np.concatenate([shortest_route[:insert_pos], [customer], shortest_route[insert_pos:]])\n\n                    # Remove customer from longest route\n                    new_longest = np.concatenate([longest_route[:customer_pos], longest_route[customer_pos+1:]])\n\n                    # Update solution\n                    new_solution[longest_idx] = new_longest\n                    new_solution[shortest_idx] = new_shortest\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    max_total = max(sol[1][0] for sol in archive)\n    min_total = min(sol[1][0] for sol in archive)\n    max_makespan = max(sol[1][1] for sol in archive)\n    min_makespan = min(sol[1][1] for sol in archive)\n\n    candidates = []\n    for sol in archive:\n        total, makespan = sol[1]\n        if (total == max_total and makespan == min_makespan) or (total == min_total and makespan == max_makespan):\n            candidates.append(sol)\n\n    if not candidates:\n        selected_solution = archive[0][0]\n    else:\n        selected_solution = random.choice(candidates)[0]\n\n    # Hybrid local search: route-splitting and merging followed by cross-route 2-opt*\n    new_solution = selected_solution.copy()\n\n    # Route-splitting: split the longest route into two\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n    if len(longest_route) > 4:  # Ensure the route can be split\n        split_pos = len(longest_route) // 2\n        new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints\n        if sum(demand[new_route1[1:-1]]) <= capacity and sum(demand[new_route2[1:-1]]) <= capacity:\n            new_solution.pop(longest_route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    # Route-merging: merge two shortest routes if possible\n    if len(new_solution) > 2:\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        shortest_route1_idx = np.argmin(route_lengths)\n        shortest_route1 = new_solution[shortest_route1_idx]\n        route_lengths[shortest_route1_idx] = float('inf')\n        shortest_route2_idx = np.argmin(route_lengths)\n        shortest_route2 = new_solution[shortest_route2_idx]\n\n        merged_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n        if sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution.pop(max(shortest_route1_idx, shortest_route2_idx))\n            new_solution.pop(min(shortest_route1_idx, shortest_route2_idx))\n            new_solution.append(merged_route)\n\n    # Cross-route 2-opt*: improve inter-route connections\n    for _ in range(5):  # Limit iterations for efficiency\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random positions in each route (excluding depots)\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Create new routes by swapping segments\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:-1], route1[pos1:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:-1], route2[pos2:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.699445763637308,
            1.5950243473052979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    max_total = max(sol[1][0] for sol in archive)\n    min_total = min(sol[1][0] for sol in archive)\n    max_makespan = max(sol[1][1] for sol in archive)\n    min_makespan = min(sol[1][1] for sol in archive)\n\n    candidates = []\n    for sol in archive:\n        total, makespan = sol[1]\n        if (total == max_total and makespan == min_makespan) or (total == min_total and makespan == max_makespan):\n            candidates.append(sol)\n\n    if not candidates:\n        selected_solution = archive[0][0]\n    else:\n        selected_solution = random.choice(candidates)[0]\n\n    # Hybrid local search: route-splitting and merging followed by cross-route 2-opt*\n    new_solution = selected_solution.copy()\n\n    # Route-splitting: split the longest route into two\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n    if len(longest_route) > 4:  # Ensure the route can be split\n        split_pos = len(longest_route) // 2\n        new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints\n        if sum(demand[new_route1[1:-1]]) <= capacity and sum(demand[new_route2[1:-1]]) <= capacity:\n            new_solution.pop(longest_route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    # Route-merging: merge two shortest routes if possible\n    if len(new_solution) > 2:\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        shortest_route1_idx = np.argmin(route_lengths)\n        shortest_route1 = new_solution[shortest_route1_idx]\n        route_lengths[shortest_route1_idx] = float('inf')\n        shortest_route2_idx = np.argmin(route_lengths)\n        shortest_route2 = new_solution[shortest_route2_idx]\n\n        merged_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n        if sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution.pop(max(shortest_route1_idx, shortest_route2_idx))\n            new_solution.pop(min(shortest_route1_idx, shortest_route2_idx))\n            new_solution.append(merged_route)\n\n    # Cross-route 2-opt*: improve inter-route connections\n    for _ in range(5):  # Limit iterations for efficiency\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random positions in each route (excluding depots)\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Create new routes by swapping segments\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:-1], route1[pos1:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:-1], route2[pos2:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{A hybrid local search strategy that combines route merging, route splitting, and intelligent customer reallocation to balance distance and makespan objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] - x[1][0])  # Prefer solutions with high makespan but not too high distance\n    selected = random.choice(archive_sorted[:max(1, len(archive) // 2)])\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, splitting, and customer reallocation\n    if len(new_solution) > 1:\n        # Try merging two routes if feasible\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route] + [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n\n    # Try splitting a long route\n    for route in new_solution:\n        if len(route) > 4:  # Avoid splitting too short routes\n            split_pos = random.randint(2, len(route) - 3)\n            part1 = route[:split_pos + 1]\n            part2 = np.concatenate([[0], route[split_pos:]])\n            if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n                new_solution.remove(route)\n                new_solution.extend([part1, part2])\n                break\n\n    # Try reallocating customers to balance makespan\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than one customer\n            customer = random.choice(route[1:-1])\n            for other_route in new_solution:\n                if other_route is not route and np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion point in other_route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(other_route)):\n                        increase = distance_matrix[other_route[pos-1], customer] + distance_matrix[customer, other_route[pos]] - distance_matrix[other_route[pos-1], other_route[pos]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    # Perform insertion\n                    other_route = np.insert(other_route, best_pos, customer)\n                    route = np.delete(route, np.where(route == customer)[0][0])\n                    # Update solution\n                    new_solution = [r for r in new_solution if len(r) > 2]  # Remove empty routes\n                    new_solution.append(other_route)\n                    break\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        # Assign missing customers to the route with most remaining capacity\n        for customer in missing:\n            best_route = None\n            best_capacity = -1\n            for route in new_solution:\n                current_capacity = np.sum(demand[route[1:-1]])\n                if current_capacity + demand[customer] <= capacity and current_capacity > best_capacity:\n                    best_route = route\n                    best_capacity = current_capacity\n            if best_route is not None:\n                # Find best insertion point\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(best_route)):\n                    increase = distance_matrix[best_route[pos-1], customer] + distance_matrix[customer, best_route[pos]] - distance_matrix[best_route[pos-1], best_route[pos]]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n                best_route = np.insert(best_route, best_pos, customer)\n            else:\n                # Create new route if no feasible insertion found\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7616219979527507,
            4.632235884666443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] - x[1][0])  # Prefer solutions with high makespan but not too high distance\n    selected = random.choice(archive_sorted[:max(1, len(archive) // 2)])\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, splitting, and customer reallocation\n    if len(new_solution) > 1:\n        # Try merging two routes if feasible\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route] + [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n\n    # Try splitting a long route\n    for route in new_solution:\n        if len(route) > 4:  # Avoid splitting too short routes\n            split_pos = random.randint(2, len(route) - 3)\n            part1 = route[:split_pos + 1]\n            part2 = np.concatenate([[0], route[split_pos:]])\n            if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n                new_solution.remove(route)\n                new_solution.extend([part1, part2])\n                break\n\n    # Try reallocating customers to balance makespan\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than one customer\n            customer = random.choice(route[1:-1])\n            for other_route in new_solution:\n                if other_route is not route and np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion point in other_route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(other_route)):\n                        increase = distance_matrix[other_route[pos-1], customer] + distance_matrix[customer, other_route[pos]] - distance_matrix[other_route[pos-1], other_route[pos]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    # Perform insertion\n                    other_route = np.insert(other_route, best_pos, customer)\n                    route = np.delete(route, np.where(route == customer)[0][0])\n                    # Update solution\n                    new_solution = [r for r in new_solution if len(r) > 2]  # Remove empty routes\n                    new_solution.append(other_route)\n                    break\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        # Assign missing customers to the route with most remaining capacity\n        for customer in missing:\n            best_route = None\n            best_capacity = -1\n            for route in new_solution:\n                current_capacity = np.sum(demand[route[1:-1]])\n                if current_capacity + demand[customer] <= capacity and current_capacity > best_capacity:\n                    best_route = route\n                    best_capacity = current_capacity\n            if best_route is not None:\n                # Find best insertion point\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(best_route)):\n                    increase = distance_matrix[best_route[pos-1], customer] + distance_matrix[customer, best_route[pos]] - distance_matrix[best_route[pos-1], best_route[pos]]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n                best_route = np.insert(best_route, best_pos, customer)\n            else:\n                # Create new route if no feasible insertion found\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{The algorithm selects a solution from the archive using a weighted random selection based on normalized objective values, then applies a hybrid local search combining route segment shuffling and inter-route insertion with feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (1 + normalized.sum(axis=1))\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route segment shuffling and inter-route insertion\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Randomly select a route and shuffle a segment\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes (start, end, and 2 customers)\n            start, end = np.random.randint(1, len(route)-2, size=2)\n            if start > end:\n                start, end = end, start\n            segment = route[start:end+1]\n            np.random.shuffle(segment)\n            route[start:end+1] = segment\n\n            # Check capacity constraint\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # Revert if infeasible\n                new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Try inter-route insertion\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:  # Need at least 3 nodes in each route\n            # Select a customer from route1 to insert into route2\n            customer_idx = np.random.randint(1, len(route1)-1)\n            customer = route1[customer_idx]\n\n            # Find best insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(route2)):\n                # Calculate insertion cost\n                cost = (distance_matrix[route2[i-1], customer] +\n                        distance_matrix[customer, route2[i]] -\n                        distance_matrix[route2[i-1], route2[i]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            # Check capacity constraint\n            if np.sum(demand[route1[1:-1]]) - demand[customer] <= capacity and \\\n               np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Perform insertion\n                route1 = np.delete(route1, customer_idx)\n                route2 = np.insert(route2, best_pos, customer)\n\n                # Update solution\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5372795724862178,
            1.478256642818451
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (1 + normalized.sum(axis=1))\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route segment shuffling and inter-route insertion\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Randomly select a route and shuffle a segment\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes (start, end, and 2 customers)\n            start, end = np.random.randint(1, len(route)-2, size=2)\n            if start > end:\n                start, end = end, start\n            segment = route[start:end+1]\n            np.random.shuffle(segment)\n            route[start:end+1] = segment\n\n            # Check capacity constraint\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # Revert if infeasible\n                new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Try inter-route insertion\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:  # Need at least 3 nodes in each route\n            # Select a customer from route1 to insert into route2\n            customer_idx = np.random.randint(1, len(route1)-1)\n            customer = route1[customer_idx]\n\n            # Find best insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(route2)):\n                # Calculate insertion cost\n                cost = (distance_matrix[route2[i-1], customer] +\n                        distance_matrix[customer, route2[i]] -\n                        distance_matrix[route2[i-1], route2[i]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            # Check capacity constraint\n            if np.sum(demand[route1[1:-1]]) - demand[customer] <= capacity and \\\n               np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Perform insertion\n                route1 = np.delete(route1, customer_idx)\n                route2 = np.insert(route2, best_pos, customer)\n\n                # Update solution\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts\n            split_idx = np.random.randint(1, len(route) - 1)\n            part1 = route[:split_idx + 1]\n            part2 = route[split_idx:]\n\n            # Calculate demands for both parts\n            demand_part1 = sum(demand[node] for node in part1[1:-1])\n            demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n            # If splitting is feasible, proceed\n            if demand_part1 <= capacity and demand_part2 <= capacity:\n                # Try to reinsert customers from part2 into other routes\n                for j in range(len(new_solution)):\n                    if i == j:\n                        continue\n                    other_route = new_solution[j]\n                    other_demand = sum(demand[node] for node in other_route[1:-1])\n\n                    for node in part2[1:-1]:\n                        if other_demand + demand[node] <= capacity:\n                            # Insert node into other_route (random position)\n                            insert_pos = np.random.randint(1, len(other_route))\n                            other_route = np.insert(other_route, insert_pos, node)\n                            other_demand += demand[node]\n\n                    new_solution[j] = other_route\n\n                # Update the split route\n                new_solution[i] = part1\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.844469557329888,
            11.076634794473648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts\n            split_idx = np.random.randint(1, len(route) - 1)\n            part1 = route[:split_idx + 1]\n            part2 = route[split_idx:]\n\n            # Calculate demands for both parts\n            demand_part1 = sum(demand[node] for node in part1[1:-1])\n            demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n            # If splitting is feasible, proceed\n            if demand_part1 <= capacity and demand_part2 <= capacity:\n                # Try to reinsert customers from part2 into other routes\n                for j in range(len(new_solution)):\n                    if i == j:\n                        continue\n                    other_route = new_solution[j]\n                    other_demand = sum(demand[node] for node in other_route[1:-1])\n\n                    for node in part2[1:-1]:\n                        if other_demand + demand[node] <= capacity:\n                            # Insert node into other_route (random position)\n                            insert_pos = np.random.randint(1, len(other_route))\n                            other_route = np.insert(other_route, insert_pos, node)\n                            other_demand += demand[node]\n\n                    new_solution[j] = other_route\n\n                # Update the split route\n                new_solution[i] = part1\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Hybrid local search: Combine route balancing with demand-aware relocations\n    new_solution = selected_solution.copy()\n\n    # Find the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Find the shortest route (most balanced)\n    shortest_route_idx = np.argmax([-sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Attempt to move a customer from the longest to the shortest route\n    for i in range(1, len(longest_route)-1):\n        customer = longest_route[i]\n        current_demand = sum(demand[node] for node in shortest_route[1:-1])\n\n        if current_demand + demand[customer] <= capacity:\n            # Check all possible insertion positions in the shortest route\n            best_insert_pos = -1\n            best_insert_cost = float('inf')\n\n            for j in range(1, len(shortest_route)):\n                # Calculate insertion cost\n                cost = (distance_matrix[shortest_route[j-1], customer] +\n                        distance_matrix[customer, shortest_route[j]] -\n                        distance_matrix[shortest_route[j-1], shortest_route[j]])\n\n                if cost < best_insert_cost:\n                    best_insert_cost = cost\n                    best_insert_pos = j\n\n            if best_insert_pos != -1:\n                # Perform the move\n                new_shortest_route = np.insert(shortest_route, best_insert_pos, customer)\n                new_longest_route = np.delete(longest_route, i)\n\n                # Update the solution\n                new_solution[shortest_route_idx] = new_shortest_route\n                new_solution[longest_route_idx] = new_longest_route\n\n                # Check if the routes are still valid (start and end with depot)\n                if new_longest_route[0] == 0 and new_longest_route[-1] == 0 and new_shortest_route[0] == 0 and new_shortest_route[-1] == 0:\n                    return new_solution\n\n    # If no improvement found, perform a demand-aware 2-opt on the longest route\n    for i in range(1, len(longest_route)-2):\n        for j in range(i+1, len(longest_route)-1):\n            # Check if swapping nodes i and j improves the route\n            original_cost = (distance_matrix[longest_route[i-1], longest_route[i]] +\n                            distance_matrix[longest_route[i], longest_route[i+1]] +\n                            distance_matrix[longest_route[j-1], longest_route[j]] +\n                            distance_matrix[longest_route[j], longest_route[j+1]])\n\n            swapped_cost = (distance_matrix[longest_route[i-1], longest_route[j]] +\n                            distance_matrix[longest_route[j], longest_route[i+1]] +\n                            distance_matrix[longest_route[j-1], longest_route[i]] +\n                            distance_matrix[longest_route[i], longest_route[j+1]])\n\n            if swapped_cost < original_cost:\n                # Perform the swap\n                new_route = longest_route.copy()\n                new_route[i], new_route[j] = new_route[j], new_route[i]\n                new_solution[longest_route_idx] = new_route\n                return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8036998008993166,
            1.2176149785518646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Hybrid local search: Combine route balancing with demand-aware relocations\n    new_solution = selected_solution.copy()\n\n    # Find the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Find the shortest route (most balanced)\n    shortest_route_idx = np.argmax([-sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Attempt to move a customer from the longest to the shortest route\n    for i in range(1, len(longest_route)-1):\n        customer = longest_route[i]\n        current_demand = sum(demand[node] for node in shortest_route[1:-1])\n\n        if current_demand + demand[customer] <= capacity:\n            # Check all possible insertion positions in the shortest route\n            best_insert_pos = -1\n            best_insert_cost = float('inf')\n\n            for j in range(1, len(shortest_route)):\n                # Calculate insertion cost\n                cost = (distance_matrix[shortest_route[j-1], customer] +\n                        distance_matrix[customer, shortest_route[j]] -\n                        distance_matrix[shortest_route[j-1], shortest_route[j]])\n\n                if cost < best_insert_cost:\n                    best_insert_cost = cost\n                    best_insert_pos = j\n\n            if best_insert_pos != -1:\n                # Perform the move\n                new_shortest_route = np.insert(shortest_route, best_insert_pos, customer)\n                new_longest_route = np.delete(longest_route, i)\n\n                # Update the solution\n                new_solution[shortest_route_idx] = new_shortest_route\n                new_solution[longest_route_idx] = new_longest_route\n\n                # Check if the routes are still valid (start and end with depot)\n                if new_longest_route[0] == 0 and new_longest_route[-1] == 0 and new_shortest_route[0] == 0 and new_shortest_route[-1] == 0:\n                    return new_solution\n\n    # If no improvement found, perform a demand-aware 2-opt on the longest route\n    for i in range(1, len(longest_route)-2):\n        for j in range(i+1, len(longest_route)-1):\n            # Check if swapping nodes i and j improves the route\n            original_cost = (distance_matrix[longest_route[i-1], longest_route[i]] +\n                            distance_matrix[longest_route[i], longest_route[i+1]] +\n                            distance_matrix[longest_route[j-1], longest_route[j]] +\n                            distance_matrix[longest_route[j], longest_route[j+1]])\n\n            swapped_cost = (distance_matrix[longest_route[i-1], longest_route[j]] +\n                            distance_matrix[longest_route[j], longest_route[i+1]] +\n                            distance_matrix[longest_route[j-1], longest_route[i]] +\n                            distance_matrix[longest_route[i], longest_route[j+1]])\n\n            if swapped_cost < original_cost:\n                # Perform the swap\n                new_route = longest_route.copy()\n                new_route[i], new_route[j] = new_route[j], new_route[i]\n                new_solution[longest_route_idx] = new_route\n                return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{The algorithm selects a promising solution from the archive by considering Pareto dominance and diversity, then applies a hybrid local search combining route fragmentation and intra-route 2-opt with capacity-aware swaps to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (e.g., not dominated and has high makespan)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    selected_objectives = archive[selected_idx][1]\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Fragmentation + Intra-route 2-opt with capacity checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Fragmentation - Split long routes into two\n        if len(route) > 6:  # Arbitrary threshold for fragmentation\n            split_pos = np.random.randint(2, len(route)-2)\n            new_route1 = route[:split_pos+1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                continue  # Skip 2-opt for this route after fragmentation\n\n        # Step 2: Intra-route 2-opt with capacity checks\n        improved = True\n        while improved:\n            improved = False\n            for j in range(1, len(route)-2):\n                for k in range(j+1, len(route)-1):\n                    # Try reversing segment [j,k]\n                    new_route = route.copy()\n                    new_route[j:k+1] = route[j:k+1][::-1]\n\n                    # Check capacity\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Check if distance improves\n                        old_dist = (distance_matrix[route[j-1], route[j]] +\n                                   distance_matrix[route[k], route[k+1]])\n                        new_dist = (distance_matrix[new_route[j-1], new_route[j]] +\n                                   distance_matrix[new_route[k], new_route[k+1]])\n                        if new_dist < old_dist:\n                            route = new_route\n                            improved = True\n                            break\n                if improved:\n                    break\n            new_solution[i] = route\n\n    # Ensure all routes are feasible (though fragmentation and 2-opt should maintain this)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "score": [
            -0.6288883860885307,
            1.3350785076618195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (e.g., not dominated and has high makespan)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    selected_objectives = archive[selected_idx][1]\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Fragmentation + Intra-route 2-opt with capacity checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Fragmentation - Split long routes into two\n        if len(route) > 6:  # Arbitrary threshold for fragmentation\n            split_pos = np.random.randint(2, len(route)-2)\n            new_route1 = route[:split_pos+1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                continue  # Skip 2-opt for this route after fragmentation\n\n        # Step 2: Intra-route 2-opt with capacity checks\n        improved = True\n        while improved:\n            improved = False\n            for j in range(1, len(route)-2):\n                for k in range(j+1, len(route)-1):\n                    # Try reversing segment [j,k]\n                    new_route = route.copy()\n                    new_route[j:k+1] = route[j:k+1][::-1]\n\n                    # Check capacity\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Check if distance improves\n                        old_dist = (distance_matrix[route[j-1], route[j]] +\n                                   distance_matrix[route[k], route[k+1]])\n                        new_dist = (distance_matrix[new_route[j-1], new_route[j]] +\n                                   distance_matrix[new_route[k], new_route[k+1]])\n                        if new_dist < old_dist:\n                            route = new_route\n                            improved = True\n                            break\n                if improved:\n                    break\n            new_solution[i] = route\n\n    # Ensure all routes are feasible (though fragmentation and 2-opt should maintain this)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high total distance or makespan, then applies a hybrid local search combining route splitting, customer reallocation, and capacity-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0], -x[1][1]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Route splitting - split the longest route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        split_pos = len(longest_route) // 2\n        new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints\n        if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Step 2: Customer reallocation - move customers between routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            customer_to_move = random.choice(route[1:-1])\n            for j in range(len(new_solution)):\n                if i != j:\n                    candidate_route = new_solution[j]\n                    new_route = np.concatenate([candidate_route[:-1], [customer_to_move], [0]])\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[j] = new_route\n                        new_solution[i] = np.concatenate([route[route != customer_to_move], [0]])\n                        break\n\n    # Step 3: Capacity-aware swaps - swap customers between routes if capacity allows\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            if len(route1) > 2 and len(route2) > 2:\n                customer1 = random.choice(route1[1:-1])\n                customer2 = random.choice(route2[1:-1])\n                new_route1 = np.concatenate([route1[route1 != customer1], [customer2], [0]])\n                new_route2 = np.concatenate([route2[route2 != customer2], [customer1], [0]])\n                if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7775956798354725,
            2.7952930629253387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0], -x[1][1]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Route splitting - split the longest route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        split_pos = len(longest_route) // 2\n        new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints\n        if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Step 2: Customer reallocation - move customers between routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            customer_to_move = random.choice(route[1:-1])\n            for j in range(len(new_solution)):\n                if i != j:\n                    candidate_route = new_solution[j]\n                    new_route = np.concatenate([candidate_route[:-1], [customer_to_move], [0]])\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[j] = new_route\n                        new_solution[i] = np.concatenate([route[route != customer_to_move], [0]])\n                        break\n\n    # Step 3: Capacity-aware swaps - swap customers between routes if capacity allows\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            if len(route1) > 2 and len(route2) > 2:\n                customer1 = random.choice(route1[1:-1])\n                customer2 = random.choice(route2[1:-1])\n                new_route1 = np.concatenate([route1[route1 != customer1], [customer2], [0]])\n                new_route2 = np.concatenate([route2[route2 != customer2], [customer1], [0]])\n                if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] / x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: merge two random routes if feasible, otherwise perform split insertion\n    if len(selected_solution) > 1:\n        i, j = random.sample(range(len(selected_solution)), 2)\n        route_i = selected_solution[i]\n        route_j = selected_solution[j]\n\n        # Try merging routes if their total demand fits in one vehicle\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [r for idx, r in enumerate(selected_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n        else:\n            # Split insertion: move a segment from one route to another if feasible\n            route_to_split = route_i if len(route_i) > 3 else route_j\n            split_pos = random.randint(1, len(route_to_split) - 2)\n            segment = route_to_split[split_pos:-split_pos]\n\n            if sum(demand[segment]) <= capacity:\n                # Insert segment into another route if feasible\n                for route in selected_solution:\n                    if route is not route_to_split and sum(demand[route[1:-1]]) + sum(demand[segment]) <= capacity:\n                        insert_pos = random.randint(1, len(route) - 1)\n                        new_route = np.concatenate([route[:insert_pos], segment, route[insert_pos:]])\n                        selected_solution = [r if r is not route else new_route for r in selected_solution]\n                        break\n    else:\n        # If only one route, perform demand-aware relocation\n        route = selected_solution[0]\n        if len(route) > 3:\n            pos = random.randint(1, len(route) - 2)\n            customer = route[pos]\n            # Find the best position to relocate the customer to minimize distance increase\n            best_pos = -1\n            min_increase = float('inf')\n            for i in range(len(route)):\n                if i != pos and i != pos - 1:\n                    new_route = np.concatenate([route[:i], [customer], route[i:]])\n                    if i == 0 or i == len(route) - 1:\n                        new_route = np.concatenate([[0], new_route[1:]])\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        increase = distance_matrix[route[i-1], customer] + distance_matrix[customer, route[i]] - distance_matrix[route[pos-1], route[pos]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n            if best_pos != -1:\n                new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                if best_pos == 0 or best_pos == len(route):\n                    new_route = np.concatenate([[0], new_route[1:]])\n                selected_solution = [new_route]\n\n    return selected_solution\n\n",
        "score": [
            -0.8365811889222343,
            6.027525633573532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] / x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: merge two random routes if feasible, otherwise perform split insertion\n    if len(selected_solution) > 1:\n        i, j = random.sample(range(len(selected_solution)), 2)\n        route_i = selected_solution[i]\n        route_j = selected_solution[j]\n\n        # Try merging routes if their total demand fits in one vehicle\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [r for idx, r in enumerate(selected_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n        else:\n            # Split insertion: move a segment from one route to another if feasible\n            route_to_split = route_i if len(route_i) > 3 else route_j\n            split_pos = random.randint(1, len(route_to_split) - 2)\n            segment = route_to_split[split_pos:-split_pos]\n\n            if sum(demand[segment]) <= capacity:\n                # Insert segment into another route if feasible\n                for route in selected_solution:\n                    if route is not route_to_split and sum(demand[route[1:-1]]) + sum(demand[segment]) <= capacity:\n                        insert_pos = random.randint(1, len(route) - 1)\n                        new_route = np.concatenate([route[:insert_pos], segment, route[insert_pos:]])\n                        selected_solution = [r if r is not route else new_route for r in selected_solution]\n                        break\n    else:\n        # If only one route, perform demand-aware relocation\n        route = selected_solution[0]\n        if len(route) > 3:\n            pos = random.randint(1, len(route) - 2)\n            customer = route[pos]\n            # Find the best position to relocate the customer to minimize distance increase\n            best_pos = -1\n            min_increase = float('inf')\n            for i in range(len(route)):\n                if i != pos and i != pos - 1:\n                    new_route = np.concatenate([route[:i], [customer], route[i:]])\n                    if i == 0 or i == len(route) - 1:\n                        new_route = np.concatenate([[0], new_route[1:]])\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        increase = distance_matrix[route[i-1], customer] + distance_matrix[customer, route[i]] - distance_matrix[route[pos-1], route[pos]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n            if best_pos != -1:\n                new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                if best_pos == 0 or best_pos == len(route):\n                    new_route = np.concatenate([[0], new_route[1:]])\n                selected_solution = [new_route]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.choice(len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Apply a hybrid local search: split the route into two parts and reinsert nodes\n        if len(selected_route) > 4:  # Ensure the route is long enough to split\n            split_pos = np.random.randint(2, len(selected_route) - 2)\n            part1 = selected_route[:split_pos]\n            part2 = selected_route[split_pos:]\n\n            # Reinsert nodes from part2 into part1 while respecting capacity\n            for node in part2[1:-1]:  # Skip depots\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(part1)):\n                    # Try inserting node between part1[i-1] and part1[i]\n                    new_route = np.insert(part1, i, node)\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[new_route[i-1], node] + distance_matrix[node, new_route[i+1]] - distance_matrix[new_route[i-1], new_route[i+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    part1 = np.insert(part1, best_pos, node)\n\n            # Rebuild the route\n            new_solution[route_idx] = part1\n\n            # If part2 has remaining nodes, create a new route\n            remaining_nodes = part2[1:-1]\n            if len(remaining_nodes) > 0:\n                # Create a new route with remaining nodes, ensuring capacity is not exceeded\n                new_route = [0]\n                current_load = 0\n                for node in remaining_nodes:\n                    if current_load + demand[node] <= capacity:\n                        new_route.append(node)\n                        current_load += demand[node]\n                new_route.append(0)\n                if len(new_route) > 2:  # Only add if it serves at least one customer\n                    new_solution.append(np.array(new_route))\n\n    return new_solution\n\n",
        "score": [
            -0.6976600432719102,
            3.178699940443039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.choice(len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Apply a hybrid local search: split the route into two parts and reinsert nodes\n        if len(selected_route) > 4:  # Ensure the route is long enough to split\n            split_pos = np.random.randint(2, len(selected_route) - 2)\n            part1 = selected_route[:split_pos]\n            part2 = selected_route[split_pos:]\n\n            # Reinsert nodes from part2 into part1 while respecting capacity\n            for node in part2[1:-1]:  # Skip depots\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(part1)):\n                    # Try inserting node between part1[i-1] and part1[i]\n                    new_route = np.insert(part1, i, node)\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[new_route[i-1], node] + distance_matrix[node, new_route[i+1]] - distance_matrix[new_route[i-1], new_route[i+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    part1 = np.insert(part1, best_pos, node)\n\n            # Rebuild the route\n            new_solution[route_idx] = part1\n\n            # If part2 has remaining nodes, create a new route\n            remaining_nodes = part2[1:-1]\n            if len(remaining_nodes) > 0:\n                # Create a new route with remaining nodes, ensuring capacity is not exceeded\n                new_route = [0]\n                current_load = 0\n                for node in remaining_nodes:\n                    if current_load + demand[node] <= capacity:\n                        new_route.append(node)\n                        current_load += demand[node]\n                new_route.append(0)\n                if len(new_route) > 2:  # Only add if it serves at least one customer\n                    new_solution.append(np.array(new_route))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{A hybrid local search strategy that combines route fragmentation and capacity-aware route merging to balance travel distance and makespan by intelligently reassigning customers between routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by combined objective\n    selected_solution = archive[0][0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route fragmentation and capacity-aware merging\n    for _ in range(10):  # Number of iterations\n        # Step 1: Randomly select a route to fragment\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Step 2: Find a split point that maintains feasibility\n        if len(route) <= 3:  # Cannot split a route with only depot and one customer\n            continue\n        split_pos = random.randint(1, len(route) - 2)\n\n        # Split the route into two parts\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Step 3: Try to merge part2 into another route\n        best_merge = None\n        best_merge_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n            candidate_route = new_solution[i]\n\n            # Check if merging part2 into candidate_route is feasible\n            total_demand = sum(demand[node] for node in candidate_route)\n            part2_demand = sum(demand[node] for node in part2[1:-1])  # Exclude depots\n            if total_demand + part2_demand > capacity:\n                continue\n\n            # Calculate the cost of merging\n            # Cost = distance from candidate_route's last node to part2's first node\n            #        + distance from part2's last node to candidate_route's last node\n            #        - distance from candidate_route's last node to its previous node\n            last_node = candidate_route[-2]\n            first_node = part2[1]\n            last_node_part2 = part2[-2]\n\n            cost = (distance_matrix[last_node][first_node] +\n                    distance_matrix[last_node_part2][candidate_route[-2]] -\n                    distance_matrix[candidate_route[-3]][candidate_route[-2]])\n\n            if cost < best_merge_cost:\n                best_merge_cost = cost\n                best_merge = (i, candidate_route)\n\n        # Perform the merge if beneficial\n        if best_merge is not None and best_merge_cost < 0:  # Only merge if it improves\n            merge_idx, merge_route = best_merge\n            # Merge part2 into merge_route\n            merged_route = np.concatenate([merge_route[:-1], part2[1:]])\n            new_solution[merge_idx] = merged_route\n            # Update the fragmented route\n            new_solution[route_idx] = part1\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6455795724557818,
            4.5076872408390045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by combined objective\n    selected_solution = archive[0][0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route fragmentation and capacity-aware merging\n    for _ in range(10):  # Number of iterations\n        # Step 1: Randomly select a route to fragment\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Step 2: Find a split point that maintains feasibility\n        if len(route) <= 3:  # Cannot split a route with only depot and one customer\n            continue\n        split_pos = random.randint(1, len(route) - 2)\n\n        # Split the route into two parts\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Step 3: Try to merge part2 into another route\n        best_merge = None\n        best_merge_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n            candidate_route = new_solution[i]\n\n            # Check if merging part2 into candidate_route is feasible\n            total_demand = sum(demand[node] for node in candidate_route)\n            part2_demand = sum(demand[node] for node in part2[1:-1])  # Exclude depots\n            if total_demand + part2_demand > capacity:\n                continue\n\n            # Calculate the cost of merging\n            # Cost = distance from candidate_route's last node to part2's first node\n            #        + distance from part2's last node to candidate_route's last node\n            #        - distance from candidate_route's last node to its previous node\n            last_node = candidate_route[-2]\n            first_node = part2[1]\n            last_node_part2 = part2[-2]\n\n            cost = (distance_matrix[last_node][first_node] +\n                    distance_matrix[last_node_part2][candidate_route[-2]] -\n                    distance_matrix[candidate_route[-3]][candidate_route[-2]])\n\n            if cost < best_merge_cost:\n                best_merge_cost = cost\n                best_merge = (i, candidate_route)\n\n        # Perform the merge if beneficial\n        if best_merge is not None and best_merge_cost < 0:  # Only merge if it improves\n            merge_idx, merge_route = best_merge\n            # Merge part2 into merge_route\n            merged_route = np.concatenate([merge_route[:-1], part2[1:]])\n            new_solution[merge_idx] = merged_route\n            # Update the fragmented route\n            new_solution[route_idx] = part1\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route Splitting and Customer Reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route)-1)\n        part1 = route[:split_idx+1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution[i] = part1\n            new_solution.insert(i+1, part2)\n            break  # Only perform one split per iteration\n\n    # Customer Reallocation: Move customers between routes to balance makespan\n    for _ in range(2):  # Perform up to 2 reallocations\n        if len(new_solution) < 2:\n            break\n\n        # Select a random route and a random customer to move\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) <= 2:  # Skip empty or single-customer routes\n            continue\n\n        customer_idx = np.random.randint(1, len(route)-1)\n        customer = route[customer_idx]\n\n        # Try to insert the customer into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            # Find the best insertion position in the other route\n            best_pos = -1\n            best_cost = float('inf')\n\n            for pos in range(1, len(other_route)):\n                # Calculate the cost of inserting the customer at this position\n                prev_node = other_route[pos-1]\n                next_node = other_route[pos]\n                cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Check capacity constraint\n            if best_pos != -1:\n                new_demand = sum(demand[node] for node in other_route[1:-1]) + demand[customer]\n                if new_demand <= capacity:\n                    # Perform the move\n                    new_solution[route_idx] = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                    new_solution[other_route_idx] = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7521734599324277,
            0.4057977497577667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route Splitting and Customer Reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route)-1)\n        part1 = route[:split_idx+1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution[i] = part1\n            new_solution.insert(i+1, part2)\n            break  # Only perform one split per iteration\n\n    # Customer Reallocation: Move customers between routes to balance makespan\n    for _ in range(2):  # Perform up to 2 reallocations\n        if len(new_solution) < 2:\n            break\n\n        # Select a random route and a random customer to move\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) <= 2:  # Skip empty or single-customer routes\n            continue\n\n        customer_idx = np.random.randint(1, len(route)-1)\n        customer = route[customer_idx]\n\n        # Try to insert the customer into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            # Find the best insertion position in the other route\n            best_pos = -1\n            best_cost = float('inf')\n\n            for pos in range(1, len(other_route)):\n                # Calculate the cost of inserting the customer at this position\n                prev_node = other_route[pos-1]\n                next_node = other_route[pos]\n                cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Check capacity constraint\n            if best_pos != -1:\n                new_demand = sum(demand[node] for node in other_route[1:-1]) + demand[customer]\n                if new_demand <= capacity:\n                    # Perform the move\n                    new_solution[route_idx] = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                    new_solution[other_route_idx] = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Choose a random route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: 2-opt with route splitting\n    if len(selected_route) > 4:  # Only modify if route has enough customers\n        # Randomly select two non-depot nodes to swap\n        i, j = np.random.choice(range(1, len(selected_route)-1), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Perform 2-opt swap\n        new_route = np.concatenate([\n            selected_route[:i],\n            selected_route[j:i-1:-1],\n            selected_route[j+1:]\n        ])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route]) <= capacity:\n            selected_solution[route_idx] = new_route\n        else:\n            # If infeasible, split the route into two\n            split_pos = np.random.randint(1, len(new_route)-1)\n            route1 = np.concatenate([new_route[:split_pos], [0]])\n            route2 = np.concatenate([[0], new_route[split_pos:]])\n\n            # Check capacity of both new routes\n            if np.sum(demand[route1]) <= capacity and np.sum(demand[route2]) <= capacity:\n                selected_solution = [\n                    route for idx, route in enumerate(selected_solution)\n                    if idx != route_idx\n                ] + [route1, route2]\n\n    return selected_solution\n\n",
        "score": [
            -0.349209257562505,
            0.7827937006950378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Choose a random route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: 2-opt with route splitting\n    if len(selected_route) > 4:  # Only modify if route has enough customers\n        # Randomly select two non-depot nodes to swap\n        i, j = np.random.choice(range(1, len(selected_route)-1), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Perform 2-opt swap\n        new_route = np.concatenate([\n            selected_route[:i],\n            selected_route[j:i-1:-1],\n            selected_route[j+1:]\n        ])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route]) <= capacity:\n            selected_solution[route_idx] = new_route\n        else:\n            # If infeasible, split the route into two\n            split_pos = np.random.randint(1, len(new_route)-1)\n            route1 = np.concatenate([new_route[:split_pos], [0]])\n            route2 = np.concatenate([[0], new_route[split_pos:]])\n\n            # Check capacity of both new routes\n            if np.sum(demand[route1]) <= capacity and np.sum(demand[route2]) <= capacity:\n                selected_solution = [\n                    route for idx, route in enumerate(selected_solution)\n                    if idx != route_idx\n                ] + [route1, route2]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    new_solution = [route.copy() for route in selected]\n\n    # Step 1: Route Splitting (if a route is too long, split it into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 5:  # Arbitrary threshold for splitting\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n            new_route2 = np.concatenate([[0], new_route2[1:]])\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    # Step 2: Demand-based Node Reinsertion (move high-demand nodes to separate routes)\n    for route in new_solution:\n        if len(route) > 3:\n            high_demand_nodes = [node for node in route[1:-1] if demand[node] > capacity * 0.3]\n            for node in high_demand_nodes:\n                if np.sum(demand[route]) - demand[node] <= capacity:\n                    continue\n                # Reinsert the node into a new route\n                new_route = np.array([0, node, 0])\n                new_solution.append(new_route)\n                route = np.delete(route, np.where(route == node))\n\n    # Step 3: Cross-Route Swaps (improve total distance and makespan)\n    if len(new_solution) > 1:\n        for _ in range(3):  # Limit iterations for efficiency\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n            # Select random nodes (excluding depot)\n            node1 = np.random.choice(route1[1:-1])\n            node2 = np.random.choice(route2[1:-1])\n            # Swap nodes if capacity allows\n            if (np.sum(demand[route1]) - demand[node1] + demand[node2] <= capacity and\n                np.sum(demand[route2]) - demand[node2] + demand[node1] <= capacity):\n                route1[np.where(route1 == node1)] = node2\n                route2[np.where(route2 == node2)] = node1\n\n    # Ensure feasibility and return\n    for route in new_solution:\n        assert np.sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated!\"\n    return new_solution\n\n",
        "score": [
            -0.6846242798338886,
            2.3843342065811157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    new_solution = [route.copy() for route in selected]\n\n    # Step 1: Route Splitting (if a route is too long, split it into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 5:  # Arbitrary threshold for splitting\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n            new_route2 = np.concatenate([[0], new_route2[1:]])\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    # Step 2: Demand-based Node Reinsertion (move high-demand nodes to separate routes)\n    for route in new_solution:\n        if len(route) > 3:\n            high_demand_nodes = [node for node in route[1:-1] if demand[node] > capacity * 0.3]\n            for node in high_demand_nodes:\n                if np.sum(demand[route]) - demand[node] <= capacity:\n                    continue\n                # Reinsert the node into a new route\n                new_route = np.array([0, node, 0])\n                new_solution.append(new_route)\n                route = np.delete(route, np.where(route == node))\n\n    # Step 3: Cross-Route Swaps (improve total distance and makespan)\n    if len(new_solution) > 1:\n        for _ in range(3):  # Limit iterations for efficiency\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            if len(route1) < 3 or len(route2) < 3:\n                continue\n            # Select random nodes (excluding depot)\n            node1 = np.random.choice(route1[1:-1])\n            node2 = np.random.choice(route2[1:-1])\n            # Swap nodes if capacity allows\n            if (np.sum(demand[route1]) - demand[node1] + demand[node2] <= capacity and\n                np.sum(demand[route2]) - demand[node2] + demand[node1] <= capacity):\n                route1[np.where(route1 == node1)] = node2\n                route2[np.where(route2 == node2)] = node1\n\n    # Ensure feasibility and return\n    for route in new_solution:\n        assert np.sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated!\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{The algorithm selects a promising solution from the archive, applies a hybrid local search combining route-shaking (randomly perturbing routes) and a capacity-aware insertion heuristic to improve both distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route shaking + capacity-aware insertion\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select a route to shake\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Shake the route: Remove 2-3 random customers and reinsert them\n        if len(route) > 4:  # Ensure route has enough nodes to shake\n            # Select 2-3 random customers to remove (excluding depots)\n            num_remove = random.randint(2, min(3, len(route) - 3))\n            remove_indices = sorted(random.sample(range(1, len(route) - 1), num_remove), reverse=True)\n            removed_nodes = [route[i] for i in remove_indices]\n\n            # Remove nodes from route\n            for i in remove_indices:\n                route = np.delete(route, i)\n\n            # Reinsert nodes using capacity-aware nearest insertion\n            for node in removed_nodes:\n                best_pos = 1  # Default to first position\n                best_cost = float('inf')\n\n                # Evaluate insertion positions\n                for i in range(1, len(route)):\n                    # Check capacity constraint\n                    current_load = sum(demand[route[1:i]])\n                    if current_load + demand[node] <= capacity:\n                        # Calculate insertion cost\n                        insertion_cost = (distance_matrix[route[i-1]][node] +\n                                        distance_matrix[node][route[i]] -\n                                        distance_matrix[route[i-1]][route[i]])\n                        if insertion_cost < best_cost:\n                            best_cost = insertion_cost\n                            best_pos = i\n\n                # Insert node at best position\n                route = np.insert(route, best_pos, node)\n\n            new_solution[route_idx] = route\n\n    return new_solution\n\n",
        "score": [
            -0.26191138266341385,
            8.811086386442184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route shaking + capacity-aware insertion\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select a route to shake\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Shake the route: Remove 2-3 random customers and reinsert them\n        if len(route) > 4:  # Ensure route has enough nodes to shake\n            # Select 2-3 random customers to remove (excluding depots)\n            num_remove = random.randint(2, min(3, len(route) - 3))\n            remove_indices = sorted(random.sample(range(1, len(route) - 1), num_remove), reverse=True)\n            removed_nodes = [route[i] for i in remove_indices]\n\n            # Remove nodes from route\n            for i in remove_indices:\n                route = np.delete(route, i)\n\n            # Reinsert nodes using capacity-aware nearest insertion\n            for node in removed_nodes:\n                best_pos = 1  # Default to first position\n                best_cost = float('inf')\n\n                # Evaluate insertion positions\n                for i in range(1, len(route)):\n                    # Check capacity constraint\n                    current_load = sum(demand[route[1:i]])\n                    if current_load + demand[node] <= capacity:\n                        # Calculate insertion cost\n                        insertion_cost = (distance_matrix[route[i-1]][node] +\n                                        distance_matrix[node][route[i]] -\n                                        distance_matrix[route[i-1]][route[i]])\n                        if insertion_cost < best_cost:\n                            best_cost = insertion_cost\n                            best_pos = i\n\n                # Insert node at best position\n                route = np.insert(route, best_pos, node)\n\n            new_solution[route_idx] = route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive[-1][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Step 2.1: Relocate a random customer to a different position (avoiding pure 2-opt)\n        temp_route = route.copy()\n        customer_pos = np.random.randint(1, len(temp_route) - 1)\n        customer = temp_route[customer_pos]\n\n        # Remove the customer\n        temp_route = np.delete(temp_route, customer_pos)\n\n        # Insert the customer at a new position (not adjacent to original)\n        new_pos = np.random.randint(1, len(temp_route))\n        if new_pos >= customer_pos:\n            new_pos += 1\n        temp_route = np.insert(temp_route, new_pos, customer)\n\n        # Step 2.2: Check capacity constraint\n        route_demand = np.sum(demand[temp_route[1:-1]])\n        if route_demand <= capacity:\n            new_solution.append(temp_route)\n        else:\n            new_solution.append(route.copy())\n\n    return new_solution\n\n",
        "score": [
            -0.7763085202863979,
            2.130125731229782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive[-1][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Step 2.1: Relocate a random customer to a different position (avoiding pure 2-opt)\n        temp_route = route.copy()\n        customer_pos = np.random.randint(1, len(temp_route) - 1)\n        customer = temp_route[customer_pos]\n\n        # Remove the customer\n        temp_route = np.delete(temp_route, customer_pos)\n\n        # Insert the customer at a new position (not adjacent to original)\n        new_pos = np.random.randint(1, len(temp_route))\n        if new_pos >= customer_pos:\n            new_pos += 1\n        temp_route = np.insert(temp_route, new_pos, customer)\n\n        # Step 2.2: Check capacity constraint\n        route_demand = np.sum(demand[temp_route[1:-1]])\n        if route_demand <= capacity:\n            new_solution.append(temp_route)\n        else:\n            new_solution.append(route.copy())\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive, then applies a hybrid local search combining route splitting, demand-based merging, and a novel \"demand-aware swap\" operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by total distance and makespan to find non-dominated solutions\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        non_dominated = [sorted_archive[0]]\n        for sol in sorted_archive[1:]:\n            if sol[1][1] < non_dominated[-1][1][1]:\n                non_dominated.append(sol)\n        # Randomly select from non-dominated solutions\n        base_solution = random.choice(non_dominated)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search steps\n    # Step 1: Route splitting if a route is too long (demand-aware)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand > capacity:\n                # Split the route into two parts\n                split_pos = len(route) // 2\n                new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n                new_solution = np.concatenate((new_solution[:i], [new_route1], [new_route2], new_solution[i+1:]))\n\n    # Step 2: Demand-based merging of short routes\n    if len(new_solution) > 1:\n        merged = True\n        while merged:\n            merged = False\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    combined_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n                    if combined_demand <= capacity:\n                        # Merge the two routes\n                        new_route = np.concatenate(([0], route1[1:-1], route2[1:-1], [0]))\n                        new_solution = np.concatenate((new_solution[:i], [new_route], new_solution[i+1:j], new_solution[j+1:]))\n                        merged = True\n                        break\n                if merged:\n                    break\n\n    # Step 3: Demand-aware swap operator\n    for route in new_solution:\n        if len(route) > 3:\n            # Select two random customers in the route\n            idx1, idx2 = random.sample(range(1, len(route)-1), 2)\n            # Swap them if demand constraints are satisfied\n            temp = route[idx1]\n            route[idx1] = route[idx2]\n            route[idx2] = temp\n            # Check feasibility\n            if sum(demand[node] for node in route[1:-1]) > capacity:\n                # Undo swap if infeasible\n                temp = route[idx1]\n                route[idx1] = route[idx2]\n                route[idx2] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.49589610992903277,
            3.227878123521805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by total distance and makespan to find non-dominated solutions\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        non_dominated = [sorted_archive[0]]\n        for sol in sorted_archive[1:]:\n            if sol[1][1] < non_dominated[-1][1][1]:\n                non_dominated.append(sol)\n        # Randomly select from non-dominated solutions\n        base_solution = random.choice(non_dominated)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search steps\n    # Step 1: Route splitting if a route is too long (demand-aware)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand > capacity:\n                # Split the route into two parts\n                split_pos = len(route) // 2\n                new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n                new_solution = np.concatenate((new_solution[:i], [new_route1], [new_route2], new_solution[i+1:]))\n\n    # Step 2: Demand-based merging of short routes\n    if len(new_solution) > 1:\n        merged = True\n        while merged:\n            merged = False\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    combined_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n                    if combined_demand <= capacity:\n                        # Merge the two routes\n                        new_route = np.concatenate(([0], route1[1:-1], route2[1:-1], [0]))\n                        new_solution = np.concatenate((new_solution[:i], [new_route], new_solution[i+1:j], new_solution[j+1:]))\n                        merged = True\n                        break\n                if merged:\n                    break\n\n    # Step 3: Demand-aware swap operator\n    for route in new_solution:\n        if len(route) > 3:\n            # Select two random customers in the route\n            idx1, idx2 = random.sample(range(1, len(route)-1), 2)\n            # Swap them if demand constraints are satisfied\n            temp = route[idx1]\n            route[idx1] = route[idx2]\n            route[idx2] = temp\n            # Check feasibility\n            if sum(demand[node] for node in route[1:-1]) > capacity:\n                # Undo swap if infeasible\n                temp = route[idx1]\n                route[idx1] = route[idx2]\n                route[idx2] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.random.choice([i for i in range(len(archive)) if archive[i][1][1] > np.median([s[1][1] for s in archive]) or archive[i][1][0] < np.median([s[1][0] for s in archive])])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Repeat the operator a few times for better exploration\n        # Step 1: Randomly select a route to modify\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n\n        # Step 2: Split the route into two parts at a random customer\n        if len(route) > 3:  # Ensure the route has enough customers to split\n            split_pos = np.random.randint(1, len(route)-1)\n            first_part = route[:split_pos]\n            second_part = route[split_pos:]\n\n            # Step 3: Reverse the second part to explore alternative sequences\n            second_part = second_part[::-1]\n\n            # Step 4: Reinsert the reversed segment into the route or a new route\n            if np.random.rand() > 0.5 and len(new_solution) < len(base_solution) + 1:  # Create a new route\n                new_route = np.concatenate([[0], second_part, [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:  # Check capacity constraint\n                    new_solution.append(new_route)\n                    new_solution[route_idx] = np.concatenate([first_part, [0]])\n            else:  # Reinsert into the same route\n                new_route = np.concatenate([first_part, second_part, [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:  # Check capacity constraint\n                    new_solution[route_idx] = new_route\n\n        # Step 5: Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.733768227860816,
            2.632543057203293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.random.choice([i for i in range(len(archive)) if archive[i][1][1] > np.median([s[1][1] for s in archive]) or archive[i][1][0] < np.median([s[1][0] for s in archive])])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Repeat the operator a few times for better exploration\n        # Step 1: Randomly select a route to modify\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n\n        # Step 2: Split the route into two parts at a random customer\n        if len(route) > 3:  # Ensure the route has enough customers to split\n            split_pos = np.random.randint(1, len(route)-1)\n            first_part = route[:split_pos]\n            second_part = route[split_pos:]\n\n            # Step 3: Reverse the second part to explore alternative sequences\n            second_part = second_part[::-1]\n\n            # Step 4: Reinsert the reversed segment into the route or a new route\n            if np.random.rand() > 0.5 and len(new_solution) < len(base_solution) + 1:  # Create a new route\n                new_route = np.concatenate([[0], second_part, [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:  # Check capacity constraint\n                    new_solution.append(new_route)\n                    new_solution[route_idx] = np.concatenate([first_part, [0]])\n            else:  # Reinsert into the same route\n                new_route = np.concatenate([first_part, second_part, [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:  # Check capacity constraint\n                    new_solution[route_idx] = new_route\n\n        # Step 5: Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{A hybrid local search strategy combining route splitting, demand-based customer relocation, and adaptive insertion to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly choose a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n    else:\n        route_idx = 0\n        selected_route = new_solution[0].copy()\n\n    # Calculate current route demand\n    route_demand = sum(demand[customer] for customer in selected_route[1:-1])\n\n    # Step 1: Route Splitting (if route is too long and can be split)\n    if len(selected_route) > 4:  # Avoid trivial routes\n        split_point = random.randint(1, len(selected_route) - 2)\n        first_part = selected_route[:split_point + 1]\n        second_part = selected_route[split_point:]\n\n        # Check feasibility of split\n        first_demand = sum(demand[customer] for customer in first_part[1:-1])\n        second_demand = sum(demand[customer] for customer in second_part[1:-1])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace the original route with the two new routes\n            new_solution.pop(route_idx)\n            new_solution.insert(route_idx, first_part)\n            new_solution.insert(route_idx + 1, second_part)\n            return new_solution\n\n    # Step 2: Demand-based Customer Relocation (move high-demand customers)\n    if len(new_solution) > 1:\n        # Find the route with the highest demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        max_demand_idx = demands.index(max(demands))\n        max_demand_route = new_solution[max_demand_idx].copy()\n\n        # Find a customer to move (prefer high-demand customers)\n        customers = max_demand_route[1:-1]\n        if len(customers) > 0:\n            # Sort customers by demand (descending) and pick the highest\n            customers_sorted = sorted(customers, key=lambda x: -demand[x])\n            customer_to_move = customers_sorted[0]\n\n            # Find the best insertion point in another route\n            best_insertion = None\n            best_distance_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == max_demand_idx:\n                    continue\n\n                for j in range(1, len(route)):\n                    # Try inserting before and after each customer in the route\n                    for k in [j, j + 1]:\n                        if k == len(route):\n                            continue\n\n                        # Calculate new demand\n                        new_demand = sum(demand[route[1:-1]]) + demand[customer_to_move]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate distance increase\n                        if k == j:\n                            prev_node = route[j - 1]\n                            next_node = route[j]\n                        else:\n                            prev_node = route[j]\n                            next_node = route[j + 1] if j + 1 < len(route) else route[j]\n\n                        dist_increase = (distance_matrix[prev_node][customer_to_move] +\n                                        distance_matrix[customer_to_move][next_node] -\n                                        distance_matrix[prev_node][next_node])\n\n                        if dist_increase < best_distance_increase:\n                            best_distance_increase = dist_increase\n                            best_insertion = (i, k)\n\n            # Perform the best insertion\n            if best_insertion is not None:\n                route_idx, pos = best_insertion\n                new_route = new_solution[route_idx].copy()\n                new_route = np.insert(new_route, pos, customer_to_move)\n\n                # Update the routes\n                new_solution[max_demand_idx] = np.delete(max_demand_route, np.where(max_demand_route == customer_to_move)[0][0])\n                new_solution[route_idx] = new_route\n\n                return new_solution\n\n    # Step 3: Adaptive Insertion (insert a customer from one route to another)\n    if len(new_solution) > 1:\n        # Select a random route to take a customer from\n        source_route_idx = random.randint(0, len(new_solution) - 1)\n        source_route = new_solution[source_route_idx].copy()\n\n        if len(source_route) > 3:  # Ensure there's a customer to move\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(source_route) - 2)\n            customer_to_move = source_route[customer_idx]\n\n            # Find the best route to insert into\n            best_route_idx = -1\n            best_pos = -1\n            best_distance_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == source_route_idx:\n                    continue\n\n                for j in range(1, len(route)):\n                    # Try inserting before and after each customer in the route\n                    for k in [j, j + 1]:\n                        if k == len(route):\n                            continue\n\n                        # Calculate new demand\n                        new_demand = sum(demand[route[1:-1]]) + demand[customer_to_move]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate distance increase\n                        if k == j:\n                            prev_node = route[j - 1]\n                            next_node = route[j]\n                        else:\n                            prev_node = route[j]\n                            next_node = route[j + 1] if j + 1 < len(route) else route[j]\n\n                        dist_increase = (distance_matrix[prev_node][customer_to_move] +\n                                        distance_matrix[customer_to_move][next_node] -\n                                        distance_matrix[prev_node][next_node])\n\n                        if dist_increase < best_distance_increase:\n                            best_distance_increase = dist_increase\n                            best_route_idx = i\n                            best_pos = k\n\n            # Perform the best insertion\n            if best_route_idx != -1 and best_pos != -1:\n                # Remove customer from source route\n                new_source_route = np.delete(source_route, customer_idx)\n\n                # Insert into target route\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.insert(target_route, best_pos, customer_to_move)\n\n                # Update the routes\n                new_solution[source_route_idx] = new_source_route\n                new_solution[best_route_idx] = new_target_route\n\n                return new_solution\n\n    # If no improvement found, return the original solution\n    return new_solution\n\n",
        "score": [
            -0.7132248520077387,
            0.22465655207633972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly choose a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n    else:\n        route_idx = 0\n        selected_route = new_solution[0].copy()\n\n    # Calculate current route demand\n    route_demand = sum(demand[customer] for customer in selected_route[1:-1])\n\n    # Step 1: Route Splitting (if route is too long and can be split)\n    if len(selected_route) > 4:  # Avoid trivial routes\n        split_point = random.randint(1, len(selected_route) - 2)\n        first_part = selected_route[:split_point + 1]\n        second_part = selected_route[split_point:]\n\n        # Check feasibility of split\n        first_demand = sum(demand[customer] for customer in first_part[1:-1])\n        second_demand = sum(demand[customer] for customer in second_part[1:-1])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace the original route with the two new routes\n            new_solution.pop(route_idx)\n            new_solution.insert(route_idx, first_part)\n            new_solution.insert(route_idx + 1, second_part)\n            return new_solution\n\n    # Step 2: Demand-based Customer Relocation (move high-demand customers)\n    if len(new_solution) > 1:\n        # Find the route with the highest demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        max_demand_idx = demands.index(max(demands))\n        max_demand_route = new_solution[max_demand_idx].copy()\n\n        # Find a customer to move (prefer high-demand customers)\n        customers = max_demand_route[1:-1]\n        if len(customers) > 0:\n            # Sort customers by demand (descending) and pick the highest\n            customers_sorted = sorted(customers, key=lambda x: -demand[x])\n            customer_to_move = customers_sorted[0]\n\n            # Find the best insertion point in another route\n            best_insertion = None\n            best_distance_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == max_demand_idx:\n                    continue\n\n                for j in range(1, len(route)):\n                    # Try inserting before and after each customer in the route\n                    for k in [j, j + 1]:\n                        if k == len(route):\n                            continue\n\n                        # Calculate new demand\n                        new_demand = sum(demand[route[1:-1]]) + demand[customer_to_move]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate distance increase\n                        if k == j:\n                            prev_node = route[j - 1]\n                            next_node = route[j]\n                        else:\n                            prev_node = route[j]\n                            next_node = route[j + 1] if j + 1 < len(route) else route[j]\n\n                        dist_increase = (distance_matrix[prev_node][customer_to_move] +\n                                        distance_matrix[customer_to_move][next_node] -\n                                        distance_matrix[prev_node][next_node])\n\n                        if dist_increase < best_distance_increase:\n                            best_distance_increase = dist_increase\n                            best_insertion = (i, k)\n\n            # Perform the best insertion\n            if best_insertion is not None:\n                route_idx, pos = best_insertion\n                new_route = new_solution[route_idx].copy()\n                new_route = np.insert(new_route, pos, customer_to_move)\n\n                # Update the routes\n                new_solution[max_demand_idx] = np.delete(max_demand_route, np.where(max_demand_route == customer_to_move)[0][0])\n                new_solution[route_idx] = new_route\n\n                return new_solution\n\n    # Step 3: Adaptive Insertion (insert a customer from one route to another)\n    if len(new_solution) > 1:\n        # Select a random route to take a customer from\n        source_route_idx = random.randint(0, len(new_solution) - 1)\n        source_route = new_solution[source_route_idx].copy()\n\n        if len(source_route) > 3:  # Ensure there's a customer to move\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(source_route) - 2)\n            customer_to_move = source_route[customer_idx]\n\n            # Find the best route to insert into\n            best_route_idx = -1\n            best_pos = -1\n            best_distance_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == source_route_idx:\n                    continue\n\n                for j in range(1, len(route)):\n                    # Try inserting before and after each customer in the route\n                    for k in [j, j + 1]:\n                        if k == len(route):\n                            continue\n\n                        # Calculate new demand\n                        new_demand = sum(demand[route[1:-1]]) + demand[customer_to_move]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate distance increase\n                        if k == j:\n                            prev_node = route[j - 1]\n                            next_node = route[j]\n                        else:\n                            prev_node = route[j]\n                            next_node = route[j + 1] if j + 1 < len(route) else route[j]\n\n                        dist_increase = (distance_matrix[prev_node][customer_to_move] +\n                                        distance_matrix[customer_to_move][next_node] -\n                                        distance_matrix[prev_node][next_node])\n\n                        if dist_increase < best_distance_increase:\n                            best_distance_increase = dist_increase\n                            best_route_idx = i\n                            best_pos = k\n\n            # Perform the best insertion\n            if best_route_idx != -1 and best_pos != -1:\n                # Remove customer from source route\n                new_source_route = np.delete(source_route, customer_idx)\n\n                # Insert into target route\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.insert(target_route, best_pos, customer_to_move)\n\n                # Update the routes\n                new_solution[source_route_idx] = new_source_route\n                new_solution[best_route_idx] = new_target_route\n\n                return new_solution\n\n    # If no improvement found, return the original solution\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by evaluating the ratio of total distance to makespan, then applies a hybrid local search combining route splitting, demand-based relocations, and adaptive 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: archive[i][1][0] / archive[i][1][1])\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route splitting, demand-based relocation, and adaptive 2-opt\n    for _ in range(5):  # Number of iterations\n        # Step 1: Route splitting - split a long route into two feasible parts\n        if len(new_solution) > 1:\n            long_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n            long_route = new_solution[long_route_idx]\n            if len(long_route) > 3:  # Ensure it can be split\n                split_pos = random.randint(1, len(long_route) - 2)\n                route1 = long_route[:split_pos + 1]\n                route2 = np.concatenate([[0], long_route[split_pos:-1], [0]])\n\n                # Check feasibility\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution.pop(long_route_idx)\n                    new_solution.append(route1)\n                    new_solution.append(route2)\n\n        # Step 2: Demand-based relocation - move a customer from one route to another\n        if len(new_solution) > 1:\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) > 3:\n                customer_pos = random.randint(1, len(from_route) - 2)\n                customer = from_route[customer_pos]\n\n                # Try to insert into another route\n                for to_route_idx in range(len(new_solution)):\n                    if to_route_idx != from_route_idx:\n                        to_route = new_solution[to_route_idx]\n                        for insert_pos in range(1, len(to_route)):\n                            new_to_route = np.concatenate([\n                                to_route[:insert_pos], [customer], to_route[insert_pos:]\n                            ])\n                            if np.sum(demand[new_to_route[1:-1]]) <= capacity:\n                                # Update routes\n                                new_from_route = np.concatenate([\n                                    from_route[:customer_pos], from_route[customer_pos + 1:]\n                                ])\n                                if len(new_from_route) > 2:  # Ensure valid route\n                                    new_solution[from_route_idx] = new_from_route\n                                    new_solution[to_route_idx] = new_to_route\n                                    break\n\n        # Step 3: Adaptive 2-opt - apply 2-opt on the longest route\n        if len(new_solution) > 0:\n            long_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n            long_route = new_solution[long_route_idx]\n            if len(long_route) > 4:  # At least 4 nodes to apply 2-opt\n                i = random.randint(1, len(long_route) - 3)\n                j = random.randint(i + 1, len(long_route) - 2)\n                new_route = np.concatenate([\n                    long_route[:i], long_route[i:j][::-1], long_route[j:]\n                ])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[long_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.772893815041615,
            10.655781745910645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: archive[i][1][0] / archive[i][1][1])\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route splitting, demand-based relocation, and adaptive 2-opt\n    for _ in range(5):  # Number of iterations\n        # Step 1: Route splitting - split a long route into two feasible parts\n        if len(new_solution) > 1:\n            long_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n            long_route = new_solution[long_route_idx]\n            if len(long_route) > 3:  # Ensure it can be split\n                split_pos = random.randint(1, len(long_route) - 2)\n                route1 = long_route[:split_pos + 1]\n                route2 = np.concatenate([[0], long_route[split_pos:-1], [0]])\n\n                # Check feasibility\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution.pop(long_route_idx)\n                    new_solution.append(route1)\n                    new_solution.append(route2)\n\n        # Step 2: Demand-based relocation - move a customer from one route to another\n        if len(new_solution) > 1:\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) > 3:\n                customer_pos = random.randint(1, len(from_route) - 2)\n                customer = from_route[customer_pos]\n\n                # Try to insert into another route\n                for to_route_idx in range(len(new_solution)):\n                    if to_route_idx != from_route_idx:\n                        to_route = new_solution[to_route_idx]\n                        for insert_pos in range(1, len(to_route)):\n                            new_to_route = np.concatenate([\n                                to_route[:insert_pos], [customer], to_route[insert_pos:]\n                            ])\n                            if np.sum(demand[new_to_route[1:-1]]) <= capacity:\n                                # Update routes\n                                new_from_route = np.concatenate([\n                                    from_route[:customer_pos], from_route[customer_pos + 1:]\n                                ])\n                                if len(new_from_route) > 2:  # Ensure valid route\n                                    new_solution[from_route_idx] = new_from_route\n                                    new_solution[to_route_idx] = new_to_route\n                                    break\n\n        # Step 3: Adaptive 2-opt - apply 2-opt on the longest route\n        if len(new_solution) > 0:\n            long_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n            long_route = new_solution[long_route_idx]\n            if len(long_route) > 4:  # At least 4 nodes to apply 2-opt\n                i = random.randint(1, len(long_route) - 3)\n                j = random.randint(i + 1, len(long_route) - 2)\n                new_route = np.concatenate([\n                    long_route[:i], long_route[i:j][::-1], long_route[j:]\n                ])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[long_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest makespan or highest total distance)\n    archive.sort(key=lambda x: (x[1][1], -x[1][0]))  # Prioritize low makespan, then high total distance\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Step 1: Randomly select two routes for potential swapping\n    route_indices = list(range(n_routes))\n    np.random.shuffle(route_indices)\n    route1_idx, route2_idx = route_indices[:2]\n\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Step 2: Check if swapping the routes improves the makespan\n    current_makespan = max([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    new_routes = new_solution.copy()\n    new_routes[route1_idx], new_routes[route2_idx] = route2, route1\n    new_makespan = max([sum(distance_matrix[route[:-1], route[1:]]) for route in new_routes])\n\n    if new_makespan < current_makespan:\n        new_solution = new_routes\n    else:\n        # Step 3: If swapping doesn't help, try moving a customer from one route to another\n        # Select a random customer from route1 (excluding depot)\n        customers_route1 = route1[1:-1]\n        if len(customers_route1) == 0:\n            return new_solution\n\n        np.random.shuffle(customers_route1)\n        customer_to_move = customers_route1[0]\n\n        # Find the best insertion position in route2\n        best_insert_pos = -1\n        best_insert_cost = float('inf')\n\n        for i in range(1, len(route2)):\n            # Insert customer_to_move between route2[i-1] and route2[i]\n            new_route = np.insert(route2, i, customer_to_move)\n            # Check capacity constraint\n            route_demand = sum(demand[new_route[1:-1]])\n            if route_demand > capacity:\n                continue\n            # Calculate insertion cost\n            cost = (distance_matrix[route2[i-1], customer_to_move] +\n                    distance_matrix[customer_to_move, route2[i]] -\n                    distance_matrix[route2[i-1], route2[i]])\n            if cost < best_insert_cost:\n                best_insert_cost = cost\n                best_insert_pos = i\n\n        if best_insert_pos != -1:\n            # Perform the move\n            new_route2 = np.insert(route2, best_insert_pos, customer_to_move)\n            new_route1 = np.delete(route1, np.where(route1 == customer_to_move)[0][0])\n\n            # Ensure routes are valid (non-empty except depot)\n            if len(new_route1) > 2 or len(new_route2) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.5618378287383575,
            1.2196317911148071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest makespan or highest total distance)\n    archive.sort(key=lambda x: (x[1][1], -x[1][0]))  # Prioritize low makespan, then high total distance\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Step 1: Randomly select two routes for potential swapping\n    route_indices = list(range(n_routes))\n    np.random.shuffle(route_indices)\n    route1_idx, route2_idx = route_indices[:2]\n\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Step 2: Check if swapping the routes improves the makespan\n    current_makespan = max([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    new_routes = new_solution.copy()\n    new_routes[route1_idx], new_routes[route2_idx] = route2, route1\n    new_makespan = max([sum(distance_matrix[route[:-1], route[1:]]) for route in new_routes])\n\n    if new_makespan < current_makespan:\n        new_solution = new_routes\n    else:\n        # Step 3: If swapping doesn't help, try moving a customer from one route to another\n        # Select a random customer from route1 (excluding depot)\n        customers_route1 = route1[1:-1]\n        if len(customers_route1) == 0:\n            return new_solution\n\n        np.random.shuffle(customers_route1)\n        customer_to_move = customers_route1[0]\n\n        # Find the best insertion position in route2\n        best_insert_pos = -1\n        best_insert_cost = float('inf')\n\n        for i in range(1, len(route2)):\n            # Insert customer_to_move between route2[i-1] and route2[i]\n            new_route = np.insert(route2, i, customer_to_move)\n            # Check capacity constraint\n            route_demand = sum(demand[new_route[1:-1]])\n            if route_demand > capacity:\n                continue\n            # Calculate insertion cost\n            cost = (distance_matrix[route2[i-1], customer_to_move] +\n                    distance_matrix[customer_to_move, route2[i]] -\n                    distance_matrix[route2[i-1], route2[i]])\n            if cost < best_insert_cost:\n                best_insert_cost = cost\n                best_insert_pos = i\n\n        if best_insert_pos != -1:\n            # Perform the move\n            new_route2 = np.insert(route2, best_insert_pos, customer_to_move)\n            new_route1 = np.delete(route1, np.where(route1 == customer_to_move)[0][0])\n\n            # Ensure routes are valid (non-empty except depot)\n            if len(new_route1) > 2 or len(new_route2) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan (descending) to prioritize long routes for splitting\n        archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n        # If multiple have same makespan, pick the one with lowest distance\n        if archive_sorted[0][1][1] == archive_sorted[1][1][1]:\n            archive_sorted = sorted(archive, key=lambda x: x[1][0])\n        base_solution = archive_sorted[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route splitting, reallocation, and merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route splitting - split long routes into two\n        if len(route) > 5:  # Arbitrary threshold for \"long\" routes\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n        # Step 2: Customer reallocation - move customers between routes\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j]\n            # Try moving each customer from route i to route j\n            for k in range(1, len(route)-1):\n                customer = route[k]\n                # Check if adding this customer to other_route would exceed capacity\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion position in other_route\n                    best_pos = 1\n                    best_dist = float('inf')\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion cost\n                        prev_node = other_route[pos-1]\n                        next_node = other_route[pos]\n                        dist_diff = (distance_matrix[prev_node][customer] +\n                                    distance_matrix[customer][next_node] -\n                                    distance_matrix[prev_node][next_node])\n                        if dist_diff < best_dist:\n                            best_dist = dist_diff\n                            best_pos = pos\n\n                    # Perform the move\n                    new_other_route = np.concatenate((\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ))\n                    new_solution[j] = new_other_route\n                    new_solution[i] = np.concatenate((\n                        route[:k],\n                        route[k+1:]\n                    ))\n                    # Early exit after first successful move\n                    break\n\n    # Step 3: Route merging - merge short routes if beneficial\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)-1):\n            route1 = new_solution[i]\n            route2 = new_solution[i+1]\n            # Check if merging would exceed capacity\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Calculate potential distance reduction\n                dist_before = (distance_matrix[route1[-2]][0] +\n                              distance_matrix[0][route2[1]] +\n                              distance_matrix[route2[-2]][0])\n                dist_after = distance_matrix[route1[-2]][route2[1]]\n                if dist_after < dist_before:\n                    # Merge routes\n                    merged_route = np.concatenate((\n                        route1[:-1],\n                        route2[1:]\n                    ))\n                    new_solution[i] = merged_route\n                    new_solution.pop(i+1)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7480829156130322,
            0.7246957421302795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan (descending) to prioritize long routes for splitting\n        archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n        # If multiple have same makespan, pick the one with lowest distance\n        if archive_sorted[0][1][1] == archive_sorted[1][1][1]:\n            archive_sorted = sorted(archive, key=lambda x: x[1][0])\n        base_solution = archive_sorted[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route splitting, reallocation, and merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route splitting - split long routes into two\n        if len(route) > 5:  # Arbitrary threshold for \"long\" routes\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n        # Step 2: Customer reallocation - move customers between routes\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j]\n            # Try moving each customer from route i to route j\n            for k in range(1, len(route)-1):\n                customer = route[k]\n                # Check if adding this customer to other_route would exceed capacity\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion position in other_route\n                    best_pos = 1\n                    best_dist = float('inf')\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion cost\n                        prev_node = other_route[pos-1]\n                        next_node = other_route[pos]\n                        dist_diff = (distance_matrix[prev_node][customer] +\n                                    distance_matrix[customer][next_node] -\n                                    distance_matrix[prev_node][next_node])\n                        if dist_diff < best_dist:\n                            best_dist = dist_diff\n                            best_pos = pos\n\n                    # Perform the move\n                    new_other_route = np.concatenate((\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ))\n                    new_solution[j] = new_other_route\n                    new_solution[i] = np.concatenate((\n                        route[:k],\n                        route[k+1:]\n                    ))\n                    # Early exit after first successful move\n                    break\n\n    # Step 3: Route merging - merge short routes if beneficial\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)-1):\n            route1 = new_solution[i]\n            route2 = new_solution[i+1]\n            # Check if merging would exceed capacity\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Calculate potential distance reduction\n                dist_before = (distance_matrix[route1[-2]][0] +\n                              distance_matrix[0][route2[1]] +\n                              distance_matrix[route2[-2]][0])\n                dist_after = distance_matrix[route1[-2]][route2[1]]\n                if dist_after < dist_before:\n                    # Merge routes\n                    merged_route = np.concatenate((\n                        route1[:-1],\n                        route2[1:]\n                    ))\n                    new_solution[i] = merged_route\n                    new_solution.pop(i+1)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0])\n    solution = selected[0].copy()\n    new_solution = solution.copy()\n\n    # Hybrid local search: route segment swapping + demand-aware reinsertion\n    for i in range(len(new_solution)):\n        route_i = new_solution[i]\n        if len(route_i) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment from route_i\n        start = np.random.randint(1, len(route_i)-2)\n        end = np.random.randint(start+1, len(route_i)-1)\n        segment = route_i[start:end+1]\n\n        # Calculate total demand of the segment\n        segment_demand = np.sum(demand[segment])\n\n        # Find another route that can accommodate the segment's demand\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route_j = new_solution[j]\n\n            # Check if route_j can fit the segment's demand\n            if np.sum(demand[route_j]) + segment_demand <= capacity:\n                # Insert the segment into route_j at a random feasible position\n                insert_pos = np.random.randint(1, len(route_j))\n                new_route_j = np.concatenate([route_j[:insert_pos], segment, route_j[insert_pos:]])\n\n                # Check if the insertion is feasible (no duplicate customers)\n                if len(np.unique(new_route_j)) == len(new_route_j) - 1:  # -1 for depot\n                    new_solution[j] = new_route_j\n\n                    # Remove the segment from route_i\n                    new_route_i = np.concatenate([route_i[:start], route_i[end+1:]])\n                    new_solution[i] = new_route_i\n\n                    # Ensure the new routes are valid (start/end with depot)\n                    if new_route_i[0] == 0 and new_route_i[-1] == 0 and new_route_j[0] == 0 and new_route_j[-1] == 0:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6678260330348736,
            2.6810489296913147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0])\n    solution = selected[0].copy()\n    new_solution = solution.copy()\n\n    # Hybrid local search: route segment swapping + demand-aware reinsertion\n    for i in range(len(new_solution)):\n        route_i = new_solution[i]\n        if len(route_i) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment from route_i\n        start = np.random.randint(1, len(route_i)-2)\n        end = np.random.randint(start+1, len(route_i)-1)\n        segment = route_i[start:end+1]\n\n        # Calculate total demand of the segment\n        segment_demand = np.sum(demand[segment])\n\n        # Find another route that can accommodate the segment's demand\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route_j = new_solution[j]\n\n            # Check if route_j can fit the segment's demand\n            if np.sum(demand[route_j]) + segment_demand <= capacity:\n                # Insert the segment into route_j at a random feasible position\n                insert_pos = np.random.randint(1, len(route_j))\n                new_route_j = np.concatenate([route_j[:insert_pos], segment, route_j[insert_pos:]])\n\n                # Check if the insertion is feasible (no duplicate customers)\n                if len(np.unique(new_route_j)) == len(new_route_j) - 1:  # -1 for depot\n                    new_solution[j] = new_route_j\n\n                    # Remove the segment from route_i\n                    new_route_i = np.concatenate([route_i[:start], route_i[end+1:]])\n                    new_solution[i] = new_route_i\n\n                    # Ensure the new routes are valid (start/end with depot)\n                    if new_route_i[0] == 0 and new_route_i[-1] == 0 and new_route_j[0] == 0 and new_route_j[-1] == 0:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route merging and intra-route relocations\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Intra-route relocation: Move a random customer to a better position\n        modified_route = route.copy()\n        candidate_pos = np.random.choice(range(1, len(route)-1))\n        candidate_node = modified_route[candidate_pos]\n\n        # Find the best insertion position (minimizing distance increase)\n        best_pos = 1\n        min_increase = float('inf')\n        for i in range(1, len(route)-1):\n            if i == candidate_pos or i == candidate_pos + 1:\n                continue\n            # Calculate distance increase if inserted at position i\n            increase = (distance_matrix[modified_route[i-1]][candidate_node] +\n                        distance_matrix[candidate_node][modified_route[i]] -\n                        distance_matrix[modified_route[i-1]][modified_route[i]])\n            if increase < min_increase:\n                min_increase = increase\n                best_pos = i\n\n        # Apply the relocation if feasible\n        if best_pos != candidate_pos:\n            modified_route = np.delete(modified_route, candidate_pos)\n            modified_route = np.insert(modified_route, best_pos, candidate_node)\n\n        new_solution.append(modified_route)\n\n    # Randomly select two routes and attempt to merge them if feasible\n    if len(new_solution) >= 2:\n        idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[idx1]\n        route2 = new_solution[idx2]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Try to find a good merge point by minimizing the distance increase\n            best_increase = float('inf')\n            best_merge = None\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Calculate distance increase for merging at these points\n                    increase = (distance_matrix[route1[i-1]][route2[j]] +\n                               distance_matrix[route2[j]][route1[i]] -\n                               distance_matrix[route1[i-1]][route1[i]]) + \\\n                              (distance_matrix[route2[j-1]][route1[i]] +\n                               distance_matrix[route1[i]][route2[j]] -\n                               distance_matrix[route2[j-1]][route2[j]])\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_merge = (i, j)\n\n            if best_merge is not None:\n                i, j = best_merge\n                # Merge the routes at the best points\n                merged_route = np.concatenate([\n                    route1[:i], route2[j:], route2[:j], route1[i:]\n                ])\n                # Remove duplicates (except depot)\n                unique_nodes = np.unique(merged_route)\n                merged_route = np.concatenate([[0], unique_nodes[1:-1], [0]])\n                # Replace the two routes with the merged one\n                new_solution.pop(max(idx1, idx2))\n                new_solution.pop(min(idx1, idx2))\n                new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.587183201933583,
            3.653209924697876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route merging and intra-route relocations\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Intra-route relocation: Move a random customer to a better position\n        modified_route = route.copy()\n        candidate_pos = np.random.choice(range(1, len(route)-1))\n        candidate_node = modified_route[candidate_pos]\n\n        # Find the best insertion position (minimizing distance increase)\n        best_pos = 1\n        min_increase = float('inf')\n        for i in range(1, len(route)-1):\n            if i == candidate_pos or i == candidate_pos + 1:\n                continue\n            # Calculate distance increase if inserted at position i\n            increase = (distance_matrix[modified_route[i-1]][candidate_node] +\n                        distance_matrix[candidate_node][modified_route[i]] -\n                        distance_matrix[modified_route[i-1]][modified_route[i]])\n            if increase < min_increase:\n                min_increase = increase\n                best_pos = i\n\n        # Apply the relocation if feasible\n        if best_pos != candidate_pos:\n            modified_route = np.delete(modified_route, candidate_pos)\n            modified_route = np.insert(modified_route, best_pos, candidate_node)\n\n        new_solution.append(modified_route)\n\n    # Randomly select two routes and attempt to merge them if feasible\n    if len(new_solution) >= 2:\n        idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[idx1]\n        route2 = new_solution[idx2]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Try to find a good merge point by minimizing the distance increase\n            best_increase = float('inf')\n            best_merge = None\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Calculate distance increase for merging at these points\n                    increase = (distance_matrix[route1[i-1]][route2[j]] +\n                               distance_matrix[route2[j]][route1[i]] -\n                               distance_matrix[route1[i-1]][route1[i]]) + \\\n                              (distance_matrix[route2[j-1]][route1[i]] +\n                               distance_matrix[route1[i]][route2[j]] -\n                               distance_matrix[route2[j-1]][route2[j]])\n                    if increase < best_increase:\n                        best_increase = increase\n                        best_merge = (i, j)\n\n            if best_merge is not None:\n                i, j = best_merge\n                # Merge the routes at the best points\n                merged_route = np.concatenate([\n                    route1[:i], route2[j:], route2[:j], route1[i:]\n                ])\n                # Remove duplicates (except depot)\n                unique_nodes = np.unique(merged_route)\n                merged_route = np.concatenate([[0], unique_nodes[1:-1], [0]])\n                # Replace the two routes with the merged one\n                new_solution.pop(max(idx1, idx2))\n                new_solution.pop(min(idx1, idx2))\n                new_solution.append(merged_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with lower makespan or total distance, then applies a hybrid local search combining route merging and capacity-aware node swaps to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route merging + capacity-aware node swaps\n    if len(new_solution) > 1:\n        # Try merging two routes if feasible\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}] + [merged_route]\n\n    # Perform capacity-aware node swaps within routes\n    for route in new_solution:\n        if len(route) > 3:  # Ensure there are nodes to swap\n            a, b = random.sample(range(1, len(route)-1), 2)\n            node_a = route[a]\n            node_b = route[b]\n\n            # Check if swap is feasible\n            if sum(demand[route[1:a]]) - demand[node_a] + demand[node_b] <= capacity and \\\n               sum(demand[route[a+1:b]]) <= capacity and \\\n               sum(demand[route[b+1:-1]]) - demand[node_b] + demand[node_a] <= capacity:\n                route[a], route[b] = route[b], route[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5328367798326825,
            1.1095350682735443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route merging + capacity-aware node swaps\n    if len(new_solution) > 1:\n        # Try merging two routes if feasible\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}] + [merged_route]\n\n    # Perform capacity-aware node swaps within routes\n    for route in new_solution:\n        if len(route) > 3:  # Ensure there are nodes to swap\n            a, b = random.sample(range(1, len(route)-1), 2)\n            node_a = route[a]\n            node_b = route[b]\n\n            # Check if swap is feasible\n            if sum(demand[route[1:a]]) - demand[node_a] + demand[node_b] <= capacity and \\\n               sum(demand[route[a+1:b]]) <= capacity and \\\n               sum(demand[route[b+1:-1]]) - demand[node_b] + demand[node_a] <= capacity:\n                route[a], route[b] = route[b], route[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: 3-opt with route balancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Randomly select three non-depot nodes to apply 3-opt\n        nodes = route[1:-1]\n        if len(nodes) < 3:\n            continue\n\n        a, b, c = sorted(np.random.choice(nodes, 3, replace=False))\n\n        # Find positions in the route\n        pos_a = np.where(route == a)[0][0]\n        pos_b = np.where(route == b)[0][0]\n        pos_c = np.where(route == c)[0][0]\n\n        # Generate all possible 3-opt neighbors\n        variants = []\n        variants.append(route.copy())\n        variants.append(np.concatenate([route[:pos_a], route[pos_b:pos_c+1][::-1], route[pos_a+1:pos_b], route[pos_c+1:]]))\n        variants.append(np.concatenate([route[:pos_b], route[pos_a:pos_c+1][::-1], route[pos_b+1:pos_a], route[pos_c+1:]]))\n        variants.append(np.concatenate([route[:pos_a], route[pos_c:pos_b-1:-1], route[pos_a+1:pos_c], route[pos_b+1:]]))\n\n        # Check feasibility and select the best variant\n        best_variant = route\n        best_cost = float('inf')\n        for variant in variants:\n            if np.sum(demand[variant[1:-1]]) <= capacity:\n                cost = np.sum(distance_matrix[variant[:-1], variant[1:]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_variant = variant\n\n        new_solution[i] = best_variant\n\n    # Apply route balancing: redistribute nodes between routes to balance makespan\n    all_nodes = []\n    for route in new_solution:\n        all_nodes.extend(route[1:-1])\n\n    # Sort nodes by demand (descending) to prioritize high-demand nodes\n    sorted_nodes = sorted(all_nodes, key=lambda x: -demand[x])\n\n    # Reconstruct routes with balanced load\n    routes = []\n    current_route = [0]\n    current_load = 0\n\n    for node in sorted_nodes:\n        if current_load + demand[node] <= capacity:\n            current_route.append(node)\n            current_load += demand[node]\n        else:\n            current_route.append(0)\n            routes.append(np.array(current_route))\n            current_route = [0, node]\n            current_load = demand[node]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        routes.append(np.array(current_route))\n\n    # Ensure all nodes are included\n    remaining_nodes = [node for node in all_nodes if node not in [n for route in routes for n in route[1:-1]]]\n    if remaining_nodes:\n        for node in remaining_nodes:\n            # Find the route with the least increase in distance\n            best_route_idx = -1\n            best_increase = float('inf')\n            for i, route in enumerate(routes):\n                # Insert node at the best position\n                for pos in range(1, len(route)):\n                    new_route = np.concatenate([route[:pos], [node], route[pos:]])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        increase = distance_matrix[route[pos-1], node] + distance_matrix[node, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if increase < best_increase:\n                            best_increase = increase\n                            best_route_idx = i\n                            best_pos = pos\n            if best_route_idx != -1:\n                routes[best_route_idx] = np.concatenate([routes[best_route_idx][:best_pos], [node], routes[best_route_idx][best_pos:]])\n\n    new_solution = routes\n\n    return new_solution\n\n",
        "score": [
            -0.7357791066828714,
            9.425897002220154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: 3-opt with route balancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Randomly select three non-depot nodes to apply 3-opt\n        nodes = route[1:-1]\n        if len(nodes) < 3:\n            continue\n\n        a, b, c = sorted(np.random.choice(nodes, 3, replace=False))\n\n        # Find positions in the route\n        pos_a = np.where(route == a)[0][0]\n        pos_b = np.where(route == b)[0][0]\n        pos_c = np.where(route == c)[0][0]\n\n        # Generate all possible 3-opt neighbors\n        variants = []\n        variants.append(route.copy())\n        variants.append(np.concatenate([route[:pos_a], route[pos_b:pos_c+1][::-1], route[pos_a+1:pos_b], route[pos_c+1:]]))\n        variants.append(np.concatenate([route[:pos_b], route[pos_a:pos_c+1][::-1], route[pos_b+1:pos_a], route[pos_c+1:]]))\n        variants.append(np.concatenate([route[:pos_a], route[pos_c:pos_b-1:-1], route[pos_a+1:pos_c], route[pos_b+1:]]))\n\n        # Check feasibility and select the best variant\n        best_variant = route\n        best_cost = float('inf')\n        for variant in variants:\n            if np.sum(demand[variant[1:-1]]) <= capacity:\n                cost = np.sum(distance_matrix[variant[:-1], variant[1:]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_variant = variant\n\n        new_solution[i] = best_variant\n\n    # Apply route balancing: redistribute nodes between routes to balance makespan\n    all_nodes = []\n    for route in new_solution:\n        all_nodes.extend(route[1:-1])\n\n    # Sort nodes by demand (descending) to prioritize high-demand nodes\n    sorted_nodes = sorted(all_nodes, key=lambda x: -demand[x])\n\n    # Reconstruct routes with balanced load\n    routes = []\n    current_route = [0]\n    current_load = 0\n\n    for node in sorted_nodes:\n        if current_load + demand[node] <= capacity:\n            current_route.append(node)\n            current_load += demand[node]\n        else:\n            current_route.append(0)\n            routes.append(np.array(current_route))\n            current_route = [0, node]\n            current_load = demand[node]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        routes.append(np.array(current_route))\n\n    # Ensure all nodes are included\n    remaining_nodes = [node for node in all_nodes if node not in [n for route in routes for n in route[1:-1]]]\n    if remaining_nodes:\n        for node in remaining_nodes:\n            # Find the route with the least increase in distance\n            best_route_idx = -1\n            best_increase = float('inf')\n            for i, route in enumerate(routes):\n                # Insert node at the best position\n                for pos in range(1, len(route)):\n                    new_route = np.concatenate([route[:pos], [node], route[pos:]])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        increase = distance_matrix[route[pos-1], node] + distance_matrix[node, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if increase < best_increase:\n                            best_increase = increase\n                            best_route_idx = i\n                            best_pos = pos\n            if best_route_idx != -1:\n                routes[best_route_idx] = np.concatenate([routes[best_route_idx][:best_pos], [node], routes[best_route_idx][best_pos:]])\n\n    new_solution = routes\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Remove the selected route from the solution\n    new_solution = [route for i, route in enumerate(base_solution) if i != route_idx]\n\n    # Perform a hybrid local search: combine 2-opt with route splitting\n    # First, apply 2-opt to the selected route\n    improved_route = selected_route.copy()\n    for i in range(1, len(improved_route) - 2):\n        for j in range(i + 1, len(improved_route) - 1):\n            # Reverse the segment between i and j\n            new_route = improved_route.copy()\n            new_route[i:j+1] = new_route[j:i-1:-1]\n\n            # Check feasibility (capacity and depot constraints)\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                # Calculate the new distance for the route\n                new_distance = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n                old_distance = sum(distance_matrix[improved_route[k]][improved_route[k+1]] for k in range(len(improved_route)-1))\n\n                # Accept if better\n                if new_distance < old_distance:\n                    improved_route = new_route\n\n    # Split the improved route into two if beneficial\n    split_pos = len(improved_route) // 2\n    route1 = improved_route[:split_pos+1] + [0]\n    route2 = [0] + improved_route[split_pos+1:]\n\n    # Check feasibility of both new routes\n    if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n        new_solution.extend([route1, route2])\n    else:\n        new_solution.append(improved_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7715138979282894,
            4.827434778213501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Remove the selected route from the solution\n    new_solution = [route for i, route in enumerate(base_solution) if i != route_idx]\n\n    # Perform a hybrid local search: combine 2-opt with route splitting\n    # First, apply 2-opt to the selected route\n    improved_route = selected_route.copy()\n    for i in range(1, len(improved_route) - 2):\n        for j in range(i + 1, len(improved_route) - 1):\n            # Reverse the segment between i and j\n            new_route = improved_route.copy()\n            new_route[i:j+1] = new_route[j:i-1:-1]\n\n            # Check feasibility (capacity and depot constraints)\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                # Calculate the new distance for the route\n                new_distance = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n                old_distance = sum(distance_matrix[improved_route[k]][improved_route[k+1]] for k in range(len(improved_route)-1))\n\n                # Accept if better\n                if new_distance < old_distance:\n                    improved_route = new_route\n\n    # Split the improved route into two if beneficial\n    split_pos = len(improved_route) // 2\n    route1 = improved_route[:split_pos+1] + [0]\n    route2 = [0] + improved_route[split_pos+1:]\n\n    # Check feasibility of both new routes\n    if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n        new_solution.extend([route1, route2])\n    else:\n        new_solution.append(improved_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted random selection favoring solutions with lower total distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion with demand-aware positioning, and inter-route swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search\n    if random.random() < 0.5:  # Route splitting with demand-aware reinsertion\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n    else:  # Inter-route customer swap with demand check\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                cust1_pos = random.randint(1, len(route1) - 2)\n                cust2_pos = random.randint(1, len(route2) - 2)\n                cust1 = route1[cust1_pos]\n                cust2 = route2[cust2_pos]\n\n                # Check capacity constraints after swap\n                demand1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n                demand2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n                if demand1 <= capacity and demand2 <= capacity:\n                    route1[cust1_pos], route2[cust2_pos] = route2[cust2_pos], route1[cust1_pos]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5913965965077701,
            0.7216036915779114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search\n    if random.random() < 0.5:  # Route splitting with demand-aware reinsertion\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n    else:  # Inter-route customer swap with demand check\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                cust1_pos = random.randint(1, len(route1) - 2)\n                cust2_pos = random.randint(1, len(route2) - 2)\n                cust1 = route1[cust1_pos]\n                cust2 = route2[cust2_pos]\n\n                # Check capacity constraints after swap\n                demand1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n                demand2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n                if demand1 <= capacity and demand2 <= capacity:\n                    route1[cust1_pos], route2[cust2_pos] = route2[cust2_pos], route1[cust1_pos]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted combination of normalized objectives, then applies a hybrid local search combining route splitting, demand-based reinsertion, and adaptive 2-opt with capacity-aware perturbations to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives and select based on weighted combination\n        distances = np.array([obj[0] for _, obj in archive])\n        makespans = np.array([obj[1] for _, obj in archive])\n        norm_distances = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-8)\n        norm_makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n        scores = 0.6 * norm_distances + 0.4 * norm_makespans  # Weighted combination\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid operator: Route splitting + demand-based reinsertion + adaptive 2-opt\n    if len(new_solution) > 1:\n        # Route splitting: Split a long route into two\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Ensure we can split meaningfully\n            split_pos = len(longest_route) // 2\n            new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n            new_route2 = np.array([0] + longest_route[split_pos:-1].tolist() + [0])\n\n            # Check capacity constraints\n            def is_feasible(route):\n                return sum(demand[node] for node in route[1:-1]) <= capacity\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution = [r for i, r in enumerate(new_solution) if i != longest_route_idx]\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n\n    # Demand-based reinsertion: Move a high-demand node from a route to another\n    if len(new_solution) > 1:\n        # Find route with highest average demand\n        avg_demands = [sum(demand[route[1:-1]]) / (len(route) - 2) if len(route) > 2 else 0 for route in new_solution]\n        high_demand_route_idx = np.argmax(avg_demands)\n        high_demand_route = new_solution[high_demand_route_idx]\n\n        if len(high_demand_route) > 3:  # Ensure we can remove a node\n            # Find node with highest demand in this route\n            candidate_nodes = high_demand_route[1:-1]\n            node_demands = [demand[node] for node in candidate_nodes]\n            node_to_move = candidate_nodes[np.argmax(node_demands)]\n\n            # Try to insert into another route\n            for i, route in enumerate(new_solution):\n                if i != high_demand_route_idx:\n                    # Find best insertion position\n                    best_pos = None\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        # Try inserting at position pos\n                        new_route = np.concatenate([route[:pos], [node_to_move], route[pos:]])\n                        if is_feasible(new_route):\n                            cost = sum(distance_matrix[new_route[j], new_route[j+1]] for j in range(len(new_route)-1))\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                    if best_pos is not None:\n                        # Perform the insertion\n                        new_route = np.concatenate([route[:best_pos], [node_to_move], route[best_pos:]])\n                        new_solution[i] = new_route\n                        # Remove from original route\n                        new_solution[high_demand_route_idx] = np.delete(high_demand_route, np.where(high_demand_route == node_to_move)[0][0])\n                        break\n\n    # Adaptive 2-opt with capacity-aware perturbations\n    for route in new_solution:\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Randomly select two edges to swap\n            i, j = sorted(random.sample(range(1, len(route)-2), 2))\n            # Create new route by reversing the segment between i and j\n            new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            if is_feasible(new_route):\n                # Check if the swap improves the route length\n                old_length = sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                new_length = sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1))\n                if new_length < old_length:\n                    route[:] = new_route\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5502867993501532,
            8.93741363286972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives and select based on weighted combination\n        distances = np.array([obj[0] for _, obj in archive])\n        makespans = np.array([obj[1] for _, obj in archive])\n        norm_distances = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-8)\n        norm_makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n        scores = 0.6 * norm_distances + 0.4 * norm_makespans  # Weighted combination\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid operator: Route splitting + demand-based reinsertion + adaptive 2-opt\n    if len(new_solution) > 1:\n        # Route splitting: Split a long route into two\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Ensure we can split meaningfully\n            split_pos = len(longest_route) // 2\n            new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n            new_route2 = np.array([0] + longest_route[split_pos:-1].tolist() + [0])\n\n            # Check capacity constraints\n            def is_feasible(route):\n                return sum(demand[node] for node in route[1:-1]) <= capacity\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution = [r for i, r in enumerate(new_solution) if i != longest_route_idx]\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n\n    # Demand-based reinsertion: Move a high-demand node from a route to another\n    if len(new_solution) > 1:\n        # Find route with highest average demand\n        avg_demands = [sum(demand[route[1:-1]]) / (len(route) - 2) if len(route) > 2 else 0 for route in new_solution]\n        high_demand_route_idx = np.argmax(avg_demands)\n        high_demand_route = new_solution[high_demand_route_idx]\n\n        if len(high_demand_route) > 3:  # Ensure we can remove a node\n            # Find node with highest demand in this route\n            candidate_nodes = high_demand_route[1:-1]\n            node_demands = [demand[node] for node in candidate_nodes]\n            node_to_move = candidate_nodes[np.argmax(node_demands)]\n\n            # Try to insert into another route\n            for i, route in enumerate(new_solution):\n                if i != high_demand_route_idx:\n                    # Find best insertion position\n                    best_pos = None\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        # Try inserting at position pos\n                        new_route = np.concatenate([route[:pos], [node_to_move], route[pos:]])\n                        if is_feasible(new_route):\n                            cost = sum(distance_matrix[new_route[j], new_route[j+1]] for j in range(len(new_route)-1))\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                    if best_pos is not None:\n                        # Perform the insertion\n                        new_route = np.concatenate([route[:best_pos], [node_to_move], route[best_pos:]])\n                        new_solution[i] = new_route\n                        # Remove from original route\n                        new_solution[high_demand_route_idx] = np.delete(high_demand_route, np.where(high_demand_route == node_to_move)[0][0])\n                        break\n\n    # Adaptive 2-opt with capacity-aware perturbations\n    for route in new_solution:\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Randomly select two edges to swap\n            i, j = sorted(random.sample(range(1, len(route)-2), 2))\n            # Create new route by reversing the segment between i and j\n            new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            if is_feasible(new_route):\n                # Check if the swap improves the route length\n                old_length = sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                new_length = sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1))\n                if new_length < old_length:\n                    route[:] = new_route\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Find the longest route in the selected solution\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Apply a hybrid local search: split the longest route into two and re-insert customers\n    if len(longest_route) > 3:  # Ensure route can be split\n        split_point = len(longest_route) // 2\n        first_part = longest_route[:split_point + 1]\n        second_part = longest_route[split_point:]\n\n        # Re-insert customers from the second part into other routes or create a new route\n        customers_to_reinsert = second_part[1:-1]\n\n        # Try to insert into existing routes first\n        inserted = False\n        for i, route in enumerate(selected_solution):\n            if i == longest_route_idx:\n                continue\n            current_load = sum(demand[route[1:-1]])\n            for customer in customers_to_reinsert:\n                if current_load + demand[customer] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(route)):\n                        increase = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    route = np.insert(route, best_pos, customer)\n                    selected_solution[i] = route\n                    inserted = True\n                    break\n\n        # If not all customers were inserted, create a new route\n        if not inserted:\n            new_route = np.array([0] + list(customers_to_reinsert) + [0])\n            selected_solution.append(new_route)\n\n        # Update the longest route\n        selected_solution[longest_route_idx] = first_part\n\n    return selected_solution\n\n",
        "score": [
            -0.7612129617663672,
            1.5949883162975311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Find the longest route in the selected solution\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Apply a hybrid local search: split the longest route into two and re-insert customers\n    if len(longest_route) > 3:  # Ensure route can be split\n        split_point = len(longest_route) // 2\n        first_part = longest_route[:split_point + 1]\n        second_part = longest_route[split_point:]\n\n        # Re-insert customers from the second part into other routes or create a new route\n        customers_to_reinsert = second_part[1:-1]\n\n        # Try to insert into existing routes first\n        inserted = False\n        for i, route in enumerate(selected_solution):\n            if i == longest_route_idx:\n                continue\n            current_load = sum(demand[route[1:-1]])\n            for customer in customers_to_reinsert:\n                if current_load + demand[customer] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(route)):\n                        increase = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    route = np.insert(route, best_pos, customer)\n                    selected_solution[i] = route\n                    inserted = True\n                    break\n\n        # If not all customers were inserted, create a new route\n        if not inserted:\n            new_route = np.array([0] + list(customers_to_reinsert) + [0])\n            selected_solution.append(new_route)\n\n        # Update the longest route\n        selected_solution[longest_route_idx] = first_part\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)  # Start with random selection for diversity\n\n    # Step 2: Hybrid Local Search: Route Splitting with Customer Reallocation\n    # This operator splits a long route into two and reallocates customers to balance the makespan\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # If route is too small, skip\n        return selected_solution\n\n    # Split the longest route into two by finding the best split point\n    split_point = len(longest_route) // 2\n    new_route1 = longest_route[:split_point + 1]\n    new_route2 = longest_route[split_point:]\n\n    # Reallocate customers between the two new routes to balance demand and distance\n    # This is a simplified approach; a more sophisticated method could be used\n    temp_routes = [new_route1, new_route2]\n\n    # Check capacity feasibility for the new routes\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if not is_feasible(new_route1) or not is_feasible(new_route2):\n        return selected_solution  # If split is infeasible, return original\n\n    # Replace the original route with the two new routes\n    new_solution = selected_solution[:longest_route_idx] + temp_routes + selected_solution[longest_route_idx + 1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8049883715267501,
            0.36577633023262024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)  # Start with random selection for diversity\n\n    # Step 2: Hybrid Local Search: Route Splitting with Customer Reallocation\n    # This operator splits a long route into two and reallocates customers to balance the makespan\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # If route is too small, skip\n        return selected_solution\n\n    # Split the longest route into two by finding the best split point\n    split_point = len(longest_route) // 2\n    new_route1 = longest_route[:split_point + 1]\n    new_route2 = longest_route[split_point:]\n\n    # Reallocate customers between the two new routes to balance demand and distance\n    # This is a simplified approach; a more sophisticated method could be used\n    temp_routes = [new_route1, new_route2]\n\n    # Check capacity feasibility for the new routes\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if not is_feasible(new_route1) or not is_feasible(new_route2):\n        return selected_solution  # If split is infeasible, return original\n\n    # Replace the original route with the two new routes\n    new_solution = selected_solution[:longest_route_idx] + temp_routes + selected_solution[longest_route_idx + 1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and route structure, then applies a hybrid local search operator that combines route splitting, customer reinsertion with capacity checks, and route merging to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on makespan and total distance\n        weights = [1 / (obj[1] + 1e-6) for _, obj in archive]  # Higher weight for lower makespan\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    for _ in range(3):  # Repeat a few times for better exploration\n        # Step 1: Randomly select a route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Step 2: Split the route at a random point\n        if len(route) > 3:  # Ensure we have customers to split\n            split_point = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_point + 1]\n            new_route2 = route[split_point:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])  # Exclude depot\n            demand2 = np.sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Replace the original route with the two new routes\n                new_solution = new_solution[:route_idx] + [new_route1, new_route2] + new_solution[route_idx+1:]\n\n        # Step 3: Reinsert customers from one route to another with capacity checks\n        if len(new_solution) >= 2:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx].copy()\n            route2 = new_solution[route2_idx].copy()\n\n            if len(route1) > 3:  # Ensure we have customers to move\n                # Select a customer to move\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                # Remove customer from route1\n                new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n\n                # Find the best insertion point in route2\n                best_insert_pos = -1\n                best_increase = float('inf')\n                for i in range(1, len(route2)):\n                    # Insert customer between route2[i-1] and route2[i]\n                    new_demand = np.sum(demand[route2[1:i]]) + demand[customer] + np.sum(demand[route2[i:-1]])\n                    if new_demand <= capacity:\n                        # Calculate the increase in distance\n                        distance_increase = (\n                            distance_matrix[route2[i-1], customer] +\n                            distance_matrix[customer, route2[i]] -\n                            distance_matrix[route2[i-1], route2[i]]\n                        )\n                        if distance_increase < best_increase:\n                            best_increase = distance_increase\n                            best_insert_pos = i\n\n                if best_insert_pos != -1:\n                    # Insert customer into route2\n                    new_route2 = np.concatenate([\n                        route2[:best_insert_pos],\n                        np.array([customer]),\n                        route2[best_insert_pos:]\n                    ])\n                    # Update the solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # Step 4: Merge two routes if they can be combined without exceeding capacity\n        if len(new_solution) >= 2:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx].copy()\n            route2 = new_solution[route2_idx].copy()\n\n            # Check if merging is possible\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge the routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                # Replace the two routes with the merged one\n                new_solution = new_solution[:min(route1_idx, route2_idx)] + \\\n                              [merged_route] + \\\n                              new_solution[max(route1_idx, route2_idx)+1:]\n\n    return new_solution\n\n",
        "score": [
            -0.7025116354792706,
            1.8098099827766418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on makespan and total distance\n        weights = [1 / (obj[1] + 1e-6) for _, obj in archive]  # Higher weight for lower makespan\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    for _ in range(3):  # Repeat a few times for better exploration\n        # Step 1: Randomly select a route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Step 2: Split the route at a random point\n        if len(route) > 3:  # Ensure we have customers to split\n            split_point = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_point + 1]\n            new_route2 = route[split_point:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])  # Exclude depot\n            demand2 = np.sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Replace the original route with the two new routes\n                new_solution = new_solution[:route_idx] + [new_route1, new_route2] + new_solution[route_idx+1:]\n\n        # Step 3: Reinsert customers from one route to another with capacity checks\n        if len(new_solution) >= 2:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx].copy()\n            route2 = new_solution[route2_idx].copy()\n\n            if len(route1) > 3:  # Ensure we have customers to move\n                # Select a customer to move\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                # Remove customer from route1\n                new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n\n                # Find the best insertion point in route2\n                best_insert_pos = -1\n                best_increase = float('inf')\n                for i in range(1, len(route2)):\n                    # Insert customer between route2[i-1] and route2[i]\n                    new_demand = np.sum(demand[route2[1:i]]) + demand[customer] + np.sum(demand[route2[i:-1]])\n                    if new_demand <= capacity:\n                        # Calculate the increase in distance\n                        distance_increase = (\n                            distance_matrix[route2[i-1], customer] +\n                            distance_matrix[customer, route2[i]] -\n                            distance_matrix[route2[i-1], route2[i]]\n                        )\n                        if distance_increase < best_increase:\n                            best_increase = distance_increase\n                            best_insert_pos = i\n\n                if best_insert_pos != -1:\n                    # Insert customer into route2\n                    new_route2 = np.concatenate([\n                        route2[:best_insert_pos],\n                        np.array([customer]),\n                        route2[best_insert_pos:]\n                    ])\n                    # Update the solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # Step 4: Merge two routes if they can be combined without exceeding capacity\n        if len(new_solution) >= 2:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx].copy()\n            route2 = new_solution[route2_idx].copy()\n\n            # Check if merging is possible\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge the routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                # Replace the two routes with the merged one\n                new_solution = new_solution[:min(route1_idx, route2_idx)] + \\\n                              [merged_route] + \\\n                              new_solution[max(route1_idx, route2_idx)+1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{A novel hybrid local search operator combines a randomized route segment relocation with a capacity-aware edge swap to intelligently balance distance and makespan minimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights based on inverse makespan (prioritize solutions with shorter makespan)\n    makespans = np.array([obj[1] for _, obj in archive])\n    weights = 1.0 / (makespans + 1e-6)  # Avoid division by zero\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Hybrid local search operator\n    # Randomly select a route to modify\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_idx1 = random.randint(0, len(new_solution) - 1)\n    route1 = new_solution[route_idx1]\n\n    # Option 1: Relocate a random segment from route1 to another route\n    if len(route1) > 3:  # Ensure we can relocate a segment\n        # Select a random segment to relocate\n        start = random.randint(1, len(route1) - 3)\n        end = random.randint(start + 1, len(route1) - 2)\n        segment = route1[start:end]\n\n        # Calculate total demand of the segment\n        segment_demand = np.sum(demand[segment])\n\n        # Find a target route that can accommodate the segment\n        possible_targets = []\n        for i, route in enumerate(new_solution):\n            if i != route_idx1:\n                route_demand = np.sum(demand[route[1:-1]])\n                if route_demand + segment_demand <= capacity:\n                    possible_targets.append(i)\n\n        if possible_targets:\n            target_idx = random.choice(possible_targets)\n            target_route = new_solution[target_idx]\n\n            # Insert the segment into the target route at a random position\n            insert_pos = random.randint(1, len(target_route) - 1)\n            new_target_route = np.concatenate([target_route[:insert_pos], segment, target_route[insert_pos:]])\n\n            # Remove the segment from the original route\n            new_route1 = np.concatenate([route1[:start], route1[end:]])\n\n            # Update the solution\n            new_solution[route_idx1] = new_route1\n            new_solution[target_idx] = new_target_route\n\n            # Check feasibility (should be guaranteed by demand check)\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_target_route[1:-1]]) <= capacity):\n                return new_solution\n\n    # Option 2: Edge swap between two routes (if Option 1 didn't work)\n    route_idx2 = random.randint(0, len(new_solution) - 1)\n    while route_idx2 == route_idx1:\n        route_idx2 = random.randint(0, len(new_solution) - 1)\n\n    route2 = new_solution[route_idx2]\n\n    if len(route1) > 2 and len(route2) > 2:\n        # Select a random edge from route1 and route2\n        edge1_pos = random.randint(1, len(route1) - 2)\n        edge2_pos = random.randint(1, len(route2) - 2)\n\n        # Get the edges\n        edge1 = (route1[edge1_pos - 1], route1[edge1_pos])\n        edge2 = (route2[edge2_pos - 1], route2[edge2_pos])\n\n        # Calculate new demands for the routes after swap\n        # Remove edge1 from route1 and add edge2\n        new_route1_demand = np.sum(demand[route1[1:-1]]) - demand[edge1[1]] + demand[edge2[1]]\n        # Remove edge2 from route2 and add edge1\n        new_route2_demand = np.sum(demand[route2[1:-1]]) - demand[edge2[1]] + demand[edge1[1]]\n\n        # Check capacity constraints\n        if new_route1_demand <= capacity and new_route2_demand <= capacity:\n            # Perform the swap\n            new_route1 = np.concatenate([\n                route1[:edge1_pos],\n                [edge2[1]],\n                route1[edge1_pos + 1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:edge2_pos],\n                [edge1[1]],\n                route2[edge2_pos + 1:]\n            ])\n\n            # Update the solution\n            new_solution[route_idx1] = new_route1\n            new_solution[route_idx2] = new_route2\n\n            return new_solution\n\n    # If neither option worked, return the original solution\n    return base_solution\n\n",
        "score": [
            -0.5505258399623909,
            0.8038743734359741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights based on inverse makespan (prioritize solutions with shorter makespan)\n    makespans = np.array([obj[1] for _, obj in archive])\n    weights = 1.0 / (makespans + 1e-6)  # Avoid division by zero\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Hybrid local search operator\n    # Randomly select a route to modify\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_idx1 = random.randint(0, len(new_solution) - 1)\n    route1 = new_solution[route_idx1]\n\n    # Option 1: Relocate a random segment from route1 to another route\n    if len(route1) > 3:  # Ensure we can relocate a segment\n        # Select a random segment to relocate\n        start = random.randint(1, len(route1) - 3)\n        end = random.randint(start + 1, len(route1) - 2)\n        segment = route1[start:end]\n\n        # Calculate total demand of the segment\n        segment_demand = np.sum(demand[segment])\n\n        # Find a target route that can accommodate the segment\n        possible_targets = []\n        for i, route in enumerate(new_solution):\n            if i != route_idx1:\n                route_demand = np.sum(demand[route[1:-1]])\n                if route_demand + segment_demand <= capacity:\n                    possible_targets.append(i)\n\n        if possible_targets:\n            target_idx = random.choice(possible_targets)\n            target_route = new_solution[target_idx]\n\n            # Insert the segment into the target route at a random position\n            insert_pos = random.randint(1, len(target_route) - 1)\n            new_target_route = np.concatenate([target_route[:insert_pos], segment, target_route[insert_pos:]])\n\n            # Remove the segment from the original route\n            new_route1 = np.concatenate([route1[:start], route1[end:]])\n\n            # Update the solution\n            new_solution[route_idx1] = new_route1\n            new_solution[target_idx] = new_target_route\n\n            # Check feasibility (should be guaranteed by demand check)\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_target_route[1:-1]]) <= capacity):\n                return new_solution\n\n    # Option 2: Edge swap between two routes (if Option 1 didn't work)\n    route_idx2 = random.randint(0, len(new_solution) - 1)\n    while route_idx2 == route_idx1:\n        route_idx2 = random.randint(0, len(new_solution) - 1)\n\n    route2 = new_solution[route_idx2]\n\n    if len(route1) > 2 and len(route2) > 2:\n        # Select a random edge from route1 and route2\n        edge1_pos = random.randint(1, len(route1) - 2)\n        edge2_pos = random.randint(1, len(route2) - 2)\n\n        # Get the edges\n        edge1 = (route1[edge1_pos - 1], route1[edge1_pos])\n        edge2 = (route2[edge2_pos - 1], route2[edge2_pos])\n\n        # Calculate new demands for the routes after swap\n        # Remove edge1 from route1 and add edge2\n        new_route1_demand = np.sum(demand[route1[1:-1]]) - demand[edge1[1]] + demand[edge2[1]]\n        # Remove edge2 from route2 and add edge1\n        new_route2_demand = np.sum(demand[route2[1:-1]]) - demand[edge2[1]] + demand[edge1[1]]\n\n        # Check capacity constraints\n        if new_route1_demand <= capacity and new_route2_demand <= capacity:\n            # Perform the swap\n            new_route1 = np.concatenate([\n                route1[:edge1_pos],\n                [edge2[1]],\n                route1[edge1_pos + 1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:edge2_pos],\n                [edge1[1]],\n                route2[edge2_pos + 1:]\n            ])\n\n            # Update the solution\n            new_solution[route_idx1] = new_route1\n            new_solution[route_idx2] = new_route2\n\n            return new_solution\n\n    # If neither option worked, return the original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random choice favoring solutions with lower makespan and total distance, then applies a hybrid local search combining route segment swapping with capacity-aware insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap with capacity-aware insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Find a feasible segment to move from route1 to route2\n        for i in range(1, len(route1) - 1):\n            segment = route1[i:-1]  # Exclude depot\n            segment_demand = sum(demand[segment])\n            if segment_demand <= capacity:\n                # Check if insertion into route2 is feasible\n                for j in range(1, len(route2)):\n                    # Try inserting segment into route2 at position j\n                    new_route2 = np.insert(route2, j, segment)\n                    if sum(demand[new_route2[1:-1]]) <= capacity:\n                        # Update routes\n                        new_route1 = np.delete(route1, slice(i, len(route1) - 1))\n                        new_solution[route_indices[0]] = new_route1\n                        new_solution[route_indices[1]] = new_route2\n                        break\n                else:\n                    continue\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5517887584921891,
            8.965767443180084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap with capacity-aware insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Find a feasible segment to move from route1 to route2\n        for i in range(1, len(route1) - 1):\n            segment = route1[i:-1]  # Exclude depot\n            segment_demand = sum(demand[segment])\n            if segment_demand <= capacity:\n                # Check if insertion into route2 is feasible\n                for j in range(1, len(route2)):\n                    # Try inserting segment into route2 at position j\n                    new_route2 = np.insert(route2, j, segment)\n                    if sum(demand[new_route2[1:-1]]) <= capacity:\n                        # Update routes\n                        new_route1 = np.delete(route1, slice(i, len(route1) - 1))\n                        new_solution[route_indices[0]] = new_route1\n                        new_solution[route_indices[1]] = new_route2\n                        break\n                else:\n                    continue\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{A novel hybrid local search strategy combines route decomposition with cross-route insertion and capacity-aware merging, intelligently balancing distance and makespan reduction by selecting high-demand customers for targeted improvements while ensuring feasibility through dynamic capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route decomposition (split high-demand segments)\n        high_demand_indices = [i for i in range(1, len(route)-1) if demand[route[i]] > capacity/4]\n        if not high_demand_indices:\n            continue\n\n        # Step 2: Cross-route insertion of high-demand customers\n        for i in high_demand_indices:\n            customer = route[i]\n            # Find best position in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_insert_cost = float('inf')\n\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Check capacity constraint\n                if sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Evaluate all possible insertion positions\n                for pos in range(1, len(other_route)):\n                    prev_node = other_route[pos-1]\n                    next_node = other_route[pos]\n                    insert_cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                    if insert_cost < best_insert_cost:\n                        best_insert_cost = insert_cost\n                        best_route_idx = other_route_idx\n                        best_pos = pos\n\n            # Perform the insertion if beneficial\n            if best_route_idx != -1 and best_insert_cost < 0:\n                # Remove from original route\n                new_solution[route_idx] = np.delete(route, i)\n                # Insert into best position\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    # Step 3: Capacity-aware merging of small routes\n    small_routes = [i for i in range(len(new_solution)) if len(new_solution[i]) <= 4]\n    for i in small_routes:\n        if len(new_solution[i]) <= 2:  # Only depot\n            continue\n        for j in range(len(new_solution)):\n            if i == j or len(new_solution[j]) <= 2:\n                continue\n            # Check if merging is possible\n            if sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]]) <= capacity:\n                # Merge routes\n                merged_route = np.concatenate((new_solution[j][:-1], new_solution[i][1:]))\n                new_solution[j] = merged_route\n                new_solution[i] = np.array([0])  # Mark for removal\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 1]\n\n    return new_solution\n\n",
        "score": [
            -0.5922345261530588,
            10.176501482725143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route decomposition (split high-demand segments)\n        high_demand_indices = [i for i in range(1, len(route)-1) if demand[route[i]] > capacity/4]\n        if not high_demand_indices:\n            continue\n\n        # Step 2: Cross-route insertion of high-demand customers\n        for i in high_demand_indices:\n            customer = route[i]\n            # Find best position in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_insert_cost = float('inf')\n\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Check capacity constraint\n                if sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Evaluate all possible insertion positions\n                for pos in range(1, len(other_route)):\n                    prev_node = other_route[pos-1]\n                    next_node = other_route[pos]\n                    insert_cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                    if insert_cost < best_insert_cost:\n                        best_insert_cost = insert_cost\n                        best_route_idx = other_route_idx\n                        best_pos = pos\n\n            # Perform the insertion if beneficial\n            if best_route_idx != -1 and best_insert_cost < 0:\n                # Remove from original route\n                new_solution[route_idx] = np.delete(route, i)\n                # Insert into best position\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    # Step 3: Capacity-aware merging of small routes\n    small_routes = [i for i in range(len(new_solution)) if len(new_solution[i]) <= 4]\n    for i in small_routes:\n        if len(new_solution[i]) <= 2:  # Only depot\n            continue\n        for j in range(len(new_solution)):\n            if i == j or len(new_solution[j]) <= 2:\n                continue\n            # Check if merging is possible\n            if sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]]) <= capacity:\n                # Merge routes\n                merged_route = np.concatenate((new_solution[j][:-1], new_solution[i][1:]))\n                new_solution[j] = merged_route\n                new_solution[i] = np.array([0])  # Mark for removal\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer swapping, and capacity-aware insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        improved = False\n        routes = [route.copy() for route in solution]\n\n        # Step 1: Route splitting (if a route is too long, split it)\n        for i in range(len(routes)):\n            route = routes[i]\n            if len(route) > 4:  # Arbitrary threshold to avoid trivial splits\n                split_pos = len(route) // 2\n                new_route1 = np.concatenate((route[:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos:]))\n\n                # Check capacity feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    routes[i] = new_route1\n                    routes.insert(i+1, new_route2)\n                    improved = True\n                    break\n\n        if improved:\n            return routes\n\n        # Step 2: Customer swapping (swap customers between routes if beneficial)\n        for _ in range(5):  # Try multiple swaps\n            r1, r2 = random.sample(range(len(routes)), 2)\n            route1, route2 = routes[r1], routes[r2]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Select random customers from each route (excluding depot)\n            c1 = random.randint(1, len(route1)-2)\n            c2 = random.randint(1, len(route2)-2)\n\n            # Swap customers and check capacity\n            new_route1 = np.concatenate((route1[:c1], [route2[c2]], route1[c1+1:]))\n            new_route2 = np.concatenate((route2[:c2], [route1[c1]], route2[c2+1:]))\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                routes[r1] = new_route1\n                routes[r2] = new_route2\n                improved = True\n                break\n\n        if improved:\n            return routes\n\n        # Step 3: Capacity-aware insertion (move a customer to a different route if beneficial)\n        for _ in range(5):  # Try multiple insertions\n            r1 = random.choice(range(len(routes)))\n            route = routes[r1]\n\n            if len(route) <= 2:\n                continue\n\n            # Select a random customer (excluding depot)\n            c = random.randint(1, len(route)-2)\n            customer = route[c]\n\n            # Try inserting into other routes\n            for r2 in range(len(routes)):\n                if r1 == r2:\n                    continue\n\n                other_route = routes[r2]\n                # Check capacity feasibility\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the middle of the other route\n                    insert_pos = len(other_route) // 2\n                    new_route = np.concatenate((other_route[:insert_pos], [customer], other_route[insert_pos:]))\n                    routes[r2] = new_route\n                    # Remove customer from original route\n                    routes[r1] = np.concatenate((route[:c], route[c+1:]))\n                    improved = True\n                    break\n\n            if improved:\n                break\n\n        return routes\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure the solution is feasible (all customers served, capacity not exceeded)\n    # Verify all customers are included in the solution\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # If not all customers are served, fall back to the original solution\n        new_solution = base_solution\n\n    # Verify capacity constraints\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7924970623630991,
            0.5549175441265106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        improved = False\n        routes = [route.copy() for route in solution]\n\n        # Step 1: Route splitting (if a route is too long, split it)\n        for i in range(len(routes)):\n            route = routes[i]\n            if len(route) > 4:  # Arbitrary threshold to avoid trivial splits\n                split_pos = len(route) // 2\n                new_route1 = np.concatenate((route[:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos:]))\n\n                # Check capacity feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    routes[i] = new_route1\n                    routes.insert(i+1, new_route2)\n                    improved = True\n                    break\n\n        if improved:\n            return routes\n\n        # Step 2: Customer swapping (swap customers between routes if beneficial)\n        for _ in range(5):  # Try multiple swaps\n            r1, r2 = random.sample(range(len(routes)), 2)\n            route1, route2 = routes[r1], routes[r2]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Select random customers from each route (excluding depot)\n            c1 = random.randint(1, len(route1)-2)\n            c2 = random.randint(1, len(route2)-2)\n\n            # Swap customers and check capacity\n            new_route1 = np.concatenate((route1[:c1], [route2[c2]], route1[c1+1:]))\n            new_route2 = np.concatenate((route2[:c2], [route1[c1]], route2[c2+1:]))\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                routes[r1] = new_route1\n                routes[r2] = new_route2\n                improved = True\n                break\n\n        if improved:\n            return routes\n\n        # Step 3: Capacity-aware insertion (move a customer to a different route if beneficial)\n        for _ in range(5):  # Try multiple insertions\n            r1 = random.choice(range(len(routes)))\n            route = routes[r1]\n\n            if len(route) <= 2:\n                continue\n\n            # Select a random customer (excluding depot)\n            c = random.randint(1, len(route)-2)\n            customer = route[c]\n\n            # Try inserting into other routes\n            for r2 in range(len(routes)):\n                if r1 == r2:\n                    continue\n\n                other_route = routes[r2]\n                # Check capacity feasibility\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the middle of the other route\n                    insert_pos = len(other_route) // 2\n                    new_route = np.concatenate((other_route[:insert_pos], [customer], other_route[insert_pos:]))\n                    routes[r2] = new_route\n                    # Remove customer from original route\n                    routes[r1] = np.concatenate((route[:c], route[c+1:]))\n                    improved = True\n                    break\n\n            if improved:\n                break\n\n        return routes\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure the solution is feasible (all customers served, capacity not exceeded)\n    # Verify all customers are included in the solution\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # If not all customers are served, fall back to the original solution\n        new_solution = base_solution\n\n    # Verify capacity constraints\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search combining route splitting, customer reallocation with demand constraints, and route merging to improve both total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the base solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Step 2: Try to split the route into two parts\n        if len(selected_route) > 4:  # Ensure it's worth splitting\n            split_pos = random.randint(2, len(selected_route) - 3)\n            part1 = selected_route[:split_pos + 1]\n            part2 = selected_route[split_pos:]\n\n            # Check capacity constraints\n            if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n                new_solution[route_idx] = part1\n                new_solution.insert(route_idx + 1, part2)\n\n        # Step 3: Try to reallocate a customer from this route to another route\n        if len(new_solution) > 1 and len(selected_route) > 3:\n            customer_pos = random.randint(1, len(selected_route) - 2)\n            customer = selected_route[customer_pos]\n\n            # Find another route that can accommodate this customer\n            for i, route in enumerate(new_solution):\n                if i != route_idx and (np.sum(demand[route[1:-1]]) + demand[customer]) <= capacity:\n                    # Insert customer into this route (random position)\n                    insert_pos = random.randint(1, len(route) - 1)\n                    new_route = np.insert(route, insert_pos, customer)\n\n                    # Update both routes\n                    new_solution[i] = new_route\n                    new_solution[route_idx] = np.delete(selected_route, customer_pos)\n                    break\n\n        # Step 4: Try to merge this route with another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx].copy()\n\n            # Check if merging is possible\n            if (np.sum(demand[selected_route[1:-1]]) + np.sum(demand[other_route[1:-1]])) <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([selected_route[:-1], other_route[1:]])\n\n                # Update the solution\n                new_solution[route_idx] = merged_route\n                new_solution.pop(other_route_idx)\n\n    # Ensure the solution is feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible!\")\n\n    return new_solution\n\n",
        "score": [
            -0.657421662568469,
            1.0165860950946808
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the base solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Step 2: Try to split the route into two parts\n        if len(selected_route) > 4:  # Ensure it's worth splitting\n            split_pos = random.randint(2, len(selected_route) - 3)\n            part1 = selected_route[:split_pos + 1]\n            part2 = selected_route[split_pos:]\n\n            # Check capacity constraints\n            if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n                new_solution[route_idx] = part1\n                new_solution.insert(route_idx + 1, part2)\n\n        # Step 3: Try to reallocate a customer from this route to another route\n        if len(new_solution) > 1 and len(selected_route) > 3:\n            customer_pos = random.randint(1, len(selected_route) - 2)\n            customer = selected_route[customer_pos]\n\n            # Find another route that can accommodate this customer\n            for i, route in enumerate(new_solution):\n                if i != route_idx and (np.sum(demand[route[1:-1]]) + demand[customer]) <= capacity:\n                    # Insert customer into this route (random position)\n                    insert_pos = random.randint(1, len(route) - 1)\n                    new_route = np.insert(route, insert_pos, customer)\n\n                    # Update both routes\n                    new_solution[i] = new_route\n                    new_solution[route_idx] = np.delete(selected_route, customer_pos)\n                    break\n\n        # Step 4: Try to merge this route with another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx].copy()\n\n            # Check if merging is possible\n            if (np.sum(demand[selected_route[1:-1]]) + np.sum(demand[other_route[1:-1]])) <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([selected_route[:-1], other_route[1:]])\n\n                # Update the solution\n                new_solution[route_idx] = merged_route\n                new_solution.pop(other_route_idx)\n\n    # Ensure the solution is feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible!\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Remove a random segment and reinsert it elsewhere (with capacity check)\n    if len(route) > 3:  # Ensure we can remove a segment\n        start = np.random.randint(1, len(route) - 2)\n        end = np.random.randint(start + 1, len(route) - 1)\n        segment = route[start:end]\n        segment_demand = np.sum(demand[segment])\n\n        # Remove the segment\n        new_route = np.concatenate([route[:start], route[end:]])\n\n        # Try to reinsert the segment into another route or the same route\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i in range(len(base_solution)):\n            if i == route_idx:\n                # Try inserting into the same route\n                for j in range(1, len(new_route)):\n                    # Check capacity constraint\n                    if np.sum(demand[np.concatenate([new_route[:j], segment, new_route[j:]])]) <= capacity:\n                        # Calculate the increase in distance\n                        prev_node = new_route[j-1]\n                        next_node = new_route[j]\n                        insert_distance = distance_matrix[prev_node, segment[0]] + np.sum(distance_matrix[segment[:-1], segment[1:]]) + distance_matrix[segment[-1], next_node] - distance_matrix[prev_node, next_node]\n                        if insert_distance < min_increase:\n                            min_increase = insert_distance\n                            best_insertion = (i, j, segment)\n            else:\n                # Try inserting into another route\n                other_route = base_solution[i].copy()\n                for j in range(1, len(other_route)):\n                    # Check capacity constraint\n                    if np.sum(demand[np.concatenate([other_route[:j], segment, other_route[j:]])]) <= capacity:\n                        # Calculate the increase in distance\n                        prev_node = other_route[j-1]\n                        next_node = other_route[j]\n                        insert_distance = distance_matrix[prev_node, segment[0]] + np.sum(distance_matrix[segment[:-1], segment[1:]]) + distance_matrix[segment[-1], next_node] - distance_matrix[prev_node, next_node]\n                        if insert_distance < min_increase:\n                            min_increase = insert_distance\n                            best_insertion = (i, j, segment)\n\n        if best_insertion:\n            i, j, segment = best_insertion\n            if i == route_idx:\n                # Insert into the same route\n                new_route = np.concatenate([new_route[:j], segment, new_route[j:]])\n                base_solution[route_idx] = new_route\n            else:\n                # Insert into another route\n                other_route = base_solution[i].copy()\n                other_route = np.concatenate([other_route[:j], segment, other_route[j:]])\n                base_solution[i] = other_route\n\n    return base_solution\n\n",
        "score": [
            -0.3841278604728062,
            4.52871173620224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Remove a random segment and reinsert it elsewhere (with capacity check)\n    if len(route) > 3:  # Ensure we can remove a segment\n        start = np.random.randint(1, len(route) - 2)\n        end = np.random.randint(start + 1, len(route) - 1)\n        segment = route[start:end]\n        segment_demand = np.sum(demand[segment])\n\n        # Remove the segment\n        new_route = np.concatenate([route[:start], route[end:]])\n\n        # Try to reinsert the segment into another route or the same route\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i in range(len(base_solution)):\n            if i == route_idx:\n                # Try inserting into the same route\n                for j in range(1, len(new_route)):\n                    # Check capacity constraint\n                    if np.sum(demand[np.concatenate([new_route[:j], segment, new_route[j:]])]) <= capacity:\n                        # Calculate the increase in distance\n                        prev_node = new_route[j-1]\n                        next_node = new_route[j]\n                        insert_distance = distance_matrix[prev_node, segment[0]] + np.sum(distance_matrix[segment[:-1], segment[1:]]) + distance_matrix[segment[-1], next_node] - distance_matrix[prev_node, next_node]\n                        if insert_distance < min_increase:\n                            min_increase = insert_distance\n                            best_insertion = (i, j, segment)\n            else:\n                # Try inserting into another route\n                other_route = base_solution[i].copy()\n                for j in range(1, len(other_route)):\n                    # Check capacity constraint\n                    if np.sum(demand[np.concatenate([other_route[:j], segment, other_route[j:]])]) <= capacity:\n                        # Calculate the increase in distance\n                        prev_node = other_route[j-1]\n                        next_node = other_route[j]\n                        insert_distance = distance_matrix[prev_node, segment[0]] + np.sum(distance_matrix[segment[:-1], segment[1:]]) + distance_matrix[segment[-1], next_node] - distance_matrix[prev_node, next_node]\n                        if insert_distance < min_increase:\n                            min_increase = insert_distance\n                            best_insertion = (i, j, segment)\n\n        if best_insertion:\n            i, j, segment = best_insertion\n            if i == route_idx:\n                # Insert into the same route\n                new_route = np.concatenate([new_route[:j], segment, new_route[j:]])\n                base_solution[route_idx] = new_route\n            else:\n                # Insert into another route\n                other_route = base_solution[i].copy()\n                other_route = np.concatenate([other_route[:j], segment, other_route[j:]])\n                base_solution[i] = other_route\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment to split\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment = route[split_pos:-1]\n\n        # Check if splitting improves makespan\n        new_route1 = route[:split_pos + 1]\n        new_route2 = np.concatenate([[0], segment, [0]])\n\n        # Verify capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Randomly reallocate a customer from the new route to another route\n            if len(new_route2) > 2:\n                realloc_pos = np.random.randint(1, len(new_route2) - 1)\n                customer = new_route2[realloc_pos]\n\n                # Find a target route with sufficient capacity\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    target_route = new_solution[j].copy()\n                    if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into target route (nearest neighbor)\n                        best_pos = 1\n                        min_dist = float('inf')\n                        for k in range(1, len(target_route)):\n                            dist = (distance_matrix[target_route[k-1], customer] +\n                                    distance_matrix[customer, target_route[k]] -\n                                    distance_matrix[target_route[k-1], target_route[k]])\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_pos = k\n\n                        new_target_route = np.insert(target_route, best_pos, customer)\n                        new_solution[j] = new_target_route\n\n                        # Remove customer from new_route2\n                        new_route2 = np.delete(new_route2, realloc_pos)\n                        break\n\n                # Update routes\n                new_solution[i] = new_route1\n                if len(new_route2) > 2:\n                    new_solution.append(new_route2)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8918934328004013,
            0.4840622842311859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment to split\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment = route[split_pos:-1]\n\n        # Check if splitting improves makespan\n        new_route1 = route[:split_pos + 1]\n        new_route2 = np.concatenate([[0], segment, [0]])\n\n        # Verify capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Randomly reallocate a customer from the new route to another route\n            if len(new_route2) > 2:\n                realloc_pos = np.random.randint(1, len(new_route2) - 1)\n                customer = new_route2[realloc_pos]\n\n                # Find a target route with sufficient capacity\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    target_route = new_solution[j].copy()\n                    if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into target route (nearest neighbor)\n                        best_pos = 1\n                        min_dist = float('inf')\n                        for k in range(1, len(target_route)):\n                            dist = (distance_matrix[target_route[k-1], customer] +\n                                    distance_matrix[customer, target_route[k]] -\n                                    distance_matrix[target_route[k-1], target_route[k]])\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_pos = k\n\n                        new_target_route = np.insert(target_route, best_pos, customer)\n                        new_solution[j] = new_target_route\n\n                        # Remove customer from new_route2\n                        new_route2 = np.delete(new_route2, realloc_pos)\n                        break\n\n                # Update routes\n                new_solution[i] = new_route1\n                if len(new_route2) > 2:\n                    new_solution.append(new_route2)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search operator: route merging and split with demand-aware insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Randomly select a split point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Try merging with another route\n        merged = False\n        for i, other_route in enumerate(selected_solution):\n            if other_route is route or len(other_route) <= 2:\n                continue\n\n            # Check if merging part1 with other_route is feasible\n            if np.sum(demand[part1[1:-1]]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n                merged_route = np.concatenate((other_route[:-1], part1[1:]))\n                new_solution.append(merged_route)\n                selected_solution[i] = part2  # Update the other route with part2\n                merged = True\n                break\n\n        if not merged:\n            new_solution.append(part1)\n            new_solution.append(part2)\n\n    # Apply demand-aware insertion to improve the split routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Randomly select a customer to move\n        move_idx = np.random.randint(1, len(route) - 1)\n        customer = route[move_idx]\n\n        # Try inserting into another route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n\n            other_route = new_solution[j]\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Find the best insertion position\n            best_pos = 1\n            min_cost = float('inf')\n            for k in range(1, len(other_route)):\n                # Calculate insertion cost\n                cost = (distance_matrix[other_route[k-1], customer] +\n                        distance_matrix[customer, other_route[k]] -\n                        distance_matrix[other_route[k-1], other_route[k]])\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = k\n\n            # Insert the customer\n            new_route = np.concatenate((other_route[:best_pos], [customer], other_route[best_pos:]))\n            new_solution[j] = new_route\n            new_solution[i] = np.concatenate((route[:move_idx], route[move_idx+1:]))\n            break  # Only move one customer at a time\n\n    return new_solution\n\n",
        "score": [
            -0.7221380213724883,
            5.37389600276947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search operator: route merging and split with demand-aware insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Randomly select a split point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Try merging with another route\n        merged = False\n        for i, other_route in enumerate(selected_solution):\n            if other_route is route or len(other_route) <= 2:\n                continue\n\n            # Check if merging part1 with other_route is feasible\n            if np.sum(demand[part1[1:-1]]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n                merged_route = np.concatenate((other_route[:-1], part1[1:]))\n                new_solution.append(merged_route)\n                selected_solution[i] = part2  # Update the other route with part2\n                merged = True\n                break\n\n        if not merged:\n            new_solution.append(part1)\n            new_solution.append(part2)\n\n    # Apply demand-aware insertion to improve the split routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Randomly select a customer to move\n        move_idx = np.random.randint(1, len(route) - 1)\n        customer = route[move_idx]\n\n        # Try inserting into another route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n\n            other_route = new_solution[j]\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Find the best insertion position\n            best_pos = 1\n            min_cost = float('inf')\n            for k in range(1, len(other_route)):\n                # Calculate insertion cost\n                cost = (distance_matrix[other_route[k-1], customer] +\n                        distance_matrix[customer, other_route[k]] -\n                        distance_matrix[other_route[k-1], other_route[k]])\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = k\n\n            # Insert the customer\n            new_route = np.concatenate((other_route[:best_pos], [customer], other_route[best_pos:]))\n            new_solution[j] = new_route\n            new_solution[i] = np.concatenate((route[:move_idx], route[move_idx+1:]))\n            break  # Only move one customer at a time\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: combine route merging and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts and try to reallocate customers\n        split_point = len(route) // 2\n        part1 = route[:split_point + 1]  # Include depot\n        part2 = route[split_point - 1:]  # Include depot\n\n        # Check capacity feasibility for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity and\n            np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try to reallocate customers to other routes\n            for customer in route[1:-1]:\n                # Find the route with minimal additional distance and feasible capacity\n                best_route = None\n                min_additional_distance = float('inf')\n                for i, candidate_route in enumerate(new_solution):\n                    if np.sum(demand[candidate_route[1:-1]]) + demand[customer] <= capacity:\n                        # Calculate additional distance if customer is inserted at the end\n                        last_node = candidate_route[-2]\n                        additional_distance = distance_matrix[last_node][customer] + distance_matrix[customer][0] - distance_matrix[last_node][0]\n                        if additional_distance < min_additional_distance:\n                            min_additional_distance = additional_distance\n                            best_route = i\n\n                if best_route is not None:\n                    # Insert customer into the best route\n                    new_solution[best_route] = np.append(new_solution[best_route][:-1], [customer, 0])\n\n            # Add the remaining part if no reallocation was possible\n            if part1 not in new_solution and len(part1) > 2:\n                new_solution.append(part1.copy())\n            if part2 not in new_solution and len(part2) > 2:\n                new_solution.append(part2.copy())\n\n    # Ensure all customers are served (edge case handling)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Assign missing customers to new routes\n    for customer in missing_customers:\n        best_route = None\n        min_additional_distance = float('inf')\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                last_node = route[-2]\n                additional_distance = distance_matrix[last_node][customer] + distance_matrix[customer][0] - distance_matrix[last_node][0]\n                if additional_distance < min_additional_distance:\n                    min_additional_distance = additional_distance\n                    best_route = i\n\n        if best_route is not None:\n            new_solution[best_route] = np.append(new_solution[best_route][:-1], [customer, 0])\n        else:\n            # Create a new route if no feasible route exists\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7797750225651185,
            0.6954724490642548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: combine route merging and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts and try to reallocate customers\n        split_point = len(route) // 2\n        part1 = route[:split_point + 1]  # Include depot\n        part2 = route[split_point - 1:]  # Include depot\n\n        # Check capacity feasibility for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity and\n            np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try to reallocate customers to other routes\n            for customer in route[1:-1]:\n                # Find the route with minimal additional distance and feasible capacity\n                best_route = None\n                min_additional_distance = float('inf')\n                for i, candidate_route in enumerate(new_solution):\n                    if np.sum(demand[candidate_route[1:-1]]) + demand[customer] <= capacity:\n                        # Calculate additional distance if customer is inserted at the end\n                        last_node = candidate_route[-2]\n                        additional_distance = distance_matrix[last_node][customer] + distance_matrix[customer][0] - distance_matrix[last_node][0]\n                        if additional_distance < min_additional_distance:\n                            min_additional_distance = additional_distance\n                            best_route = i\n\n                if best_route is not None:\n                    # Insert customer into the best route\n                    new_solution[best_route] = np.append(new_solution[best_route][:-1], [customer, 0])\n\n            # Add the remaining part if no reallocation was possible\n            if part1 not in new_solution and len(part1) > 2:\n                new_solution.append(part1.copy())\n            if part2 not in new_solution and len(part2) > 2:\n                new_solution.append(part2.copy())\n\n    # Ensure all customers are served (edge case handling)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Assign missing customers to new routes\n    for customer in missing_customers:\n        best_route = None\n        min_additional_distance = float('inf')\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                last_node = route[-2]\n                additional_distance = distance_matrix[last_node][customer] + distance_matrix[customer][0] - distance_matrix[last_node][0]\n                if additional_distance < min_additional_distance:\n                    min_additional_distance = additional_distance\n                    best_route = i\n\n        if best_route is not None:\n            new_solution[best_route] = np.append(new_solution[best_route][:-1], [customer, 0])\n        else:\n            # Create a new route if no feasible route exists\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining route fragmentation and capacity-aware insertion to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))  # Prioritize low makespan, then high distance\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: route fragmentation + capacity-aware insertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Fragment route into segments and attempt reinsertion\n        frag_points = sorted(np.random.choice(range(1, len(route)-1), size=min(3, len(route)-2), replace=False))\n        segments = []\n        prev = 0\n        for point in frag_points:\n            segments.append(route[prev:point+1])\n            prev = point\n        segments.append(route[prev:])\n\n        # Rebuild route with capacity-aware insertion\n        rebuilt_route = [0]\n        remaining_nodes = []\n        for seg in segments:\n            if len(seg) > 2:  # Skip single nodes\n                remaining_nodes.extend(seg[1:-1])\n\n        # Insert nodes back with capacity constraints\n        while remaining_nodes:\n            node = remaining_nodes.pop(0)\n            best_pos = 1\n            best_cost = float('inf')\n            current_load = sum(demand[rebuilt_route[1:-1]])\n\n            for i in range(1, len(rebuilt_route)):\n                if current_load + demand[node] <= capacity:\n                    cost = distance_matrix[rebuilt_route[i-1]][node] + distance_matrix[node][rebuilt_route[i]] - distance_matrix[rebuilt_route[i-1]][rebuilt_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n            rebuilt_route.insert(best_pos, node)\n            current_load += demand[node]\n\n        rebuilt_route.append(0)\n        new_solution[route_idx] = np.array(rebuilt_route)\n\n    return new_solution\n\n",
        "score": [
            -0.6814972464135725,
            4.112370163202286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))  # Prioritize low makespan, then high distance\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: route fragmentation + capacity-aware insertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Fragment route into segments and attempt reinsertion\n        frag_points = sorted(np.random.choice(range(1, len(route)-1), size=min(3, len(route)-2), replace=False))\n        segments = []\n        prev = 0\n        for point in frag_points:\n            segments.append(route[prev:point+1])\n            prev = point\n        segments.append(route[prev:])\n\n        # Rebuild route with capacity-aware insertion\n        rebuilt_route = [0]\n        remaining_nodes = []\n        for seg in segments:\n            if len(seg) > 2:  # Skip single nodes\n                remaining_nodes.extend(seg[1:-1])\n\n        # Insert nodes back with capacity constraints\n        while remaining_nodes:\n            node = remaining_nodes.pop(0)\n            best_pos = 1\n            best_cost = float('inf')\n            current_load = sum(demand[rebuilt_route[1:-1]])\n\n            for i in range(1, len(rebuilt_route)):\n                if current_load + demand[node] <= capacity:\n                    cost = distance_matrix[rebuilt_route[i-1]][node] + distance_matrix[node][rebuilt_route[i]] - distance_matrix[rebuilt_route[i-1]][rebuilt_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n            rebuilt_route.insert(best_pos, node)\n            current_load += demand[node]\n\n        rebuilt_route.append(0)\n        new_solution[route_idx] = np.array(rebuilt_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance or low makespan, then applies a hybrid local search combining route splitting, customer reallocation, and cross-route relinking to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and cross-route relinking\n    def is_feasible(route, demand, capacity):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting - split long routes into smaller ones if possible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # If route has more than 2 customers\n            split_point = random.randint(2, len(route)-2)\n            new_route1 = route[:split_point+1]\n            new_route2 = [0] + route[split_point:-1] + [0]\n            if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Step 2: Customer reallocation - move customers between routes if beneficial\n    for _ in range(2):  # Try a few times\n        for i in range(len(new_solution)):\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if len(route1) <= 3 or len(route2) >= 10:\n                    continue\n\n                # Try moving a customer from route1 to route2\n                for k in range(1, len(route1)-1):\n                    customer = route1[k]\n                    new_route1 = np.concatenate([route1[:k], route1[k+1:]])\n                    new_route2 = np.insert(route2, -1, customer)\n\n                    if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                        new_solution[i] = new_route1\n                        new_solution[j] = new_route2\n                        break\n\n    # Step 3: Cross-route relinking - exchange segments between routes\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        if len(route1) <= 3 or len(route2) <= 3:\n            continue\n\n        # Find exchange points\n        pos1 = random.randint(1, len(route1)-2)\n        pos2 = random.randint(1, len(route2)-2)\n\n        # Exchange segments\n        new_route1 = np.concatenate([route1[:pos1], route2[pos2:-1], route1[pos1:]])\n        new_route2 = np.concatenate([route2[:pos2], route1[pos1:-1], route2[pos2:]])\n\n        if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n            new_solution[i] = new_route1\n            new_solution[j] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8405541970218245,
            9.702647417783737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and cross-route relinking\n    def is_feasible(route, demand, capacity):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting - split long routes into smaller ones if possible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # If route has more than 2 customers\n            split_point = random.randint(2, len(route)-2)\n            new_route1 = route[:split_point+1]\n            new_route2 = [0] + route[split_point:-1] + [0]\n            if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Step 2: Customer reallocation - move customers between routes if beneficial\n    for _ in range(2):  # Try a few times\n        for i in range(len(new_solution)):\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if len(route1) <= 3 or len(route2) >= 10:\n                    continue\n\n                # Try moving a customer from route1 to route2\n                for k in range(1, len(route1)-1):\n                    customer = route1[k]\n                    new_route1 = np.concatenate([route1[:k], route1[k+1:]])\n                    new_route2 = np.insert(route2, -1, customer)\n\n                    if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                        new_solution[i] = new_route1\n                        new_solution[j] = new_route2\n                        break\n\n    # Step 3: Cross-route relinking - exchange segments between routes\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        if len(route1) <= 3 or len(route2) <= 3:\n            continue\n\n        # Find exchange points\n        pos1 = random.randint(1, len(route1)-2)\n        pos2 = random.randint(1, len(route2)-2)\n\n        # Exchange segments\n        new_route1 = np.concatenate([route1[:pos1], route2[pos2:-1], route1[pos1:]])\n        new_route2 = np.concatenate([route2[:pos2], route1[pos1:-1], route2[pos2:]])\n\n        if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n            new_solution[i] = new_route1\n            new_solution[j] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{The algorithm selects a solution from the archive with the highest \"potential improvement\" (lowest makespan and total distance), then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt with capacity-aware adjustments to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Perform multiple iterations for better improvement\n        # Step 1: Route splitting - identify long routes and split them\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only split routes with more than 3 customers\n                split_pos = random.randint(1, len(route)-2)\n                new_route1 = route[:split_pos+1]\n                new_route2 = route[split_pos:]\n                new_route2[0] = 0  # Ensure new route starts at depot\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Customer reallocation - move customers between routes\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:  # Ensure there's a customer to move\n                    customer_pos = random.randint(1, len(route1)-2)\n                    customer = route1[customer_pos]\n\n                    # Check if moving the customer to route2 is feasible\n                    if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        new_route1 = np.delete(route1, customer_pos)\n                        new_route2 = np.insert(route2, -1, customer)\n\n                        # Update the solution\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n        # Step 3: Adaptive 2-opt with capacity check\n        for route in new_solution:\n            if len(route) > 4:  # Only perform 2-opt on routes with enough customers\n                i, j = sorted(random.sample(range(1, len(route)-1), 2))\n                new_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], new_segment, route[j+1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8207354354408208,
            2.5238391757011414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Perform multiple iterations for better improvement\n        # Step 1: Route splitting - identify long routes and split them\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only split routes with more than 3 customers\n                split_pos = random.randint(1, len(route)-2)\n                new_route1 = route[:split_pos+1]\n                new_route2 = route[split_pos:]\n                new_route2[0] = 0  # Ensure new route starts at depot\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Customer reallocation - move customers between routes\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:  # Ensure there's a customer to move\n                    customer_pos = random.randint(1, len(route1)-2)\n                    customer = route1[customer_pos]\n\n                    # Check if moving the customer to route2 is feasible\n                    if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        new_route1 = np.delete(route1, customer_pos)\n                        new_route2 = np.insert(route2, -1, customer)\n\n                        # Update the solution\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n        # Step 3: Adaptive 2-opt with capacity check\n        for route in new_solution:\n            if len(route) > 4:  # Only perform 2-opt on routes with enough customers\n                i, j = sorted(random.sample(range(1, len(route)-1), 2))\n                new_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], new_segment, route[j+1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random customer\n    split_point = np.random.randint(1, len(longest_route)-1)\n    part1 = longest_route[:split_point+1]\n    part2 = longest_route[split_point:]\n\n    # Reconstruct the solution with the split routes\n    new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n    new_solution.append(part1)\n    new_solution.append(part2)\n\n    # Check and fix capacity violations in the new routes\n    for i in range(len(new_solution)):\n        current_route = new_solution[i]\n        total_demand = sum(demand[node] for node in current_route[1:-1])\n        if total_demand > capacity:\n            # Reallocate violating customers to other routes\n            violating_nodes = [node for node in current_route[1:-1] if demand[node] > capacity]\n            for node in violating_nodes:\n                # Find the nearest feasible route\n                for j in range(len(new_solution)):\n                    if j != i:\n                        temp_route = np.insert(new_solution[j], -1, node)\n                        if sum(demand[n] for n in temp_route[1:-1]) <= capacity:\n                            new_solution[j] = temp_route\n                            new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == node)[0][0])\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.6753313833526063,
            0.6110067963600159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random customer\n    split_point = np.random.randint(1, len(longest_route)-1)\n    part1 = longest_route[:split_point+1]\n    part2 = longest_route[split_point:]\n\n    # Reconstruct the solution with the split routes\n    new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n    new_solution.append(part1)\n    new_solution.append(part2)\n\n    # Check and fix capacity violations in the new routes\n    for i in range(len(new_solution)):\n        current_route = new_solution[i]\n        total_demand = sum(demand[node] for node in current_route[1:-1])\n        if total_demand > capacity:\n            # Reallocate violating customers to other routes\n            violating_nodes = [node for node in current_route[1:-1] if demand[node] > capacity]\n            for node in violating_nodes:\n                # Find the nearest feasible route\n                for j in range(len(new_solution)):\n                    if j != i:\n                        temp_route = np.insert(new_solution[j], -1, node)\n                        if sum(demand[n] for n in temp_route[1:-1]) <= capacity:\n                            new_solution[j] = temp_route\n                            new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == node)[0][0])\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by combining multi-objective ranking, route diversity analysis, and a hybrid local search strategy that dynamically interleaves route perturbation, rebalancing, and capacity-aware edge swaps to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions based on makespan and total distance\n        sorted_archive = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n        # Select a solution that is not the best but has potential for improvement\n        selected_idx = min(1, len(archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_routes = len(new_solution)\n\n    # Step 2.1: Route perturbation - randomly select a route and reorder its customers\n    if n_routes > 1:\n        route_idx = np.random.randint(0, n_routes)\n        route = new_solution[route_idx].copy()\n        customers = route[1:-1]  # exclude depot\n\n        # Shuffle customers and reinsert them in a new order\n        np.random.shuffle(customers)\n        new_route = np.concatenate([[0], customers, [0]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n        else:\n            # If infeasible, try to split the route if possible\n            if len(customers) > 2:\n                split_pos = len(customers) // 2\n                route1 = np.concatenate([[0], customers[:split_pos], [0]])\n                route2 = np.concatenate([[0], customers[split_pos:], [0]])\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution = np.concatenate([new_solution[:route_idx], [route1, route2], new_solution[route_idx+1:]])\n\n    # Step 2.2: Capacity-aware edge swap between routes\n    if n_routes > 1:\n        route1_idx, route2_idx = np.random.choice(n_routes, 2, replace=False)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Try to swap a customer from route1 to route2 and vice versa\n        for _ in range(2):  # Try both directions\n            if len(route1) > 2 and len(route2) > 2:\n                # Select a customer from route1 and route2\n                cust1 = np.random.choice(route1[1:-1])\n                cust2 = np.random.choice(route2[1:-1])\n\n                # Create new routes after swap\n                new_route1 = np.concatenate([[0], route1[1:-1][route1[1:-1] != cust1], [cust2], [0]])\n                new_route2 = np.concatenate([[0], route2[1:-1][route2[1:-1] != cust2], [cust1], [0]])\n\n                # Check capacity feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    # Step 2.3: Route rebalancing - redistribute customers to balance makespan\n    if n_routes > 1:\n        # Calculate current route lengths\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        max_length_idx = np.argmax(route_lengths)\n        min_length_idx = np.argmin(route_lengths)\n\n        if max_length_idx != min_length_idx:\n            max_route = new_solution[max_length_idx].copy()\n            min_route = new_solution[min_length_idx].copy()\n\n            # Try to transfer a customer from max_route to min_route\n            for cust in max_route[1:-1]:\n                new_min_route = np.concatenate([[0], min_route[1:-1], [cust], [0]])\n                new_max_route = np.concatenate([[0], max_route[1:-1][max_route[1:-1] != cust], [0]])\n\n                # Check capacity feasibility\n                if (np.sum(demand[new_min_route[1:-1]]) <= capacity and\n                    np.sum(demand[new_max_route[1:-1]]) <= capacity):\n                    new_solution[min_length_idx] = new_min_route\n                    new_solution[max_length_idx] = new_max_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4610873130104997,
            1.7509090304374695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions based on makespan and total distance\n        sorted_archive = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n        # Select a solution that is not the best but has potential for improvement\n        selected_idx = min(1, len(archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_routes = len(new_solution)\n\n    # Step 2.1: Route perturbation - randomly select a route and reorder its customers\n    if n_routes > 1:\n        route_idx = np.random.randint(0, n_routes)\n        route = new_solution[route_idx].copy()\n        customers = route[1:-1]  # exclude depot\n\n        # Shuffle customers and reinsert them in a new order\n        np.random.shuffle(customers)\n        new_route = np.concatenate([[0], customers, [0]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n        else:\n            # If infeasible, try to split the route if possible\n            if len(customers) > 2:\n                split_pos = len(customers) // 2\n                route1 = np.concatenate([[0], customers[:split_pos], [0]])\n                route2 = np.concatenate([[0], customers[split_pos:], [0]])\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution = np.concatenate([new_solution[:route_idx], [route1, route2], new_solution[route_idx+1:]])\n\n    # Step 2.2: Capacity-aware edge swap between routes\n    if n_routes > 1:\n        route1_idx, route2_idx = np.random.choice(n_routes, 2, replace=False)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Try to swap a customer from route1 to route2 and vice versa\n        for _ in range(2):  # Try both directions\n            if len(route1) > 2 and len(route2) > 2:\n                # Select a customer from route1 and route2\n                cust1 = np.random.choice(route1[1:-1])\n                cust2 = np.random.choice(route2[1:-1])\n\n                # Create new routes after swap\n                new_route1 = np.concatenate([[0], route1[1:-1][route1[1:-1] != cust1], [cust2], [0]])\n                new_route2 = np.concatenate([[0], route2[1:-1][route2[1:-1] != cust2], [cust1], [0]])\n\n                # Check capacity feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    # Step 2.3: Route rebalancing - redistribute customers to balance makespan\n    if n_routes > 1:\n        # Calculate current route lengths\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        max_length_idx = np.argmax(route_lengths)\n        min_length_idx = np.argmin(route_lengths)\n\n        if max_length_idx != min_length_idx:\n            max_route = new_solution[max_length_idx].copy()\n            min_route = new_solution[min_length_idx].copy()\n\n            # Try to transfer a customer from max_route to min_route\n            for cust in max_route[1:-1]:\n                new_min_route = np.concatenate([[0], min_route[1:-1], [cust], [0]])\n                new_max_route = np.concatenate([[0], max_route[1:-1][max_route[1:-1] != cust], [0]])\n\n                # Check capacity feasibility\n                if (np.sum(demand[new_min_route[1:-1]]) <= capacity and\n                    np.sum(demand[new_max_route[1:-1]]) <= capacity):\n                    new_solution[min_length_idx] = new_min_route\n                    new_solution[max_length_idx] = new_max_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{A hybrid local search strategy combining route segmentation, demand-based insertion, and adaptive 2-opt with capacity-aware swaps, prioritizing solutions with high makespan and total distance reduction potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))  # Sort by makespan (descending) then total distance (descending)\n    selected_idx = min(3, len(sorted_archive) - 1)  # Select from top 4 solutions\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Create a copy of the base solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation + demand-based insertion + adaptive 2-opt\n    for _ in range(2):  # Perform 2 iterations\n        # Step 1: Route segmentation - split long routes into smaller segments\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only consider routes with more than 3 customers\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = route[:split_pos + 1]\n                new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Demand-based insertion - move customers between routes\n        for _ in range(3):  # Try 3 insertions\n            # Select a random route and customer\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) <= 3:  # Skip if route has only depot and one customer\n                continue\n\n            customer_idx = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_idx]\n\n            # Try to insert into another route\n            to_route_idx = random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n            to_route = new_solution[to_route_idx]\n\n            # Find best insertion position in target route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(to_route)):\n                new_route = np.concatenate([to_route[:pos], [customer], to_route[pos:]])\n                if np.sum(demand[new_route[1:-1]]) > capacity:\n                    continue\n\n                # Calculate insertion cost\n                cost = (distance_matrix[to_route[pos-1]][customer] +\n                        distance_matrix[customer][to_route[pos]] -\n                        distance_matrix[to_route[pos-1]][to_route[pos]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            if best_cost < float('inf'):\n                # Perform the insertion\n                new_route = np.concatenate([to_route[:best_pos], [customer], to_route[best_pos:]])\n                new_solution[to_route_idx] = new_route\n\n                # Remove customer from original route\n                new_route = np.delete(from_route, customer_idx)\n                if len(new_route) > 2:  # Only keep if route still has customers\n                    new_solution[from_route_idx] = new_route\n                else:\n                    del new_solution[from_route_idx]\n                break\n\n        # Step 3: Adaptive 2-opt with capacity awareness\n        for _ in range(2):  # Try 2 2-opt swaps\n            # Select two random routes\n            route_indices = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n            route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n            # Select two random segments from each route (excluding depots)\n            if len(route1) > 3 and len(route2) > 3:\n                seg1_start = random.randint(1, len(route1) - 3)\n                seg1_end = random.randint(seg1_start, len(route1) - 2)\n\n                seg2_start = random.randint(1, len(route2) - 3)\n                seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n                # Create new routes by swapping segments\n                new_route1 = np.concatenate([\n                    route1[:seg1_start],\n                    route2[seg2_start:seg2_end + 1],\n                    route1[seg1_end + 1:]\n                ])\n\n                new_route2 = np.concatenate([\n                    route2[:seg2_start],\n                    route1[seg1_start:seg1_end + 1],\n                    route2[seg2_end + 1:]\n                ])\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route_indices[0]] = new_route1\n                    new_solution[route_indices[1]] = new_route2\n                    break\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.654809834980645,
            1.1603071689605713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))  # Sort by makespan (descending) then total distance (descending)\n    selected_idx = min(3, len(sorted_archive) - 1)  # Select from top 4 solutions\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Create a copy of the base solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation + demand-based insertion + adaptive 2-opt\n    for _ in range(2):  # Perform 2 iterations\n        # Step 1: Route segmentation - split long routes into smaller segments\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only consider routes with more than 3 customers\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = route[:split_pos + 1]\n                new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Demand-based insertion - move customers between routes\n        for _ in range(3):  # Try 3 insertions\n            # Select a random route and customer\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) <= 3:  # Skip if route has only depot and one customer\n                continue\n\n            customer_idx = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_idx]\n\n            # Try to insert into another route\n            to_route_idx = random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n            to_route = new_solution[to_route_idx]\n\n            # Find best insertion position in target route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(to_route)):\n                new_route = np.concatenate([to_route[:pos], [customer], to_route[pos:]])\n                if np.sum(demand[new_route[1:-1]]) > capacity:\n                    continue\n\n                # Calculate insertion cost\n                cost = (distance_matrix[to_route[pos-1]][customer] +\n                        distance_matrix[customer][to_route[pos]] -\n                        distance_matrix[to_route[pos-1]][to_route[pos]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            if best_cost < float('inf'):\n                # Perform the insertion\n                new_route = np.concatenate([to_route[:best_pos], [customer], to_route[best_pos:]])\n                new_solution[to_route_idx] = new_route\n\n                # Remove customer from original route\n                new_route = np.delete(from_route, customer_idx)\n                if len(new_route) > 2:  # Only keep if route still has customers\n                    new_solution[from_route_idx] = new_route\n                else:\n                    del new_solution[from_route_idx]\n                break\n\n        # Step 3: Adaptive 2-opt with capacity awareness\n        for _ in range(2):  # Try 2 2-opt swaps\n            # Select two random routes\n            route_indices = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n            route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n            # Select two random segments from each route (excluding depots)\n            if len(route1) > 3 and len(route2) > 3:\n                seg1_start = random.randint(1, len(route1) - 3)\n                seg1_end = random.randint(seg1_start, len(route1) - 2)\n\n                seg2_start = random.randint(1, len(route2) - 3)\n                seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n                # Create new routes by swapping segments\n                new_route1 = np.concatenate([\n                    route1[:seg1_start],\n                    route2[seg2_start:seg2_end + 1],\n                    route1[seg1_end + 1:]\n                ])\n\n                new_route2 = np.concatenate([\n                    route2[:seg2_start],\n                    route1[seg1_start:seg1_end + 1],\n                    route2[seg2_end + 1:]\n                ])\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route_indices[0]] = new_route1\n                    new_solution[route_indices[1]] = new_route2\n                    break\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)  # Weighted sum to balance objectives\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    selected_route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[selected_route_idx].copy()\n\n    # Apply a hybrid local search operator: route splitting and customer reinsertion\n    if len(selected_route) > 4:  # Ensure the route has enough nodes to split\n        # Split the route into two parts\n        split_point = np.random.randint(2, len(selected_route) - 2)\n        first_part = selected_route[:split_point + 1]\n        second_part = selected_route[split_point:]\n\n        # Check capacity constraints for both parts\n        first_demand = np.sum(demand[first_part[1:-1]])\n        second_demand = np.sum(demand[second_part[1:-1]])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace the original route with the two new routes\n            new_solution = [route.copy() for route in base_solution]\n            new_solution[selected_route_idx] = first_part\n            new_solution.insert(selected_route_idx + 1, second_part)\n            return new_solution\n\n    # If splitting fails, try reinserting a customer from another route\n    other_routes = [i for i in range(len(base_solution)) if i != selected_route_idx]\n    if other_routes:\n        # Select a random customer from another route\n        other_route_idx = np.random.choice(other_routes)\n        other_route = base_solution[other_route_idx].copy()\n        if len(other_route) > 3:  # Ensure there's a customer to move\n            customer_to_move = np.random.randint(1, len(other_route) - 1)\n            customer = other_route[customer_to_move]\n\n            # Find the best insertion position in the selected route\n            best_pos = -1\n            min_increase = float('inf')\n            for i in range(1, len(selected_route)):\n                # Insert customer between i-1 and i\n                new_route = np.concatenate([selected_route[:i], [customer], selected_route[i:]])\n                new_demand = np.sum(demand[new_route[1:-1]])\n                if new_demand <= capacity:\n                    # Calculate the increase in total distance\n                    dist_before = distance_matrix[selected_route[i-1], selected_route[i]]\n                    dist_after = distance_matrix[selected_route[i-1], customer] + distance_matrix[customer, selected_route[i]]\n                    increase = dist_after - dist_before\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n\n            if best_pos != -1:\n                # Perform the insertion\n                new_solution = [route.copy() for route in base_solution]\n                new_solution[selected_route_idx] = np.concatenate([selected_route[:best_pos], [customer], selected_route[best_pos:]])\n                # Remove the customer from the other route\n                new_solution[other_route_idx] = np.concatenate([other_route[:customer_to_move], other_route[customer_to_move + 1:]])\n                return new_solution\n\n    # If no improvement found, return the original solution\n    return base_solution\n\n",
        "score": [
            -0.7699339238423479,
            0.25029462575912476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)  # Weighted sum to balance objectives\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    selected_route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[selected_route_idx].copy()\n\n    # Apply a hybrid local search operator: route splitting and customer reinsertion\n    if len(selected_route) > 4:  # Ensure the route has enough nodes to split\n        # Split the route into two parts\n        split_point = np.random.randint(2, len(selected_route) - 2)\n        first_part = selected_route[:split_point + 1]\n        second_part = selected_route[split_point:]\n\n        # Check capacity constraints for both parts\n        first_demand = np.sum(demand[first_part[1:-1]])\n        second_demand = np.sum(demand[second_part[1:-1]])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace the original route with the two new routes\n            new_solution = [route.copy() for route in base_solution]\n            new_solution[selected_route_idx] = first_part\n            new_solution.insert(selected_route_idx + 1, second_part)\n            return new_solution\n\n    # If splitting fails, try reinserting a customer from another route\n    other_routes = [i for i in range(len(base_solution)) if i != selected_route_idx]\n    if other_routes:\n        # Select a random customer from another route\n        other_route_idx = np.random.choice(other_routes)\n        other_route = base_solution[other_route_idx].copy()\n        if len(other_route) > 3:  # Ensure there's a customer to move\n            customer_to_move = np.random.randint(1, len(other_route) - 1)\n            customer = other_route[customer_to_move]\n\n            # Find the best insertion position in the selected route\n            best_pos = -1\n            min_increase = float('inf')\n            for i in range(1, len(selected_route)):\n                # Insert customer between i-1 and i\n                new_route = np.concatenate([selected_route[:i], [customer], selected_route[i:]])\n                new_demand = np.sum(demand[new_route[1:-1]])\n                if new_demand <= capacity:\n                    # Calculate the increase in total distance\n                    dist_before = distance_matrix[selected_route[i-1], selected_route[i]]\n                    dist_after = distance_matrix[selected_route[i-1], customer] + distance_matrix[customer, selected_route[i]]\n                    increase = dist_after - dist_before\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n\n            if best_pos != -1:\n                # Perform the insertion\n                new_solution = [route.copy() for route in base_solution]\n                new_solution[selected_route_idx] = np.concatenate([selected_route[:best_pos], [customer], selected_route[best_pos:]])\n                # Remove the customer from the other route\n                new_solution[other_route_idx] = np.concatenate([other_route[:customer_to_move], other_route[customer_to_move + 1:]])\n                return new_solution\n\n    # If no improvement found, return the original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid of adaptive weight-based selection and makespan-focused diversification, then applies a novel \"Route Segmentation and Reassignment\" operator that intelligently splits and merges route segments while respecting capacity constraints, balancing distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives for selection\n        distances = np.array([s[1][0] for s in archive])\n        makespans = np.array([s[1][1] for s in archive])\n        norm_distances = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-8)\n        norm_makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n\n        # Weighted selection (more weight to makespan reduction)\n        weights = 0.7 * norm_makespans + 0.3 * norm_distances\n        selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply Route Segmentation and Reassignment\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find split points where capacity constraints are respected\n        valid_splits1 = []\n        current_demand = 0\n        for i in range(1, len(route1)-1):\n            current_demand += demand[route1[i]]\n            if current_demand <= capacity:\n                valid_splits1.append(i)\n\n        valid_splits2 = []\n        current_demand = 0\n        for i in range(1, len(route2)-1):\n            current_demand += demand[route2[i]]\n            if current_demand <= capacity:\n                valid_splits2.append(i)\n\n        if valid_splits1 and valid_splits2:\n            # Select random split points\n            split1 = random.choice(valid_splits1)\n            split2 = random.choice(valid_splits2)\n\n            # Create segments\n            segment1 = route1[split1:-1]\n            segment2 = route2[split2:-1]\n\n            # Check if merging segments would exceed capacity\n            total_demand = np.sum(demand[segment1]) + np.sum(demand[segment2])\n            if total_demand <= capacity:\n                # Merge segments (with depot at ends)\n                merged_segment = np.concatenate([[0], segment1[1:], segment2[1:], [0]])\n\n                # Update routes\n                new_solution[route1_idx] = np.concatenate([route1[:split1+1], [0]])\n                new_solution[route2_idx] = np.concatenate([route2[:split2+1], [0]])\n\n                # Add new merged route\n                new_solution.append(merged_segment)\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6462812703584111,
            1.7509288787841797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives for selection\n        distances = np.array([s[1][0] for s in archive])\n        makespans = np.array([s[1][1] for s in archive])\n        norm_distances = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-8)\n        norm_makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n\n        # Weighted selection (more weight to makespan reduction)\n        weights = 0.7 * norm_makespans + 0.3 * norm_distances\n        selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply Route Segmentation and Reassignment\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find split points where capacity constraints are respected\n        valid_splits1 = []\n        current_demand = 0\n        for i in range(1, len(route1)-1):\n            current_demand += demand[route1[i]]\n            if current_demand <= capacity:\n                valid_splits1.append(i)\n\n        valid_splits2 = []\n        current_demand = 0\n        for i in range(1, len(route2)-1):\n            current_demand += demand[route2[i]]\n            if current_demand <= capacity:\n                valid_splits2.append(i)\n\n        if valid_splits1 and valid_splits2:\n            # Select random split points\n            split1 = random.choice(valid_splits1)\n            split2 = random.choice(valid_splits2)\n\n            # Create segments\n            segment1 = route1[split1:-1]\n            segment2 = route2[split2:-1]\n\n            # Check if merging segments would exceed capacity\n            total_demand = np.sum(demand[segment1]) + np.sum(demand[segment2])\n            if total_demand <= capacity:\n                # Merge segments (with depot at ends)\n                merged_segment = np.concatenate([[0], segment1[1:], segment2[1:], [0]])\n\n                # Update routes\n                new_solution[route1_idx] = np.concatenate([route1[:split1+1], [0]])\n                new_solution[route2_idx] = np.concatenate([route2[:split2+1], [0]])\n\n                # Add new merged route\n                new_solution.append(merged_segment)\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search operator that combines route merging, intra-route 2-opt, and inter-route relocations to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # Prefer solutions with better total distance\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for (_, obj) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Route merging (if two routes can be combined without exceeding capacity)\n    if len(new_solution) > 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [route for k, route in enumerate(new_solution) if k not in [i, j]]\n            new_solution.append(merged_route)\n\n    # Step 2: Intra-route 2-opt with demand constraint\n    for route in new_solution:\n        if len(route) > 4:  # Only apply if route has enough nodes\n            a, b = sorted(random.sample(range(1, len(route)-1), 2))\n            # Check demand feasibility for reversed segment\n            segment_demand = np.sum(demand[route[a:b+1]])\n            if segment_demand <= capacity:\n                # Reverse segment\n                route[a:b+1] = route[a:b+1][::-1]\n\n    # Step 3: Inter-route relocation with demand constraint\n    if len(new_solution) > 1:\n        source_route_idx = random.randint(0, len(new_solution)-1)\n        target_route_idx = random.randint(0, len(new_solution)-1)\n        if source_route_idx != target_route_idx:\n            source_route = new_solution[source_route_idx]\n            target_route = new_solution[target_route_idx]\n\n            if len(source_route) > 2:  # Ensure source has nodes to move\n                # Select a random node from source route (not depot)\n                node_idx = random.randint(1, len(source_route)-2)\n                node = source_route[node_idx]\n\n                # Check if moving node to target route is feasible\n                if (np.sum(demand[target_route[1:-1]]) + demand[node]) <= capacity:\n                    # Remove node from source route\n                    new_source_route = np.concatenate([source_route[:node_idx], source_route[node_idx+1:]])\n                    new_solution[source_route_idx] = new_source_route\n\n                    # Insert node into target route (random position)\n                    insert_pos = random.randint(1, len(target_route)-1)\n                    new_target_route = np.concatenate([target_route[:insert_pos], [node], target_route[insert_pos:]])\n                    new_solution[target_route_idx] = new_target_route\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.6075877023232247,
            1.3277249038219452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # Prefer solutions with better total distance\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for (_, obj) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Route merging (if two routes can be combined without exceeding capacity)\n    if len(new_solution) > 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [route for k, route in enumerate(new_solution) if k not in [i, j]]\n            new_solution.append(merged_route)\n\n    # Step 2: Intra-route 2-opt with demand constraint\n    for route in new_solution:\n        if len(route) > 4:  # Only apply if route has enough nodes\n            a, b = sorted(random.sample(range(1, len(route)-1), 2))\n            # Check demand feasibility for reversed segment\n            segment_demand = np.sum(demand[route[a:b+1]])\n            if segment_demand <= capacity:\n                # Reverse segment\n                route[a:b+1] = route[a:b+1][::-1]\n\n    # Step 3: Inter-route relocation with demand constraint\n    if len(new_solution) > 1:\n        source_route_idx = random.randint(0, len(new_solution)-1)\n        target_route_idx = random.randint(0, len(new_solution)-1)\n        if source_route_idx != target_route_idx:\n            source_route = new_solution[source_route_idx]\n            target_route = new_solution[target_route_idx]\n\n            if len(source_route) > 2:  # Ensure source has nodes to move\n                # Select a random node from source route (not depot)\n                node_idx = random.randint(1, len(source_route)-2)\n                node = source_route[node_idx]\n\n                # Check if moving node to target route is feasible\n                if (np.sum(demand[target_route[1:-1]]) + demand[node]) <= capacity:\n                    # Remove node from source route\n                    new_source_route = np.concatenate([source_route[:node_idx], source_route[node_idx+1:]])\n                    new_solution[source_route_idx] = new_source_route\n\n                    # Insert node into target route (random position)\n                    insert_pos = random.randint(1, len(target_route)-1)\n                    new_target_route = np.concatenate([target_route[:insert_pos], [node], target_route[insert_pos:]])\n                    new_solution[target_route_idx] = new_target_route\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring solutions with better makespan and total distance, then applies a hybrid local search combining route splitting and merging with a novel intra-route segment reversal and insertion heuristic to balance objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting and merging with segment reversal and insertion\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Split routes at random points\n        split1 = random.randint(1, len(route1) - 2) if len(route1) > 2 else 1\n        split2 = random.randint(1, len(route2) - 2) if len(route2) > 2 else 1\n\n        # Create segments\n        seg1 = route1[split1:-1]\n        seg2 = route2[split2:-1]\n\n        # Reverse segments with probability 0.5\n        if random.random() < 0.5:\n            seg1 = seg1[::-1]\n        if random.random() < 0.5:\n            seg2 = seg2[::-1]\n\n        # Check capacity constraints for new segments\n        def is_feasible(segment):\n            total_demand = sum(demand[node] for node in segment)\n            return total_demand <= capacity\n\n        if is_feasible(seg1) and is_feasible(seg2):\n            # Merge segments into new routes\n            new_route1 = np.concatenate([route1[:split1], seg2, [0]])\n            new_route2 = np.concatenate([route2[:split2], seg1, [0]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Intra-route segment reversal and insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) > 3:\n            # Select a random segment\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end]\n\n            # Reverse segment with probability 0.5\n            if random.random() < 0.5:\n                segment = segment[::-1]\n\n            # Check capacity\n            if is_feasible(segment):\n                # Remove original segment\n                new_route = np.concatenate([route[:start], route[end:]])\n                # Insert segment at a random position\n                insert_pos = random.randint(1, len(new_route) - 1)\n                new_route = np.concatenate([new_route[:insert_pos], segment, new_route[insert_pos:]])\n                new_solution[i] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8250426954269989,
            0.7188847661018372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting and merging with segment reversal and insertion\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Split routes at random points\n        split1 = random.randint(1, len(route1) - 2) if len(route1) > 2 else 1\n        split2 = random.randint(1, len(route2) - 2) if len(route2) > 2 else 1\n\n        # Create segments\n        seg1 = route1[split1:-1]\n        seg2 = route2[split2:-1]\n\n        # Reverse segments with probability 0.5\n        if random.random() < 0.5:\n            seg1 = seg1[::-1]\n        if random.random() < 0.5:\n            seg2 = seg2[::-1]\n\n        # Check capacity constraints for new segments\n        def is_feasible(segment):\n            total_demand = sum(demand[node] for node in segment)\n            return total_demand <= capacity\n\n        if is_feasible(seg1) and is_feasible(seg2):\n            # Merge segments into new routes\n            new_route1 = np.concatenate([route1[:split1], seg2, [0]])\n            new_route2 = np.concatenate([route2[:split2], seg1, [0]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Intra-route segment reversal and insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) > 3:\n            # Select a random segment\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end]\n\n            # Reverse segment with probability 0.5\n            if random.random() < 0.5:\n                segment = segment[::-1]\n\n            # Check capacity\n            if is_feasible(segment):\n                # Remove original segment\n                new_route = np.concatenate([route[:start], route[end:]])\n                # Insert segment at a random position\n                insert_pos = random.randint(1, len(new_route) - 1)\n                new_route = np.concatenate([new_route[:insert_pos], segment, new_route[insert_pos:]])\n                new_solution[i] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: merge two routes and relocate segments\n    if len(selected_solution) > 1:\n        # Merge two shortest routes\n        route_indices = sorted(range(len(selected_solution)), key=lambda i: len(selected_solution[i]))\n        route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n        # Find feasible insertion points for merging\n        valid_insertions = []\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                # Check capacity constraint for merged segment\n                segment1 = route1[i:-1]\n                segment2 = route2[j:-1]\n                if sum(demand[segment1]) + sum(demand[segment2]) <= capacity:\n                    valid_insertions.append((i, j))\n\n        if valid_insertions:\n            i, j = random.choice(valid_insertions)\n            # Merge segments and create new route\n            new_route = np.concatenate([route1[:i], route2[j:-1], route1[i:-1], route2[-1:]])\n            # Remove merged routes and add new route\n            new_solution = [r for idx, r in enumerate(selected_solution) if idx not in route_indices]\n            new_solution.append(new_route)\n            return new_solution\n\n    # If merging fails, perform segment relocation\n    for route in selected_solution:\n        if len(route) > 3:  # Ensure route has segments to relocate\n            # Randomly select a segment to relocate\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end]\n\n            # Check capacity constraint for relocated segment\n            if sum(demand[segment]) <= capacity:\n                # Find best insertion point in another route\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for other_route in selected_solution:\n                    if np.array_equal(other_route, route):\n                        continue\n                    for i in range(1, len(other_route)):\n                        # Check capacity constraint\n                        if sum(demand[other_route[1:i]]) + sum(demand[segment]) + sum(demand[other_route[i:-1]]) <= capacity:\n                            # Calculate insertion cost\n                            cost = (distance_matrix[other_route[i-1], segment[0]] +\n                                    distance_matrix[segment[-1], other_route[i]] -\n                                    distance_matrix[other_route[i-1], other_route[i]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = other_route\n                                best_pos = i\n\n                if best_route is not None:\n                    # Perform relocation\n                    new_route = np.concatenate([\n                        best_route[:best_pos],\n                        segment,\n                        best_route[best_pos:]\n                    ])\n                    # Update routes\n                    new_solution = [r for r in selected_solution if not np.array_equal(r, route)]\n                    new_solution.append(new_route)\n                    return new_solution\n\n    # If no improvement found, return original solution\n    return selected_solution\n\n",
        "score": [
            -0.7943099539878595,
            0.6907411515712738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: merge two routes and relocate segments\n    if len(selected_solution) > 1:\n        # Merge two shortest routes\n        route_indices = sorted(range(len(selected_solution)), key=lambda i: len(selected_solution[i]))\n        route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n        # Find feasible insertion points for merging\n        valid_insertions = []\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                # Check capacity constraint for merged segment\n                segment1 = route1[i:-1]\n                segment2 = route2[j:-1]\n                if sum(demand[segment1]) + sum(demand[segment2]) <= capacity:\n                    valid_insertions.append((i, j))\n\n        if valid_insertions:\n            i, j = random.choice(valid_insertions)\n            # Merge segments and create new route\n            new_route = np.concatenate([route1[:i], route2[j:-1], route1[i:-1], route2[-1:]])\n            # Remove merged routes and add new route\n            new_solution = [r for idx, r in enumerate(selected_solution) if idx not in route_indices]\n            new_solution.append(new_route)\n            return new_solution\n\n    # If merging fails, perform segment relocation\n    for route in selected_solution:\n        if len(route) > 3:  # Ensure route has segments to relocate\n            # Randomly select a segment to relocate\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end]\n\n            # Check capacity constraint for relocated segment\n            if sum(demand[segment]) <= capacity:\n                # Find best insertion point in another route\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for other_route in selected_solution:\n                    if np.array_equal(other_route, route):\n                        continue\n                    for i in range(1, len(other_route)):\n                        # Check capacity constraint\n                        if sum(demand[other_route[1:i]]) + sum(demand[segment]) + sum(demand[other_route[i:-1]]) <= capacity:\n                            # Calculate insertion cost\n                            cost = (distance_matrix[other_route[i-1], segment[0]] +\n                                    distance_matrix[segment[-1], other_route[i]] -\n                                    distance_matrix[other_route[i-1], other_route[i]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = other_route\n                                best_pos = i\n\n                if best_route is not None:\n                    # Perform relocation\n                    new_route = np.concatenate([\n                        best_route[:best_pos],\n                        segment,\n                        best_route[best_pos:]\n                    ])\n                    # Update routes\n                    new_solution = [r for r in selected_solution if not np.array_equal(r, route)]\n                    new_solution.append(new_route)\n                    return new_solution\n\n    # If no improvement found, return original solution\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    top_30 = archive_sorted[:max(1, int(0.3 * len(archive)))]\n    selected_solution = random.choice(top_30)[0]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Split route at a random customer node\n        if len(route) > 3:  # Ensure route can be split\n            split_idx = random.randint(1, len(route)-2)\n            route1 = route[:split_idx+1]\n            route2 = [0] + route[split_idx:-1] + [0]\n\n            # Check capacity constraints\n            if (sum(demand[route1]) <= capacity) and (sum(demand[route2]) <= capacity):\n                new_solution.extend([np.array(route1), np.array(route2)])\n            else:\n                new_solution.append(route.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Randomly reallocate a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = random.randint(0, len(new_solution)-1)\n        from_route = new_solution[from_route_idx]\n        if len(from_route) > 2:  # Route has customers to reallocate\n            customer_to_move = random.choice(from_route[1:-1])\n            new_solution[from_route_idx] = np.array([x for x in from_route if x != customer_to_move])\n\n            # Find feasible insertion point in another route\n            for to_route_idx in range(len(new_solution)):\n                if to_route_idx != from_route_idx:\n                    to_route = new_solution[to_route_idx]\n                    if sum(demand[to_route]) + demand[customer_to_move] <= capacity:\n                        # Insert at position that minimizes additional distance\n                        min_cost = float('inf')\n                        best_pos = 1\n                        for i in range(1, len(to_route)):\n                            cost = (distance_matrix[to_route[i-1]][customer_to_move] +\n                                    distance_matrix[customer_to_move][to_route[i]] -\n                                    distance_matrix[to_route[i-1]][to_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n                        new_to_route = np.concatenate([to_route[:best_pos], [customer_to_move], to_route[best_pos:]])\n                        new_solution[to_route_idx] = new_to_route\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8125942747559023,
            0.4572307765483856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    top_30 = archive_sorted[:max(1, int(0.3 * len(archive)))]\n    selected_solution = random.choice(top_30)[0]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Split route at a random customer node\n        if len(route) > 3:  # Ensure route can be split\n            split_idx = random.randint(1, len(route)-2)\n            route1 = route[:split_idx+1]\n            route2 = [0] + route[split_idx:-1] + [0]\n\n            # Check capacity constraints\n            if (sum(demand[route1]) <= capacity) and (sum(demand[route2]) <= capacity):\n                new_solution.extend([np.array(route1), np.array(route2)])\n            else:\n                new_solution.append(route.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Randomly reallocate a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = random.randint(0, len(new_solution)-1)\n        from_route = new_solution[from_route_idx]\n        if len(from_route) > 2:  # Route has customers to reallocate\n            customer_to_move = random.choice(from_route[1:-1])\n            new_solution[from_route_idx] = np.array([x for x in from_route if x != customer_to_move])\n\n            # Find feasible insertion point in another route\n            for to_route_idx in range(len(new_solution)):\n                if to_route_idx != from_route_idx:\n                    to_route = new_solution[to_route_idx]\n                    if sum(demand[to_route]) + demand[customer_to_move] <= capacity:\n                        # Insert at position that minimizes additional distance\n                        min_cost = float('inf')\n                        best_pos = 1\n                        for i in range(1, len(to_route)):\n                            cost = (distance_matrix[to_route[i-1]][customer_to_move] +\n                                    distance_matrix[customer_to_move][to_route[i]] -\n                                    distance_matrix[to_route[i-1]][to_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n                        new_to_route = np.concatenate([to_route[:best_pos], [customer_to_move], to_route[best_pos:]])\n                        new_solution[to_route_idx] = new_to_route\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{A novel hybrid local search strategy that combines route merging, partial route reversal, and adaptive demand-based node swaps to balance distance and makespan minimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1] + x[1][0])  # Sort by sum of objectives\n    selected_solution = archive[-1][0].copy()  # Select the worst solution for improvement\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search\n    # 1. Route merging if two routes have low load and can be merged\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                    # Merge route2 into route1\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    break\n\n    # 2. Partial route reversal for selected routes\n    for route in new_solution:\n        if len(route) > 4:  # Only reverse if route has enough nodes\n            start_idx = random.randint(1, len(route) - 3)\n            end_idx = random.randint(start_idx + 1, len(route) - 2)\n            route[start_idx:end_idx] = route[start_idx:end_idx][::-1]\n\n    # 3. Adaptive demand-based node swaps\n    for route in new_solution:\n        if len(route) > 3:\n            for _ in range(2):  # Try a few swaps per route\n                i, j = random.sample(range(1, len(route) - 1), 2)\n                if demand[route[i]] + demand[route[j]] <= capacity:\n                    # Swap nodes if demand constraint is satisfied\n                    route[i], route[j] = route[j], route[i]\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If route is infeasible, split it into two\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.remove(route)\n            new_solution.extend([new_route1, new_route2])\n\n    return new_solution\n\n",
        "score": [
            -0.694998079301369,
            2.7320801317691803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1] + x[1][0])  # Sort by sum of objectives\n    selected_solution = archive[-1][0].copy()  # Select the worst solution for improvement\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search\n    # 1. Route merging if two routes have low load and can be merged\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                    # Merge route2 into route1\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    break\n\n    # 2. Partial route reversal for selected routes\n    for route in new_solution:\n        if len(route) > 4:  # Only reverse if route has enough nodes\n            start_idx = random.randint(1, len(route) - 3)\n            end_idx = random.randint(start_idx + 1, len(route) - 2)\n            route[start_idx:end_idx] = route[start_idx:end_idx][::-1]\n\n    # 3. Adaptive demand-based node swaps\n    for route in new_solution:\n        if len(route) > 3:\n            for _ in range(2):  # Try a few swaps per route\n                i, j = random.sample(range(1, len(route) - 1), 2)\n                if demand[route[i]] + demand[route[j]] <= capacity:\n                    # Swap nodes if demand constraint is satisfied\n                    route[i], route[j] = route[j], route[i]\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If route is infeasible, split it into two\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.remove(route)\n            new_solution.extend([new_route1, new_route2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge-split-2opt\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by concatenating them and removing duplicate depot nodes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n            # Apply selective 2-opt on the merged route\n            improved_route = selective_2opt(merged_route, distance_matrix, demand, capacity)\n            new_solution[i] = improved_route\n\n    # Apply route splitting if any route exceeds capacity\n    for idx, route in enumerate(new_solution):\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Split the route into two parts at a feasible point\n            split_point = find_split_point(route, demand, capacity)\n            part1 = np.concatenate([route[:split_point+1], [0]])\n            part2 = np.concatenate([[0], route[split_point+1:]])\n            new_solution[idx] = part1\n            new_solution.insert(idx+1, part2)\n\n    # Apply demand-aware edge swaps between routes\n    for _ in range(3):  # Limit iterations to balance exploration and computation\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            # Find feasible edge swaps between routes\n            for k in range(1, len(route1)-1):\n                for l in range(1, len(route2)-1):\n                    # Check if swapping edges k and l is feasible\n                    if (np.sum(demand[route1[1:k]]) + demand[route2[l]] <= capacity and\n                        np.sum(demand[route2[1:l]]) + demand[route1[k]] <= capacity):\n                        # Perform the swap\n                        new_route1 = np.concatenate([route1[:k], [route2[l]], route1[k+1:]])\n                        new_route2 = np.concatenate([route2[:l], [route1[k]], route2[l+1:]])\n                        new_solution[i] = new_route1\n                        new_solution[j] = new_route2\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.3942704156464971,
            2.8928100764751434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge-split-2opt\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by concatenating them and removing duplicate depot nodes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n            # Apply selective 2-opt on the merged route\n            improved_route = selective_2opt(merged_route, distance_matrix, demand, capacity)\n            new_solution[i] = improved_route\n\n    # Apply route splitting if any route exceeds capacity\n    for idx, route in enumerate(new_solution):\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Split the route into two parts at a feasible point\n            split_point = find_split_point(route, demand, capacity)\n            part1 = np.concatenate([route[:split_point+1], [0]])\n            part2 = np.concatenate([[0], route[split_point+1:]])\n            new_solution[idx] = part1\n            new_solution.insert(idx+1, part2)\n\n    # Apply demand-aware edge swaps between routes\n    for _ in range(3):  # Limit iterations to balance exploration and computation\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            # Find feasible edge swaps between routes\n            for k in range(1, len(route1)-1):\n                for l in range(1, len(route2)-1):\n                    # Check if swapping edges k and l is feasible\n                    if (np.sum(demand[route1[1:k]]) + demand[route2[l]] <= capacity and\n                        np.sum(demand[route2[1:l]]) + demand[route1[k]] <= capacity):\n                        # Perform the swap\n                        new_route1 = np.concatenate([route1[:k], [route2[l]], route1[k+1:]])\n                        new_route2 = np.concatenate([route2[:l], [route1[k]], route2[l+1:]])\n                        new_solution[i] = new_route1\n                        new_solution[j] = new_route2\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough customers to split\n            # Randomly select a split point (not at the start or end)\n            split_point = np.random.randint(2, len(route) - 2)\n            first_part = route[:split_point + 1]\n            second_part = route[split_point:]\n\n            # Check capacity constraints for both parts\n            first_load = np.sum(demand[first_part[1:-1]])\n            second_load = np.sum(demand[second_part[1:-1]])\n\n            if first_load <= capacity and second_load <= capacity:\n                # Replace the original route with the two split routes\n                new_solution[i] = first_part\n                new_solution.insert(i + 1, second_part)\n                break\n\n    # Randomly select a route to improve by inserting a customer from another route\n    if len(new_solution) > 1:\n        route_idx1 = np.random.randint(len(new_solution))\n        route_idx2 = (route_idx1 + np.random.randint(1, len(new_solution))) % len(new_solution)\n\n        route1 = new_solution[route_idx1]\n        route2 = new_solution[route_idx2]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select a customer from route1 (not depot)\n            customer_idx = np.random.randint(1, len(route1) - 1)\n            customer = route1[customer_idx]\n\n            # Try to insert this customer into route2 at different positions\n            best_insert_pos = -1\n            best_insert_cost = float('inf')\n\n            for pos in range(1, len(route2)):\n                # Create a temporary insertion\n                temp_route = np.insert(route2, pos, customer)\n                temp_load = np.sum(demand[temp_route[1:-1]])\n\n                if temp_load <= capacity:\n                    # Calculate the cost of this insertion\n                    cost = (distance_matrix[temp_route[pos-1], customer] +\n                            distance_matrix[customer, temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1], temp_route[pos+1]])\n\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_insert_pos = pos\n\n            if best_insert_pos != -1:\n                # Perform the insertion\n                new_solution[route_idx2] = np.insert(route2, best_insert_pos, customer)\n\n                # Remove the customer from its original route\n                new_solution[route_idx1] = np.delete(route1, customer_idx)\n\n                # If the original route becomes empty (only depot), remove it\n                if len(new_solution[route_idx1]) <= 2:\n                    new_solution.pop(route_idx1)\n\n    return new_solution\n\n",
        "score": [
            -0.6914361520410344,
            1.1953602135181427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough customers to split\n            # Randomly select a split point (not at the start or end)\n            split_point = np.random.randint(2, len(route) - 2)\n            first_part = route[:split_point + 1]\n            second_part = route[split_point:]\n\n            # Check capacity constraints for both parts\n            first_load = np.sum(demand[first_part[1:-1]])\n            second_load = np.sum(demand[second_part[1:-1]])\n\n            if first_load <= capacity and second_load <= capacity:\n                # Replace the original route with the two split routes\n                new_solution[i] = first_part\n                new_solution.insert(i + 1, second_part)\n                break\n\n    # Randomly select a route to improve by inserting a customer from another route\n    if len(new_solution) > 1:\n        route_idx1 = np.random.randint(len(new_solution))\n        route_idx2 = (route_idx1 + np.random.randint(1, len(new_solution))) % len(new_solution)\n\n        route1 = new_solution[route_idx1]\n        route2 = new_solution[route_idx2]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select a customer from route1 (not depot)\n            customer_idx = np.random.randint(1, len(route1) - 1)\n            customer = route1[customer_idx]\n\n            # Try to insert this customer into route2 at different positions\n            best_insert_pos = -1\n            best_insert_cost = float('inf')\n\n            for pos in range(1, len(route2)):\n                # Create a temporary insertion\n                temp_route = np.insert(route2, pos, customer)\n                temp_load = np.sum(demand[temp_route[1:-1]])\n\n                if temp_load <= capacity:\n                    # Calculate the cost of this insertion\n                    cost = (distance_matrix[temp_route[pos-1], customer] +\n                            distance_matrix[customer, temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1], temp_route[pos+1]])\n\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_insert_pos = pos\n\n            if best_insert_pos != -1:\n                # Perform the insertion\n                new_solution[route_idx2] = np.insert(route2, best_insert_pos, customer)\n\n                # Remove the customer from its original route\n                new_solution[route_idx1] = np.delete(route1, customer_idx)\n\n                # If the original route becomes empty (only depot), remove it\n                if len(new_solution[route_idx1]) <= 2:\n                    new_solution.pop(route_idx1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts at a random point\n            split_idx = np.random.randint(1, len(route) - 2)\n            part1 = route[:split_idx + 1]\n            part2 = route[split_idx:]\n\n            # Check capacity constraints for both parts\n            if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n                new_solution.append(part1)\n                new_solution.append(part2)\n            else:\n                # If splitting violates capacity, try reinserting customers\n                customers = route[1:-1]\n                np.random.shuffle(customers)\n                for customer in customers:\n                    inserted = False\n                    for i, r in enumerate(new_solution):\n                        if sum(demand[r[1:-1]]) + demand[customer] <= capacity:\n                            # Insert customer into the first feasible position\n                            for j in range(1, len(r)):\n                                r_inserted = np.insert(r, j, customer)\n                                if sum(demand[r_inserted[1:-1]]) <= capacity:\n                                    new_solution[i] = r_inserted\n                                    inserted = True\n                                    break\n                            if inserted:\n                                break\n                    if not inserted:\n                        # If not inserted into any existing route, create a new one\n                        new_route = np.array([0, customer, 0])\n                        if sum(demand[new_route[1:-1]]) <= capacity:\n                            new_solution.append(new_route)\n        else:\n            new_solution.append(route)\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served (fallback to greedy insertion if not)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = list(all_customers - served_customers)\n\n    if missing_customers:\n        for customer in missing_customers:\n            inserted = False\n            # Try to insert into existing routes\n            for i, route in enumerate(new_solution):\n                for j in range(1, len(route)):\n                    route_inserted = np.insert(route, j, customer)\n                    if sum(demand[route_inserted[1:-1]]) <= capacity:\n                        new_solution[i] = route_inserted\n                        inserted = True\n                        break\n                if inserted:\n                    break\n            if not inserted:\n                # Create a new route if no feasible insertion\n                new_route = np.array([0, customer, 0])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.6672559677015076,
            6.6509108543396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts at a random point\n            split_idx = np.random.randint(1, len(route) - 2)\n            part1 = route[:split_idx + 1]\n            part2 = route[split_idx:]\n\n            # Check capacity constraints for both parts\n            if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n                new_solution.append(part1)\n                new_solution.append(part2)\n            else:\n                # If splitting violates capacity, try reinserting customers\n                customers = route[1:-1]\n                np.random.shuffle(customers)\n                for customer in customers:\n                    inserted = False\n                    for i, r in enumerate(new_solution):\n                        if sum(demand[r[1:-1]]) + demand[customer] <= capacity:\n                            # Insert customer into the first feasible position\n                            for j in range(1, len(r)):\n                                r_inserted = np.insert(r, j, customer)\n                                if sum(demand[r_inserted[1:-1]]) <= capacity:\n                                    new_solution[i] = r_inserted\n                                    inserted = True\n                                    break\n                            if inserted:\n                                break\n                    if not inserted:\n                        # If not inserted into any existing route, create a new one\n                        new_route = np.array([0, customer, 0])\n                        if sum(demand[new_route[1:-1]]) <= capacity:\n                            new_solution.append(new_route)\n        else:\n            new_solution.append(route)\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served (fallback to greedy insertion if not)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = list(all_customers - served_customers)\n\n    if missing_customers:\n        for customer in missing_customers:\n            inserted = False\n            # Try to insert into existing routes\n            for i, route in enumerate(new_solution):\n                for j in range(1, len(route)):\n                    route_inserted = np.insert(route, j, customer)\n                    if sum(demand[route_inserted[1:-1]]) <= capacity:\n                        new_solution[i] = route_inserted\n                        inserted = True\n                        break\n                if inserted:\n                    break\n            if not inserted:\n                # Create a new route if no feasible insertion\n                new_route = np.array([0, customer, 0])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] * 0.1 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[np.concatenate([route1[1:-1], route2[1:-1]])])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1 at the closest position\n            min_dist = float('inf')\n            best_pos = -1\n            for i in range(len(route1) - 1):\n                dist = distance_matrix[route1[i], route2[1]] + distance_matrix[route2[-2], route1[i+1]] - distance_matrix[route1[i], route1[i+1]]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pos = i\n\n            # Perform the merge\n            merged_route = np.concatenate([route1[:best_pos+1], route2[1:-1], route1[best_pos+1:]])\n            new_solution[route1_idx] = merged_route\n\n            # Remove the merged route\n            if route1_idx < route2_idx:\n                del new_solution[route2_idx]\n            else:\n                del new_solution[route2_idx - 1]\n\n    # Customer reallocation: move a random customer from one route to another if feasible\n    if len(new_solution) > 1:\n        # Select a random route to remove a customer from\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure there's at least one customer to move\n            # Select a random customer to move\n            customer_idx = np.random.randint(1, len(route) - 1)\n            customer = route[customer_idx]\n\n            # Try to insert this customer into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n                    # Check if adding the customer exceeds capacity\n                    other_route_demand = np.sum(demand[other_route[1:-1]])\n                    if other_route_demand + demand[customer] <= capacity:\n                        # Find the best insertion position in the other route\n                        min_dist = float('inf')\n                        best_pos = -1\n                        for i in range(len(other_route) - 1):\n                            dist = distance_matrix[other_route[i], customer] + distance_matrix[customer, other_route[i+1]] - distance_matrix[other_route[i], other_route[i+1]]\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_pos = i\n\n                        # Perform the insertion\n                        new_other_route = np.concatenate([other_route[:best_pos+1], [customer], other_route[best_pos+1:]])\n                        new_solution[other_route_idx] = new_other_route\n\n                        # Remove the customer from the original route\n                        new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                        new_solution[route_idx] = new_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6941622661653064,
            1.0109521448612213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] * 0.1 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[np.concatenate([route1[1:-1], route2[1:-1]])])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1 at the closest position\n            min_dist = float('inf')\n            best_pos = -1\n            for i in range(len(route1) - 1):\n                dist = distance_matrix[route1[i], route2[1]] + distance_matrix[route2[-2], route1[i+1]] - distance_matrix[route1[i], route1[i+1]]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pos = i\n\n            # Perform the merge\n            merged_route = np.concatenate([route1[:best_pos+1], route2[1:-1], route1[best_pos+1:]])\n            new_solution[route1_idx] = merged_route\n\n            # Remove the merged route\n            if route1_idx < route2_idx:\n                del new_solution[route2_idx]\n            else:\n                del new_solution[route2_idx - 1]\n\n    # Customer reallocation: move a random customer from one route to another if feasible\n    if len(new_solution) > 1:\n        # Select a random route to remove a customer from\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure there's at least one customer to move\n            # Select a random customer to move\n            customer_idx = np.random.randint(1, len(route) - 1)\n            customer = route[customer_idx]\n\n            # Try to insert this customer into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n                    # Check if adding the customer exceeds capacity\n                    other_route_demand = np.sum(demand[other_route[1:-1]])\n                    if other_route_demand + demand[customer] <= capacity:\n                        # Find the best insertion position in the other route\n                        min_dist = float('inf')\n                        best_pos = -1\n                        for i in range(len(other_route) - 1):\n                            dist = distance_matrix[other_route[i], customer] + distance_matrix[customer, other_route[i+1]] - distance_matrix[other_route[i], other_route[i+1]]\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_pos = i\n\n                        # Perform the insertion\n                        new_other_route = np.concatenate([other_route[:best_pos+1], [customer], other_route[best_pos+1:]])\n                        new_solution[other_route_idx] = new_other_route\n\n                        # Remove the customer from the original route\n                        new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                        new_solution[route_idx] = new_route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{The algorithm intelligently selects a solution with high potential for improvement by combining an adaptive route-segment swapping mechanism with a demand-aware makespan balancing strategy, while ensuring feasibility through iterative capacity checks and local reoptimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Adaptive route segment swap with demand-aware balancing\n    new_solution = selected_solution.copy()\n\n    # Step 1: Identify routes with high makespan and low distance\n    makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    max_makespan_route = np.argmax(makespans)\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Step 2: Swap segments between routes to balance makespan\n    for _ in range(5):  # Limited iterations for efficiency\n        route1 = new_solution[max_makespan_route]\n        route2 = new_solution[(max_makespan_route + 1) % len(new_solution)]\n\n        # Find segments to swap (avoid depot nodes)\n        seg1_start = np.random.randint(1, len(route1)-1)\n        seg1_end = np.random.randint(seg1_start, len(route1)-1)\n        seg2_start = np.random.randint(1, len(route2)-1)\n        seg2_end = np.random.randint(seg2_start, len(route2)-1)\n\n        # Perform swap\n        new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end+1], route1[seg1_end+1:]])\n        new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end+1], route2[seg2_end+1:]])\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Update solution if improvement is found\n            new_solution[max_makespan_route] = new_route1\n            new_solution[(max_makespan_route + 1) % len(new_solution)] = new_route2\n\n            # Recalculate makespans for next iteration\n            makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            max_makespan_route = np.argmax(makespans)\n\n    return new_solution\n\n",
        "score": [
            -0.6862082847869023,
            2.6313477754592896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Adaptive route segment swap with demand-aware balancing\n    new_solution = selected_solution.copy()\n\n    # Step 1: Identify routes with high makespan and low distance\n    makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    max_makespan_route = np.argmax(makespans)\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Step 2: Swap segments between routes to balance makespan\n    for _ in range(5):  # Limited iterations for efficiency\n        route1 = new_solution[max_makespan_route]\n        route2 = new_solution[(max_makespan_route + 1) % len(new_solution)]\n\n        # Find segments to swap (avoid depot nodes)\n        seg1_start = np.random.randint(1, len(route1)-1)\n        seg1_end = np.random.randint(seg1_start, len(route1)-1)\n        seg2_start = np.random.randint(1, len(route2)-1)\n        seg2_end = np.random.randint(seg2_start, len(route2)-1)\n\n        # Perform swap\n        new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end+1], route1[seg1_end+1:]])\n        new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end+1], route2[seg2_end+1:]])\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Update solution if improvement is found\n            new_solution[max_makespan_route] = new_route1\n            new_solution[(max_makespan_route + 1) % len(new_solution)] = new_route2\n\n            # Recalculate makespans for next iteration\n            makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            max_makespan_route = np.argmax(makespans)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and 2-opt with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select two non-depot nodes for 2-opt\n        i, j = sorted(random.sample(range(1, len(route)-1), 2))\n\n        # Check capacity constraints for the new segments\n        segment1 = route[:i+1]\n        segment2 = route[i+1:j+1]\n        segment3 = route[j+1:]\n\n        new_route1 = np.concatenate([segment1, segment2[::-1], segment3])\n        new_route2 = np.concatenate([segment1, segment3[::-1], segment2])\n\n        # Check capacity for new_route1\n        valid1 = True\n        for r in [new_route1, new_route2]:\n            current_load = 0\n            for node in r[1:-1]:  # Exclude depot\n                current_load += demand[node]\n                if current_load > capacity:\n                    valid1 = False\n                    break\n            if not valid1:\n                break\n\n        if valid1:\n            new_solution.append(new_route1)\n        else:\n            new_solution.append(route.copy())\n\n        # Additional route splitting if possible\n        if len(new_solution[-1]) > 4 and random.random() < 0.3:\n            split_pos = random.randint(2, len(new_solution[-1])-3)\n            new_route_a = np.concatenate([new_solution[-1][:split_pos], [0]])\n            new_route_b = np.concatenate([[0], new_solution[-1][split_pos:]])\n\n            # Check capacity for both new routes\n            valid_split = True\n            for r in [new_route_a, new_route_b]:\n                current_load = 0\n                for node in r[1:-1]:\n                    current_load += demand[node]\n                    if current_load > capacity:\n                        valid_split = False\n                        break\n                if not valid_split:\n                    break\n\n            if valid_split:\n                new_solution[-1:] = [new_route_a, new_route_b]\n\n    return new_solution\n\n",
        "score": [
            -0.6775908281763604,
            2.2980067431926727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and 2-opt with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select two non-depot nodes for 2-opt\n        i, j = sorted(random.sample(range(1, len(route)-1), 2))\n\n        # Check capacity constraints for the new segments\n        segment1 = route[:i+1]\n        segment2 = route[i+1:j+1]\n        segment3 = route[j+1:]\n\n        new_route1 = np.concatenate([segment1, segment2[::-1], segment3])\n        new_route2 = np.concatenate([segment1, segment3[::-1], segment2])\n\n        # Check capacity for new_route1\n        valid1 = True\n        for r in [new_route1, new_route2]:\n            current_load = 0\n            for node in r[1:-1]:  # Exclude depot\n                current_load += demand[node]\n                if current_load > capacity:\n                    valid1 = False\n                    break\n            if not valid1:\n                break\n\n        if valid1:\n            new_solution.append(new_route1)\n        else:\n            new_solution.append(route.copy())\n\n        # Additional route splitting if possible\n        if len(new_solution[-1]) > 4 and random.random() < 0.3:\n            split_pos = random.randint(2, len(new_solution[-1])-3)\n            new_route_a = np.concatenate([new_solution[-1][:split_pos], [0]])\n            new_route_b = np.concatenate([[0], new_solution[-1][split_pos:]])\n\n            # Check capacity for both new routes\n            valid_split = True\n            for r in [new_route_a, new_route_b]:\n                current_load = 0\n                for node in r[1:-1]:\n                    current_load += demand[node]\n                    if current_load > capacity:\n                        valid_split = False\n                        break\n                if not valid_split:\n                    break\n\n            if valid_split:\n                new_solution[-1:] = [new_route_a, new_route_b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by considering both objectives, then applies a hybrid local search combining route splitting, customer reallocation, and cross-route swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split routes, reallocate customers, and cross-route swaps\n    new_solution = []\n    for route in selected_solution:\n        # Split the route if it exceeds capacity or has high distance\n        if np.sum(demand[route[1:-1]]) > capacity or len(route) > 5:\n            # Split into two parts\n            split_idx = len(route) // 2\n            new_solution.append(np.concatenate(([0], route[1:split_idx], [0])))\n            new_solution.append(np.concatenate(([0], route[split_idx:-1], [0])))\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    for _ in range(3):  # Number of reallocation attempts\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1, route2 = random.sample(new_solution, 2)\n        # Find a customer in route1 to move to route2\n        for i in range(1, len(route1)-1):\n            customer = route1[i]\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Move customer from route1 to route2\n                route1 = np.concatenate((route1[:i], route1[i+1:]))\n                route2 = np.concatenate((route2[:-1], [customer], [0]))\n                break\n\n    # Cross-route swaps to reduce total distance\n    for _ in range(5):  # Number of swap attempts\n        if len(new_solution) < 2:\n            break\n        route1, route2 = random.sample(new_solution, 2)\n        # Find two customers, one from each route, to swap\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                customer1, customer2 = route1[i], route2[j]\n                # Check capacity constraints\n                if (np.sum(demand[route1[1:-1]]) - demand[customer1] + demand[customer2] <= capacity and\n                    np.sum(demand[route2[1:-1]]) - demand[customer2] + demand[customer1] <= capacity):\n                    # Swap customers\n                    route1[i], route2[j] = route2[j], route1[i]\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6651019628274997,
            2.6015940606594086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split routes, reallocate customers, and cross-route swaps\n    new_solution = []\n    for route in selected_solution:\n        # Split the route if it exceeds capacity or has high distance\n        if np.sum(demand[route[1:-1]]) > capacity or len(route) > 5:\n            # Split into two parts\n            split_idx = len(route) // 2\n            new_solution.append(np.concatenate(([0], route[1:split_idx], [0])))\n            new_solution.append(np.concatenate(([0], route[split_idx:-1], [0])))\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    for _ in range(3):  # Number of reallocation attempts\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1, route2 = random.sample(new_solution, 2)\n        # Find a customer in route1 to move to route2\n        for i in range(1, len(route1)-1):\n            customer = route1[i]\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Move customer from route1 to route2\n                route1 = np.concatenate((route1[:i], route1[i+1:]))\n                route2 = np.concatenate((route2[:-1], [customer], [0]))\n                break\n\n    # Cross-route swaps to reduce total distance\n    for _ in range(5):  # Number of swap attempts\n        if len(new_solution) < 2:\n            break\n        route1, route2 = random.sample(new_solution, 2)\n        # Find two customers, one from each route, to swap\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                customer1, customer2 = route1[i], route2[j]\n                # Check capacity constraints\n                if (np.sum(demand[route1[1:-1]]) - demand[customer1] + demand[customer2] <= capacity and\n                    np.sum(demand[route2[1:-1]]) - demand[customer2] + demand[customer1] <= capacity):\n                    # Swap customers\n                    route1[i], route2[j] = route2[j], route1[i]\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search steps\n    if len(new_solution) > 1:\n        # Step 1: Merge two shortest routes if their combined demand is <= capacity\n        route_lengths = [sum(demand[route[1:-1]]) for route in new_solution]\n        shortest_route_idx = np.argmin(route_lengths)\n        second_shortest_route_idx = np.argsort(route_lengths)[1] if len(new_solution) > 1 else -1\n\n        if second_shortest_route_idx != -1:\n            route1 = new_solution[shortest_route_idx]\n            route2 = new_solution[second_shortest_route_idx]\n            combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n            if combined_demand <= capacity:\n                # Merge routes by connecting them via the closest pair of nodes\n                last_node_route1 = route1[-2]\n                first_node_route2 = route2[1]\n\n                # Find the closest pair of nodes between the two routes\n                min_dist = float('inf')\n                best_pair = (0, 0)\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        dist = distance_matrix[route1[i], route2[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pair = (i, j)\n\n                # Merge the routes at the best pair\n                merged_route = np.concatenate([\n                    route1[:best_pair[0]+1],\n                    route2[best_pair[1]:]\n                ])\n\n                # Update the solution\n                new_solution[shortest_route_idx] = merged_route\n                new_solution.pop(second_shortest_route_idx)\n\n        # Step 2: Reverse a segment of the longest route to reduce distance\n        if len(new_solution) > 0:\n            longest_route_idx = np.argmax([len(route) for route in new_solution])\n            longest_route = new_solution[longest_route_idx].copy()\n\n            if len(longest_route) > 3:\n                # Select a random segment to reverse\n                start = np.random.randint(1, len(longest_route)-2)\n                end = np.random.randint(start+1, len(longest_route)-1)\n                reversed_segment = longest_route[start:end+1][::-1]\n\n                # Check capacity feasibility\n                if sum(demand[reversed_segment[1:-1]]) <= capacity:\n                    longest_route[start:end+1] = reversed_segment\n                    new_solution[longest_route_idx] = longest_route\n\n        # Step 3: Reinsert a customer from a route with high demand to another route with low demand\n        if len(new_solution) > 1:\n            # Find the route with the highest average demand per customer\n            avg_demands = [sum(demand[route[1:-1]]) / (len(route)-2) if len(route) > 2 else 0 for route in new_solution]\n            high_demand_route_idx = np.argmax(avg_demands)\n            high_demand_route = new_solution[high_demand_route_idx].copy()\n\n            if len(high_demand_route) > 3:\n                # Select a random customer to reinsert\n                customer_idx = np.random.randint(1, len(high_demand_route)-1)\n                customer = high_demand_route[customer_idx]\n\n                # Find the route with the lowest average demand per customer\n                low_demand_route_idx = np.argmin(avg_demands)\n                low_demand_route = new_solution[low_demand_route_idx].copy()\n\n                # Check capacity feasibility\n                if sum(demand[low_demand_route[1:-1]]) + demand[customer] <= capacity:\n                    # Remove the customer from the high-demand route\n                    high_demand_route = np.concatenate([\n                        high_demand_route[:customer_idx],\n                        high_demand_route[customer_idx+1:]\n                    ])\n\n                    # Insert the customer into the low-demand route\n                    # Find the best insertion position (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = 1\n                    for i in range(1, len(low_demand_route)):\n                        increase = (distance_matrix[low_demand_route[i-1], customer] +\n                                   distance_matrix[customer, low_demand_route[i]] -\n                                   distance_matrix[low_demand_route[i-1], low_demand_route[i]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n\n                    low_demand_route = np.insert(low_demand_route, best_pos, customer)\n\n                    # Update the solution\n                    new_solution[high_demand_route_idx] = high_demand_route\n                    new_solution[low_demand_route_idx] = low_demand_route\n\n    return new_solution\n\n",
        "score": [
            -0.5195011830187659,
            1.0491434037685394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search steps\n    if len(new_solution) > 1:\n        # Step 1: Merge two shortest routes if their combined demand is <= capacity\n        route_lengths = [sum(demand[route[1:-1]]) for route in new_solution]\n        shortest_route_idx = np.argmin(route_lengths)\n        second_shortest_route_idx = np.argsort(route_lengths)[1] if len(new_solution) > 1 else -1\n\n        if second_shortest_route_idx != -1:\n            route1 = new_solution[shortest_route_idx]\n            route2 = new_solution[second_shortest_route_idx]\n            combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n            if combined_demand <= capacity:\n                # Merge routes by connecting them via the closest pair of nodes\n                last_node_route1 = route1[-2]\n                first_node_route2 = route2[1]\n\n                # Find the closest pair of nodes between the two routes\n                min_dist = float('inf')\n                best_pair = (0, 0)\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        dist = distance_matrix[route1[i], route2[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pair = (i, j)\n\n                # Merge the routes at the best pair\n                merged_route = np.concatenate([\n                    route1[:best_pair[0]+1],\n                    route2[best_pair[1]:]\n                ])\n\n                # Update the solution\n                new_solution[shortest_route_idx] = merged_route\n                new_solution.pop(second_shortest_route_idx)\n\n        # Step 2: Reverse a segment of the longest route to reduce distance\n        if len(new_solution) > 0:\n            longest_route_idx = np.argmax([len(route) for route in new_solution])\n            longest_route = new_solution[longest_route_idx].copy()\n\n            if len(longest_route) > 3:\n                # Select a random segment to reverse\n                start = np.random.randint(1, len(longest_route)-2)\n                end = np.random.randint(start+1, len(longest_route)-1)\n                reversed_segment = longest_route[start:end+1][::-1]\n\n                # Check capacity feasibility\n                if sum(demand[reversed_segment[1:-1]]) <= capacity:\n                    longest_route[start:end+1] = reversed_segment\n                    new_solution[longest_route_idx] = longest_route\n\n        # Step 3: Reinsert a customer from a route with high demand to another route with low demand\n        if len(new_solution) > 1:\n            # Find the route with the highest average demand per customer\n            avg_demands = [sum(demand[route[1:-1]]) / (len(route)-2) if len(route) > 2 else 0 for route in new_solution]\n            high_demand_route_idx = np.argmax(avg_demands)\n            high_demand_route = new_solution[high_demand_route_idx].copy()\n\n            if len(high_demand_route) > 3:\n                # Select a random customer to reinsert\n                customer_idx = np.random.randint(1, len(high_demand_route)-1)\n                customer = high_demand_route[customer_idx]\n\n                # Find the route with the lowest average demand per customer\n                low_demand_route_idx = np.argmin(avg_demands)\n                low_demand_route = new_solution[low_demand_route_idx].copy()\n\n                # Check capacity feasibility\n                if sum(demand[low_demand_route[1:-1]]) + demand[customer] <= capacity:\n                    # Remove the customer from the high-demand route\n                    high_demand_route = np.concatenate([\n                        high_demand_route[:customer_idx],\n                        high_demand_route[customer_idx+1:]\n                    ])\n\n                    # Insert the customer into the low-demand route\n                    # Find the best insertion position (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = 1\n                    for i in range(1, len(low_demand_route)):\n                        increase = (distance_matrix[low_demand_route[i-1], customer] +\n                                   distance_matrix[customer, low_demand_route[i]] -\n                                   distance_matrix[low_demand_route[i-1], low_demand_route[i]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n\n                    low_demand_route = np.insert(low_demand_route, best_pos, customer)\n\n                    # Update the solution\n                    new_solution[high_demand_route_idx] = high_demand_route\n                    new_solution[low_demand_route_idx] = low_demand_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{A hybrid local search strategy combining route segmentation, demand-based node swaps, and adaptive route merging to intelligently balance distance and makespan minimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Segment route into parts with balanced demand\n        segments = []\n        current_segment = [route[0]]\n        current_demand = 0\n        for node in route[1:-1]:\n            current_demand += demand[node]\n            current_segment.append(node)\n            if current_demand >= capacity * 0.7:  # Segment threshold\n                segments.append(current_segment)\n                current_segment = [route[0]]\n                current_demand = 0\n        if current_segment[-1] != route[0]:\n            segments.append(current_segment + [route[0]])\n\n        # Process segments with demand-based swaps\n        new_segments = []\n        for seg in segments:\n            if len(seg) <= 3:\n                new_segments.append(seg.copy())\n                continue\n\n            # Find nodes with high demand to prioritize\n            high_demand_nodes = [node for node in seg[1:-1] if demand[node] > capacity * 0.3]\n            if not high_demand_nodes:\n                new_segments.append(seg.copy())\n                continue\n\n            # Perform demand-based swaps\n            new_seg = seg.copy()\n            for i in range(1, len(new_seg)-1):\n                if demand[new_seg[i]] > capacity * 0.3:\n                    # Find best swap candidate\n                    best_j = -1\n                    best_improvement = 0\n                    for j in range(1, len(new_seg)-1):\n                        if i == j or demand[new_seg[j]] > capacity * 0.3:\n                            continue\n                        # Calculate potential improvement\n                        old_dist = (distance_matrix[new_seg[i-1], new_seg[i]] +\n                                   distance_matrix[new_seg[i], new_seg[i+1]])\n                        new_dist = (distance_matrix[new_seg[i-1], new_seg[j]] +\n                                   distance_matrix[new_seg[j], new_seg[i+1]])\n                        improvement = old_dist - new_dist\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_j = j\n                    if best_j != -1 and best_improvement > 0:\n                        # Perform swap\n                        new_seg[i], new_seg[best_j] = new_seg[best_j], new_seg[i]\n\n            new_segments.append(new_seg)\n\n        # Merge segments if beneficial\n        merged_route = []\n        for seg in new_segments:\n            if not merged_route:\n                merged_route = seg.copy()\n            else:\n                # Calculate merge cost\n                old_cost = (distance_matrix[merged_route[-2], merged_route[-1]] +\n                           distance_matrix[seg[0], seg[1]])\n                new_cost = distance_matrix[merged_route[-2], seg[1]]\n                if new_cost < old_cost * 1.1:  # Allow slight increase for makespan reduction\n                    merged_route = merged_route[:-1] + seg[1:]\n\n        new_solution.append(np.array(merged_route))\n\n    return new_solution\n\n",
        "score": [
            -0.7170617889502796,
            2.3039143681526184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Segment route into parts with balanced demand\n        segments = []\n        current_segment = [route[0]]\n        current_demand = 0\n        for node in route[1:-1]:\n            current_demand += demand[node]\n            current_segment.append(node)\n            if current_demand >= capacity * 0.7:  # Segment threshold\n                segments.append(current_segment)\n                current_segment = [route[0]]\n                current_demand = 0\n        if current_segment[-1] != route[0]:\n            segments.append(current_segment + [route[0]])\n\n        # Process segments with demand-based swaps\n        new_segments = []\n        for seg in segments:\n            if len(seg) <= 3:\n                new_segments.append(seg.copy())\n                continue\n\n            # Find nodes with high demand to prioritize\n            high_demand_nodes = [node for node in seg[1:-1] if demand[node] > capacity * 0.3]\n            if not high_demand_nodes:\n                new_segments.append(seg.copy())\n                continue\n\n            # Perform demand-based swaps\n            new_seg = seg.copy()\n            for i in range(1, len(new_seg)-1):\n                if demand[new_seg[i]] > capacity * 0.3:\n                    # Find best swap candidate\n                    best_j = -1\n                    best_improvement = 0\n                    for j in range(1, len(new_seg)-1):\n                        if i == j or demand[new_seg[j]] > capacity * 0.3:\n                            continue\n                        # Calculate potential improvement\n                        old_dist = (distance_matrix[new_seg[i-1], new_seg[i]] +\n                                   distance_matrix[new_seg[i], new_seg[i+1]])\n                        new_dist = (distance_matrix[new_seg[i-1], new_seg[j]] +\n                                   distance_matrix[new_seg[j], new_seg[i+1]])\n                        improvement = old_dist - new_dist\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_j = j\n                    if best_j != -1 and best_improvement > 0:\n                        # Perform swap\n                        new_seg[i], new_seg[best_j] = new_seg[best_j], new_seg[i]\n\n            new_segments.append(new_seg)\n\n        # Merge segments if beneficial\n        merged_route = []\n        for seg in new_segments:\n            if not merged_route:\n                merged_route = seg.copy()\n            else:\n                # Calculate merge cost\n                old_cost = (distance_matrix[merged_route[-2], merged_route[-1]] +\n                           distance_matrix[seg[0], seg[1]])\n                new_cost = distance_matrix[merged_route[-2], seg[1]]\n                if new_cost < old_cost * 1.1:  # Allow slight increase for makespan reduction\n                    merged_route = merged_route[:-1] + seg[1:]\n\n        new_solution.append(np.array(merged_route))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{A hybrid local search operator that combines route-splitting with demand-aware customer reallocation to balance distance and makespan, while ensuring feasibility through capacity checks and intelligent route merging.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][1])  # Prioritize solutions with longer makespan\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split long routes and reallocate customers to balance makespan\n    for i, route in enumerate(base_solution):\n        if len(route) > 3:  # Skip trivial routes (depot -> customer -> depot)\n            # Split the route at a demand-aware point to balance load\n            total_demand = sum(demand[route[1:-1]])\n            half_capacity = total_demand / 2\n            cumulative_demand = 0\n            split_pos = 1  # Default to split after first customer\n\n            for j in range(1, len(route)-1):\n                cumulative_demand += demand[route[j]]\n                if cumulative_demand >= half_capacity:\n                    split_pos = j\n                    break\n\n            # Create two new routes\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break  # Only modify one route per iteration\n\n    # Optional: Perform a demand-aware 2-opt swap between routes to further improve\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                # Find customers in route i and j that can swap without violating capacity\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                for k in range(1, len(route_i)-1):\n                    for l in range(1, len(route_j)-1):\n                        # Check if swapping customers i[k] and j[l] is feasible\n                        if (sum(demand[route_i[1:-1]]) - demand[route_i[k]] + demand[route_j[l]] <= capacity and\n                            sum(demand[route_j[1:-1]]) - demand[route_j[l]] + demand[route_i[k]] <= capacity):\n                            # Perform the swap\n                            temp = route_i[k]\n                            route_i[k] = route_j[l]\n                            route_j[l] = temp\n                            new_solution[i] = route_i\n                            new_solution[j] = route_j\n                            return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7916546603367418,
            0.36038294434547424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][1])  # Prioritize solutions with longer makespan\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split long routes and reallocate customers to balance makespan\n    for i, route in enumerate(base_solution):\n        if len(route) > 3:  # Skip trivial routes (depot -> customer -> depot)\n            # Split the route at a demand-aware point to balance load\n            total_demand = sum(demand[route[1:-1]])\n            half_capacity = total_demand / 2\n            cumulative_demand = 0\n            split_pos = 1  # Default to split after first customer\n\n            for j in range(1, len(route)-1):\n                cumulative_demand += demand[route[j]]\n                if cumulative_demand >= half_capacity:\n                    split_pos = j\n                    break\n\n            # Create two new routes\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break  # Only modify one route per iteration\n\n    # Optional: Perform a demand-aware 2-opt swap between routes to further improve\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                # Find customers in route i and j that can swap without violating capacity\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                for k in range(1, len(route_i)-1):\n                    for l in range(1, len(route_j)-1):\n                        # Check if swapping customers i[k] and j[l] is feasible\n                        if (sum(demand[route_i[1:-1]]) - demand[route_i[k]] + demand[route_j[l]] <= capacity and\n                            sum(demand[route_j[1:-1]]) - demand[route_j[l]] + demand[route_i[k]] <= capacity):\n                            # Perform the swap\n                            temp = route_i[k]\n                            route_i[k] = route_j[l]\n                            route_j[l] = temp\n                            new_solution[i] = route_i\n                            new_solution[j] = route_j\n                            return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted random selection favoring solutions with lower makespan and total distance, then applies a hybrid local search combining route splitting, customer reinsertion with demand-aware positioning, and route merging to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting, customer reinsertion, and merging\n    if len(new_solution) > 1:\n        # Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Split the route into two parts at a random position\n        split_pos = random.randint(1, len(selected_route) - 2)\n        part1 = selected_route[:split_pos + 1]\n        part2 = selected_route[split_pos:]\n\n        # Reinsert customers from part2 into other routes or create new routes\n        customers_to_reinsert = part2[1:-1]\n        new_solution[route_idx] = part1\n\n        for customer in customers_to_reinsert:\n            # Find the best route to insert the customer (considering demand and distance)\n            best_route_idx = -1\n            best_position = -1\n            min_increase = float('inf')\n\n            for i in range(len(new_solution)):\n                route = new_solution[i]\n                route_demand = sum(demand[route[1:-1]])\n                if route_demand + demand[customer] > capacity:\n                    continue\n\n                for j in range(1, len(route)):\n                    # Calculate the increase in distance if customer is inserted at position j\n                    prev_node = route[j-1]\n                    next_node = route[j]\n                    increase = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_route_idx = i\n                        best_position = j\n\n            if best_route_idx != -1:\n                # Insert the customer into the best position\n                route = new_solution[best_route_idx].copy()\n                new_route = np.concatenate([route[:best_position], [customer], route[best_position:]])\n                new_solution[best_route_idx] = new_route\n            else:\n                # If no feasible position found, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n        # Merge routes if possible to reduce total distance\n        merged = True\n        while merged:\n            merged = False\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                        # Try merging route1 and route2\n                        # Calculate the distance of merged route\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        merged_distance = sum(distance_matrix[merged_route[k]][merged_route[k+1]] for k in range(len(merged_route)-1))\n                        original_distance = sum(distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1)) + \\\n                                           sum(distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1))\n\n                        if merged_distance < original_distance:\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            merged = True\n                            break\n                if merged:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7479423736812243,
            3.14789417386055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting, customer reinsertion, and merging\n    if len(new_solution) > 1:\n        # Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Split the route into two parts at a random position\n        split_pos = random.randint(1, len(selected_route) - 2)\n        part1 = selected_route[:split_pos + 1]\n        part2 = selected_route[split_pos:]\n\n        # Reinsert customers from part2 into other routes or create new routes\n        customers_to_reinsert = part2[1:-1]\n        new_solution[route_idx] = part1\n\n        for customer in customers_to_reinsert:\n            # Find the best route to insert the customer (considering demand and distance)\n            best_route_idx = -1\n            best_position = -1\n            min_increase = float('inf')\n\n            for i in range(len(new_solution)):\n                route = new_solution[i]\n                route_demand = sum(demand[route[1:-1]])\n                if route_demand + demand[customer] > capacity:\n                    continue\n\n                for j in range(1, len(route)):\n                    # Calculate the increase in distance if customer is inserted at position j\n                    prev_node = route[j-1]\n                    next_node = route[j]\n                    increase = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_route_idx = i\n                        best_position = j\n\n            if best_route_idx != -1:\n                # Insert the customer into the best position\n                route = new_solution[best_route_idx].copy()\n                new_route = np.concatenate([route[:best_position], [customer], route[best_position:]])\n                new_solution[best_route_idx] = new_route\n            else:\n                # If no feasible position found, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n        # Merge routes if possible to reduce total distance\n        merged = True\n        while merged:\n            merged = False\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                        # Try merging route1 and route2\n                        # Calculate the distance of merged route\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        merged_distance = sum(distance_matrix[merged_route[k]][merged_route[k+1]] for k in range(len(merged_route)-1))\n                        original_distance = sum(distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1)) + \\\n                                           sum(distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1))\n\n                        if merged_distance < original_distance:\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            merged = True\n                            break\n                if merged:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route-splitting and customer relocation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        first_part = route[:split_idx + 1]\n        second_part = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        first_demand = np.sum(demand[first_part[1:-1]])\n        second_demand = np.sum(demand[second_part[1:-1]])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = first_part\n            new_solution.append(second_part)\n\n    # Relocate a random customer from one route to another if feasible\n    if len(new_solution) > 1:\n        src_route_idx = np.random.randint(len(new_solution))\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure we can remove a customer\n            customer_idx = np.random.randint(1, len(src_route) - 1)\n            customer = src_route[customer_idx]\n\n            # Try to insert into another route\n            for dst_route_idx in range(len(new_solution)):\n                if dst_route_idx == src_route_idx:\n                    continue\n                dst_route = new_solution[dst_route_idx]\n                for pos in range(1, len(dst_route)):\n                    # Insert customer into dst_route at position pos\n                    new_dst_route = np.insert(dst_route, pos, customer)\n                    new_dst_demand = np.sum(demand[new_dst_route[1:-1]])\n                    if new_dst_demand <= capacity:\n                        # Remove customer from src_route\n                        new_src_route = np.delete(src_route, customer_idx)\n                        # Update routes\n                        new_solution[src_route_idx] = new_src_route\n                        new_solution[dst_route_idx] = new_dst_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7960564912550154,
            2.6546458899974823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route-splitting and customer relocation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        first_part = route[:split_idx + 1]\n        second_part = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        first_demand = np.sum(demand[first_part[1:-1]])\n        second_demand = np.sum(demand[second_part[1:-1]])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = first_part\n            new_solution.append(second_part)\n\n    # Relocate a random customer from one route to another if feasible\n    if len(new_solution) > 1:\n        src_route_idx = np.random.randint(len(new_solution))\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure we can remove a customer\n            customer_idx = np.random.randint(1, len(src_route) - 1)\n            customer = src_route[customer_idx]\n\n            # Try to insert into another route\n            for dst_route_idx in range(len(new_solution)):\n                if dst_route_idx == src_route_idx:\n                    continue\n                dst_route = new_solution[dst_route_idx]\n                for pos in range(1, len(dst_route)):\n                    # Insert customer into dst_route at position pos\n                    new_dst_route = np.insert(dst_route, pos, customer)\n                    new_dst_demand = np.sum(demand[new_dst_route[1:-1]])\n                    if new_dst_demand <= capacity:\n                        # Remove customer from src_route\n                        new_src_route = np.delete(src_route, customer_idx)\n                        # Update routes\n                        new_solution[src_route_idx] = new_src_route\n                        new_solution[dst_route_idx] = new_dst_route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to split or reinsert\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx].copy()\n\n    # Split the route into two parts at a random customer node\n    if len(selected_route) > 3:  # Ensure route can be split\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        part1 = selected_route[:split_pos + 1]\n        part2 = selected_route[split_pos:]\n\n        # Calculate demands for the split parts\n        demand_part1 = np.sum(demand[part1[1:-1]])  # Exclude depot\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution[route_idx] = part1\n            new_solution.insert(route_idx + 1, part2)\n        else:\n            # If splitting violates capacity, try reinserting a customer from the route\n            customer_to_reinsert = np.random.choice(selected_route[1:-1])\n            new_solution[route_idx] = np.array([0] + [c for c in selected_route[1:-1] if c != customer_to_reinsert] + [0])\n\n            # Find the best feasible insertion point for the reinserted customer\n            best_insertion_cost = float('inf')\n            best_route_idx = -1\n            best_pos = -1\n\n            for i, route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                route_demand = np.sum(demand[route[1:-1]])\n                if route_demand + demand[customer_to_reinsert] > capacity:\n                    continue\n\n                for pos in range(1, len(route)):\n                    insertion_cost = distance_matrix[route[pos - 1], customer_to_reinsert] + distance_matrix[customer_to_reinsert, route[pos]] - distance_matrix[route[pos - 1], route[pos]]\n                    if insertion_cost < best_insertion_cost:\n                        best_insertion_cost = insertion_cost\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_route = np.insert(new_solution[best_route_idx], best_pos, customer_to_reinsert)\n                new_solution[best_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7036481137281495,
            0.23446685075759888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to split or reinsert\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx].copy()\n\n    # Split the route into two parts at a random customer node\n    if len(selected_route) > 3:  # Ensure route can be split\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        part1 = selected_route[:split_pos + 1]\n        part2 = selected_route[split_pos:]\n\n        # Calculate demands for the split parts\n        demand_part1 = np.sum(demand[part1[1:-1]])  # Exclude depot\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution[route_idx] = part1\n            new_solution.insert(route_idx + 1, part2)\n        else:\n            # If splitting violates capacity, try reinserting a customer from the route\n            customer_to_reinsert = np.random.choice(selected_route[1:-1])\n            new_solution[route_idx] = np.array([0] + [c for c in selected_route[1:-1] if c != customer_to_reinsert] + [0])\n\n            # Find the best feasible insertion point for the reinserted customer\n            best_insertion_cost = float('inf')\n            best_route_idx = -1\n            best_pos = -1\n\n            for i, route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                route_demand = np.sum(demand[route[1:-1]])\n                if route_demand + demand[customer_to_reinsert] > capacity:\n                    continue\n\n                for pos in range(1, len(route)):\n                    insertion_cost = distance_matrix[route[pos - 1], customer_to_reinsert] + distance_matrix[customer_to_reinsert, route[pos]] - distance_matrix[route[pos - 1], route[pos]]\n                    if insertion_cost < best_insertion_cost:\n                        best_insertion_cost = insertion_cost\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_route = np.insert(new_solution[best_route_idx], best_pos, customer_to_reinsert)\n                new_solution[best_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining route segmentation, demand-aware relocations, and adaptive 2-opt to balance distance and makespan, while ensuring feasibility through capacity checks and distance recalculations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route segmentation and demand-aware relocation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip too short routes\n            continue\n\n        # Find the most \"expensive\" segment (high distance-to-demand ratio)\n        max_ratio = -1\n        split_pos = 1\n        for i in range(1, len(route)-1):\n            segment_dist = distance_matrix[route[i-1]][route[i]]\n            segment_demand = demand[route[i]]\n            ratio = segment_dist / (segment_demand + 1e-6)  # Avoid division by zero\n            if ratio > max_ratio:\n                max_ratio = ratio\n                split_pos = i\n\n        # Split the route at the expensive segment\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Try to relocate a node from part1 to part2 if demand allows\n        for i in range(1, len(part1)-1):\n            node = part1[i]\n            if demand[node] + sum(demand[part2[1:-1]]) <= capacity:\n                # Relocate node\n                part1 = np.concatenate([part1[:i], part1[i+1:]])\n                part2 = np.insert(part2, 1, node)\n                break\n\n        # Update the route\n        new_solution[route_idx] = part1\n        if len(part2) > 2:  # Only add if it's not just depot-depot\n            new_solution.append(part2)\n\n    # Step 2: Adaptive 2-opt for makespan reduction\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Find the pair of edges that would most reduce the makespan\n        best_reduction = 0\n        best_i, best_j = 1, 2\n\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Calculate current and potential distances\n                current_dist = distance_matrix[route[i-1]][route[i]] + distance_matrix[route[j]][route[j+1]]\n                potential_dist = distance_matrix[route[i-1]][route[j]] + distance_matrix[route[i]][route[j+1]]\n\n                if potential_dist < current_dist:\n                    reduction = current_dist - potential_dist\n                    if reduction > best_reduction:\n                        best_reduction = reduction\n                        best_i, best_j = i, j\n\n        # Apply the best 2-opt move if it improves\n        if best_reduction > 0:\n            # Reverse the segment between best_i and best_j\n            new_segment = np.concatenate([route[best_i:best_j+1][::-1]])\n            new_solution[route_idx] = np.concatenate([route[:best_i], new_segment, route[best_j+1:]])\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8028313922338435,
            5.615170508623123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route segmentation and demand-aware relocation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip too short routes\n            continue\n\n        # Find the most \"expensive\" segment (high distance-to-demand ratio)\n        max_ratio = -1\n        split_pos = 1\n        for i in range(1, len(route)-1):\n            segment_dist = distance_matrix[route[i-1]][route[i]]\n            segment_demand = demand[route[i]]\n            ratio = segment_dist / (segment_demand + 1e-6)  # Avoid division by zero\n            if ratio > max_ratio:\n                max_ratio = ratio\n                split_pos = i\n\n        # Split the route at the expensive segment\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Try to relocate a node from part1 to part2 if demand allows\n        for i in range(1, len(part1)-1):\n            node = part1[i]\n            if demand[node] + sum(demand[part2[1:-1]]) <= capacity:\n                # Relocate node\n                part1 = np.concatenate([part1[:i], part1[i+1:]])\n                part2 = np.insert(part2, 1, node)\n                break\n\n        # Update the route\n        new_solution[route_idx] = part1\n        if len(part2) > 2:  # Only add if it's not just depot-depot\n            new_solution.append(part2)\n\n    # Step 2: Adaptive 2-opt for makespan reduction\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Find the pair of edges that would most reduce the makespan\n        best_reduction = 0\n        best_i, best_j = 1, 2\n\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Calculate current and potential distances\n                current_dist = distance_matrix[route[i-1]][route[i]] + distance_matrix[route[j]][route[j+1]]\n                potential_dist = distance_matrix[route[i-1]][route[j]] + distance_matrix[route[i]][route[j+1]]\n\n                if potential_dist < current_dist:\n                    reduction = current_dist - potential_dist\n                    if reduction > best_reduction:\n                        best_reduction = reduction\n                        best_i, best_j = i, j\n\n        # Apply the best 2-opt move if it improves\n        if best_reduction > 0:\n            # Reverse the segment between best_i and best_j\n            new_segment = np.concatenate([route[best_i:best_j+1][::-1]])\n            new_solution[route_idx] = np.concatenate([route[:best_i], new_segment, route[best_j+1:]])\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining route splitting, demand-based swaps, and makespan-aware edge insertions to generate a neighbor solution while ensuring feasibility and balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: (x[1][1] * 0.7 + x[1][0] * 0.3, random.random()))[:3]\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split, Swap, Insert\n    if len(new_solution) > 1:\n        # Route Splitting: Split a long route into two if possible\n        long_routes = sorted([(i, len(route)) for i, route in enumerate(new_solution)], key=lambda x: -x[1])\n        for idx, _ in long_routes[:2]:\n            route = new_solution[idx]\n            if len(route) > 4:  # Only split if route has enough nodes\n                split_pos = random.randint(2, len(route)-3)\n                new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+1:]])\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[idx] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n    # Demand-based Swap: Swap nodes between routes if demands are compatible\n    if len(new_solution) > 1:\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[r1]\n        route2 = new_solution[r2]\n        if len(route1) > 3 and len(route2) > 3:\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n            node1 = route1[pos1]\n            node2 = route2[pos2]\n            new_demand1 = np.sum(demand[route1[1:-1]]) - demand[node1] + demand[node2]\n            new_demand2 = np.sum(demand[route2[1:-1]]) - demand[node2] + demand[node1]\n            if new_demand1 <= capacity and new_demand2 <= capacity:\n                new_solution[r1][pos1] = node2\n                new_solution[r2][pos2] = node1\n\n    # Makespan-aware Insertion: Insert a node from one route into another to balance makespan\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        shortest_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        if longest_route_idx != shortest_route_idx and len(new_solution[longest_route_idx]) > 3:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n            pos = random.randint(1, len(longest_route)-2)\n            node = longest_route[pos]\n            if np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity:\n                # Find best insertion position in shortest route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shortest_route)):\n                    cost = (distance_matrix[shortest_route[i-1], node] +\n                            distance_matrix[node, shortest_route[i]] -\n                            distance_matrix[shortest_route[i-1], shortest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n                # Perform insertion\n                shortest_route = np.concatenate([shortest_route[:best_pos], [node], shortest_route[best_pos:]])\n                longest_route = np.concatenate([longest_route[:pos], longest_route[pos+1:]])\n                new_solution[shortest_route_idx] = shortest_route\n                new_solution[longest_route_idx] = longest_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.587833263102002,
            3.014329820871353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: (x[1][1] * 0.7 + x[1][0] * 0.3, random.random()))[:3]\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split, Swap, Insert\n    if len(new_solution) > 1:\n        # Route Splitting: Split a long route into two if possible\n        long_routes = sorted([(i, len(route)) for i, route in enumerate(new_solution)], key=lambda x: -x[1])\n        for idx, _ in long_routes[:2]:\n            route = new_solution[idx]\n            if len(route) > 4:  # Only split if route has enough nodes\n                split_pos = random.randint(2, len(route)-3)\n                new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+1:]])\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[idx] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n    # Demand-based Swap: Swap nodes between routes if demands are compatible\n    if len(new_solution) > 1:\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[r1]\n        route2 = new_solution[r2]\n        if len(route1) > 3 and len(route2) > 3:\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n            node1 = route1[pos1]\n            node2 = route2[pos2]\n            new_demand1 = np.sum(demand[route1[1:-1]]) - demand[node1] + demand[node2]\n            new_demand2 = np.sum(demand[route2[1:-1]]) - demand[node2] + demand[node1]\n            if new_demand1 <= capacity and new_demand2 <= capacity:\n                new_solution[r1][pos1] = node2\n                new_solution[r2][pos2] = node1\n\n    # Makespan-aware Insertion: Insert a node from one route into another to balance makespan\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        shortest_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        if longest_route_idx != shortest_route_idx and len(new_solution[longest_route_idx]) > 3:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n            pos = random.randint(1, len(longest_route)-2)\n            node = longest_route[pos]\n            if np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity:\n                # Find best insertion position in shortest route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shortest_route)):\n                    cost = (distance_matrix[shortest_route[i-1], node] +\n                            distance_matrix[node, shortest_route[i]] -\n                            distance_matrix[shortest_route[i-1], shortest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n                # Perform insertion\n                shortest_route = np.concatenate([shortest_route[:best_pos], [node], shortest_route[best_pos:]])\n                longest_route = np.concatenate([longest_route[:pos], longest_route[pos+1:]])\n                new_solution[shortest_route_idx] = shortest_route\n                new_solution[longest_route_idx] = longest_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{A novel hybrid local search strategy combines route-segment swapping with demand-aware insertion, prioritizing regions of high demand density to reduce makespan while maintaining or improving total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify high-demand regions by clustering customers with high demand\n    high_demand_nodes = np.where(demand > capacity * 0.5)[0]  # Nodes with demand > 50% of capacity\n    if len(high_demand_nodes) == 0:\n        high_demand_nodes = np.where(demand > 0)[0]  # Fallback to all customers\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.choice(len(new_solution))\n        route = new_solution[route_idx]\n\n        # Find a segment in the route that includes high-demand nodes\n        segment_start = -1\n        for i in range(1, len(route)-1):\n            if route[i] in high_demand_nodes:\n                segment_start = i\n                break\n\n        if segment_start > 0:\n            # Extract the segment\n            segment_end = segment_start\n            while segment_end < len(route)-1 and demand[route[segment_end]] > 0:\n                segment_end += 1\n\n            segment = route[segment_start:segment_end]\n\n            # Remove the segment from the route\n            new_route = np.concatenate([route[:segment_start], route[segment_end:]])\n\n            # Try to reinsert the segment into another route or a new route\n            inserted = False\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                temp_route = np.insert(new_solution[i], 1, segment)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    new_solution[i] = temp_route\n                    inserted = True\n                    break\n\n            if not inserted:\n                # Create a new route with the segment\n                temp_route = np.concatenate([[0], segment, [0]])\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    new_solution.append(temp_route)\n\n            # Ensure the original route is still feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n            else:\n                # If not feasible, revert changes\n                new_solution = [route.copy() for route in base_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.5089674100159295,
            8.237624645233154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify high-demand regions by clustering customers with high demand\n    high_demand_nodes = np.where(demand > capacity * 0.5)[0]  # Nodes with demand > 50% of capacity\n    if len(high_demand_nodes) == 0:\n        high_demand_nodes = np.where(demand > 0)[0]  # Fallback to all customers\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.choice(len(new_solution))\n        route = new_solution[route_idx]\n\n        # Find a segment in the route that includes high-demand nodes\n        segment_start = -1\n        for i in range(1, len(route)-1):\n            if route[i] in high_demand_nodes:\n                segment_start = i\n                break\n\n        if segment_start > 0:\n            # Extract the segment\n            segment_end = segment_start\n            while segment_end < len(route)-1 and demand[route[segment_end]] > 0:\n                segment_end += 1\n\n            segment = route[segment_start:segment_end]\n\n            # Remove the segment from the route\n            new_route = np.concatenate([route[:segment_start], route[segment_end:]])\n\n            # Try to reinsert the segment into another route or a new route\n            inserted = False\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                temp_route = np.insert(new_solution[i], 1, segment)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    new_solution[i] = temp_route\n                    inserted = True\n                    break\n\n            if not inserted:\n                # Create a new route with the segment\n                temp_route = np.concatenate([[0], segment, [0]])\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    new_solution.append(temp_route)\n\n            # Ensure the original route is still feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n            else:\n                # If not feasible, revert changes\n                new_solution = [route.copy() for route in base_solution]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive with high potential for improvement, then applies a hybrid local search combining route splitting and customer reinsertion to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan and pick a solution that's not the best in makespan (to allow improvement)\n        sorted_archive = sorted(archive, key=lambda x: x[1][1])\n        candidate = random.choice(sorted_archive[1:min(3, len(sorted_archive))])\n    else:\n        candidate = archive[0]\n\n    base_solution = candidate[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + customer reinsertion\n    if len(base_solution) > 1:\n        # Select a route to split\n        route_idx = random.randint(0, len(base_solution) - 1)\n        selected_route = base_solution[route_idx].copy()\n\n        # Split the route at a random point (excluding depot)\n        if len(selected_route) > 3:  # Need at least 3 nodes (depot, customer, depot)\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity constraints for both parts\n            def check_capacity(route):\n                total_demand = sum(demand[node] for node in route if node != 0)\n                return total_demand <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                # Replace the original route with the two new routes\n                new_solution = [route for i, route in enumerate(new_solution) if i != route_idx]\n                new_solution.append(first_part)\n                new_solution.append(second_part)\n\n                # Attempt to reinsert customers from the longer route to balance makespan\n                longer_route = first_part if len(first_part) > len(second_part) else second_part\n                shorter_route = second_part if len(first_part) > len(second_part) else first_part\n\n                # Try to reinsert customers from the longer route into the shorter one\n                for customer in longer_route[1:-1]:\n                    if demand[customer] + sum(demand[node] for node in shorter_route if node != 0) <= capacity:\n                        # Find best insertion position in the shorter route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(shorter_route)):\n                            cost = (distance_matrix[shorter_route[pos-1]][customer] +\n                                   distance_matrix[customer][shorter_route[pos]] -\n                                   distance_matrix[shorter_route[pos-1]][shorter_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Insert the customer\n                        shorter_route = np.insert(shorter_route, best_pos, customer)\n                        longer_route = np.delete(longer_route, np.where(longer_route == customer)[0][0])\n\n                # Update the solution\n                new_solution = [route for i, route in enumerate(new_solution) if i != route_idx]\n                new_solution.append(longer_route)\n                new_solution.append(shorter_route)\n\n    # If no improvement or splitting not possible, try a different operation\n    if np.array_equal(new_solution, base_solution):\n        # Try relocating a customer between routes\n        if len(base_solution) > 1:\n            # Select a random route and customer (not depot)\n            route_idx = random.randint(0, len(base_solution) - 1)\n            selected_route = base_solution[route_idx].copy()\n            if len(selected_route) > 2:\n                customer_idx = random.randint(1, len(selected_route) - 2)\n                customer = selected_route[customer_idx]\n\n                # Try to insert into another route\n                for other_route_idx in range(len(base_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = base_solution[other_route_idx].copy()\n                        if demand[customer] + sum(demand[node] for node in other_route if node != 0) <= capacity:\n                            # Find best insertion position\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(other_route)):\n                                cost = (distance_matrix[other_route[pos-1]][customer] +\n                                       distance_matrix[customer][other_route[pos]] -\n                                       distance_matrix[other_route[pos-1]][other_route[pos]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n\n                            # Create new routes\n                            new_route1 = np.delete(selected_route, customer_idx)\n                            new_route2 = np.insert(other_route, best_pos, customer)\n\n                            # Update solution\n                            new_solution = [route for i, route in enumerate(new_solution) if i != route_idx and i != other_route_idx]\n                            new_solution.append(new_route1)\n                            new_solution.append(new_route2)\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.7774682657186859,
            1.432850331068039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan and pick a solution that's not the best in makespan (to allow improvement)\n        sorted_archive = sorted(archive, key=lambda x: x[1][1])\n        candidate = random.choice(sorted_archive[1:min(3, len(sorted_archive))])\n    else:\n        candidate = archive[0]\n\n    base_solution = candidate[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + customer reinsertion\n    if len(base_solution) > 1:\n        # Select a route to split\n        route_idx = random.randint(0, len(base_solution) - 1)\n        selected_route = base_solution[route_idx].copy()\n\n        # Split the route at a random point (excluding depot)\n        if len(selected_route) > 3:  # Need at least 3 nodes (depot, customer, depot)\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity constraints for both parts\n            def check_capacity(route):\n                total_demand = sum(demand[node] for node in route if node != 0)\n                return total_demand <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                # Replace the original route with the two new routes\n                new_solution = [route for i, route in enumerate(new_solution) if i != route_idx]\n                new_solution.append(first_part)\n                new_solution.append(second_part)\n\n                # Attempt to reinsert customers from the longer route to balance makespan\n                longer_route = first_part if len(first_part) > len(second_part) else second_part\n                shorter_route = second_part if len(first_part) > len(second_part) else first_part\n\n                # Try to reinsert customers from the longer route into the shorter one\n                for customer in longer_route[1:-1]:\n                    if demand[customer] + sum(demand[node] for node in shorter_route if node != 0) <= capacity:\n                        # Find best insertion position in the shorter route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(shorter_route)):\n                            cost = (distance_matrix[shorter_route[pos-1]][customer] +\n                                   distance_matrix[customer][shorter_route[pos]] -\n                                   distance_matrix[shorter_route[pos-1]][shorter_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Insert the customer\n                        shorter_route = np.insert(shorter_route, best_pos, customer)\n                        longer_route = np.delete(longer_route, np.where(longer_route == customer)[0][0])\n\n                # Update the solution\n                new_solution = [route for i, route in enumerate(new_solution) if i != route_idx]\n                new_solution.append(longer_route)\n                new_solution.append(shorter_route)\n\n    # If no improvement or splitting not possible, try a different operation\n    if np.array_equal(new_solution, base_solution):\n        # Try relocating a customer between routes\n        if len(base_solution) > 1:\n            # Select a random route and customer (not depot)\n            route_idx = random.randint(0, len(base_solution) - 1)\n            selected_route = base_solution[route_idx].copy()\n            if len(selected_route) > 2:\n                customer_idx = random.randint(1, len(selected_route) - 2)\n                customer = selected_route[customer_idx]\n\n                # Try to insert into another route\n                for other_route_idx in range(len(base_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = base_solution[other_route_idx].copy()\n                        if demand[customer] + sum(demand[node] for node in other_route if node != 0) <= capacity:\n                            # Find best insertion position\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(other_route)):\n                                cost = (distance_matrix[other_route[pos-1]][customer] +\n                                       distance_matrix[customer][other_route[pos]] -\n                                       distance_matrix[other_route[pos-1]][other_route[pos]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n\n                            # Create new routes\n                            new_route1 = np.delete(selected_route, customer_idx)\n                            new_route2 = np.insert(other_route, best_pos, customer)\n\n                            # Update solution\n                            new_solution = [route for i, route in enumerate(new_solution) if i != route_idx and i != other_route_idx]\n                            new_solution.append(new_route1)\n                            new_solution.append(new_route2)\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, customer reallocation, and a novel \"distance-balancing\" operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-8)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n\n    # Combine objectives with weights (can be adjusted)\n    combined_scores = 0.6 * norm_total + 0.4 * norm_makespan\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the base solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    # 1. Route Splitting: Split long routes into two shorter ones\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 3 customers\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # 2. Customer Reallocation: Move customers between routes\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select a customer from route1 to move to route2\n        customer_pos = random.randint(1, len(route1)-2)\n        customer = route1[customer_pos]\n\n        # Check capacity constraint\n        if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            # Insert customer into route2\n            insert_pos = random.randint(1, len(route2)-1)\n            new_route2 = np.concatenate([\n                route2[:insert_pos],\n                [customer],\n                route2[insert_pos:]\n            ])\n\n            # Remove customer from route1\n            new_route1 = np.concatenate([\n                route1[:customer_pos],\n                route1[customer_pos+1:]\n            ])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # 3. Distance Balancing Operator: Adjust routes to balance distances\n    if len(new_solution) > 1:\n        # Find the two most extreme routes (shortest and longest)\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                         for route in new_solution]\n        shortest_idx = np.argmin(route_lengths)\n        longest_idx = np.argmax(route_lengths)\n\n        if shortest_idx != longest_idx:\n            # Try to transfer a customer from longest to shortest route\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            for _ in range(3):  # Try a few times\n                if len(longest_route) <= 2:\n                    break\n\n                # Select a customer from longest route\n                customer_pos = random.randint(1, len(longest_route)-2)\n                customer = longest_route[customer_pos]\n\n                # Check capacity constraint\n                if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion position in shortest route\n                    min_increase = float('inf')\n                    best_pos = 1\n                    for pos in range(1, len(shortest_route)):\n                        # Calculate distance increase\n                        increase = (distance_matrix[shortest_route[pos-1], customer] +\n                                   distance_matrix[customer, shortest_route[pos]] -\n                                   distance_matrix[shortest_route[pos-1], shortest_route[pos]])\n\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Insert customer into shortest route\n                    new_shortest = np.concatenate([\n                        shortest_route[:best_pos],\n                        [customer],\n                        shortest_route[best_pos:]\n                    ])\n\n                    # Remove customer from longest route\n                    new_longest = np.concatenate([\n                        longest_route[:customer_pos],\n                        longest_route[customer_pos+1:]\n                    ])\n\n                    # Update solution\n                    new_solution[shortest_idx] = new_shortest\n                    new_solution[longest_idx] = new_longest\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4705766675063018,
            2.0957895517349243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-8)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n\n    # Combine objectives with weights (can be adjusted)\n    combined_scores = 0.6 * norm_total + 0.4 * norm_makespan\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the base solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    # 1. Route Splitting: Split long routes into two shorter ones\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 3 customers\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # 2. Customer Reallocation: Move customers between routes\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select a customer from route1 to move to route2\n        customer_pos = random.randint(1, len(route1)-2)\n        customer = route1[customer_pos]\n\n        # Check capacity constraint\n        if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            # Insert customer into route2\n            insert_pos = random.randint(1, len(route2)-1)\n            new_route2 = np.concatenate([\n                route2[:insert_pos],\n                [customer],\n                route2[insert_pos:]\n            ])\n\n            # Remove customer from route1\n            new_route1 = np.concatenate([\n                route1[:customer_pos],\n                route1[customer_pos+1:]\n            ])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # 3. Distance Balancing Operator: Adjust routes to balance distances\n    if len(new_solution) > 1:\n        # Find the two most extreme routes (shortest and longest)\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                         for route in new_solution]\n        shortest_idx = np.argmin(route_lengths)\n        longest_idx = np.argmax(route_lengths)\n\n        if shortest_idx != longest_idx:\n            # Try to transfer a customer from longest to shortest route\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            for _ in range(3):  # Try a few times\n                if len(longest_route) <= 2:\n                    break\n\n                # Select a customer from longest route\n                customer_pos = random.randint(1, len(longest_route)-2)\n                customer = longest_route[customer_pos]\n\n                # Check capacity constraint\n                if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion position in shortest route\n                    min_increase = float('inf')\n                    best_pos = 1\n                    for pos in range(1, len(shortest_route)):\n                        # Calculate distance increase\n                        increase = (distance_matrix[shortest_route[pos-1], customer] +\n                                   distance_matrix[customer, shortest_route[pos]] -\n                                   distance_matrix[shortest_route[pos-1], shortest_route[pos]])\n\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Insert customer into shortest route\n                    new_shortest = np.concatenate([\n                        shortest_route[:best_pos],\n                        [customer],\n                        shortest_route[best_pos:]\n                    ])\n\n                    # Remove customer from longest route\n                    new_longest = np.concatenate([\n                        longest_route[:customer_pos],\n                        longest_route[customer_pos+1:]\n                    ])\n\n                    # Update solution\n                    new_solution[shortest_idx] = new_shortest\n                    new_solution[longest_idx] = new_longest\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{The algorithm selects a solution with the smallest makespan from the archive, then applies a hybrid local search combining route fragmentation and demand-aware insertion to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Route fragmentation + demand-aware insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Fragment the route into segments\n        segments = []\n        current_segment = [route[0]]\n        current_load = 0\n        for i in range(1, len(route)-1):\n            node = route[i]\n            if current_load + demand[node] <= capacity:\n                current_segment.append(node)\n                current_load += demand[node]\n            else:\n                current_segment.append(route[-1])\n                segments.append(current_segment)\n                current_segment = [route[0], node]\n                current_load = demand[node]\n        current_segment.append(route[-1])\n        segments.append(current_segment)\n\n        # Rebuild routes with demand-aware insertion\n        temp_routes = []\n        for seg in segments:\n            if len(seg) <= 2:  # Skip empty segments\n                continue\n            temp_route = [seg[0]]\n            remaining_nodes = seg[1:-1]\n            np.random.shuffle(remaining_nodes)  # Randomize insertion order\n\n            for node in remaining_nodes:\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(temp_route)):\n                    # Insert node between temp_route[i-1] and temp_route[i]\n                    cost = (distance_matrix[temp_route[i-1], node] +\n                            distance_matrix[node, temp_route[i]] -\n                            distance_matrix[temp_route[i-1], temp_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n                temp_route.insert(best_pos, node)\n            temp_route.append(seg[-1])\n            temp_routes.append(np.array(temp_route))\n\n        # Merge small routes if possible\n        merged_routes = []\n        for route in temp_routes:\n            if len(route) <= 2:\n                continue\n            merged = False\n            for i, existing_route in enumerate(merged_routes):\n                if (np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]]) <= capacity):\n                    # Merge routes\n                    new_route = np.concatenate([existing_route[:-1], route[1:]])\n                    merged_routes[i] = new_route\n                    merged = True\n                    break\n            if not merged:\n                merged_routes.append(route)\n\n        new_solution.extend(merged_routes)\n\n    # Convert back to original format (list of routes)\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Only include non-trivial routes\n            final_solution.append(route)\n\n    # Ensure all customers are served (fallback)\n    all_customers = set(range(1, len(demand)))\n    served = set()\n    for route in final_solution:\n        served.update(route[1:-1])\n    missing = all_customers - served\n    if missing:\n        # Create new routes for missing customers\n        remaining_nodes = list(missing)\n        while remaining_nodes:\n            new_route = [0]\n            current_load = 0\n            i = 0\n            while i < len(remaining_nodes):\n                node = remaining_nodes[i]\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                    remaining_nodes.pop(i)\n                else:\n                    i += 1\n            new_route.append(0)\n            final_solution.append(np.array(new_route))\n\n    return final_solution\n\n",
        "score": [
            -0.523074633086376,
            3.3254560232162476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Route fragmentation + demand-aware insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Fragment the route into segments\n        segments = []\n        current_segment = [route[0]]\n        current_load = 0\n        for i in range(1, len(route)-1):\n            node = route[i]\n            if current_load + demand[node] <= capacity:\n                current_segment.append(node)\n                current_load += demand[node]\n            else:\n                current_segment.append(route[-1])\n                segments.append(current_segment)\n                current_segment = [route[0], node]\n                current_load = demand[node]\n        current_segment.append(route[-1])\n        segments.append(current_segment)\n\n        # Rebuild routes with demand-aware insertion\n        temp_routes = []\n        for seg in segments:\n            if len(seg) <= 2:  # Skip empty segments\n                continue\n            temp_route = [seg[0]]\n            remaining_nodes = seg[1:-1]\n            np.random.shuffle(remaining_nodes)  # Randomize insertion order\n\n            for node in remaining_nodes:\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(temp_route)):\n                    # Insert node between temp_route[i-1] and temp_route[i]\n                    cost = (distance_matrix[temp_route[i-1], node] +\n                            distance_matrix[node, temp_route[i]] -\n                            distance_matrix[temp_route[i-1], temp_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n                temp_route.insert(best_pos, node)\n            temp_route.append(seg[-1])\n            temp_routes.append(np.array(temp_route))\n\n        # Merge small routes if possible\n        merged_routes = []\n        for route in temp_routes:\n            if len(route) <= 2:\n                continue\n            merged = False\n            for i, existing_route in enumerate(merged_routes):\n                if (np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]]) <= capacity):\n                    # Merge routes\n                    new_route = np.concatenate([existing_route[:-1], route[1:]])\n                    merged_routes[i] = new_route\n                    merged = True\n                    break\n            if not merged:\n                merged_routes.append(route)\n\n        new_solution.extend(merged_routes)\n\n    # Convert back to original format (list of routes)\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Only include non-trivial routes\n            final_solution.append(route)\n\n    # Ensure all customers are served (fallback)\n    all_customers = set(range(1, len(demand)))\n    served = set()\n    for route in final_solution:\n        served.update(route[1:-1])\n    missing = all_customers - served\n    if missing:\n        # Create new routes for missing customers\n        remaining_nodes = list(missing)\n        while remaining_nodes:\n            new_route = [0]\n            current_load = 0\n            i = 0\n            while i < len(remaining_nodes):\n                node = remaining_nodes[i]\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                    remaining_nodes.pop(i)\n                else:\n                    i += 1\n            new_route.append(0)\n            final_solution.append(np.array(new_route))\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search: a combination of route splitting and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts and reinsert customers\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Reinsert customers from part2 into part1 if feasible\n        for customer in part2[1:-1]:\n            if np.sum(demand[part1[1:-1]]) + demand[customer] <= capacity:\n                part1 = np.insert(part1, -1, customer)\n            else:\n                new_solution.append(part1.copy())\n                part1 = np.array([0, customer, 0])\n\n        if len(part1) > 2:\n            new_solution.append(part1.copy())\n\n    # Step 3: Apply a 2-opt* move to further improve the solution\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 4:\n            continue\n\n        # Randomly select two edges to reverse\n        a, b = sorted(np.random.choice(range(1, len(route)-2), 2, replace=False))\n        c, d = a+1, b+1\n\n        # Check feasibility\n        if np.sum(demand[route[a+1:b+1]]) <= capacity:\n            new_route = np.concatenate([route[:a+1], route[b:d][::-1], route[d:]])\n            new_solution[i] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7059333700831925,
            5.948176771402359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search: a combination of route splitting and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts and reinsert customers\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Reinsert customers from part2 into part1 if feasible\n        for customer in part2[1:-1]:\n            if np.sum(demand[part1[1:-1]]) + demand[customer] <= capacity:\n                part1 = np.insert(part1, -1, customer)\n            else:\n                new_solution.append(part1.copy())\n                part1 = np.array([0, customer, 0])\n\n        if len(part1) > 2:\n            new_solution.append(part1.copy())\n\n    # Step 3: Apply a 2-opt* move to further improve the solution\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 4:\n            continue\n\n        # Randomly select two edges to reverse\n        a, b = sorted(np.random.choice(range(1, len(route)-2), 2, replace=False))\n        c, d = a+1, b+1\n\n        # Check feasibility\n        if np.sum(demand[route[a+1:b+1]]) <= capacity:\n            new_route = np.concatenate([route[:a+1], route[b:d][::-1], route[d:]])\n            new_solution[i] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{My novel local search strategy combines route merging, customer reallocation, and a capacity-aware two-opt variant to balance distance and makespan objectives by intelligently redistributing customers between routes while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan then distance\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route merging + customer reallocation + capacity-aware 2-opt\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes for potential merging\n        route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Step 2: Check if merging is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution.pop(route_indices[1]) if route_indices[0] < route_indices[1] else new_solution.pop(route_indices[0])\n            new_solution[route_indices[0]] = merged_route\n        else:\n            # Step 3: If merging fails, try customer reallocation\n            for customer in route1[1:-1]:\n                if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Move customer to route2\n                    route1 = np.delete(route1, np.where(route1 == customer)[0][0])\n                    insert_pos = np.random.randint(1, len(route2))\n                    route2 = np.insert(route2, insert_pos, customer)\n                    break\n\n        # Step 4: Apply capacity-aware 2-opt on a random route\n        if len(new_solution) > 0:\n            target_route_idx = np.random.randint(len(new_solution))\n            target_route = new_solution[target_route_idx].copy()\n\n            # Find best 2-opt move that maintains capacity\n            best_improvement = 0\n            best_i, best_j = -1, -1\n            for i in range(1, len(target_route)-2):\n                for j in range(i+1, len(target_route)-1):\n                    # Check capacity for the reversed segment\n                    segment = target_route[i:j+1]\n                    reversed_segment = segment[::-1]\n                    if sum(demand[reversed_segment[1:-1]]) <= capacity:\n                        # Calculate improvement\n                        original_dist = (distance_matrix[target_route[i-1], target_route[i]] +\n                                        distance_matrix[target_route[j], target_route[j+1]])\n                        new_dist = (distance_matrix[target_route[i-1], reversed_segment[0]] +\n                                   distance_matrix[reversed_segment[-1], target_route[j+1]])\n                        improvement = original_dist - new_dist\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_i, best_j = i, j\n\n            # Apply the best move if found\n            if best_i != -1:\n                target_route[best_i:best_j+1] = target_route[best_i:best_j+1][::-1]\n                new_solution[target_route_idx] = target_route\n\n    return new_solution\n\n",
        "score": [
            -0.6669233326718966,
            6.536586225032806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan then distance\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route merging + customer reallocation + capacity-aware 2-opt\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes for potential merging\n        route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Step 2: Check if merging is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution.pop(route_indices[1]) if route_indices[0] < route_indices[1] else new_solution.pop(route_indices[0])\n            new_solution[route_indices[0]] = merged_route\n        else:\n            # Step 3: If merging fails, try customer reallocation\n            for customer in route1[1:-1]:\n                if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Move customer to route2\n                    route1 = np.delete(route1, np.where(route1 == customer)[0][0])\n                    insert_pos = np.random.randint(1, len(route2))\n                    route2 = np.insert(route2, insert_pos, customer)\n                    break\n\n        # Step 4: Apply capacity-aware 2-opt on a random route\n        if len(new_solution) > 0:\n            target_route_idx = np.random.randint(len(new_solution))\n            target_route = new_solution[target_route_idx].copy()\n\n            # Find best 2-opt move that maintains capacity\n            best_improvement = 0\n            best_i, best_j = -1, -1\n            for i in range(1, len(target_route)-2):\n                for j in range(i+1, len(target_route)-1):\n                    # Check capacity for the reversed segment\n                    segment = target_route[i:j+1]\n                    reversed_segment = segment[::-1]\n                    if sum(demand[reversed_segment[1:-1]]) <= capacity:\n                        # Calculate improvement\n                        original_dist = (distance_matrix[target_route[i-1], target_route[i]] +\n                                        distance_matrix[target_route[j], target_route[j+1]])\n                        new_dist = (distance_matrix[target_route[i-1], reversed_segment[0]] +\n                                   distance_matrix[reversed_segment[-1], target_route[j+1]])\n                        improvement = original_dist - new_dist\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_i, best_j = i, j\n\n            # Apply the best move if found\n            if best_i != -1:\n                target_route[best_i:best_j+1] = target_route[best_i:best_j+1][::-1]\n                new_solution[target_route_idx] = target_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify the longest route in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random customer\n    split_pos = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_pos + 1]\n    part2 = longest_route[split_pos:]\n\n    # Check capacity feasibility for the split parts\n    if demand[part1[1:-1]].sum() <= capacity and demand[part2[1:-1]].sum() <= capacity:\n        # Replace the original route with the two new routes\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n\n    # Attempt to reallocate a random customer from another route to the longest route\n    if len(new_solution) > 1:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != longest_route_idx])\n        other_route = new_solution[other_route_idx].copy()\n\n        if len(other_route) > 2:  # Ensure there's a customer to move\n            customer_pos = np.random.randint(1, len(other_route) - 1)\n            customer = other_route[customer_pos]\n\n            # Check if adding this customer to the longest route is feasible\n            if demand[new_solution[longest_route_idx][1:-1]].sum() + demand[customer] <= capacity:\n                # Insert the customer into the longest route at a random position\n                insert_pos = np.random.randint(1, len(new_solution[longest_route_idx]))\n                new_solution[longest_route_idx] = np.insert(new_solution[longest_route_idx], insert_pos, customer)\n\n                # Remove the customer from the other route\n                other_route = np.delete(other_route, customer_pos)\n                if len(other_route) > 2:  # Keep the route if it still has customers\n                    new_solution[other_route_idx] = other_route\n                else:  # Remove the empty route\n                    new_solution.pop(other_route_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.8623014363265793,
            0.7176578640937805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify the longest route in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random customer\n    split_pos = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_pos + 1]\n    part2 = longest_route[split_pos:]\n\n    # Check capacity feasibility for the split parts\n    if demand[part1[1:-1]].sum() <= capacity and demand[part2[1:-1]].sum() <= capacity:\n        # Replace the original route with the two new routes\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n\n    # Attempt to reallocate a random customer from another route to the longest route\n    if len(new_solution) > 1:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != longest_route_idx])\n        other_route = new_solution[other_route_idx].copy()\n\n        if len(other_route) > 2:  # Ensure there's a customer to move\n            customer_pos = np.random.randint(1, len(other_route) - 1)\n            customer = other_route[customer_pos]\n\n            # Check if adding this customer to the longest route is feasible\n            if demand[new_solution[longest_route_idx][1:-1]].sum() + demand[customer] <= capacity:\n                # Insert the customer into the longest route at a random position\n                insert_pos = np.random.randint(1, len(new_solution[longest_route_idx]))\n                new_solution[longest_route_idx] = np.insert(new_solution[longest_route_idx], insert_pos, customer)\n\n                # Remove the customer from the other route\n                other_route = np.delete(other_route, customer_pos)\n                if len(other_route) > 2:  # Keep the route if it still has customers\n                    new_solution[other_route_idx] = other_route\n                else:  # Remove the empty route\n                    new_solution.pop(other_route_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{A hybrid local search operator that combines route segment swaps with demand-aware route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Choose a random route to modify\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = list(range(len(selected_solution)))\n    i = random.choice(route_indices)\n    route_i = selected_solution[i]\n\n    # Try to merge with another route if possible\n    if len(selected_solution) > 1:\n        j = random.choice([x for x in route_indices if x != i])\n        route_j = selected_solution[j]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route_i's customers into route_j\n            merged_route = [0] + list(route_j[1:-1]) + list(route_i[1:-1]) + [0]\n            # Remove duplicates and re-optimize (simplified here)\n            unique_customers = list(dict.fromkeys(merged_route[1:-1]))\n            merged_route = [0] + unique_customers + [0]\n\n            # Check feasibility\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Replace both routes with the merged one\n                new_solution = [r for idx, r in enumerate(selected_solution) if idx not in {i, j}]\n                new_solution.append(np.array(merged_route))\n                return new_solution\n\n    # If merging fails, try a segment swap\n    if len(route_i) > 3:  # Need at least 2 customers to swap\n        # Select a random segment from route_i\n        start_idx = random.randint(1, len(route_i) - 3)\n        end_idx = random.randint(start_idx + 1, len(route_i) - 2)\n        segment = route_i[start_idx:end_idx]\n\n        # Find another route to insert the segment\n        for j in route_indices:\n            if j == i:\n                continue\n            route_j = selected_solution[j]\n\n            # Try inserting the segment into route_j\n            for pos in range(1, len(route_j)):\n                # Create new route with segment inserted\n                new_route_j = np.concatenate([route_j[:pos], segment, route_j[pos:]])\n                if np.sum(demand[new_route_j[1:-1]]) <= capacity:\n                    # Remove segment from original route\n                    new_route_i = np.concatenate([route_i[:start_idx], route_i[end_idx:]])\n                    if np.sum(demand[new_route_i[1:-1]]) <= capacity:\n                        # Update solution\n                        new_solution = selected_solution.copy()\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n                        return new_solution\n\n    # If no improvement found, return original solution\n    return selected_solution\n\n",
        "score": [
            -0.5976795512069375,
            2.2477922439575195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Choose a random route to modify\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = list(range(len(selected_solution)))\n    i = random.choice(route_indices)\n    route_i = selected_solution[i]\n\n    # Try to merge with another route if possible\n    if len(selected_solution) > 1:\n        j = random.choice([x for x in route_indices if x != i])\n        route_j = selected_solution[j]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route_i's customers into route_j\n            merged_route = [0] + list(route_j[1:-1]) + list(route_i[1:-1]) + [0]\n            # Remove duplicates and re-optimize (simplified here)\n            unique_customers = list(dict.fromkeys(merged_route[1:-1]))\n            merged_route = [0] + unique_customers + [0]\n\n            # Check feasibility\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Replace both routes with the merged one\n                new_solution = [r for idx, r in enumerate(selected_solution) if idx not in {i, j}]\n                new_solution.append(np.array(merged_route))\n                return new_solution\n\n    # If merging fails, try a segment swap\n    if len(route_i) > 3:  # Need at least 2 customers to swap\n        # Select a random segment from route_i\n        start_idx = random.randint(1, len(route_i) - 3)\n        end_idx = random.randint(start_idx + 1, len(route_i) - 2)\n        segment = route_i[start_idx:end_idx]\n\n        # Find another route to insert the segment\n        for j in route_indices:\n            if j == i:\n                continue\n            route_j = selected_solution[j]\n\n            # Try inserting the segment into route_j\n            for pos in range(1, len(route_j)):\n                # Create new route with segment inserted\n                new_route_j = np.concatenate([route_j[:pos], segment, route_j[pos:]])\n                if np.sum(demand[new_route_j[1:-1]]) <= capacity:\n                    # Remove segment from original route\n                    new_route_i = np.concatenate([route_i[:start_idx], route_i[end_idx:]])\n                    if np.sum(demand[new_route_i[1:-1]]) <= capacity:\n                        # Update solution\n                        new_solution = selected_solution.copy()\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n                        return new_solution\n\n    # If no improvement found, return original solution\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine route merging and intra-route 3-opt\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential merging\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by inserting route2 into route1 at the closest possible points\n            insertion_costs = []\n            for i in range(1, len(route1)):\n                for j in range(1, len(route2)):\n                    # Cost of inserting route2[j] after route1[i]\n                    cost = (distance_matrix[route1[i-1], route2[j]] +\n                            distance_matrix[route2[j], route1[i]] -\n                            distance_matrix[route1[i-1], route1[i]])\n                    insertion_costs.append((i, j, cost))\n\n            if insertion_costs:\n                # Select the insertion with the lowest cost\n                best_i, best_j, _ = min(insertion_costs, key=lambda x: x[2])\n                # Merge the routes\n                merged_route = np.concatenate([route1[:best_i], route2[1:-1], route1[best_i:]])\n                new_solution[route1_idx] = merged_route\n                new_solution = np.delete(new_solution, route2_idx)\n        else:\n            # If merging is not feasible, perform intra-route 3-opt on the selected route\n            selected_route = new_solution[route1_idx]\n            if len(selected_route) > 5:  # Ensure route is long enough for 3-opt\n                # Randomly select three distinct edges to reverse\n                a, b, c = sorted(np.random.choice(range(1, len(selected_route)-1), 3, replace=False))\n                # Create three possible 3-opt moves\n                route_options = [\n                    np.concatenate([selected_route[:a], selected_route[b:c+1][::-1], selected_route[a:b], selected_route[c+1:]]),\n                    np.concatenate([selected_route[:a], selected_route[b:c+1], selected_route[a:b][::-1], selected_route[c+1:]]),\n                    np.concatenate([selected_route[:b], selected_route[a:c+1][::-1], selected_route[b:a], selected_route[c+1:]])\n                ]\n                # Select the option that minimizes the route distance\n                original_distance = np.sum(distance_matrix[selected_route[:-1], selected_route[1:]])\n                best_option = min(route_options, key=lambda r: np.sum(distance_matrix[r[:-1], r[1:]]))\n                if np.sum(distance_matrix[best_option[:-1], best_option[1:]]) < original_distance:\n                    new_solution[route1_idx] = best_option\n\n    return new_solution\n\n",
        "score": [
            -0.4577959386409394,
            1.2297418117523193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine route merging and intra-route 3-opt\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential merging\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by inserting route2 into route1 at the closest possible points\n            insertion_costs = []\n            for i in range(1, len(route1)):\n                for j in range(1, len(route2)):\n                    # Cost of inserting route2[j] after route1[i]\n                    cost = (distance_matrix[route1[i-1], route2[j]] +\n                            distance_matrix[route2[j], route1[i]] -\n                            distance_matrix[route1[i-1], route1[i]])\n                    insertion_costs.append((i, j, cost))\n\n            if insertion_costs:\n                # Select the insertion with the lowest cost\n                best_i, best_j, _ = min(insertion_costs, key=lambda x: x[2])\n                # Merge the routes\n                merged_route = np.concatenate([route1[:best_i], route2[1:-1], route1[best_i:]])\n                new_solution[route1_idx] = merged_route\n                new_solution = np.delete(new_solution, route2_idx)\n        else:\n            # If merging is not feasible, perform intra-route 3-opt on the selected route\n            selected_route = new_solution[route1_idx]\n            if len(selected_route) > 5:  # Ensure route is long enough for 3-opt\n                # Randomly select three distinct edges to reverse\n                a, b, c = sorted(np.random.choice(range(1, len(selected_route)-1), 3, replace=False))\n                # Create three possible 3-opt moves\n                route_options = [\n                    np.concatenate([selected_route[:a], selected_route[b:c+1][::-1], selected_route[a:b], selected_route[c+1:]]),\n                    np.concatenate([selected_route[:a], selected_route[b:c+1], selected_route[a:b][::-1], selected_route[c+1:]]),\n                    np.concatenate([selected_route[:b], selected_route[a:c+1][::-1], selected_route[b:a], selected_route[c+1:]])\n                ]\n                # Select the option that minimizes the route distance\n                original_distance = np.sum(distance_matrix[selected_route[:-1], selected_route[1:]])\n                best_option = min(route_options, key=lambda r: np.sum(distance_matrix[r[:-1], r[1:]]))\n                if np.sum(distance_matrix[best_option[:-1], best_option[1:]]) < original_distance:\n                    new_solution[route1_idx] = best_option\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{A hybrid local search strategy that combines route merging, customer reallocation, and capacity-aware crossover to generate high-quality neighbors by intelligently selecting promising routes and reallocating customers while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Randomly select two routes to merge or modify\n    if len(selected_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(selected_solution)), 2)\n        route1 = selected_solution[route1_idx]\n        route2 = selected_solution[route2_idx]\n\n        # Attempt to merge routes if feasible\n        merged_route = []\n        current_load = 0\n        for node in route1[1:-1]:  # Skip depot\n            if current_load + demand[node] <= capacity:\n                merged_route.append(node)\n                current_load += demand[node]\n        for node in route2[1:-1]:  # Skip depot\n            if current_load + demand[node] <= capacity:\n                merged_route.append(node)\n                current_load += demand[node]\n\n        if len(merged_route) > 0:\n            # Create new merged route\n            new_route = np.array([0] + merged_route + [0], dtype=np.int32)\n            # Replace the two routes with the new merged route\n            new_solution = [r for i, r in enumerate(selected_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(new_route)\n        else:\n            # If merge fails, try to reallocate customers between routes\n            new_solution = selected_solution.copy()\n            # Select a random customer from route1 and try to move to route2\n            if len(route1) > 2:\n                customer = random.choice(route1[1:-1])\n                route1_load = sum(demand[route1[1:-1]])\n                route2_load = sum(demand[route2[1:-1]])\n                if route2_load + demand[customer] <= capacity:\n                    # Update routes\n                    updated_route1 = np.array([0] + [n for n in route1[1:-1] if n != customer] + [0], dtype=np.int32)\n                    updated_route2 = np.array([0] + [n for n in route2[1:-1]] + [customer] + [0], dtype=np.int32)\n                    new_solution[route1_idx] = updated_route1\n                    new_solution[route2_idx] = updated_route2\n    else:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7627962009714051,
            0.35781025886535645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Randomly select two routes to merge or modify\n    if len(selected_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(selected_solution)), 2)\n        route1 = selected_solution[route1_idx]\n        route2 = selected_solution[route2_idx]\n\n        # Attempt to merge routes if feasible\n        merged_route = []\n        current_load = 0\n        for node in route1[1:-1]:  # Skip depot\n            if current_load + demand[node] <= capacity:\n                merged_route.append(node)\n                current_load += demand[node]\n        for node in route2[1:-1]:  # Skip depot\n            if current_load + demand[node] <= capacity:\n                merged_route.append(node)\n                current_load += demand[node]\n\n        if len(merged_route) > 0:\n            # Create new merged route\n            new_route = np.array([0] + merged_route + [0], dtype=np.int32)\n            # Replace the two routes with the new merged route\n            new_solution = [r for i, r in enumerate(selected_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(new_route)\n        else:\n            # If merge fails, try to reallocate customers between routes\n            new_solution = selected_solution.copy()\n            # Select a random customer from route1 and try to move to route2\n            if len(route1) > 2:\n                customer = random.choice(route1[1:-1])\n                route1_load = sum(demand[route1[1:-1]])\n                route2_load = sum(demand[route2[1:-1]])\n                if route2_load + demand[customer] <= capacity:\n                    # Update routes\n                    updated_route1 = np.array([0] + [n for n in route1[1:-1] if n != customer] + [0], dtype=np.int32)\n                    updated_route2 = np.array([0] + [n for n in route2[1:-1]] + [customer] + [0], dtype=np.int32)\n                    new_solution[route1_idx] = updated_route1\n                    new_solution[route2_idx] = updated_route2\n    else:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{A novel hybrid local search operator combines route merging, customer reallocation, and demand-aware route splitting to balance distance and makespan objectives while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Merge and reallocate customers between routes\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes and remove empty routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # If merging is not feasible, try reallocating customers\n            for route in [route1, route2]:\n                for customer in route[1:-1]:\n                    # Find another route where adding this customer is feasible\n                    for other_route in new_solution:\n                        if other_route is not route:\n                            if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert customer into the other route (simple insertion)\n                                other_route = np.insert(other_route, -1, customer)\n                                route = np.delete(route, np.where(route == customer)[0][0])\n                                break\n\n    # Demand-aware route splitting: Split long routes if possible\n    for k, route in enumerate(new_solution):\n        if len(route) > 3:  # Route has at least one customer\n            current_demand = sum(demand[route[1:-1]])\n            if current_demand <= capacity * 0.7:  # If route is not fully utilized\n                # Try to split the route into two\n                split_pos = np.random.randint(1, len(route)-1)\n                route1 = np.concatenate([route[:split_pos+1], [0]])\n                route2 = np.concatenate([[0], route[split_pos+1:]])\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[k] = route1\n                    new_solution.append(route2)\n                    break\n\n    # Ensure all routes start and end at depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5275361718214888,
            8.7273508310318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Merge and reallocate customers between routes\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes and remove empty routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # If merging is not feasible, try reallocating customers\n            for route in [route1, route2]:\n                for customer in route[1:-1]:\n                    # Find another route where adding this customer is feasible\n                    for other_route in new_solution:\n                        if other_route is not route:\n                            if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert customer into the other route (simple insertion)\n                                other_route = np.insert(other_route, -1, customer)\n                                route = np.delete(route, np.where(route == customer)[0][0])\n                                break\n\n    # Demand-aware route splitting: Split long routes if possible\n    for k, route in enumerate(new_solution):\n        if len(route) > 3:  # Route has at least one customer\n            current_demand = sum(demand[route[1:-1]])\n            if current_demand <= capacity * 0.7:  # If route is not fully utilized\n                # Try to split the route into two\n                split_pos = np.random.randint(1, len(route)-1)\n                route1 = np.concatenate([route[:split_pos+1], [0]])\n                route2 = np.concatenate([[0], route[split_pos+1:]])\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[k] = route1\n                    new_solution.append(route2)\n                    break\n\n    # Ensure all routes start and end at depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Remove the route from the solution\n        del new_solution[route_idx]\n\n        # Split the selected route into two parts at a random point\n        if len(selected_route) > 3:  # Ensure the route has enough nodes to split\n            split_point = np.random.randint(1, len(selected_route) - 1)\n            first_part = selected_route[:split_point + 1]  # Include the depot\n            second_part = selected_route[split_point:]  # Include the depot\n\n            # Check capacity constraints for both new routes\n            def check_capacity(route):\n                load = 0\n                for node in route[1:-1]:  # Exclude depots\n                    load += demand[node]\n                return load <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution.append(first_part)\n                new_solution.append(second_part)\n            else:\n                # If splitting violates capacity, revert to original route\n                new_solution.append(selected_route)\n        else:\n            # If the route is too short to split, try to reinsert it into another route\n            if len(new_solution) > 0:\n                target_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                target_route = new_solution[target_route_idx].copy()\n\n                # Try to insert the entire route into the target route\n                for i in range(1, len(selected_route) - 1):\n                    node = selected_route[i]\n                    for pos in range(1, len(target_route)):\n                        # Insert node into target route\n                        new_route = np.insert(target_route, pos, node)\n                        if check_capacity(new_route):\n                            # Remove the original route and update the target route\n                            del new_solution[target_route_idx]\n                            new_solution.append(new_route)\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    # If insertion fails, revert to original solution\n                    new_solution.append(selected_route)\n\n    return new_solution\n\n",
        "score": [
            -0.93970751896928,
            0.14675891399383545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Remove the route from the solution\n        del new_solution[route_idx]\n\n        # Split the selected route into two parts at a random point\n        if len(selected_route) > 3:  # Ensure the route has enough nodes to split\n            split_point = np.random.randint(1, len(selected_route) - 1)\n            first_part = selected_route[:split_point + 1]  # Include the depot\n            second_part = selected_route[split_point:]  # Include the depot\n\n            # Check capacity constraints for both new routes\n            def check_capacity(route):\n                load = 0\n                for node in route[1:-1]:  # Exclude depots\n                    load += demand[node]\n                return load <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution.append(first_part)\n                new_solution.append(second_part)\n            else:\n                # If splitting violates capacity, revert to original route\n                new_solution.append(selected_route)\n        else:\n            # If the route is too short to split, try to reinsert it into another route\n            if len(new_solution) > 0:\n                target_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                target_route = new_solution[target_route_idx].copy()\n\n                # Try to insert the entire route into the target route\n                for i in range(1, len(selected_route) - 1):\n                    node = selected_route[i]\n                    for pos in range(1, len(target_route)):\n                        # Insert node into target route\n                        new_route = np.insert(target_route, pos, node)\n                        if check_capacity(new_route):\n                            # Remove the original route and update the target route\n                            del new_solution[target_route_idx]\n                            new_solution.append(new_route)\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    # If insertion fails, revert to original solution\n                    new_solution.append(selected_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        # Apply a hybrid local search: combine 2-opt with insertion heuristic\n        if len(route) > 4:\n            # 2-opt swap\n            i, j = np.random.choice(range(1, len(route)-2), 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n            # Insertion heuristic: move a random customer to another route\n            if len(new_solution) > 1 and len(route) > 3:\n                other_route_idx = np.random.choice([idx for idx in range(len(new_solution)) if idx != route_idx])\n                other_route = new_solution[other_route_idx].copy()\n                customer_pos = np.random.randint(1, len(route)-1)\n                customer = route[customer_pos]\n                # Check if insertion is feasible\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_other_route = np.concatenate([other_route[:-1], [customer], [0]])\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.39670106277867956,
            0.7270818054676056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        # Apply a hybrid local search: combine 2-opt with insertion heuristic\n        if len(route) > 4:\n            # 2-opt swap\n            i, j = np.random.choice(range(1, len(route)-2), 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n            # Insertion heuristic: move a random customer to another route\n            if len(new_solution) > 1 and len(route) > 3:\n                other_route_idx = np.random.choice([idx for idx in range(len(new_solution)) if idx != route_idx])\n                other_route = new_solution[other_route_idx].copy()\n                customer_pos = np.random.randint(1, len(route)-1)\n                customer = route[customer_pos]\n                # Check if insertion is feasible\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_other_route = np.concatenate([other_route[:-1], [customer], [0]])\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = new_other_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm selects a promising solution from the archive, applies a hybrid local search combining route segment swaps and demand-balanced route splits to improve both total distance and makespan, while ensuring feasibility through capacity checks and distance recalculations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine route segment swaps and demand-balanced route splits\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split route into two if demand is too high\n        total_demand = np.sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.8:  # Threshold for splitting\n            # Find a split point that balances demand\n            split_point = 1\n            cumulative_demand = 0\n            for i in range(1, len(route)-1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > capacity / 2:\n                    split_point = i\n                    break\n            # Create two new routes\n            new_route1 = np.concatenate([[0], route[1:split_point+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_point+1:], [0]])\n            new_solution.extend([new_route1, new_route2])\n        else:\n            # Attempt a segment swap with another route\n            if len(selected_solution) > 1 and len(route) > 3:\n                other_route = random.choice([r for r in selected_solution if not np.array_equal(r, route)])\n                if len(other_route) > 3:\n                    # Find a segment in each route to swap\n                    seg1_start = random.randint(1, len(route)-3)\n                    seg1_end = random.randint(seg1_start+1, len(route)-2)\n                    seg2_start = random.randint(1, len(other_route)-3)\n                    seg2_end = random.randint(seg2_start+1, len(other_route)-2)\n\n                    # Check capacity constraints\n                    seg1_demand = np.sum(demand[route[seg1_start:seg1_end]])\n                    seg2_demand = np.sum(demand[other_route[seg2_start:seg2_end]])\n                    if (np.sum(demand[route[1:-1]]) - seg1_demand + seg2_demand <= capacity and\n                        np.sum(demand[other_route[1:-1]]) - seg2_demand + seg1_demand <= capacity):\n                        # Perform the swap\n                        new_route1 = np.concatenate([route[:seg1_start], other_route[seg2_start:seg2_end], route[seg1_end:]])\n                        new_route2 = np.concatenate([other_route[:seg2_start], route[seg1_start:seg1_end], other_route[seg2_end:]])\n                        new_solution.extend([new_route1, new_route2])\n                    else:\n                        new_solution.append(route)\n            else:\n                new_solution.append(route)\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    missing_customers = all_customers - served_customers\n\n    # Assign missing customers to routes with remaining capacity\n    for customer in missing_customers:\n        best_route = None\n        best_insert_pos = None\n        best_added_distance = float('inf')\n\n        for i, route in enumerate(new_solution):\n            current_demand = np.sum(demand[route[1:-1]])\n            if current_demand + demand[customer] > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                # Calculate added distance for inserting customer at position pos\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                added_distance = (distance_matrix[prev_node, customer] +\n                                 distance_matrix[customer, next_node] -\n                                 distance_matrix[prev_node, next_node])\n\n                if added_distance < best_added_distance:\n                    best_route = i\n                    best_insert_pos = pos\n                    best_added_distance = added_distance\n\n        if best_route is not None:\n            # Insert the customer\n            new_solution[best_route] = np.concatenate([\n                new_solution[best_route][:best_insert_pos],\n                [customer],\n                new_solution[best_route][best_insert_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.7737196476019605,
            1.9795702993869781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine route segment swaps and demand-balanced route splits\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split route into two if demand is too high\n        total_demand = np.sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.8:  # Threshold for splitting\n            # Find a split point that balances demand\n            split_point = 1\n            cumulative_demand = 0\n            for i in range(1, len(route)-1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > capacity / 2:\n                    split_point = i\n                    break\n            # Create two new routes\n            new_route1 = np.concatenate([[0], route[1:split_point+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_point+1:], [0]])\n            new_solution.extend([new_route1, new_route2])\n        else:\n            # Attempt a segment swap with another route\n            if len(selected_solution) > 1 and len(route) > 3:\n                other_route = random.choice([r for r in selected_solution if not np.array_equal(r, route)])\n                if len(other_route) > 3:\n                    # Find a segment in each route to swap\n                    seg1_start = random.randint(1, len(route)-3)\n                    seg1_end = random.randint(seg1_start+1, len(route)-2)\n                    seg2_start = random.randint(1, len(other_route)-3)\n                    seg2_end = random.randint(seg2_start+1, len(other_route)-2)\n\n                    # Check capacity constraints\n                    seg1_demand = np.sum(demand[route[seg1_start:seg1_end]])\n                    seg2_demand = np.sum(demand[other_route[seg2_start:seg2_end]])\n                    if (np.sum(demand[route[1:-1]]) - seg1_demand + seg2_demand <= capacity and\n                        np.sum(demand[other_route[1:-1]]) - seg2_demand + seg1_demand <= capacity):\n                        # Perform the swap\n                        new_route1 = np.concatenate([route[:seg1_start], other_route[seg2_start:seg2_end], route[seg1_end:]])\n                        new_route2 = np.concatenate([other_route[:seg2_start], route[seg1_start:seg1_end], other_route[seg2_end:]])\n                        new_solution.extend([new_route1, new_route2])\n                    else:\n                        new_solution.append(route)\n            else:\n                new_solution.append(route)\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    all_customers = set(range(1, len(coords)))\n    missing_customers = all_customers - served_customers\n\n    # Assign missing customers to routes with remaining capacity\n    for customer in missing_customers:\n        best_route = None\n        best_insert_pos = None\n        best_added_distance = float('inf')\n\n        for i, route in enumerate(new_solution):\n            current_demand = np.sum(demand[route[1:-1]])\n            if current_demand + demand[customer] > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                # Calculate added distance for inserting customer at position pos\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                added_distance = (distance_matrix[prev_node, customer] +\n                                 distance_matrix[customer, next_node] -\n                                 distance_matrix[prev_node, next_node])\n\n                if added_distance < best_added_distance:\n                    best_route = i\n                    best_insert_pos = pos\n                    best_added_distance = added_distance\n\n        if best_route is not None:\n            # Insert the customer\n            new_solution[best_route] = np.concatenate([\n                new_solution[best_route][:best_insert_pos],\n                [customer],\n                new_solution[best_route][best_insert_pos:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([sol[1][0] + sol[1][1] for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: combine route splitting, cross-route relocations, and demand-aware segment swaps\n    for _ in range(5):  # Number of attempts\n        # Step 1: Route splitting - split a long route into two if possible\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Avoid trivial splits\n                split_pos = np.random.randint(1, len(route)-1)\n                new_route1 = route[:split_pos+1]\n                new_route2 = route[split_pos:]\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Step 2: Cross-route relocation - move a segment between routes\n        if len(new_solution) > 1:\n            r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[r1]\n            route2 = new_solution[r2]\n            if len(route1) > 3 and len(route2) > 3:\n                seg_len = np.random.randint(1, min(3, len(route1)-2))\n                seg_start = np.random.randint(1, len(route1)-seg_len)\n                segment = route1[seg_start:seg_start+seg_len]\n                if np.sum(demand[segment]) <= capacity - np.sum(demand[route2[1:-1]]):\n                    # Remove segment from route1\n                    new_route1 = np.concatenate([route1[:seg_start], route1[seg_start+seg_len:]])\n                    # Insert segment into route2 (random position)\n                    insert_pos = np.random.randint(1, len(route2))\n                    new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                    new_solution[r1] = new_route1\n                    new_solution[r2] = new_route2\n\n        # Step 3: Demand-aware segment swap - swap segments between routes if demands match\n        if len(new_solution) > 1:\n            r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[r1]\n            route2 = new_solution[r2]\n            if len(route1) > 3 and len(route2) > 3:\n                # Find segments with similar total demand\n                for seg_len in range(1, min(3, len(route1)-2, len(route2)-2)):\n                    for seg1_start in range(1, len(route1)-seg_len):\n                        seg1 = route1[seg1_start:seg1_start+seg_len]\n                        seg1_demand = np.sum(demand[seg1])\n                        for seg2_start in range(1, len(route2)-seg_len):\n                            seg2 = route2[seg2_start:seg2_start+seg_len]\n                            seg2_demand = np.sum(demand[seg2])\n                            if abs(seg1_demand - seg2_demand) < 0.1 * capacity:\n                                # Check capacity constraints\n                                if (seg1_demand <= capacity - np.sum(demand[route2[1:-1]]) + seg2_demand and\n                                    seg2_demand <= capacity - np.sum(demand[route1[1:-1]]) + seg1_demand):\n                                    # Perform swap\n                                    new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_start+seg_len:]])\n                                    new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_start+seg_len:]])\n                                    new_solution[r1] = new_route1\n                                    new_solution[r2] = new_route2\n                                    break\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7905375307278728,
            10.760657131671906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([sol[1][0] + sol[1][1] for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: combine route splitting, cross-route relocations, and demand-aware segment swaps\n    for _ in range(5):  # Number of attempts\n        # Step 1: Route splitting - split a long route into two if possible\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Avoid trivial splits\n                split_pos = np.random.randint(1, len(route)-1)\n                new_route1 = route[:split_pos+1]\n                new_route2 = route[split_pos:]\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Step 2: Cross-route relocation - move a segment between routes\n        if len(new_solution) > 1:\n            r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[r1]\n            route2 = new_solution[r2]\n            if len(route1) > 3 and len(route2) > 3:\n                seg_len = np.random.randint(1, min(3, len(route1)-2))\n                seg_start = np.random.randint(1, len(route1)-seg_len)\n                segment = route1[seg_start:seg_start+seg_len]\n                if np.sum(demand[segment]) <= capacity - np.sum(demand[route2[1:-1]]):\n                    # Remove segment from route1\n                    new_route1 = np.concatenate([route1[:seg_start], route1[seg_start+seg_len:]])\n                    # Insert segment into route2 (random position)\n                    insert_pos = np.random.randint(1, len(route2))\n                    new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                    new_solution[r1] = new_route1\n                    new_solution[r2] = new_route2\n\n        # Step 3: Demand-aware segment swap - swap segments between routes if demands match\n        if len(new_solution) > 1:\n            r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[r1]\n            route2 = new_solution[r2]\n            if len(route1) > 3 and len(route2) > 3:\n                # Find segments with similar total demand\n                for seg_len in range(1, min(3, len(route1)-2, len(route2)-2)):\n                    for seg1_start in range(1, len(route1)-seg_len):\n                        seg1 = route1[seg1_start:seg1_start+seg_len]\n                        seg1_demand = np.sum(demand[seg1])\n                        for seg2_start in range(1, len(route2)-seg_len):\n                            seg2 = route2[seg2_start:seg2_start+seg_len]\n                            seg2_demand = np.sum(demand[seg2])\n                            if abs(seg1_demand - seg2_demand) < 0.1 * capacity:\n                                # Check capacity constraints\n                                if (seg1_demand <= capacity - np.sum(demand[route2[1:-1]]) + seg2_demand and\n                                    seg2_demand <= capacity - np.sum(demand[route1[1:-1]]) + seg1_demand):\n                                    # Perform swap\n                                    new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_start+seg_len:]])\n                                    new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_start+seg_len:]])\n                                    new_solution[r1] = new_route1\n                                    new_solution[r2] = new_route2\n                                    break\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(base_solution)):\n        route = base_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split route into two parts and reallocate customers between them\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check capacity feasibility\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If split is infeasible, try reallocating customers to other routes\n            for customer in route[1:-1]:\n                for j in range(len(new_solution)):\n                    if j != i:\n                        temp_route = np.append(new_solution[j][:-1], [customer, 0])\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[j] = temp_route\n                            new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == customer))\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.7674859915716845,
            0.8250285983085632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(base_solution)):\n        route = base_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split route into two parts and reallocate customers between them\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check capacity feasibility\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If split is infeasible, try reallocating customers to other routes\n            for customer in route[1:-1]:\n                for j in range(len(new_solution)):\n                    if j != i:\n                        temp_route = np.append(new_solution[j][:-1], [customer, 0])\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[j] = temp_route\n                            new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == customer))\n                            break\n\n    return new_solution\n\n"
    }
]