[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a hybrid local search operator that combines item swapping and adaptive perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator: item swapping + adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swapping (focus on high-value items)\n    if random.random() < 0.7:  # 70% chance of swapping\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random item to remove and add\n            remove_idx = random.choice(in_items)\n            add_idx = random.choice(out_items)\n\n            # Check feasibility before swapping\n            if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    # Step 2: Adaptive perturbation (flips based on value ratios)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        value_ratio = value1_lst / (value2_lst + 1e-8)\n        sorted_items = np.argsort(value_ratio)\n\n        # Flip top 10% items with higher value ratio\n        num_flip = max(1, int(0.1 * len(sorted_items)))\n        flip_indices = sorted_items[-num_flip:]\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4350047770479071,
            2.5281842947006226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator: item swapping + adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swapping (focus on high-value items)\n    if random.random() < 0.7:  # 70% chance of swapping\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random item to remove and add\n            remove_idx = random.choice(in_items)\n            add_idx = random.choice(out_items)\n\n            # Check feasibility before swapping\n            if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    # Step 2: Adaptive perturbation (flips based on value ratios)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        value_ratio = value1_lst / (value2_lst + 1e-8)\n        sorted_items = np.argsort(value_ratio)\n\n        # Flip top 10% items with higher value ratio\n        num_flip = max(1, int(0.1 * len(sorted_items)))\n        flip_indices = sorted_items[-num_flip:]\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a hybrid local search operator that combines item swapping and adaptive perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator: item swapping + adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swapping (focus on high-value items)\n    if random.random() < 0.7:  # 70% chance of swapping\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random item to remove and add\n            remove_idx = random.choice(in_items)\n            add_idx = random.choice(out_items)\n\n            # Check feasibility before swapping\n            if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    # Step 2: Adaptive perturbation (flips based on value ratios)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        value_ratio = value1_lst / (value2_lst + 1e-8)\n        sorted_items = np.argsort(value_ratio)\n\n        # Flip top 10% items with higher value ratio\n        num_flip = max(1, int(0.1 * len(sorted_items)))\n        flip_indices = sorted_items[-num_flip:]\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4350047770479071,
            2.5281842947006226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator: item swapping + adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swapping (focus on high-value items)\n    if random.random() < 0.7:  # 70% chance of swapping\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random item to remove and add\n            remove_idx = random.choice(in_items)\n            add_idx = random.choice(out_items)\n\n            # Check feasibility before swapping\n            if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    # Step 2: Adaptive perturbation (flips based on value ratios)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        value_ratio = value1_lst / (value2_lst + 1e-8)\n        sorted_items = np.argsort(value_ratio)\n\n        # Flip top 10% items with higher value ratio\n        num_flip = max(1, int(0.1 * len(sorted_items)))\n        flip_indices = sorted_items[-num_flip:]\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a hybrid local search operator that combines item swapping and adaptive perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator: item swapping + adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swapping (focus on high-value items)\n    if random.random() < 0.7:  # 70% chance of swapping\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random item to remove and add\n            remove_idx = random.choice(in_items)\n            add_idx = random.choice(out_items)\n\n            # Check feasibility before swapping\n            if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    # Step 2: Adaptive perturbation (flips based on value ratios)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        value_ratio = value1_lst / (value2_lst + 1e-8)\n        sorted_items = np.argsort(value_ratio)\n\n        # Flip top 10% items with higher value ratio\n        num_flip = max(1, int(0.1 * len(sorted_items)))\n        flip_indices = sorted_items[-num_flip:]\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4350047770479071,
            2.5281842947006226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator: item swapping + adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swapping (focus on high-value items)\n    if random.random() < 0.7:  # 70% chance of swapping\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random item to remove and add\n            remove_idx = random.choice(in_items)\n            add_idx = random.choice(out_items)\n\n            # Check feasibility before swapping\n            if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    # Step 2: Adaptive perturbation (flips based on value ratios)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        value_ratio = value1_lst / (value2_lst + 1e-8)\n        sorted_items = np.argsort(value_ratio)\n\n        # Flip top 10% items with higher value ratio\n        num_flip = max(1, int(0.1 * len(sorted_items)))\n        flip_indices = sorted_items[-num_flip:]\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on its objective values and applies a hybrid local search operator that combines item swaps and probabilistic flips, ensuring feasibility by dynamically adjusting the selection to respect the capacity constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (lexicographical order)\n        sorted_archive = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n        # Select top 20% of solutions\n        top_solutions = sorted_archive[:max(1, len(archive) // 5)]\n        # Randomly select one from the top solutions\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: item swaps and probabilistic flips\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Perform item swaps (if possible)\n    for _ in range(3):  # Limit the number of swaps\n        if current_weight >= capacity:\n            break\n        # Select two items: one in the solution, one out\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n        item_in = random.choice(in_items)\n        item_out = random.choice(out_items)\n        # Check if swap is feasible\n        delta_weight = weight_lst[item_out] - weight_lst[item_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n            current_weight += delta_weight\n\n    # Perform probabilistic flips (flip items with a probability based on their contribution)\n    for i in range(num_items):\n        if random.random() < 0.2:  # 20% chance to consider flipping\n            if base_solution[i] == 1:\n                # Consider removing item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) == 0:\n            break\n        item_to_remove = random.choice(in_items)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.40035580020148853,
            2.6504287719726562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (lexicographical order)\n        sorted_archive = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n        # Select top 20% of solutions\n        top_solutions = sorted_archive[:max(1, len(archive) // 5)]\n        # Randomly select one from the top solutions\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: item swaps and probabilistic flips\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Perform item swaps (if possible)\n    for _ in range(3):  # Limit the number of swaps\n        if current_weight >= capacity:\n            break\n        # Select two items: one in the solution, one out\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n        item_in = random.choice(in_items)\n        item_out = random.choice(out_items)\n        # Check if swap is feasible\n        delta_weight = weight_lst[item_out] - weight_lst[item_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n            current_weight += delta_weight\n\n    # Perform probabilistic flips (flip items with a probability based on their contribution)\n    for i in range(num_items):\n        if random.random() < 0.2:  # 20% chance to consider flipping\n            if base_solution[i] == 1:\n                # Consider removing item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) == 0:\n            break\n        item_to_remove = random.choice(in_items)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic selects a promising solution from the archive by prioritizing those with high objective values and applies a novel local search strategy that intelligently flips subsets of items based on marginal gains in both objectives, while ensuring feasibility through weight constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Prioritize solutions with high objective values\n    scores = [sum(obj) for obj in archive_objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor solution using a novel local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to flip (intelligent selection)\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    # Calculate marginal gains for each objective\n    marginal_gain1 = value1_lst[flip_indices]\n    marginal_gain2 = value2_lst[flip_indices]\n\n    # Flip items based on combined marginal gains\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # If item is included, consider removing it if it doesn't violate capacity\n            if (np.sum(weight_lst * new_solution) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, consider adding it if it doesn't violate capacity\n            if (np.sum(weight_lst * new_solution) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.31798493502776015,
            2.9951846301555634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Prioritize solutions with high objective values\n    scores = [sum(obj) for obj in archive_objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor solution using a novel local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to flip (intelligent selection)\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    # Calculate marginal gains for each objective\n    marginal_gain1 = value1_lst[flip_indices]\n    marginal_gain2 = value2_lst[flip_indices]\n\n    # Flip items based on combined marginal gains\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # If item is included, consider removing it if it doesn't violate capacity\n            if (np.sum(weight_lst * new_solution) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, consider adding it if it doesn't violate capacity\n            if (np.sum(weight_lst * new_solution) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify items that can be swapped or flipped\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    possible_swaps = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item would keep the solution feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                possible_swaps.append(i)\n        else:\n            # Check if adding the item would keep the solution feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                possible_swaps.append(i)\n\n    if not possible_swaps:\n        return base_solution\n\n    # Randomly select an item to flip\n    flip_idx = np.random.choice(possible_swaps)\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Apply a second flip to create a more diverse neighbor\n    second_possible_swaps = [i for i in range(len(new_solution)) if i != flip_idx and\n                             (new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity or\n                              new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity)]\n    if second_possible_swaps:\n        second_flip_idx = np.random.choice(second_possible_swaps)\n        new_solution[second_flip_idx] = 1 - new_solution[second_flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9052719948689221,
            4.938893288373947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify items that can be swapped or flipped\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    possible_swaps = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item would keep the solution feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                possible_swaps.append(i)\n        else:\n            # Check if adding the item would keep the solution feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                possible_swaps.append(i)\n\n    if not possible_swaps:\n        return base_solution\n\n    # Randomly select an item to flip\n    flip_idx = np.random.choice(possible_swaps)\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Apply a second flip to create a more diverse neighbor\n    second_possible_swaps = [i for i in range(len(new_solution)) if i != flip_idx and\n                             (new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity or\n                              new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity)]\n    if second_possible_swaps:\n        second_flip_idx = np.random.choice(second_possible_swaps)\n        new_solution[second_flip_idx] = 1 - new_solution[second_flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify items that can be swapped or flipped\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    possible_swaps = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item would keep the solution feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                possible_swaps.append(i)\n        else:\n            # Check if adding the item would keep the solution feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                possible_swaps.append(i)\n\n    if not possible_swaps:\n        return base_solution\n\n    # Randomly select an item to flip\n    flip_idx = np.random.choice(possible_swaps)\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Apply a second flip to create a more diverse neighbor\n    second_possible_swaps = [i for i in range(len(new_solution)) if i != flip_idx and\n                             (new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity or\n                              new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity)]\n    if second_possible_swaps:\n        second_flip_idx = np.random.choice(second_possible_swaps)\n        new_solution[second_flip_idx] = 1 - new_solution[second_flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9052719948689221,
            4.938893288373947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify items that can be swapped or flipped\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    possible_swaps = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item would keep the solution feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                possible_swaps.append(i)\n        else:\n            # Check if adding the item would keep the solution feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                possible_swaps.append(i)\n\n    if not possible_swaps:\n        return base_solution\n\n    # Randomly select an item to flip\n    flip_idx = np.random.choice(possible_swaps)\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Apply a second flip to create a more diverse neighbor\n    second_possible_swaps = [i for i in range(len(new_solution)) if i != flip_idx and\n                             (new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity or\n                              new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity)]\n    if second_possible_swaps:\n        second_flip_idx = np.random.choice(second_possible_swaps)\n        new_solution[second_flip_idx] = 1 - new_solution[second_flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The heuristic function selects a solution from the archive by prioritizing those with the highest crowding distance (indicative of potential for improvement) and applies a novel local search that combines item swapping and probabilistic flipping to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (indicative of potential for improvement)\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Compute crowding distance for each solution\n    crowding_distances = np.zeros(len(solutions))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(sorted_idx) - 1):\n            crowding_distances[sorted_idx[j]] += (sorted_obj[j + 1] - sorted_obj[j - 1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly select a subset of items to flip (probabilistic flipping)\n    flip_prob = 0.2  # Probability of flipping each item\n    flip_mask = np.random.rand(len(new_solution)) < flip_prob\n    candidate_indices = np.where(flip_mask)[0]\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Remove the item if it's in the solution\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            # Add the item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Item swapping (swap items between included and excluded)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select items to swap\n        swap_in = np.random.choice(included)\n        swap_out = np.random.choice(excluded)\n\n        # Check if swapping is feasible\n        if current_weight - weight_lst[swap_in] + weight_lst[swap_out] <= capacity:\n            new_solution[swap_in], new_solution[swap_out] = 0, 1\n\n    return new_solution\n\n",
        "score": [
            -0.35306280708290705,
            3.5861319303512573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (indicative of potential for improvement)\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Compute crowding distance for each solution\n    crowding_distances = np.zeros(len(solutions))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(sorted_idx) - 1):\n            crowding_distances[sorted_idx[j]] += (sorted_obj[j + 1] - sorted_obj[j - 1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly select a subset of items to flip (probabilistic flipping)\n    flip_prob = 0.2  # Probability of flipping each item\n    flip_mask = np.random.rand(len(new_solution)) < flip_prob\n    candidate_indices = np.where(flip_mask)[0]\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Remove the item if it's in the solution\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            # Add the item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Item swapping (swap items between included and excluded)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select items to swap\n        swap_in = np.random.choice(included)\n        swap_out = np.random.choice(excluded)\n\n        # Check if swapping is feasible\n        if current_weight - weight_lst[swap_in] + weight_lst[swap_out] <= capacity:\n            new_solution[swap_in], new_solution[swap_out] = 0, 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted random choice favoring solutions with higher potential improvement, then applies a hybrid local search that combines bit-flipping with a greedy selection of items based on a dynamic objective priority, ensuring feasibility and maximizing both objectives through multi-criteria evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with weighted random choice\n    weights = [obj[0] + obj[1] for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choices([sol for sol, _ in archive], weights=weights, k=1)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Hybrid local search: bit-flipping with dynamic objective priority\n    for _ in range(3):  # Perform multiple flips\n        # Randomly select a subset of items to consider for flipping\n        flip_indices = random.sample(range(n_items), min(5, n_items))\n\n        # Evaluate flipping each selected item\n        best_flip = None\n        best_improvement = -float('inf')\n\n        for idx in flip_indices:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1 - temp_solution[idx]\n\n            # Check feasibility\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight > capacity:\n                continue\n\n            # Calculate improvement in both objectives\n            current_obj1 = np.sum(value1_lst[new_solution == 1])\n            current_obj2 = np.sum(value2_lst[new_solution == 1])\n            new_obj1 = np.sum(value1_lst[temp_solution == 1])\n            new_obj2 = np.sum(value2_lst[temp_solution == 1])\n\n            # Dynamic objective priority based on current solution's imbalance\n            if current_obj1 > current_obj2:\n                improvement = new_obj2 - current_obj2\n            else:\n                improvement = new_obj1 - current_obj1\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_flip = idx\n\n        if best_flip is not None:\n            new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Final feasibility check\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, perform a greedy repair\n        while total_weight > capacity:\n            # Remove the item with the smallest ratio of (value1 + value2)/weight\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            value_weight_ratios = [(value1_lst[i] + value2_lst[i]) / weight_lst[i] for i in included_items]\n            worst_item = included_items[np.argmin(value_weight_ratios)]\n            new_solution[worst_item] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.318341842717228,
            8.32124537229538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with weighted random choice\n    weights = [obj[0] + obj[1] for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choices([sol for sol, _ in archive], weights=weights, k=1)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Hybrid local search: bit-flipping with dynamic objective priority\n    for _ in range(3):  # Perform multiple flips\n        # Randomly select a subset of items to consider for flipping\n        flip_indices = random.sample(range(n_items), min(5, n_items))\n\n        # Evaluate flipping each selected item\n        best_flip = None\n        best_improvement = -float('inf')\n\n        for idx in flip_indices:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1 - temp_solution[idx]\n\n            # Check feasibility\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight > capacity:\n                continue\n\n            # Calculate improvement in both objectives\n            current_obj1 = np.sum(value1_lst[new_solution == 1])\n            current_obj2 = np.sum(value2_lst[new_solution == 1])\n            new_obj1 = np.sum(value1_lst[temp_solution == 1])\n            new_obj2 = np.sum(value2_lst[temp_solution == 1])\n\n            # Dynamic objective priority based on current solution's imbalance\n            if current_obj1 > current_obj2:\n                improvement = new_obj2 - current_obj2\n            else:\n                improvement = new_obj1 - current_obj1\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_flip = idx\n\n        if best_flip is not None:\n            new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Final feasibility check\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, perform a greedy repair\n        while total_weight > capacity:\n            # Remove the item with the smallest ratio of (value1 + value2)/weight\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            value_weight_ratios = [(value1_lst[i] + value2_lst[i]) / weight_lst[i] for i in included_items]\n            worst_item = included_items[np.argmin(value_weight_ratios)]\n            new_solution[worst_item] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low dominance, then applies a hybrid local search strategy combining adaptive bit flipping and weighted random perturbation to generate a feasible neighbor solution with improved multi-objective quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the base solution with highest combined normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive bit flipping + weighted random perturbation\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    items = np.arange(len(weight_lst))\n\n    # Adaptive bit flipping: flip items with high marginal contribution\n    for _ in range(5):  # Limited iterations to ensure efficiency\n        # Calculate marginal contributions\n        included = new_solution == 1\n        excluded = new_solution == 0\n        marginal1 = value1_lst[excluded] / (weight_lst[excluded] + 1e-8)\n        marginal2 = value2_lst[excluded] / (weight_lst[excluded] + 1e-8)\n\n        # Weighted selection of items to potentially add\n        weights = marginal1 + marginal2\n        if len(weights) > 0:\n            selected = random.choices(items[excluded], weights=weights, k=1)[0]\n            if current_weight + weight_lst[selected] <= capacity:\n                new_solution[selected] = 1\n                current_weight += weight_lst[selected]\n\n    # Weighted random perturbation: remove items with low marginal contribution\n    included_items = items[new_solution == 1]\n    if len(included_items) > 0:\n        marginal_remove1 = value1_lst[included_items] / (weight_lst[included_items] + 1e-8)\n        marginal_remove2 = value2_lst[included_items] / (weight_lst[included_items] + 1e-8)\n        remove_weights = marginal_remove1 + marginal_remove2\n        selected_remove = random.choices(included_items, weights=remove_weights, k=1)[0]\n        new_solution[selected_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.824914799634437,
            5.695372611284256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the base solution with highest combined normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive bit flipping + weighted random perturbation\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    items = np.arange(len(weight_lst))\n\n    # Adaptive bit flipping: flip items with high marginal contribution\n    for _ in range(5):  # Limited iterations to ensure efficiency\n        # Calculate marginal contributions\n        included = new_solution == 1\n        excluded = new_solution == 0\n        marginal1 = value1_lst[excluded] / (weight_lst[excluded] + 1e-8)\n        marginal2 = value2_lst[excluded] / (weight_lst[excluded] + 1e-8)\n\n        # Weighted selection of items to potentially add\n        weights = marginal1 + marginal2\n        if len(weights) > 0:\n            selected = random.choices(items[excluded], weights=weights, k=1)[0]\n            if current_weight + weight_lst[selected] <= capacity:\n                new_solution[selected] = 1\n                current_weight += weight_lst[selected]\n\n    # Weighted random perturbation: remove items with low marginal contribution\n    included_items = items[new_solution == 1]\n    if len(included_items) > 0:\n        marginal_remove1 = value1_lst[included_items] / (weight_lst[included_items] + 1e-8)\n        marginal_remove2 = value2_lst[included_items] / (weight_lst[included_items] + 1e-8)\n        remove_weights = marginal_remove1 + marginal_remove2\n        selected_remove = random.choices(included_items, weights=remove_weights, k=1)[0]\n        new_solution[selected_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Compute current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by flipping a subset of items with high marginal gains\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3493070514344792,
            2.7548716366291046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Compute current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by flipping a subset of items with high marginal gains\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search that combines random item swaps and greedy selection based on marginal gains in both objectives, ensuring feasibility by dynamically adjusting the solution until the total weight is within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for swapping\n    subset_size = min(10, n_items)\n    candidate_indices = random.sample(range(n_items), subset_size)\n\n    for idx in candidate_indices:\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n\n    # Greedy improvement: add items with highest marginal gain in either objective\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n\n    for idx in available_items:\n        if weight_lst[idx] <= remaining_weight:\n            # Calculate marginal gain (normalized)\n            marginal_gain = (value1_lst[idx] + value2_lst[idx]) / (weight_lst[idx] + 1e-10)\n            if marginal_gain > 0:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.36206622393594456,
            7.758741050958633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for swapping\n    subset_size = min(10, n_items)\n    candidate_indices = random.sample(range(n_items), subset_size)\n\n    for idx in candidate_indices:\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n\n    # Greedy improvement: add items with highest marginal gain in either objective\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n\n    for idx in available_items:\n        if weight_lst[idx] <= remaining_weight:\n            # Calculate marginal gain (normalized)\n            marginal_gain = (value1_lst[idx] + value2_lst[idx]) / (weight_lst[idx] + 1e-10)\n            if marginal_gain > 0:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    max_value1 = np.max(objectives[:, 0])\n    max_value2 = np.max(objectives[:, 1])\n\n    # Calculate the distance to the ideal point (max_value1, max_value2)\n    distances = np.sqrt((max_value1 - objectives[:, 0])**2 + (max_value2 - objectives[:, 1])**2)\n\n    # Select the solution with the largest distance (most under-explored)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to flip (with higher probability for items with high marginal value)\n    marginal_value1 = value1_lst / weight_lst\n    marginal_value2 = value2_lst / weight_lst\n    flip_probs = 0.5 * (marginal_value1 + marginal_value2)  # Combined marginal value\n    flip_probs = flip_probs / np.sum(flip_probs)  # Normalize to probabilities\n\n    # Randomly decide how many items to flip (between 1 and min(5, n_items))\n    n_flips = np.random.randint(1, min(6, n_items + 1))\n    items_to_flip = np.random.choice(n_items, size=n_flips, replace=False, p=flip_probs)\n\n    # Flip the selected items and ensure feasibility\n    for item in items_to_flip:\n        if new_solution[item] == 1:\n            new_solution[item] = 0\n        else:\n            # Check if adding this item keeps the solution feasible\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    # If no changes were made, force a change (to ensure progress)\n    if np.array_equal(new_solution, base_solution):\n        # Find an item to add if possible\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            feasible_items = available_items[weight_lst[available_items] + current_weight <= capacity]\n            if len(feasible_items) > 0:\n                item_to_add = np.random.choice(feasible_items)\n                new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8625367425044865,
            2.529339998960495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    max_value1 = np.max(objectives[:, 0])\n    max_value2 = np.max(objectives[:, 1])\n\n    # Calculate the distance to the ideal point (max_value1, max_value2)\n    distances = np.sqrt((max_value1 - objectives[:, 0])**2 + (max_value2 - objectives[:, 1])**2)\n\n    # Select the solution with the largest distance (most under-explored)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to flip (with higher probability for items with high marginal value)\n    marginal_value1 = value1_lst / weight_lst\n    marginal_value2 = value2_lst / weight_lst\n    flip_probs = 0.5 * (marginal_value1 + marginal_value2)  # Combined marginal value\n    flip_probs = flip_probs / np.sum(flip_probs)  # Normalize to probabilities\n\n    # Randomly decide how many items to flip (between 1 and min(5, n_items))\n    n_flips = np.random.randint(1, min(6, n_items + 1))\n    items_to_flip = np.random.choice(n_items, size=n_flips, replace=False, p=flip_probs)\n\n    # Flip the selected items and ensure feasibility\n    for item in items_to_flip:\n        if new_solution[item] == 1:\n            new_solution[item] = 0\n        else:\n            # Check if adding this item keeps the solution feasible\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    # If no changes were made, force a change (to ensure progress)\n    if np.array_equal(new_solution, base_solution):\n        # Find an item to add if possible\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            feasible_items = available_items[weight_lst[available_items] + current_weight <= capacity]\n            if len(feasible_items) > 0:\n                item_to_add = np.random.choice(feasible_items)\n                new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping items with high marginal utility\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal utility for each item\n    marginal_utility1 = value1_lst / weight_lst\n    marginal_utility2 = value2_lst / weight_lst\n    combined_utility = marginal_utility1 + marginal_utility2\n\n    # Sort items by combined marginal utility (descending)\n    sorted_items = np.argsort(combined_utility)[::-1]\n\n    # Flip items in a way that maintains feasibility and improves both objectives\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8293545485228971,
            9.246780693531036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping items with high marginal utility\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal utility for each item\n    marginal_utility1 = value1_lst / weight_lst\n    marginal_utility2 = value2_lst / weight_lst\n    combined_utility = marginal_utility1 + marginal_utility2\n\n    # Sort items by combined marginal utility (descending)\n    sorted_items = np.argsort(combined_utility)[::-1]\n\n    # Flip items in a way that maintains feasibility and improves both objectives\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive item swapping with probabilistic diversification, dynamically balancing between intensification and exploration to generate high-quality, feasible neighbor solutions while avoiding standard 2-opt approaches.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 - (i / len(archive)) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search: Adaptive item swapping with probabilistic diversification\n    for _ in range(5):  # Number of attempts per iteration\n        # Identify items to consider for swap\n        included_items = np.where(base_solution == 1)[0]\n        excluded_items = np.where(base_solution == 0)[0]\n\n        # Probabilistic selection of items to swap\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            # Select an item to remove (from included) and an item to add (from excluded)\n            remove_idx = random.choice(included_items)\n            add_idx = random.choice(excluded_items)\n\n            # Calculate new weight and values\n            new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n            new_value1 = current_value1 - value1_lst[remove_idx] + value1_lst[add_idx]\n            new_value2 = current_value2 - value2_lst[remove_idx] + value2_lst[add_idx]\n\n            # Check feasibility\n            if new_weight <= capacity:\n                # Apply the swap if feasible\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Additional diversification: small probability of random flip\n    if random.random() < 0.1:\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5309867542657807,
            5.4377186596393585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 - (i / len(archive)) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search: Adaptive item swapping with probabilistic diversification\n    for _ in range(5):  # Number of attempts per iteration\n        # Identify items to consider for swap\n        included_items = np.where(base_solution == 1)[0]\n        excluded_items = np.where(base_solution == 0)[0]\n\n        # Probabilistic selection of items to swap\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            # Select an item to remove (from included) and an item to add (from excluded)\n            remove_idx = random.choice(included_items)\n            add_idx = random.choice(excluded_items)\n\n            # Calculate new weight and values\n            new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n            new_value1 = current_value1 - value1_lst[remove_idx] + value1_lst[add_idx]\n            new_value2 = current_value2 - value2_lst[remove_idx] + value2_lst[add_idx]\n\n            # Check feasibility\n            if new_weight <= capacity:\n                # Apply the swap if feasible\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Additional diversification: small probability of random flip\n    if random.random() < 0.1:\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive based on its potential for improvement, then applies a combination of item swapping and adaptive perturbation to explore the solution space while ensuring feasibility, balancing exploration and exploitation to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 - (i / len(archive)) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: item swapping + adaptive perturbation\n    # Step 1: Item swapping (exploration)\n    for _ in range(2):\n        # Find items that can be swapped\n        zero_indices = np.where(new_solution == 0)[0]\n        one_indices = np.where(new_solution == 1)[0]\n\n        if len(zero_indices) > 0 and len(one_indices) > 0:\n            # Randomly select one item to remove and one to add\n            remove_idx = random.choice(one_indices)\n            add_idx = random.choice(zero_indices)\n\n            # Check if swap is feasible\n            if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                current_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n    # Step 2: Adaptive perturbation (exploitation)\n    # Identify items with high marginal value-to-weight ratio\n    marginal_value1 = value1_lst / (weight_lst + 1e-8)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-8)\n\n    # Combine marginal values and normalize\n    combined_marginal = (marginal_value1 + marginal_value2) / 2\n    sorted_indices = np.argsort(combined_marginal)[::-1]  # Descending order\n\n    # Flip top-k items based on their marginal value\n    k = min(3, len(sorted_indices))\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4329121574194673,
            2.6157994866371155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 - (i / len(archive)) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: item swapping + adaptive perturbation\n    # Step 1: Item swapping (exploration)\n    for _ in range(2):\n        # Find items that can be swapped\n        zero_indices = np.where(new_solution == 0)[0]\n        one_indices = np.where(new_solution == 1)[0]\n\n        if len(zero_indices) > 0 and len(one_indices) > 0:\n            # Randomly select one item to remove and one to add\n            remove_idx = random.choice(one_indices)\n            add_idx = random.choice(zero_indices)\n\n            # Check if swap is feasible\n            if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                current_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n    # Step 2: Adaptive perturbation (exploitation)\n    # Identify items with high marginal value-to-weight ratio\n    marginal_value1 = value1_lst / (weight_lst + 1e-8)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-8)\n\n    # Combine marginal values and normalize\n    combined_marginal = (marginal_value1 + marginal_value2) / 2\n    sorted_indices = np.argsort(combined_marginal)[::-1]  # Descending order\n\n    # Flip top-k items based on their marginal value\n    k = min(3, len(sorted_indices))\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The heuristic selects a promising solution from the archive by prioritizing those with high marginal gains in either objective, then applies a hybrid local search combining item swaps and probabilistic flips to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on marginal gains\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal gains for each item\n    marginal_gains1 = value1_lst / (weight_lst + 1e-6)\n    marginal_gains2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid local search: item swaps and probabilistic flips\n    for _ in range(5):  # Number of local search steps\n        # Select items to swap or flip based on marginal gains\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Add a promising item\n            item_to_add = candidate_items[np.argmax(marginal_gains1[candidate_items] + marginal_gains2[candidate_items])]\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[item_to_add] <= capacity:\n                new_solution[item_to_add] = 1\n\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            # Remove a less promising item with some probability\n            if random.random() < 0.3:\n                item_to_remove = candidate_items[np.argmin(marginal_gains1[candidate_items] + marginal_gains2[candidate_items])]\n                new_solution[item_to_remove] = 0\n\n        # Random flip for diversification\n        if random.random() < 0.2:\n            flip_idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[flip_idx] == 0 and np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n            elif new_solution[flip_idx] == 1:\n                new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.28741850545365083,
            6.0372291803359985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on marginal gains\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal gains for each item\n    marginal_gains1 = value1_lst / (weight_lst + 1e-6)\n    marginal_gains2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid local search: item swaps and probabilistic flips\n    for _ in range(5):  # Number of local search steps\n        # Select items to swap or flip based on marginal gains\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Add a promising item\n            item_to_add = candidate_items[np.argmax(marginal_gains1[candidate_items] + marginal_gains2[candidate_items])]\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[item_to_add] <= capacity:\n                new_solution[item_to_add] = 1\n\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            # Remove a less promising item with some probability\n            if random.random() < 0.3:\n                item_to_remove = candidate_items[np.argmin(marginal_gains1[candidate_items] + marginal_gains2[candidate_items])]\n                new_solution[item_to_remove] = 0\n\n        # Random flip for diversification\n        if random.random() < 0.2:\n            flip_idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[flip_idx] == 0 and np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n            elif new_solution[flip_idx] == 1:\n                new_solution[flip_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive item swapping with dynamic neighborhood exploration to generate high-quality neighbors by intelligently selecting items to flip based on their marginal contribution to both objectives, ensuring feasibility and promoting Pareto frontier expansion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    promising_indices = [i for i, (sol, _) in enumerate(archive) if np.sum(sol) > 0]\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n    selected_idx = random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Generate a neighbor by flipping items based on their marginal contribution\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    if len(items) == 0:\n        items = np.where(base_solution == 0)[0]\n\n    # Calculate marginal contributions for all items\n    marginal_contributions = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # For included items, consider removing them\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                marginal_value1 = current_value1 - value1_lst[i]\n                marginal_value2 = current_value2 - value2_lst[i]\n                marginal_contributions.append((i, marginal_value1 + marginal_value2, 'remove'))\n        else:\n            # For excluded items, consider adding them\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                marginal_value1 = current_value1 + value1_lst[i]\n                marginal_value2 = current_value2 + value2_lst[i]\n                marginal_contributions.append((i, marginal_value1 + marginal_value2, 'add'))\n\n    if not marginal_contributions:\n        # If no feasible move, return a random feasible solution\n        feasible_solutions = []\n        for _ in range(100):\n            temp_sol = np.zeros_like(base_solution)\n            np.random.shuffle(items)\n            total_weight = 0\n            for i in items:\n                if total_weight + weight_lst[i] <= capacity:\n                    temp_sol[i] = 1\n                    total_weight += weight_lst[i]\n            feasible_solutions.append(temp_sol)\n        if feasible_solutions:\n            return random.choice(feasible_solutions)\n        else:\n            return base_solution\n\n    # Select the item with the highest marginal contribution\n    best_item, _, action = max(marginal_contributions, key=lambda x: x[1])\n    if action == 'add':\n        new_solution[best_item] = 1\n    else:\n        new_solution[best_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8907252251603937,
            9.594212144613266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    promising_indices = [i for i, (sol, _) in enumerate(archive) if np.sum(sol) > 0]\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n    selected_idx = random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Generate a neighbor by flipping items based on their marginal contribution\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    if len(items) == 0:\n        items = np.where(base_solution == 0)[0]\n\n    # Calculate marginal contributions for all items\n    marginal_contributions = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # For included items, consider removing them\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                marginal_value1 = current_value1 - value1_lst[i]\n                marginal_value2 = current_value2 - value2_lst[i]\n                marginal_contributions.append((i, marginal_value1 + marginal_value2, 'remove'))\n        else:\n            # For excluded items, consider adding them\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                marginal_value1 = current_value1 + value1_lst[i]\n                marginal_value2 = current_value2 + value2_lst[i]\n                marginal_contributions.append((i, marginal_value1 + marginal_value2, 'add'))\n\n    if not marginal_contributions:\n        # If no feasible move, return a random feasible solution\n        feasible_solutions = []\n        for _ in range(100):\n            temp_sol = np.zeros_like(base_solution)\n            np.random.shuffle(items)\n            total_weight = 0\n            for i in items:\n                if total_weight + weight_lst[i] <= capacity:\n                    temp_sol[i] = 1\n                    total_weight += weight_lst[i]\n            feasible_solutions.append(temp_sol)\n        if feasible_solutions:\n            return random.choice(feasible_solutions)\n        else:\n            return base_solution\n\n    # Select the item with the highest marginal contribution\n    best_item, _, action = max(marginal_contributions, key=lambda x: x[1])\n    if action == 'add':\n        new_solution[best_item] = 1\n    else:\n        new_solution[best_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm selects a promising non-dominated solution from the archive, then applies a hybrid local search strategy that combines item swaps and probabilistic flips to explore the solution space while ensuring feasibility, aiming to improve both objectives through intelligent exploration of neighboring solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate the total weight and values for each solution in the archive\n    weights = [np.sum(weight_lst[sol[0] == 1]) for sol in archive]\n    values1 = [sol[1][0] for sol in archive]\n    values2 = [sol[1][1] for sol in archive]\n\n    # Normalize values to avoid division by zero\n    max_val1 = max(values1) if max(values1) != 0 else 1\n    max_val2 = max(values2) if max(values2) != 0 else 1\n\n    # Calculate selection probabilities based on normalized values and weight feasibility\n    probs = []\n    for w, v1, v2 in zip(weights, values1, values2):\n        if w > capacity:\n            probs.append(0)  # Discard infeasible solutions\n        else:\n            probs.append((v1 / max_val1 + v2 / max_val2) / 2)\n\n    if sum(probs) == 0:\n        probs = [1 / len(probs) for _ in probs]  # Uniform selection if all are infeasible\n\n    probs = [p / sum(probs) for p in probs]  # Normalize probabilities\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (with probability based on their value ratios)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # Probability of flipping\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Perform a value-based swap (swap two items if it improves both objectives)\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            # Calculate the change in weight and values\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            delta_val1 = (value1_lst[j] - value1_lst[i]) if new_solution[i] == 1 else (value1_lst[i] - value1_lst[j])\n            delta_val2 = (value2_lst[j] - value2_lst[i]) if new_solution[i] == 1 else (value2_lst[i] - value2_lst[j])\n\n            if current_weight + delta_weight <= capacity and delta_val1 > 0 and delta_val2 > 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    # Step 3: Add a high-value item if possible\n    available_items = [i for i in range(len(new_solution)) if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity]\n    if available_items:\n        # Select item with the highest combined value ratio\n        value_ratios = [(value1_lst[i] / max_val1 + value2_lst[i] / max_val2) for i in available_items]\n        best_item = available_items[np.argmax(value_ratios)]\n        new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5139564632986923,
            7.519614100456238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate the total weight and values for each solution in the archive\n    weights = [np.sum(weight_lst[sol[0] == 1]) for sol in archive]\n    values1 = [sol[1][0] for sol in archive]\n    values2 = [sol[1][1] for sol in archive]\n\n    # Normalize values to avoid division by zero\n    max_val1 = max(values1) if max(values1) != 0 else 1\n    max_val2 = max(values2) if max(values2) != 0 else 1\n\n    # Calculate selection probabilities based on normalized values and weight feasibility\n    probs = []\n    for w, v1, v2 in zip(weights, values1, values2):\n        if w > capacity:\n            probs.append(0)  # Discard infeasible solutions\n        else:\n            probs.append((v1 / max_val1 + v2 / max_val2) / 2)\n\n    if sum(probs) == 0:\n        probs = [1 / len(probs) for _ in probs]  # Uniform selection if all are infeasible\n\n    probs = [p / sum(probs) for p in probs]  # Normalize probabilities\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (with probability based on their value ratios)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # Probability of flipping\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Perform a value-based swap (swap two items if it improves both objectives)\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            # Calculate the change in weight and values\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            delta_val1 = (value1_lst[j] - value1_lst[i]) if new_solution[i] == 1 else (value1_lst[i] - value1_lst[j])\n            delta_val2 = (value2_lst[j] - value2_lst[i]) if new_solution[i] == 1 else (value2_lst[i] - value2_lst[j])\n\n            if current_weight + delta_weight <= capacity and delta_val1 > 0 and delta_val2 > 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    # Step 3: Add a high-value item if possible\n    available_items = [i for i in range(len(new_solution)) if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity]\n    if available_items:\n        # Select item with the highest combined value ratio\n        value_ratios = [(value1_lst[i] / max_val1 + value2_lst[i] / max_val2) for i in available_items]\n        best_item = available_items[np.argmax(value_ratios)]\n        new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential items to swap/perturb\n    current_weight = np.sum(weight_lst * base_solution)\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: Swap items or perturb based on weight balance\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Option 1: Swap one included item with one excluded item\n        swap_in = np.random.choice(included_items)\n        swap_out = np.random.choice(excluded_items)\n        delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_in], new_solution[swap_out] = new_solution[swap_out], new_solution[swap_in]\n        else:\n            # Option 2: Perturb by removing a random item if swap is infeasible\n            remove_item = np.random.choice(included_items)\n            new_solution[remove_item] = 0\n    else:\n        # If no swaps possible, randomly add an item if feasible\n        for item in excluded_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5134040358289386,
            3.234186589717865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential items to swap/perturb\n    current_weight = np.sum(weight_lst * base_solution)\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: Swap items or perturb based on weight balance\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Option 1: Swap one included item with one excluded item\n        swap_in = np.random.choice(included_items)\n        swap_out = np.random.choice(excluded_items)\n        delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_in], new_solution[swap_out] = new_solution[swap_out], new_solution[swap_in]\n        else:\n            # Option 2: Perturb by removing a random item if swap is infeasible\n            remove_item = np.random.choice(included_items)\n            new_solution[remove_item] = 0\n    else:\n        # If no swaps possible, randomly add an item if feasible\n        for item in excluded_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement, then applies a hybrid local search strategy combining greedy item swaps with probabilistic perturbations to escape local optima while ensuring feasibility, balancing exploration and exploitation to enhance multi-objective quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected = max(archive, key=lambda x: np.sum(weight_lst[x[0].astype(bool)]) / capacity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy swaps + probabilistic perturbations\n    current_weight = np.sum(weight_lst[base_solution.astype(bool)])\n    current_value1 = selected[1][0]\n    current_value2 = selected[1][1]\n\n    # Try to swap items between included and excluded\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Find items to swap: one included, one excluded\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) == 0 or len(excluded) == 0:\n            break\n\n        # Randomly select items for potential swap\n        i_in = random.choice(included)\n        i_out = random.choice(excluded)\n\n        # Calculate new weight and values\n        new_weight = current_weight - weight_lst[i_in] + weight_lst[i_out]\n        new_value1 = current_value1 - value1_lst[i_in] + value1_lst[i_out]\n        new_value2 = current_value2 - value2_lst[i_in] + value2_lst[i_out]\n\n        # Check feasibility and improvement\n        if new_weight <= capacity:\n            # Accept if better in at least one objective\n            if (new_value1 > current_value1 or new_value2 > current_value2):\n                new_solution[i_in], new_solution[i_out] = new_solution[i_out], new_solution[i_in]\n                current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n            # Otherwise, accept with small probability to escape local optima\n            elif random.random() < 0.1:\n                new_solution[i_in], new_solution[i_out] = new_solution[i_out], new_solution[i_in]\n                current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n\n    # Add probabilistic perturbations to escape local optima\n    if random.random() < 0.2:\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.605207407778271,
            7.4564224779605865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected = max(archive, key=lambda x: np.sum(weight_lst[x[0].astype(bool)]) / capacity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy swaps + probabilistic perturbations\n    current_weight = np.sum(weight_lst[base_solution.astype(bool)])\n    current_value1 = selected[1][0]\n    current_value2 = selected[1][1]\n\n    # Try to swap items between included and excluded\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Find items to swap: one included, one excluded\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) == 0 or len(excluded) == 0:\n            break\n\n        # Randomly select items for potential swap\n        i_in = random.choice(included)\n        i_out = random.choice(excluded)\n\n        # Calculate new weight and values\n        new_weight = current_weight - weight_lst[i_in] + weight_lst[i_out]\n        new_value1 = current_value1 - value1_lst[i_in] + value1_lst[i_out]\n        new_value2 = current_value2 - value2_lst[i_in] + value2_lst[i_out]\n\n        # Check feasibility and improvement\n        if new_weight <= capacity:\n            # Accept if better in at least one objective\n            if (new_value1 > current_value1 or new_value2 > current_value2):\n                new_solution[i_in], new_solution[i_out] = new_solution[i_out], new_solution[i_in]\n                current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n            # Otherwise, accept with small probability to escape local optima\n            elif random.random() < 0.1:\n                new_solution[i_in], new_solution[i_out] = new_solution[i_out], new_solution[i_in]\n                current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n\n    # Add probabilistic perturbations to escape local optima\n    if random.random() < 0.2:\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: flip a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal gains for flipping each item\n    marginal_gains = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[i]\n                gain2 = -value2_lst[i]\n                marginal_gains.append((i, gain1, gain2, new_weight))\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                marginal_gains.append((i, gain1, gain2, new_weight))\n\n    if not marginal_gains:\n        # If no feasible flips, return a random flip (but ensure feasibility)\n        feasible_indices = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    feasible_indices.append(i)\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    feasible_indices.append(i)\n        if feasible_indices:\n            flip_idx = np.random.choice(feasible_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Select top-k items with highest marginal gains (normalized)\n    marginal_gains = np.array(marginal_gains)\n    gains = marginal_gains[:, 1:3].astype(float)\n    normalized_gains = (gains - gains.min(axis=0)) / (gains.max(axis=0) - gains.min(axis=0) + 1e-8)\n    gain_scores = normalized_gains.sum(axis=1)\n    top_k = min(5, len(gain_scores))\n    top_indices = np.argsort(gain_scores)[-top_k:]\n    selected_items = marginal_gains[top_indices, 0].astype(int)\n\n    # Flip the selected items\n    for i in selected_items:\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9276947762785493,
            5.651382148265839
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: flip a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal gains for flipping each item\n    marginal_gains = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[i]\n                gain2 = -value2_lst[i]\n                marginal_gains.append((i, gain1, gain2, new_weight))\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                marginal_gains.append((i, gain1, gain2, new_weight))\n\n    if not marginal_gains:\n        # If no feasible flips, return a random flip (but ensure feasibility)\n        feasible_indices = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    feasible_indices.append(i)\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    feasible_indices.append(i)\n        if feasible_indices:\n            flip_idx = np.random.choice(feasible_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Select top-k items with highest marginal gains (normalized)\n    marginal_gains = np.array(marginal_gains)\n    gains = marginal_gains[:, 1:3].astype(float)\n    normalized_gains = (gains - gains.min(axis=0)) / (gains.max(axis=0) - gains.min(axis=0) + 1e-8)\n    gain_scores = normalized_gains.sum(axis=1)\n    top_k = min(5, len(gain_scores))\n    top_indices = np.argsort(gain_scores)[-top_k:]\n    selected_items = marginal_gains[top_indices, 0].astype(int)\n\n    # Flip the selected items\n    for i in selected_items:\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: flip a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal gains for flipping each item\n    marginal_gains = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[i]\n                gain2 = -value2_lst[i]\n                marginal_gains.append((i, gain1, gain2, new_weight))\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                marginal_gains.append((i, gain1, gain2, new_weight))\n\n    if not marginal_gains:\n        # If no feasible flips, return a random flip (but ensure feasibility)\n        feasible_indices = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    feasible_indices.append(i)\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    feasible_indices.append(i)\n        if feasible_indices:\n            flip_idx = np.random.choice(feasible_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Select top-k items with highest marginal gains (normalized)\n    marginal_gains = np.array(marginal_gains)\n    gains = marginal_gains[:, 1:3].astype(float)\n    normalized_gains = (gains - gains.min(axis=0)) / (gains.max(axis=0) - gains.min(axis=0) + 1e-8)\n    gain_scores = normalized_gains.sum(axis=1)\n    top_k = min(5, len(gain_scores))\n    top_indices = np.argsort(gain_scores)[-top_k:]\n    selected_items = marginal_gains[top_indices, 0].astype(int)\n\n    # Flip the selected items\n    for i in selected_items:\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9276947762785493,
            5.651382148265839
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: flip a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal gains for flipping each item\n    marginal_gains = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[i]\n                gain2 = -value2_lst[i]\n                marginal_gains.append((i, gain1, gain2, new_weight))\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                marginal_gains.append((i, gain1, gain2, new_weight))\n\n    if not marginal_gains:\n        # If no feasible flips, return a random flip (but ensure feasibility)\n        feasible_indices = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    feasible_indices.append(i)\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    feasible_indices.append(i)\n        if feasible_indices:\n            flip_idx = np.random.choice(feasible_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Select top-k items with highest marginal gains (normalized)\n    marginal_gains = np.array(marginal_gains)\n    gains = marginal_gains[:, 1:3].astype(float)\n    normalized_gains = (gains - gains.min(axis=0)) / (gains.max(axis=0) - gains.min(axis=0) + 1e-8)\n    gain_scores = normalized_gains.sum(axis=1)\n    top_k = min(5, len(gain_scores))\n    top_indices = np.argsort(gain_scores)[-top_k:]\n    selected_items = marginal_gains[top_indices, 0].astype(int)\n\n    # Flip the selected items\n    for i in selected_items:\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps with adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    # We consider solutions that are not too close to the current Pareto front\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swaps with adaptive neighborhood exploration\n    # First, perform a random swap of items\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Randomly select an item to remove and an item to add\n        remove_idx = random.choice(items_in)\n        add_idx = random.choice(items_out)\n\n        # Check feasibility of the swap\n        if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n        else:\n            # If swap is infeasible, try to remove only\n            if current_weight - weight_lst[remove_idx] <= capacity:\n                new_solution[remove_idx] = 0\n            # If removing is infeasible, try to add only\n            elif current_weight + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    # Second, perform adaptive neighborhood exploration based on objective values\n    # Identify items that could potentially improve both objectives\n    potential_items = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Calculate potential improvement in both objectives\n            improvement1 = value1_lst[i]\n            improvement2 = value2_lst[i]\n            potential_items.append((i, improvement1, improvement2))\n\n    if potential_items:\n        # Sort by a combined score of improvement potential\n        potential_items.sort(key=lambda x: (x[1] + x[2]), reverse=True)\n        # Select top candidate\n        best_candidate = potential_items[0][0]\n        new_solution[best_candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.32644108091834834,
            4.400861144065857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    # We consider solutions that are not too close to the current Pareto front\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swaps with adaptive neighborhood exploration\n    # First, perform a random swap of items\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Randomly select an item to remove and an item to add\n        remove_idx = random.choice(items_in)\n        add_idx = random.choice(items_out)\n\n        # Check feasibility of the swap\n        if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n        else:\n            # If swap is infeasible, try to remove only\n            if current_weight - weight_lst[remove_idx] <= capacity:\n                new_solution[remove_idx] = 0\n            # If removing is infeasible, try to add only\n            elif current_weight + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    # Second, perform adaptive neighborhood exploration based on objective values\n    # Identify items that could potentially improve both objectives\n    potential_items = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Calculate potential improvement in both objectives\n            improvement1 = value1_lst[i]\n            improvement2 = value2_lst[i]\n            potential_items.append((i, improvement1, improvement2))\n\n    if potential_items:\n        # Sort by a combined score of improvement potential\n        potential_items.sort(key=lambda x: (x[1] + x[2]), reverse=True)\n        # Select top candidate\n        best_candidate = potential_items[0][0]\n        new_solution[best_candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping and objective-driven perturbation to intelligently explore the solution space by dynamically selecting items based on their marginal contribution to both objectives, while ensuring feasibility through capacity-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not on the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid local search: adaptive swapping and perturbation\n    new_solution = base_solution.copy()\n    num_items = len(new_solution)\n\n    # Step 1: Adaptive item swapping based on marginal contributions\n    swap_candidates = np.where(base_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        swap_idx = np.random.choice(swap_candidates)\n        new_solution[swap_idx] = 0\n        current_weight -= weight_lst[swap_idx]\n\n    # Step 2: Objective-driven perturbation\n    for _ in range(2):  # Limit perturbations to avoid excessive changes\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) == 0:\n            break\n\n        # Select items with high marginal contribution to either objective\n        candidate_scores = (marginal_value1 + marginal_value2)[candidates]\n        if np.sum(candidate_scores) > 0:\n            probs = candidate_scores / np.sum(candidate_scores)\n            selected = np.random.choice(candidates, p=probs)\n            if current_weight + weight_lst[selected] <= capacity:\n                new_solution[selected] = 1\n                current_weight += weight_lst[selected]\n\n    # Ensure feasibility (fallback if perturbations exceed capacity)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        while excess > 0:\n            included = np.where(new_solution == 1)[0]\n            if len(included) == 0:\n                break\n            remove_idx = np.random.choice(included)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.38106349317287336,
            6.389373749494553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not on the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid local search: adaptive swapping and perturbation\n    new_solution = base_solution.copy()\n    num_items = len(new_solution)\n\n    # Step 1: Adaptive item swapping based on marginal contributions\n    swap_candidates = np.where(base_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        swap_idx = np.random.choice(swap_candidates)\n        new_solution[swap_idx] = 0\n        current_weight -= weight_lst[swap_idx]\n\n    # Step 2: Objective-driven perturbation\n    for _ in range(2):  # Limit perturbations to avoid excessive changes\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) == 0:\n            break\n\n        # Select items with high marginal contribution to either objective\n        candidate_scores = (marginal_value1 + marginal_value2)[candidates]\n        if np.sum(candidate_scores) > 0:\n            probs = candidate_scores / np.sum(candidate_scores)\n            selected = np.random.choice(candidates, p=probs)\n            if current_weight + weight_lst[selected] <= capacity:\n                new_solution[selected] = 1\n                current_weight += weight_lst[selected]\n\n    # Ensure feasibility (fallback if perturbations exceed capacity)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        while excess > 0:\n            included = np.where(new_solution == 1)[0]\n            if len(included) == 0:\n                break\n            remove_idx = np.random.choice(included)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive, applies a combination of item swaps and adaptive flips to explore high-potential neighborhoods while ensuring feasibility, and prioritizes solutions with higher marginal gains in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select the most promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    best_idx = np.argmax(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Number of local search steps\n        # Step 1: Randomly select a subset of items to consider for flip\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n        item_to_flip = random.choice(candidates)\n\n        # Step 2: Evaluate potential flip (remove the item)\n        new_weight = current_weight - weight_lst[item_to_flip]\n        if new_weight <= capacity:\n            new_solution[item_to_flip] = 0\n            current_weight = new_weight\n            continue\n\n        # Step 3: If flip is not feasible, try to swap with another item\n        possible_swaps = np.where(new_solution == 0)[0]\n        if len(possible_swaps) > 0:\n            swap_item = random.choice(possible_swaps)\n            new_weight = current_weight - weight_lst[item_to_flip] + weight_lst[swap_item]\n            if new_weight <= capacity:\n                new_solution[item_to_flip] = 0\n                new_solution[swap_item] = 1\n                current_weight = new_weight\n\n    # Step 4: Adaptive flip based on marginal gains\n    for _ in range(5):\n        # Calculate marginal gains for each item\n        marginal_gains = (value1_lst + value2_lst) / (weight_lst + 1e-8)\n        marginal_gains[new_solution == 1] *= -1  # Penalize already included items\n\n        # Select top-k candidates\n        k = min(5, len(marginal_gains))\n        top_indices = np.argpartition(marginal_gains, -k)[-k:]\n\n        # Try to include the best candidate\n        for idx in top_indices:\n            if new_solution[idx] == 0:\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4824856783570909,
            5.321583718061447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select the most promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    best_idx = np.argmax(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Number of local search steps\n        # Step 1: Randomly select a subset of items to consider for flip\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n        item_to_flip = random.choice(candidates)\n\n        # Step 2: Evaluate potential flip (remove the item)\n        new_weight = current_weight - weight_lst[item_to_flip]\n        if new_weight <= capacity:\n            new_solution[item_to_flip] = 0\n            current_weight = new_weight\n            continue\n\n        # Step 3: If flip is not feasible, try to swap with another item\n        possible_swaps = np.where(new_solution == 0)[0]\n        if len(possible_swaps) > 0:\n            swap_item = random.choice(possible_swaps)\n            new_weight = current_weight - weight_lst[item_to_flip] + weight_lst[swap_item]\n            if new_weight <= capacity:\n                new_solution[item_to_flip] = 0\n                new_solution[swap_item] = 1\n                current_weight = new_weight\n\n    # Step 4: Adaptive flip based on marginal gains\n    for _ in range(5):\n        # Calculate marginal gains for each item\n        marginal_gains = (value1_lst + value2_lst) / (weight_lst + 1e-8)\n        marginal_gains[new_solution == 1] *= -1  # Penalize already included items\n\n        # Select top-k candidates\n        k = min(5, len(marginal_gains))\n        top_indices = np.argpartition(marginal_gains, -k)[-k:]\n\n        # Try to include the best candidate\n        for idx in top_indices:\n            if new_solution[idx] == 0:\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{A novel hybrid local search strategy combines adaptive perturbation with guided diversification, where promising solutions are intelligently selected based on their objective diversity and then modified by strategically flipping a subset of items to explore high-potential regions while ensuring feasibility through dynamic weight rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / sum(np.linspace(1, 0.1, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to potentially flip\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(new_solution == 0)[0]\n\n    # Select a subset of items to flip\n    flip_size = max(1, min(3, len(candidate_indices)))\n    flip_indices = np.random.choice(candidate_indices, size=flip_size, replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            new_solution[idx] = 1\n\n    # Ensure feasibility by removing excess weight\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items until feasible\n        excess_weight = new_weight - capacity\n        excess_indices = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_indices)\n        for idx in excess_indices:\n            if weight_lst[idx] <= excess_weight and new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n                if excess_weight <= 0:\n                    break\n\n    # If still infeasible, try to add items that don't exceed capacity\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Try to find a feasible solution by adding items\n        feasible = False\n        for _ in range(10):  # Limit attempts to avoid infinite loops\n            temp_solution = new_solution.copy()\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                feasible = True\n                break\n            # Randomly remove items to make space\n            excess_weight = temp_weight - capacity\n            excess_indices = np.where(temp_solution == 1)[0]\n            np.random.shuffle(excess_indices)\n            for idx in excess_indices:\n                if weight_lst[idx] <= excess_weight and temp_solution[idx] == 1:\n                    temp_solution[idx] = 0\n                    excess_weight -= weight_lst[idx]\n                    if excess_weight <= 0:\n                        break\n            if np.sum(weight_lst * temp_solution) <= capacity:\n                new_solution = temp_solution\n                feasible = True\n                break\n        if not feasible:\n            # If still infeasible, return the original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8932929328159054,
            4.263904362916946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / sum(np.linspace(1, 0.1, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to potentially flip\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(new_solution == 0)[0]\n\n    # Select a subset of items to flip\n    flip_size = max(1, min(3, len(candidate_indices)))\n    flip_indices = np.random.choice(candidate_indices, size=flip_size, replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            new_solution[idx] = 1\n\n    # Ensure feasibility by removing excess weight\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items until feasible\n        excess_weight = new_weight - capacity\n        excess_indices = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_indices)\n        for idx in excess_indices:\n            if weight_lst[idx] <= excess_weight and new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n                if excess_weight <= 0:\n                    break\n\n    # If still infeasible, try to add items that don't exceed capacity\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Try to find a feasible solution by adding items\n        feasible = False\n        for _ in range(10):  # Limit attempts to avoid infinite loops\n            temp_solution = new_solution.copy()\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                feasible = True\n                break\n            # Randomly remove items to make space\n            excess_weight = temp_weight - capacity\n            excess_indices = np.where(temp_solution == 1)[0]\n            np.random.shuffle(excess_indices)\n            for idx in excess_indices:\n                if weight_lst[idx] <= excess_weight and temp_solution[idx] == 1:\n                    temp_solution[idx] = 0\n                    excess_weight -= weight_lst[idx]\n                    if excess_weight <= 0:\n                        break\n            if np.sum(weight_lst * temp_solution) <= capacity:\n                new_solution = temp_solution\n                feasible = True\n                break\n        if not feasible:\n            # If still infeasible, return the original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a value-to-weight ratio-based swap mechanism to intelligently perturb solutions, ensuring feasibility while exploring diverse neighborhoods for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items to consider for swap\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Calculate value-to-weight ratios for objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Hybrid local search: biased random walk with value-to-weight ratio swaps\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.7:  # 70% chance for ratio-based swap\n            # Select an item to remove (lowest ratio for current objectives)\n            if len(items_in) > 0:\n                if random.random() < 0.5:\n                    remove_idx = items_in[np.argmin(ratio1[items_in])]\n                else:\n                    remove_idx = items_in[np.argmin(ratio2[items_in])]\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n                items_in = np.delete(items_in, np.where(items_in == remove_idx)[0])\n\n            # Select an item to add (highest ratio for current objectives)\n            if len(items_out) > 0:\n                if random.random() < 0.5:\n                    add_idx = items_out[np.argmax(ratio1[items_out])]\n                else:\n                    add_idx = items_out[np.argmax(ratio2[items_out])]\n                if current_weight + weight_lst[add_idx] <= capacity:\n                    new_solution[add_idx] = 1\n                    current_weight += weight_lst[add_idx]\n                    items_out = np.delete(items_out, np.where(items_out == add_idx)[0])\n        else:  # Random flip for diversity\n            if len(items_in) + len(items_out) > 0:\n                flip_idx = random.choice(np.concatenate([items_in, items_out]))\n                if new_solution[flip_idx] == 1:\n                    new_solution[flip_idx] = 0\n                    current_weight -= weight_lst[flip_idx]\n                else:\n                    if current_weight + weight_lst[flip_idx] <= capacity:\n                        new_solution[flip_idx] = 1\n                        current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4387836957192083,
            5.305620074272156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items to consider for swap\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Calculate value-to-weight ratios for objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Hybrid local search: biased random walk with value-to-weight ratio swaps\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.7:  # 70% chance for ratio-based swap\n            # Select an item to remove (lowest ratio for current objectives)\n            if len(items_in) > 0:\n                if random.random() < 0.5:\n                    remove_idx = items_in[np.argmin(ratio1[items_in])]\n                else:\n                    remove_idx = items_in[np.argmin(ratio2[items_in])]\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n                items_in = np.delete(items_in, np.where(items_in == remove_idx)[0])\n\n            # Select an item to add (highest ratio for current objectives)\n            if len(items_out) > 0:\n                if random.random() < 0.5:\n                    add_idx = items_out[np.argmax(ratio1[items_out])]\n                else:\n                    add_idx = items_out[np.argmax(ratio2[items_out])]\n                if current_weight + weight_lst[add_idx] <= capacity:\n                    new_solution[add_idx] = 1\n                    current_weight += weight_lst[add_idx]\n                    items_out = np.delete(items_out, np.where(items_out == add_idx)[0])\n        else:  # Random flip for diversity\n            if len(items_in) + len(items_out) > 0:\n                flip_idx = random.choice(np.concatenate([items_in, items_out]))\n                if new_solution[flip_idx] == 1:\n                    new_solution[flip_idx] = 0\n                    current_weight -= weight_lst[flip_idx]\n                else:\n                    if current_weight + weight_lst[flip_idx] <= capacity:\n                        new_solution[flip_idx] = 1\n                        current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search operator that combines adaptive item swapping and value-guided perturbation to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate potential improvement scores (e.g., based on value density or crowding distance)\n        improvement_scores = []\n        for sol, obj in archive:\n            total_weight = np.sum(weight_lst * sol)\n            value_density1 = obj[0] / total_weight if total_weight > 0 else 0\n            value_density2 = obj[1] / total_weight if total_weight > 0 else 0\n            # Score based on value density and diversity (e.g., crowding distance)\n            score = (value_density1 + value_density2) * (1 + random.random() * 0.1)  # Add slight randomness\n            improvement_scores.append(score)\n        # Select the solution with the highest score\n        selected_idx = np.argmax(improvement_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search: Adaptive item swapping and value-guided perturbation\n    # Step 2.1: Adaptive item swapping\n    swap_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                swap_candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Consider adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                swap_candidates.append((i, 1))  # 1 indicates addition\n\n    if swap_candidates:\n        # Select a candidate with high potential improvement (e.g., highest value density)\n        candidate_scores = []\n        for i, op in swap_candidates:\n            if op == 1:\n                # Adding item i\n                value_density1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                value_density2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                score = value_density1 + value_density2\n            else:\n                # Removing item i\n                score = - (value1_lst[i] / weight_lst[i] + value2_lst[i] / weight_lst[i]) if weight_lst[i] > 0 else 0\n            candidate_scores.append(score)\n        selected_candidate = swap_candidates[np.argmax(candidate_scores)]\n        i, op = selected_candidate\n        new_solution[i] = op if op == 1 else 0\n\n    # Step 2.2: Value-guided perturbation (if no improvement from swapping)\n    if np.array_equal(new_solution, base_solution):\n        # Randomly perturb the solution by flipping bits with high value density\n        perturbation_candidates = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                value_density1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                value_density2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                score = value_density1 + value_density2\n                perturbation_candidates.append((i, score))\n        if perturbation_candidates:\n            # Select top 20% candidates and flip one randomly\n            top_candidates = sorted(perturbation_candidates, key=lambda x: -x[1])\n            top_k = max(1, len(top_candidates) // 5)\n            selected_candidate = random.choice(top_candidates[:top_k])\n            i, _ = selected_candidate\n            new_solution[i] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible (prioritize low value density)\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Select item with lowest value density to remove\n            value_densities = []\n            for i in included_items:\n                value_density1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                value_density2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                value_densities.append((i, value_density1 + value_density2))\n            i, _ = min(value_densities, key=lambda x: x[1])\n            new_solution[i] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7510486981374616,
            6.601132452487946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate potential improvement scores (e.g., based on value density or crowding distance)\n        improvement_scores = []\n        for sol, obj in archive:\n            total_weight = np.sum(weight_lst * sol)\n            value_density1 = obj[0] / total_weight if total_weight > 0 else 0\n            value_density2 = obj[1] / total_weight if total_weight > 0 else 0\n            # Score based on value density and diversity (e.g., crowding distance)\n            score = (value_density1 + value_density2) * (1 + random.random() * 0.1)  # Add slight randomness\n            improvement_scores.append(score)\n        # Select the solution with the highest score\n        selected_idx = np.argmax(improvement_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search: Adaptive item swapping and value-guided perturbation\n    # Step 2.1: Adaptive item swapping\n    swap_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                swap_candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Consider adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                swap_candidates.append((i, 1))  # 1 indicates addition\n\n    if swap_candidates:\n        # Select a candidate with high potential improvement (e.g., highest value density)\n        candidate_scores = []\n        for i, op in swap_candidates:\n            if op == 1:\n                # Adding item i\n                value_density1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                value_density2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                score = value_density1 + value_density2\n            else:\n                # Removing item i\n                score = - (value1_lst[i] / weight_lst[i] + value2_lst[i] / weight_lst[i]) if weight_lst[i] > 0 else 0\n            candidate_scores.append(score)\n        selected_candidate = swap_candidates[np.argmax(candidate_scores)]\n        i, op = selected_candidate\n        new_solution[i] = op if op == 1 else 0\n\n    # Step 2.2: Value-guided perturbation (if no improvement from swapping)\n    if np.array_equal(new_solution, base_solution):\n        # Randomly perturb the solution by flipping bits with high value density\n        perturbation_candidates = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                value_density1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                value_density2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                score = value_density1 + value_density2\n                perturbation_candidates.append((i, score))\n        if perturbation_candidates:\n            # Select top 20% candidates and flip one randomly\n            top_candidates = sorted(perturbation_candidates, key=lambda x: -x[1])\n            top_k = max(1, len(top_candidates) // 5)\n            selected_candidate = random.choice(top_candidates[:top_k])\n            i, _ = selected_candidate\n            new_solution[i] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible (prioritize low value density)\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Select item with lowest value density to remove\n            value_densities = []\n            for i in included_items:\n                value_density1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                value_density2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                value_densities.append((i, value_density1 + value_density2))\n            i, _ = min(value_densities, key=lambda x: x[1])\n            new_solution[i] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, (val1, val2) in archive:\n        if np.sum(weight_lst * sol) < capacity:\n            candidates.append((sol, val1, val2))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Intelligent selection: prioritize solutions with high potential (e.g., high objective values)\n    selected_sol = max(candidates, key=lambda x: x[1] + x[2])[0]\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a subset of items with high marginal contribution\n    marginal_contribution = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n    sorted_indices = np.argsort(marginal_contribution)[::-1]  # Descending order\n\n    # Flip top-k items with highest marginal contribution (k=3 for diversity)\n    k = min(3, len(sorted_indices))\n    flip_indices = sorted_indices[:k]\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing excess items\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8806363862360519,
            4.076796352863312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, (val1, val2) in archive:\n        if np.sum(weight_lst * sol) < capacity:\n            candidates.append((sol, val1, val2))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Intelligent selection: prioritize solutions with high potential (e.g., high objective values)\n    selected_sol = max(candidates, key=lambda x: x[1] + x[2])[0]\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a subset of items with high marginal contribution\n    marginal_contribution = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n    sorted_indices = np.argsort(marginal_contribution)[::-1]  # Descending order\n\n    # Flip top-k items with highest marginal contribution (k=3 for diversity)\n    k = min(3, len(sorted_indices))\n    flip_indices = sorted_indices[:k]\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing excess items\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, identifies critical items (high value/weight ratio) to flip, and combines greedy improvement with probabilistic swaps to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def selection_criteria(sol_obj: Tuple[np.ndarray, Tuple[float, float]]) -> float:\n        sol, obj = sol_obj\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        # Prefer solutions with high potential for value improvement and low weight\n        return (obj[0] + obj[1]) / (1 + remaining_capacity)\n\n    selected_sol, _ = max(archive, key=selection_criteria)\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search: flip critical items and probabilistic swaps\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Calculate value-to-weight ratios for all items\n    vw_ratio1 = value1_lst / weight_lst\n    vw_ratio2 = value2_lst / weight_lst\n\n    # Identify critical items (highest value-to-weight ratio)\n    critical_items = np.argsort(-np.maximum(vw_ratio1, vw_ratio2))[:max(1, len(new_solution)//5)]\n\n    # Flip critical items if they fit\n    for item in critical_items:\n        if new_solution[item] == 0 and total_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            total_weight += weight_lst[item]\n        elif new_solution[item] == 1:\n            new_solution[item] = 0\n            total_weight -= weight_lst[item]\n\n    # Probabilistic swaps for diversification\n    for _ in range(min(3, len(new_solution))):\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n        if new_solution[item1] != new_solution[item2]:\n            if new_solution[item1] == 1 and total_weight - weight_lst[item1] + weight_lst[item2] <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            elif new_solution[item2] == 1 and total_weight - weight_lst[item2] + weight_lst[item1] <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n",
        "score": [
            -0.8794120663803864,
            6.6274314522743225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def selection_criteria(sol_obj: Tuple[np.ndarray, Tuple[float, float]]) -> float:\n        sol, obj = sol_obj\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        # Prefer solutions with high potential for value improvement and low weight\n        return (obj[0] + obj[1]) / (1 + remaining_capacity)\n\n    selected_sol, _ = max(archive, key=selection_criteria)\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search: flip critical items and probabilistic swaps\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Calculate value-to-weight ratios for all items\n    vw_ratio1 = value1_lst / weight_lst\n    vw_ratio2 = value2_lst / weight_lst\n\n    # Identify critical items (highest value-to-weight ratio)\n    critical_items = np.argsort(-np.maximum(vw_ratio1, vw_ratio2))[:max(1, len(new_solution)//5)]\n\n    # Flip critical items if they fit\n    for item in critical_items:\n        if new_solution[item] == 0 and total_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            total_weight += weight_lst[item]\n        elif new_solution[item] == 1:\n            new_solution[item] = 0\n            total_weight -= weight_lst[item]\n\n    # Probabilistic swaps for diversification\n    for _ in range(min(3, len(new_solution))):\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n        if new_solution[item1] != new_solution[item2]:\n            if new_solution[item1] == 1 and total_weight - weight_lst[item1] + weight_lst[item2] <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            elif new_solution[item2] == 1 and total_weight - weight_lst[item2] + weight_lst[item1] <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and applies a hybrid local search strategy that combines random item swaps with targeted improvements to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: random swap + targeted improvement\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Random swap to escape local optima\n    if random.random() < 0.5:  # 50% chance for random swap\n        items = np.where(new_solution == 1)[0]\n        if len(items) > 1:\n            i, j = random.sample(list(items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Targeted improvement - add high-value items if feasible\n    for i in np.where(new_solution == 0)[0]:\n        if current_weight + weight_lst[i] <= capacity:\n            # Add item if it improves at least one objective\n            if value1_lst[i] > 0 or value2_lst[i] > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 3: Remove low-value items if possible\n    for i in np.where(new_solution == 1)[0]:\n        if random.random() < 0.1:  # 10% chance to remove any item\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7376697060337436,
            6.498874694108963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: random swap + targeted improvement\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Random swap to escape local optima\n    if random.random() < 0.5:  # 50% chance for random swap\n        items = np.where(new_solution == 1)[0]\n        if len(items) > 1:\n            i, j = random.sample(list(items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Targeted improvement - add high-value items if feasible\n    for i in np.where(new_solution == 0)[0]:\n        if current_weight + weight_lst[i] <= capacity:\n            # Add item if it improves at least one objective\n            if value1_lst[i] > 0 or value2_lst[i] > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 3: Remove low-value items if possible\n    for i in np.where(new_solution == 1)[0]:\n        if random.random() < 0.1:  # 10% chance to remove any item\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps and insertions to explore non-dominated regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidate_solutions = [sol for sol, _ in archive if np.sum(weight_lst * sol) < 0.9 * capacity]\n    if not candidate_solutions:\n        candidate_solutions = [sol for sol, _ in archive]\n    base_solution = random.choice(candidate_solutions).copy()\n\n    # Generate neighbor via hybrid local search: swap + insertion\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select items to swap or insert\n    if random.random() < 0.5:  # Swap strategy\n        idx1, idx2 = random.sample(range(n_items), 2)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n    else:  # Insertion strategy\n        idx = random.randint(0, n_items - 1)\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        while excess > 0:\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) == 0:\n                break\n            remove_idx = random.choice(candidates)\n            excess -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3332471591962326,
            9.45666241645813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidate_solutions = [sol for sol, _ in archive if np.sum(weight_lst * sol) < 0.9 * capacity]\n    if not candidate_solutions:\n        candidate_solutions = [sol for sol, _ in archive]\n    base_solution = random.choice(candidate_solutions).copy()\n\n    # Generate neighbor via hybrid local search: swap + insertion\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select items to swap or insert\n    if random.random() < 0.5:  # Swap strategy\n        idx1, idx2 = random.sample(range(n_items), 2)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n    else:  # Insertion strategy\n        idx = random.randint(0, n_items - 1)\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        while excess > 0:\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) == 0:\n                break\n            remove_idx = random.choice(candidates)\n            excess -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining random item swaps and objective-driven flips to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        weight = np.sum(weight_lst * sol)\n        utilization = weight / capacity\n        candidates.append((sol, obj, utilization))\n\n    # Sort by objective values and utilization (prioritize higher values and lower utilization)\n    candidates.sort(key=lambda x: (-x[1][0] - x[1][1], x[2]))\n\n    # Select top 10% or at least 1 candidate\n    num_candidates = max(1, len(candidates) // 10)\n    selected = random.choice(candidates[:num_candidates])[0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to flip (balance exploration and exploitation)\n    flip_indices = random.sample(range(n_items), min(5, n_items))\n\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            # Try removing the item\n            if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            # Try adding the item\n            if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Additional objective-driven flip\n    if random.random() < 0.3:  # 30% chance to perform objective-driven flip\n        # Calculate marginal gains for each item\n        marginal1 = value1_lst / (weight_lst + 1e-10)\n        marginal2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine marginal gains for both objectives\n        combined_marginal = marginal1 + marginal2\n\n        # Sort items by combined marginal gain\n        sorted_indices = np.argsort(-combined_marginal)\n\n        for i in sorted_indices:\n            if new_solution[i] == 0:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n            elif new_solution[i] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.28865972457133693,
            8.873289465904236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        weight = np.sum(weight_lst * sol)\n        utilization = weight / capacity\n        candidates.append((sol, obj, utilization))\n\n    # Sort by objective values and utilization (prioritize higher values and lower utilization)\n    candidates.sort(key=lambda x: (-x[1][0] - x[1][1], x[2]))\n\n    # Select top 10% or at least 1 candidate\n    num_candidates = max(1, len(candidates) // 10)\n    selected = random.choice(candidates[:num_candidates])[0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to flip (balance exploration and exploitation)\n    flip_indices = random.sample(range(n_items), min(5, n_items))\n\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            # Try removing the item\n            if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            # Try adding the item\n            if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Additional objective-driven flip\n    if random.random() < 0.3:  # 30% chance to perform objective-driven flip\n        # Calculate marginal gains for each item\n        marginal1 = value1_lst / (weight_lst + 1e-10)\n        marginal2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine marginal gains for both objectives\n        combined_marginal = marginal1 + marginal2\n\n        # Sort items by combined marginal gain\n        sorted_indices = np.argsort(-combined_marginal)\n\n        for i in sorted_indices:\n            if new_solution[i] == 0:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n            elif new_solution[i] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive and applies a combination of random item swaps, targeted flips based on marginal gains, and adaptive neighborhood exploration to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using hybrid local search\n    for _ in range(10):  # Number of attempts to find a better neighbor\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(base_solution)), 2)\n\n        # Calculate the effect of the swap\n        delta_weight = (weight_lst[item2] - weight_lst[item1]) * (base_solution[item2] - base_solution[item1])\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Accept the swap if feasible\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight = new_weight\n            break\n\n    # Additional targeted flips based on marginal gains\n    for _ in range(5):\n        # Calculate marginal gains for each item\n        marginal_gains1 = value1_lst / weight_lst\n        marginal_gains2 = value2_lst / weight_lst\n\n        # Combine marginal gains for both objectives\n        combined_gains = marginal_gains1 + marginal_gains2\n\n        # Select items with highest combined gains\n        candidate_items = np.argsort(combined_gains)[-5:]  # Top 5 items\n\n        for item in candidate_items:\n            if new_solution[item] == 0:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n            else:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.4563931097649339,
            9.293607085943222
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using hybrid local search\n    for _ in range(10):  # Number of attempts to find a better neighbor\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(base_solution)), 2)\n\n        # Calculate the effect of the swap\n        delta_weight = (weight_lst[item2] - weight_lst[item1]) * (base_solution[item2] - base_solution[item1])\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Accept the swap if feasible\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight = new_weight\n            break\n\n    # Additional targeted flips based on marginal gains\n    for _ in range(5):\n        # Calculate marginal gains for each item\n        marginal_gains1 = value1_lst / weight_lst\n        marginal_gains2 = value2_lst / weight_lst\n\n        # Combine marginal gains for both objectives\n        combined_gains = marginal_gains1 + marginal_gains2\n\n        # Select items with highest combined gains\n        candidate_items = np.argsort(combined_gains)[-5:]  # Top 5 items\n\n        for item in candidate_items:\n            if new_solution[item] == 0:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n            else:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining item swaps, random flips, and guided diversification to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly flip items to explore neighborhood\n    flip_indices = random.sample(range(num_items), min(3, num_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Guided diversification - swap items to improve objectives\n    if random.random() < 0.5:  # 50% chance to perform swap\n        obj1_ratio = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        obj2_ratio = value2_lst / (weight_lst + 1e-6)\n\n        # Select items with highest potential improvement\n        potential_items = np.argsort(-(obj1_ratio + obj2_ratio))[:5]\n        for idx in potential_items:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n\n    # Ensure feasibility\n    while current_weight > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4154885147832828,
            2.4594805538654327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly flip items to explore neighborhood\n    flip_indices = random.sample(range(num_items), min(3, num_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Guided diversification - swap items to improve objectives\n    if random.random() < 0.5:  # 50% chance to perform swap\n        obj1_ratio = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        obj2_ratio = value2_lst / (weight_lst + 1e-6)\n\n        # Select items with highest potential improvement\n        potential_items = np.argsort(-(obj1_ratio + obj2_ratio))[:5]\n        for idx in potential_items:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n\n    # Ensure feasibility\n    while current_weight > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining item swaps, random flips, and guided diversification to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly flip items to explore neighborhood\n    flip_indices = random.sample(range(num_items), min(3, num_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Guided diversification - swap items to improve objectives\n    if random.random() < 0.5:  # 50% chance to perform swap\n        obj1_ratio = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        obj2_ratio = value2_lst / (weight_lst + 1e-6)\n\n        # Select items with highest potential improvement\n        potential_items = np.argsort(-(obj1_ratio + obj2_ratio))[:5]\n        for idx in potential_items:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n\n    # Ensure feasibility\n    while current_weight > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4154885147832828,
            2.4594805538654327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly flip items to explore neighborhood\n    flip_indices = random.sample(range(num_items), min(3, num_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Guided diversification - swap items to improve objectives\n    if random.random() < 0.5:  # 50% chance to perform swap\n        obj1_ratio = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        obj2_ratio = value2_lst / (weight_lst + 1e-6)\n\n        # Select items with highest potential improvement\n        potential_items = np.argsort(-(obj1_ratio + obj2_ratio))[:5]\n        for idx in potential_items:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n\n    # Ensure feasibility\n    while current_weight > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{A novel hybrid local search algorithm combines a dynamic item swap strategy with a probabilistic neighborhood exploration, selectively flipping items based on their marginal contribution to both objectives while ensuring feasibility through capacity-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Sort solutions by a combined score of both objectives\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Candidate items to flip (either included or excluded)\n    candidates = np.where(new_solution == 1)[0] if random.random() < 0.7 else np.where(new_solution == 0)[0]\n\n    for item in candidates:\n        # Calculate marginal contribution for both objectives\n        marginal_value1 = value1_lst[item] if new_solution[item] == 0 else -value1_lst[item]\n        marginal_value2 = value2_lst[item] if new_solution[item] == 0 else -value2_lst[item]\n        marginal_weight = weight_lst[item] if new_solution[item] == 0 else -weight_lst[item]\n\n        # Flip the item if it improves both objectives or if it's a small trade-off\n        if (marginal_value1 > 0 and marginal_value2 > 0) or (current_weight + marginal_weight <= capacity):\n            new_solution[item] = 1 - new_solution[item]\n            current_weight += marginal_weight\n\n    # Ensure feasibility by removing items randomly if over capacity\n    while current_weight > capacity:\n        over_items = np.where(new_solution == 1)[0]\n        if len(over_items) == 0:\n            break\n        remove_item = random.choice(over_items)\n        new_solution[remove_item] = 0\n        current_weight -= weight_lst[remove_item]\n\n    return new_solution\n\n",
        "score": [
            -0.5105667407819224,
            6.429270327091217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Sort solutions by a combined score of both objectives\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Candidate items to flip (either included or excluded)\n    candidates = np.where(new_solution == 1)[0] if random.random() < 0.7 else np.where(new_solution == 0)[0]\n\n    for item in candidates:\n        # Calculate marginal contribution for both objectives\n        marginal_value1 = value1_lst[item] if new_solution[item] == 0 else -value1_lst[item]\n        marginal_value2 = value2_lst[item] if new_solution[item] == 0 else -value2_lst[item]\n        marginal_weight = weight_lst[item] if new_solution[item] == 0 else -weight_lst[item]\n\n        # Flip the item if it improves both objectives or if it's a small trade-off\n        if (marginal_value1 > 0 and marginal_value2 > 0) or (current_weight + marginal_weight <= capacity):\n            new_solution[item] = 1 - new_solution[item]\n            current_weight += marginal_weight\n\n    # Ensure feasibility by removing items randomly if over capacity\n    while current_weight > capacity:\n        over_items = np.where(new_solution == 1)[0]\n        if len(over_items) == 0:\n            break\n        remove_item = random.choice(over_items)\n        new_solution[remove_item] = 0\n        current_weight -= weight_lst[remove_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{The heuristic selects a promising solution from the archive based on a combination of objective diversity and potential improvement, then applies a hybrid local search combining random swaps, greedy additions, and adaptive perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate diversity and potential improvement\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        scores = diversity[0] * 0.6 + diversity[1] * 0.4  # Weighted diversity score\n\n        # Select top 3 solutions with highest diversity\n        top_indices = np.argsort(scores)[-3:]\n        selected_idx = np.random.choice(top_indices)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy additions + adaptive perturbation\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # 1. Random swaps (50% chance)\n    if np.random.rand() < 0.5:\n        swap_indices = np.random.choice(n_items, size=2, replace=False)\n        if base_solution[swap_indices[0]] != base_solution[swap_indices[1]]:\n            new_solution[swap_indices] = 1 - new_solution[swap_indices]\n\n    # 2. Greedy additions (30% chance)\n    elif np.random.rand() < 0.8:\n        # Calculate potential improvements for 0 items\n        zero_indices = np.where(base_solution == 0)[0]\n        if len(zero_indices) > 0:\n            potential_weights = weight_lst[zero_indices]\n            potential_value1 = value1_lst[zero_indices]\n            potential_value2 = value2_lst[zero_indices]\n\n            # Filter feasible additions\n            feasible_mask = potential_weights <= remaining_capacity\n            feasible_indices = zero_indices[feasible_mask]\n\n            if len(feasible_indices) > 0:\n                # Select top 3 items with highest value ratio\n                value_ratio1 = potential_value1[feasible_mask] / potential_weights[feasible_mask]\n                value_ratio2 = potential_value2[feasible_mask] / potential_weights[feasible_mask]\n                combined_ratio = value_ratio1 * 0.7 + value_ratio2 * 0.3  # Weighted ratio\n\n                top_indices = np.argsort(combined_ratio)[-min(3, len(feasible_indices)):]\n                selected_item = np.random.choice(feasible_indices[top_indices])\n                new_solution[selected_item] = 1\n\n    # 3. Adaptive perturbation (20% chance)\n    else:\n        # Randomly flip 1-3 items, ensuring feasibility\n        n_flips = np.random.randint(1, 4)\n        flip_indices = np.random.choice(n_items, size=n_flips, replace=False)\n\n        for idx in flip_indices:\n            if base_solution[idx] == 1:\n                # If removing, check if it's safe\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n            else:\n                # If adding, check if it's feasible\n                if weight_lst[idx] <= remaining_capacity:\n                    new_solution[idx] = 1\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items until feasible\n        excess = new_weight - capacity\n        while excess > 0:\n            excess_indices = np.where(new_solution == 1)[0]\n            if len(excess_indices) == 0:\n                break\n            remove_idx = np.random.choice(excess_indices)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8181656097734881,
            4.626040518283844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate diversity and potential improvement\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        scores = diversity[0] * 0.6 + diversity[1] * 0.4  # Weighted diversity score\n\n        # Select top 3 solutions with highest diversity\n        top_indices = np.argsort(scores)[-3:]\n        selected_idx = np.random.choice(top_indices)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy additions + adaptive perturbation\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # 1. Random swaps (50% chance)\n    if np.random.rand() < 0.5:\n        swap_indices = np.random.choice(n_items, size=2, replace=False)\n        if base_solution[swap_indices[0]] != base_solution[swap_indices[1]]:\n            new_solution[swap_indices] = 1 - new_solution[swap_indices]\n\n    # 2. Greedy additions (30% chance)\n    elif np.random.rand() < 0.8:\n        # Calculate potential improvements for 0 items\n        zero_indices = np.where(base_solution == 0)[0]\n        if len(zero_indices) > 0:\n            potential_weights = weight_lst[zero_indices]\n            potential_value1 = value1_lst[zero_indices]\n            potential_value2 = value2_lst[zero_indices]\n\n            # Filter feasible additions\n            feasible_mask = potential_weights <= remaining_capacity\n            feasible_indices = zero_indices[feasible_mask]\n\n            if len(feasible_indices) > 0:\n                # Select top 3 items with highest value ratio\n                value_ratio1 = potential_value1[feasible_mask] / potential_weights[feasible_mask]\n                value_ratio2 = potential_value2[feasible_mask] / potential_weights[feasible_mask]\n                combined_ratio = value_ratio1 * 0.7 + value_ratio2 * 0.3  # Weighted ratio\n\n                top_indices = np.argsort(combined_ratio)[-min(3, len(feasible_indices)):]\n                selected_item = np.random.choice(feasible_indices[top_indices])\n                new_solution[selected_item] = 1\n\n    # 3. Adaptive perturbation (20% chance)\n    else:\n        # Randomly flip 1-3 items, ensuring feasibility\n        n_flips = np.random.randint(1, 4)\n        flip_indices = np.random.choice(n_items, size=n_flips, replace=False)\n\n        for idx in flip_indices:\n            if base_solution[idx] == 1:\n                # If removing, check if it's safe\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n            else:\n                # If adding, check if it's feasible\n                if weight_lst[idx] <= remaining_capacity:\n                    new_solution[idx] = 1\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items until feasible\n        excess = new_weight - capacity\n        while excess > 0:\n            excess_indices = np.where(new_solution == 1)[0]\n            if len(excess_indices) == 0:\n                break\n            remove_idx = np.random.choice(excess_indices)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search that combines item swapping and probabilistic flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 - (np.sum(s[0]) / len(s[0])) for s in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap two items or flip a selected item\n    if random.random() < 0.5:\n        # Swap two items (if possible)\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n        if len(items_in) >= 2 and len(items_out) >= 1:\n            # Select two items to swap out and one to swap in\n            swap_out = random.sample(list(items_in), 2)\n            swap_in = random.choice(items_out)\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_out[0]] - weight_lst[swap_out[1]] + weight_lst[swap_in]\n            if new_weight <= capacity:\n                new_solution[swap_out[0]] = 0\n                new_solution[swap_out[1]] = 0\n                new_solution[swap_in] = 1\n    else:\n        # Flip a selected item (if possible)\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Select an item to flip (50% chance to flip in or out)\n            if random.random() < 0.5:\n                # Flip out an item\n                flip_item = random.choice(items_in)\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight - weight_lst[flip_item]\n                if new_weight <= capacity:\n                    new_solution[flip_item] = 0\n            else:\n                # Flip in an item\n                flip_item = random.choice(items_out)\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight + weight_lst[flip_item]\n                if new_weight <= capacity:\n                    new_solution[flip_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.44559826739606323,
            11.185926765203476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 - (np.sum(s[0]) / len(s[0])) for s in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap two items or flip a selected item\n    if random.random() < 0.5:\n        # Swap two items (if possible)\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n        if len(items_in) >= 2 and len(items_out) >= 1:\n            # Select two items to swap out and one to swap in\n            swap_out = random.sample(list(items_in), 2)\n            swap_in = random.choice(items_out)\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_out[0]] - weight_lst[swap_out[1]] + weight_lst[swap_in]\n            if new_weight <= capacity:\n                new_solution[swap_out[0]] = 0\n                new_solution[swap_out[1]] = 0\n                new_solution[swap_in] = 1\n    else:\n        # Flip a selected item (if possible)\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Select an item to flip (50% chance to flip in or out)\n            if random.random() < 0.5:\n                # Flip out an item\n                flip_item = random.choice(items_in)\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight - weight_lst[flip_item]\n                if new_weight <= capacity:\n                    new_solution[flip_item] = 0\n            else:\n                # Flip in an item\n                flip_item = random.choice(items_out)\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight + weight_lst[flip_item]\n                if new_weight <= capacity:\n                    new_solution[flip_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution, _ = archive[0]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contribution of each item to both objectives\n    marginal_value1 = value1_lst * (1 - new_solution) - value1_lst * new_solution\n    marginal_value2 = value2_lst * (1 - new_solution) - value2_lst * new_solution\n    marginal_weight = weight_lst * (1 - new_solution) - weight_lst * new_solution\n\n    # Combine marginal contributions into a single score (prioritize items with high marginal value per unit weight)\n    score = (marginal_value1 + marginal_value2) / (marginal_weight + 1e-6)\n\n    # Select top-k items to flip (k is a small random number)\n    k = min(3, len(score))\n    top_indices = np.argpartition(score, -k)[-k:]\n    selected_items = np.zeros_like(new_solution)\n    selected_items[top_indices] = 1\n\n    # Flip selected items and ensure feasibility\n    for i in top_indices:\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8150539617380614,
            2.2154372930526733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution, _ = archive[0]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contribution of each item to both objectives\n    marginal_value1 = value1_lst * (1 - new_solution) - value1_lst * new_solution\n    marginal_value2 = value2_lst * (1 - new_solution) - value2_lst * new_solution\n    marginal_weight = weight_lst * (1 - new_solution) - weight_lst * new_solution\n\n    # Combine marginal contributions into a single score (prioritize items with high marginal value per unit weight)\n    score = (marginal_value1 + marginal_value2) / (marginal_weight + 1e-6)\n\n    # Select top-k items to flip (k is a small random number)\n    k = min(3, len(score))\n    top_indices = np.argpartition(score, -k)[-k:]\n    selected_items = np.zeros_like(new_solution)\n    selected_items[top_indices] = 1\n\n    # Flip selected items and ensure feasibility\n    for i in top_indices:\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution, _ = archive[0]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contribution of each item to both objectives\n    marginal_value1 = value1_lst * (1 - new_solution) - value1_lst * new_solution\n    marginal_value2 = value2_lst * (1 - new_solution) - value2_lst * new_solution\n    marginal_weight = weight_lst * (1 - new_solution) - weight_lst * new_solution\n\n    # Combine marginal contributions into a single score (prioritize items with high marginal value per unit weight)\n    score = (marginal_value1 + marginal_value2) / (marginal_weight + 1e-6)\n\n    # Select top-k items to flip (k is a small random number)\n    k = min(3, len(score))\n    top_indices = np.argpartition(score, -k)[-k:]\n    selected_items = np.zeros_like(new_solution)\n    selected_items[top_indices] = 1\n\n    # Flip selected items and ensure feasibility\n    for i in top_indices:\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8150539617380614,
            2.2154372930526733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution, _ = archive[0]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contribution of each item to both objectives\n    marginal_value1 = value1_lst * (1 - new_solution) - value1_lst * new_solution\n    marginal_value2 = value2_lst * (1 - new_solution) - value2_lst * new_solution\n    marginal_weight = weight_lst * (1 - new_solution) - weight_lst * new_solution\n\n    # Combine marginal contributions into a single score (prioritize items with high marginal value per unit weight)\n    score = (marginal_value1 + marginal_value2) / (marginal_weight + 1e-6)\n\n    # Select top-k items to flip (k is a small random number)\n    k = min(3, len(score))\n    top_indices = np.argpartition(score, -k)[-k:]\n    selected_items = np.zeros_like(new_solution)\n    selected_items[top_indices] = 1\n\n    # Flip selected items and ensure feasibility\n    for i in top_indices:\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping with probabilistic diversification, prioritizing high-margin items and leveraging objective-specific dominance relationships to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Prioritize solutions with higher objective values but not already on the Pareto front\n        objectives = np.array([obj for (_, obj) in archive])\n        norm_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n        scores = norm_obj[:, 0] * 0.6 + norm_obj[:, 1] * 0.4  # Weighted score\n        probs = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    # Calculate current weight and objective margins\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Find items to potentially swap or flip\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    # Calculate potential improvements\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Calculate marginal gains for in-items and losses for out-items\n        in_margins1 = value1_lst[in_items] / weight_lst[in_items]\n        in_margins2 = value2_lst[in_items] / weight_lst[in_items]\n        out_margins1 = value1_lst[out_items] / weight_lst[out_items]\n        out_margins2 = value2_lst[out_items] / weight_lst[out_items]\n\n        # Probabilistic selection based on marginal gains\n        prob_in = (in_margins1 + in_margins2) / np.sum(in_margins1 + in_margins2)\n        prob_out = (out_margins1 + out_margins2) / np.sum(out_margins1 + out_margins2)\n\n        # Select items to potentially swap\n        item_in = np.random.choice(in_items, p=prob_in)\n        item_out = np.random.choice(out_items, p=prob_out)\n\n        # Calculate new weight after swap\n        new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n        # Only perform swap if feasible\n        if new_weight <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n        else:\n            # If swap not feasible, try to remove high-margin item\n            worst_item = in_items[np.argmin(in_margins1 + in_margins2)]\n            new_weight = current_weight - weight_lst[worst_item]\n            if new_weight <= capacity:\n                new_solution[worst_item] = 0\n            else:\n                # If removal not feasible, try to add low-weight item\n                best_item = out_items[np.argmax(out_margins1 + out_margins2)]\n                if weight_lst[best_item] <= capacity - (current_weight - weight_lst[worst_item]):\n                    new_solution[worst_item] = 0\n                    new_solution[best_item] = 1\n    else:\n        # If no items in knapsack, add best items until full\n        if len(out_items) > 0:\n            out_margins = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n            sorted_out = out_items[np.argsort(out_margins)[::-1]]\n            for item in sorted_out:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                else:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5180563128956531,
            7.013137340545654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Prioritize solutions with higher objective values but not already on the Pareto front\n        objectives = np.array([obj for (_, obj) in archive])\n        norm_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n        scores = norm_obj[:, 0] * 0.6 + norm_obj[:, 1] * 0.4  # Weighted score\n        probs = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    # Calculate current weight and objective margins\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Find items to potentially swap or flip\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    # Calculate potential improvements\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Calculate marginal gains for in-items and losses for out-items\n        in_margins1 = value1_lst[in_items] / weight_lst[in_items]\n        in_margins2 = value2_lst[in_items] / weight_lst[in_items]\n        out_margins1 = value1_lst[out_items] / weight_lst[out_items]\n        out_margins2 = value2_lst[out_items] / weight_lst[out_items]\n\n        # Probabilistic selection based on marginal gains\n        prob_in = (in_margins1 + in_margins2) / np.sum(in_margins1 + in_margins2)\n        prob_out = (out_margins1 + out_margins2) / np.sum(out_margins1 + out_margins2)\n\n        # Select items to potentially swap\n        item_in = np.random.choice(in_items, p=prob_in)\n        item_out = np.random.choice(out_items, p=prob_out)\n\n        # Calculate new weight after swap\n        new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n        # Only perform swap if feasible\n        if new_weight <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n        else:\n            # If swap not feasible, try to remove high-margin item\n            worst_item = in_items[np.argmin(in_margins1 + in_margins2)]\n            new_weight = current_weight - weight_lst[worst_item]\n            if new_weight <= capacity:\n                new_solution[worst_item] = 0\n            else:\n                # If removal not feasible, try to add low-weight item\n                best_item = out_items[np.argmax(out_margins1 + out_margins2)]\n                if weight_lst[best_item] <= capacity - (current_weight - weight_lst[worst_item]):\n                    new_solution[worst_item] = 0\n                    new_solution[best_item] = 1\n    else:\n        # If no items in knapsack, add best items until full\n        if len(out_items) > 0:\n            out_margins = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n            sorted_out = out_items[np.argsort(out_margins)[::-1]]\n            for item in sorted_out:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                else:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{A novel hybrid local search operator is designed to intelligently select and perturb a solution by dynamically prioritizing items based on their marginal contributions to both objectives, while ensuring feasibility through adaptive weight adjustments and a probabilistic exploration of high-potential regions in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify candidate items for perturbation\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Hybrid local search: combine marginal value analysis with probabilistic perturbation\n    for item in candidate_items:\n        # Calculate marginal values if item is removed\n        marginal_weight = weight_lst[item]\n        marginal_value1 = value1_lst[item]\n        marginal_value2 = value2_lst[item]\n\n        # Probabilistic decision based on marginal contributions\n        if np.random.rand() < 0.5 and current_weight - marginal_weight >= 0:\n            new_solution[item] = 0\n            current_weight -= marginal_weight\n            current_value1 -= marginal_value1\n            current_value2 -= marginal_value2\n\n    # Add items probabilistically based on potential marginal gains\n    remaining_items = np.where(new_solution == 0)[0]\n    for item in remaining_items:\n        if np.random.rand() < 0.3 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n            current_value1 += value1_lst[item]\n            current_value2 += value2_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4390672782711279,
            5.890900552272797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify candidate items for perturbation\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Hybrid local search: combine marginal value analysis with probabilistic perturbation\n    for item in candidate_items:\n        # Calculate marginal values if item is removed\n        marginal_weight = weight_lst[item]\n        marginal_value1 = value1_lst[item]\n        marginal_value2 = value2_lst[item]\n\n        # Probabilistic decision based on marginal contributions\n        if np.random.rand() < 0.5 and current_weight - marginal_weight >= 0:\n            new_solution[item] = 0\n            current_weight -= marginal_weight\n            current_value1 -= marginal_value1\n            current_value2 -= marginal_value2\n\n    # Add items probabilistically based on potential marginal gains\n    remaining_items = np.where(new_solution == 0)[0]\n    for item in remaining_items:\n        if np.random.rand() < 0.3 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n            current_value1 += value1_lst[item]\n            current_value2 += value2_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm intelligently selects a high-potential solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search combining random flips and targeted swaps to explore the solution space while ensuring feasibility, balancing exploration and exploitation for better multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Sort archive by combined objective values (sum of normalized objectives)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Random flip with feasibility check\n    for _ in range(3):  # Try 3 random flips\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            if np.sum(weight_lst[new_solution == 1]) > capacity:\n                new_solution[idx] = 1\n        else:\n            new_solution[idx] = 1\n            if np.sum(weight_lst[new_solution == 1]) > capacity:\n                new_solution[idx] = 0\n\n    # Targeted swap for better objective improvement\n    for _ in range(2):  # Try 2 targeted swaps\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Find item to remove (lowest marginal contribution)\n            in_contributions = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            remove_idx = in_items[np.argmin(in_contributions)]\n\n            # Find item to add (highest marginal contribution)\n            out_contributions = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n            add_idx = out_items[np.argmax(out_contributions)]\n\n            # Check if swap is feasible\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if (current_weight - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3008935551947934,
            6.321380913257599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Sort archive by combined objective values (sum of normalized objectives)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Random flip with feasibility check\n    for _ in range(3):  # Try 3 random flips\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            if np.sum(weight_lst[new_solution == 1]) > capacity:\n                new_solution[idx] = 1\n        else:\n            new_solution[idx] = 1\n            if np.sum(weight_lst[new_solution == 1]) > capacity:\n                new_solution[idx] = 0\n\n    # Targeted swap for better objective improvement\n    for _ in range(2):  # Try 2 targeted swaps\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Find item to remove (lowest marginal contribution)\n            in_contributions = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            remove_idx = in_items[np.argmin(in_contributions)]\n\n            # Find item to add (highest marginal contribution)\n            out_contributions = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n            add_idx = out_items[np.argmax(out_contributions)]\n\n            # Check if swap is feasible\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if (current_weight - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by prioritizing those with non-dominated neighbors, then applies a hybrid local search operator that combines dynamic item swaps and adaptive neighborhood exploration to generate high-quality feasible neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those with non-dominated neighbors)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Strategy 1: Dynamic item swaps (replace one included item with one excluded item)\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select an included item to remove\n        remove_idx = np.random.choice(included_items)\n        # Randomly select an excluded item to add\n        add_idx = np.random.choice(excluded_items)\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n        if new_weight <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n            return new_solution\n\n    # Strategy 2: Adaptive neighborhood exploration (flip multiple bits if single swap fails)\n    if len(included_items) > 1:\n        # Randomly select two included items to swap\n        swap_indices = np.random.choice(included_items, size=2, replace=False)\n        new_weight = current_weight - weight_lst[swap_indices[0]] + weight_lst[swap_indices[1]]\n        if new_weight <= capacity:\n            new_solution[swap_indices[0]] = 0\n            new_solution[swap_indices[1]] = 1\n            return new_solution\n\n    # Strategy 3: Greedy improvement (add highest-value item if feasible)\n    excluded_items = np.where(new_solution == 0)[0]\n    for item in excluded_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            return new_solution\n\n    # If no improvement found, return the original solution\n    return base_solution\n\n",
        "score": [
            -0.35795439177993593,
            4.697021484375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those with non-dominated neighbors)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Strategy 1: Dynamic item swaps (replace one included item with one excluded item)\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select an included item to remove\n        remove_idx = np.random.choice(included_items)\n        # Randomly select an excluded item to add\n        add_idx = np.random.choice(excluded_items)\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n        if new_weight <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n            return new_solution\n\n    # Strategy 2: Adaptive neighborhood exploration (flip multiple bits if single swap fails)\n    if len(included_items) > 1:\n        # Randomly select two included items to swap\n        swap_indices = np.random.choice(included_items, size=2, replace=False)\n        new_weight = current_weight - weight_lst[swap_indices[0]] + weight_lst[swap_indices[1]]\n        if new_weight <= capacity:\n            new_solution[swap_indices[0]] = 0\n            new_solution[swap_indices[1]] = 1\n            return new_solution\n\n    # Strategy 3: Greedy improvement (add highest-value item if feasible)\n    excluded_items = np.where(new_solution == 0)[0]\n    for item in excluded_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            return new_solution\n\n    # If no improvement found, return the original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Identify the most crowded region in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    ranges = max_vals - min_vals\n    if np.any(ranges == 0):\n        ranges[ranges == 0] = 1  # Avoid division by zero\n\n    # Normalize objectives and compute crowding distances\n    normalized = (objectives - min_vals) / ranges\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(normalized[:, i])\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding[sorted_indices[j]] += (normalized[sorted_indices[j + 1], i] - normalized[sorted_indices[j - 1], i])\n\n    # Select the solution with the smallest crowding distance (most crowded region)\n    selected_idx = np.argmin(crowding)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search (swap + perturbation)\n    items = np.where(new_solution == 1)[0]\n    if len(items) < 2:\n        # If fewer than 2 items, perform random perturbation\n        for i in range(len(new_solution)):\n            if np.random.rand() < 0.1:  # 10% chance to flip\n                new_solution[i] = 1 - new_solution[i]\n                if np.sum(weight_lst * new_solution) > capacity:\n                    new_solution[i] = 1 - new_solution[i]\n    else:\n        # Perform swap between two items\n        i, j = np.random.choice(items, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        item_to_remove = np.random.choice(items_in)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8537864062097845,
            3.798880487680435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Identify the most crowded region in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    ranges = max_vals - min_vals\n    if np.any(ranges == 0):\n        ranges[ranges == 0] = 1  # Avoid division by zero\n\n    # Normalize objectives and compute crowding distances\n    normalized = (objectives - min_vals) / ranges\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(normalized[:, i])\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding[sorted_indices[j]] += (normalized[sorted_indices[j + 1], i] - normalized[sorted_indices[j - 1], i])\n\n    # Select the solution with the smallest crowding distance (most crowded region)\n    selected_idx = np.argmin(crowding)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search (swap + perturbation)\n    items = np.where(new_solution == 1)[0]\n    if len(items) < 2:\n        # If fewer than 2 items, perform random perturbation\n        for i in range(len(new_solution)):\n            if np.random.rand() < 0.1:  # 10% chance to flip\n                new_solution[i] = 1 - new_solution[i]\n                if np.sum(weight_lst * new_solution) > capacity:\n                    new_solution[i] = 1 - new_solution[i]\n    else:\n        # Perform swap between two items\n        i, j = np.random.choice(items, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        item_to_remove = np.random.choice(items_in)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive, applies a weighted random flip of items based on their marginal contributions to both objectives, and uses a simulated annealing-like acceptance criterion to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with highest total value sum)\n    _, (best_val1, best_val2) = max(archive, key=lambda x: x[1][0] + x[1][1])\n    candidates = [s for s, (v1, v2) in archive if v1 >= best_val1 * 0.9 and v2 >= best_val2 * 0.9]\n    if not candidates:\n        candidates = [s for s, _ in archive]\n    base_solution = random.choice(candidates).copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_val1 = np.sum(value1_lst[base_solution == 1])\n    current_val2 = np.sum(value2_lst[base_solution == 1])\n\n    # Generate neighbor by flipping items with probability based on marginal contribution\n    new_solution = base_solution.copy()\n    for i in range(len(base_solution)):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            flip = not base_solution[i]\n            new_weight = current_weight + (weight_lst[i] if flip else -weight_lst[i])\n            if new_weight <= capacity:\n                # Calculate marginal contribution for both objectives\n                marginal_val1 = value1_lst[i] if flip else -value1_lst[i]\n                marginal_val2 = value2_lst[i] if flip else -value2_lst[i]\n                # Accept if either objective improves or with some probability\n                if (marginal_val1 > 0 or marginal_val2 > 0) or random.random() < 0.1:\n                    new_solution[i] = flip\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3626294919749542,
            3.036162346601486
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with highest total value sum)\n    _, (best_val1, best_val2) = max(archive, key=lambda x: x[1][0] + x[1][1])\n    candidates = [s for s, (v1, v2) in archive if v1 >= best_val1 * 0.9 and v2 >= best_val2 * 0.9]\n    if not candidates:\n        candidates = [s for s, _ in archive]\n    base_solution = random.choice(candidates).copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_val1 = np.sum(value1_lst[base_solution == 1])\n    current_val2 = np.sum(value2_lst[base_solution == 1])\n\n    # Generate neighbor by flipping items with probability based on marginal contribution\n    new_solution = base_solution.copy()\n    for i in range(len(base_solution)):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            flip = not base_solution[i]\n            new_weight = current_weight + (weight_lst[i] if flip else -weight_lst[i])\n            if new_weight <= capacity:\n                # Calculate marginal contribution for both objectives\n                marginal_val1 = value1_lst[i] if flip else -value1_lst[i]\n                marginal_val2 = value2_lst[i] if flip else -value2_lst[i]\n                # Accept if either objective improves or with some probability\n                if (marginal_val1 > 0 or marginal_val2 > 0) or random.random() < 0.1:\n                    new_solution[i] = flip\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their sum of objectives (higher is better)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions and choose randomly\n        top_k = max(1, len(sorted_archive) // 5)\n        base_solution, _ = random.choice(sorted_archive[:top_k])\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swap-based and insertion-based moves\n    # Step 1: Randomly select a subset of items to modify\n    n_items = len(new_solution)\n    subset_size = min(5, n_items)\n    subset_indices = random.sample(range(n_items), subset_size)\n\n    # Step 2: For each item in the subset, decide to flip or insert based on a probability\n    for idx in subset_indices:\n        if random.random() < 0.7:  # Higher probability to flip\n            if new_solution[idx] == 1:\n                # Try to remove the item if it doesn't cause weight violation\n                if (np.sum(weight_lst[new_solution == 1]) - weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # Try to add the item if it doesn't exceed capacity\n                if (np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n        else:  # Lower probability to perform a swap with another item\n            swap_idx = random.choice([i for i in range(n_items) if i != idx])\n            # Swap only if it doesn't violate capacity\n            if (new_solution[idx] != new_solution[swap_idx]) and \\\n               (np.sum(weight_lst[new_solution == 1]) + (weight_lst[swap_idx] - weight_lst[idx]) * (new_solution[swap_idx] - new_solution[idx]) <= capacity):\n                new_solution[idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[idx]\n\n    # Step 3: Ensure feasibility (though the above steps should already handle it)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.30387846573563,
            3.178987592458725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their sum of objectives (higher is better)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions and choose randomly\n        top_k = max(1, len(sorted_archive) // 5)\n        base_solution, _ = random.choice(sorted_archive[:top_k])\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swap-based and insertion-based moves\n    # Step 1: Randomly select a subset of items to modify\n    n_items = len(new_solution)\n    subset_size = min(5, n_items)\n    subset_indices = random.sample(range(n_items), subset_size)\n\n    # Step 2: For each item in the subset, decide to flip or insert based on a probability\n    for idx in subset_indices:\n        if random.random() < 0.7:  # Higher probability to flip\n            if new_solution[idx] == 1:\n                # Try to remove the item if it doesn't cause weight violation\n                if (np.sum(weight_lst[new_solution == 1]) - weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # Try to add the item if it doesn't exceed capacity\n                if (np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n        else:  # Lower probability to perform a swap with another item\n            swap_idx = random.choice([i for i in range(n_items) if i != idx])\n            # Swap only if it doesn't violate capacity\n            if (new_solution[idx] != new_solution[swap_idx]) and \\\n               (np.sum(weight_lst[new_solution == 1]) + (weight_lst[swap_idx] - weight_lst[idx]) * (new_solution[swap_idx] - new_solution[idx]) <= capacity):\n                new_solution[idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[idx]\n\n    # Step 3: Ensure feasibility (though the above steps should already handle it)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive, applies a dynamic item-swap and flip operator, and uses adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n        candidates = [sol for sol, _ in archive]\n        base_solution = random.choice(candidates)\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply dynamic item-swap and flip operator\n    # Identify items to potentially swap or flip\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Dynamic strategy: prioritize items that can lead to significant improvement\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select a pair of items to swap\n        i, j = random.choice(included_items), random.choice(excluded_items)\n\n        # Check feasibility of swap\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        delta_weight = weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # If swap is infeasible, flip a random item to reduce weight\n            flip_candidates = included_items\n            if len(flip_candidates) > 0:\n                k = random.choice(flip_candidates)\n                new_solution[k] = 0\n    else:\n        # If no items to swap, flip a random item to explore new possibilities\n        if len(excluded_items) > 0:\n            j = random.choice(excluded_items)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    # Step 3: Adaptive neighborhood exploration\n    # Randomly flip a few items to diversify the search\n    num_flips = min(2, len(included_items) + len(excluded_items))\n    for _ in range(num_flips):\n        if random.random() < 0.5 and len(included_items) > 0:\n            k = random.choice(included_items)\n            new_solution[k] = 0\n        elif len(excluded_items) > 0:\n            j = random.choice(excluded_items)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4026399316202216,
            2.0422919392585754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n        candidates = [sol for sol, _ in archive]\n        base_solution = random.choice(candidates)\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply dynamic item-swap and flip operator\n    # Identify items to potentially swap or flip\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Dynamic strategy: prioritize items that can lead to significant improvement\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select a pair of items to swap\n        i, j = random.choice(included_items), random.choice(excluded_items)\n\n        # Check feasibility of swap\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        delta_weight = weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # If swap is infeasible, flip a random item to reduce weight\n            flip_candidates = included_items\n            if len(flip_candidates) > 0:\n                k = random.choice(flip_candidates)\n                new_solution[k] = 0\n    else:\n        # If no items to swap, flip a random item to explore new possibilities\n        if len(excluded_items) > 0:\n            j = random.choice(excluded_items)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    # Step 3: Adaptive neighborhood exploration\n    # Randomly flip a few items to diversify the search\n    num_flips = min(2, len(included_items) + len(excluded_items))\n    for _ in range(num_flips):\n        if random.random() < 0.5 and len(included_items) > 0:\n            k = random.choice(included_items)\n            new_solution[k] = 0\n        elif len(excluded_items) > 0:\n            j = random.choice(excluded_items)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive, applies a dynamic item-swap and flip operator, and uses adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n        candidates = [sol for sol, _ in archive]\n        base_solution = random.choice(candidates)\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply dynamic item-swap and flip operator\n    # Identify items to potentially swap or flip\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Dynamic strategy: prioritize items that can lead to significant improvement\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select a pair of items to swap\n        i, j = random.choice(included_items), random.choice(excluded_items)\n\n        # Check feasibility of swap\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        delta_weight = weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # If swap is infeasible, flip a random item to reduce weight\n            flip_candidates = included_items\n            if len(flip_candidates) > 0:\n                k = random.choice(flip_candidates)\n                new_solution[k] = 0\n    else:\n        # If no items to swap, flip a random item to explore new possibilities\n        if len(excluded_items) > 0:\n            j = random.choice(excluded_items)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    # Step 3: Adaptive neighborhood exploration\n    # Randomly flip a few items to diversify the search\n    num_flips = min(2, len(included_items) + len(excluded_items))\n    for _ in range(num_flips):\n        if random.random() < 0.5 and len(included_items) > 0:\n            k = random.choice(included_items)\n            new_solution[k] = 0\n        elif len(excluded_items) > 0:\n            j = random.choice(excluded_items)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4026399316202216,
            2.0422919392585754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n        candidates = [sol for sol, _ in archive]\n        base_solution = random.choice(candidates)\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply dynamic item-swap and flip operator\n    # Identify items to potentially swap or flip\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Dynamic strategy: prioritize items that can lead to significant improvement\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select a pair of items to swap\n        i, j = random.choice(included_items), random.choice(excluded_items)\n\n        # Check feasibility of swap\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        delta_weight = weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # If swap is infeasible, flip a random item to reduce weight\n            flip_candidates = included_items\n            if len(flip_candidates) > 0:\n                k = random.choice(flip_candidates)\n                new_solution[k] = 0\n    else:\n        # If no items to swap, flip a random item to explore new possibilities\n        if len(excluded_items) > 0:\n            j = random.choice(excluded_items)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    # Step 3: Adaptive neighborhood exploration\n    # Randomly flip a few items to diversify the search\n    num_flips = min(2, len(included_items) + len(excluded_items))\n    for _ in range(num_flips):\n        if random.random() < 0.5 and len(included_items) > 0:\n            k = random.choice(included_items)\n            new_solution[k] = 0\n        elif len(excluded_items) > 0:\n            j = random.choice(excluded_items)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with high objective values and low crowding distance\n        objectives = np.array([obj for (sol, obj) in archive])\n        values = objectives[:, 0] + objectives[:, 1]\n        norm_values = (values - np.min(values)) / (np.max(values) - np.min(values) + 1e-8)\n        crowding = np.zeros(len(archive))\n        for i in range(2):\n            sorted_indices = np.argsort(objectives[:, i])\n            crowding[sorted_indices[0]] = np.inf\n            crowding[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive) - 1):\n                crowding[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-8)\n        fitness = norm_values + crowding\n        selected_idx = np.random.choice(np.argsort(fitness)[-3:])  # Select from top 3\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: value-based flip with weight-aware perturbation\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    if total_weight > capacity:\n        # If solution is infeasible, remove items until feasible\n        items_in = np.where(base_solution == 1)[0]\n        np.random.shuffle(items_in)\n        for item in items_in:\n            if total_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                total_weight -= weight_lst[item]\n    else:\n        # Flip items based on value density and objective correlation\n        items_out = np.where(base_solution == 0)[0]\n        items_in = np.where(base_solution == 1)[0]\n        value1_density = value1_lst / (weight_lst + 1e-8)\n        value2_density = value2_lst / (weight_lst + 1e-8)\n\n        # Calculate objective correlation\n        in_value1 = np.sum(value1_lst[base_solution == 1])\n        in_value2 = np.sum(value2_lst[base_solution == 1])\n        corr = np.corrcoef(value1_lst, value2_lst)[0, 1]\n\n        # Flip strategy: prioritize items that improve both objectives\n        flip_candidates = []\n        for item in items_out:\n            if total_weight + weight_lst[item] <= capacity:\n                v1_gain = value1_lst[item]\n                v2_gain = value2_lst[item]\n                # Weighted score based on correlation and density\n                score = corr * (v1_gain * value1_density[item] + v2_gain * value2_density[item]) + (1 - corr) * (v1_gain + v2_gain)\n                flip_candidates.append((score, item))\n\n        for item in items_in:\n            if total_weight - weight_lst[item] <= capacity:\n                v1_loss = value1_lst[item]\n                v2_loss = value2_lst[item]\n                # Weighted score based on correlation and density\n                score = -corr * (v1_loss * value1_density[item] + v2_loss * value2_density[item]) - (1 - corr) * (v1_loss + v2_loss)\n                flip_candidates.append((score, item))\n\n        if flip_candidates:\n            flip_candidates.sort(reverse=True, key=lambda x: x[0])\n            best_score, best_item = flip_candidates[0]\n            new_solution[best_item] = 1 - new_solution[best_item]\n\n    return new_solution\n\n",
        "score": [
            -0.8816526040202307,
            9.228790432214737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with high objective values and low crowding distance\n        objectives = np.array([obj for (sol, obj) in archive])\n        values = objectives[:, 0] + objectives[:, 1]\n        norm_values = (values - np.min(values)) / (np.max(values) - np.min(values) + 1e-8)\n        crowding = np.zeros(len(archive))\n        for i in range(2):\n            sorted_indices = np.argsort(objectives[:, i])\n            crowding[sorted_indices[0]] = np.inf\n            crowding[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive) - 1):\n                crowding[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-8)\n        fitness = norm_values + crowding\n        selected_idx = np.random.choice(np.argsort(fitness)[-3:])  # Select from top 3\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: value-based flip with weight-aware perturbation\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    if total_weight > capacity:\n        # If solution is infeasible, remove items until feasible\n        items_in = np.where(base_solution == 1)[0]\n        np.random.shuffle(items_in)\n        for item in items_in:\n            if total_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                total_weight -= weight_lst[item]\n    else:\n        # Flip items based on value density and objective correlation\n        items_out = np.where(base_solution == 0)[0]\n        items_in = np.where(base_solution == 1)[0]\n        value1_density = value1_lst / (weight_lst + 1e-8)\n        value2_density = value2_lst / (weight_lst + 1e-8)\n\n        # Calculate objective correlation\n        in_value1 = np.sum(value1_lst[base_solution == 1])\n        in_value2 = np.sum(value2_lst[base_solution == 1])\n        corr = np.corrcoef(value1_lst, value2_lst)[0, 1]\n\n        # Flip strategy: prioritize items that improve both objectives\n        flip_candidates = []\n        for item in items_out:\n            if total_weight + weight_lst[item] <= capacity:\n                v1_gain = value1_lst[item]\n                v2_gain = value2_lst[item]\n                # Weighted score based on correlation and density\n                score = corr * (v1_gain * value1_density[item] + v2_gain * value2_density[item]) + (1 - corr) * (v1_gain + v2_gain)\n                flip_candidates.append((score, item))\n\n        for item in items_in:\n            if total_weight - weight_lst[item] <= capacity:\n                v1_loss = value1_lst[item]\n                v2_loss = value2_lst[item]\n                # Weighted score based on correlation and density\n                score = -corr * (v1_loss * value1_density[item] + v2_loss * value2_density[item]) - (1 - corr) * (v1_loss + v2_loss)\n                flip_candidates.append((score, item))\n\n        if flip_candidates:\n            flip_candidates.sort(reverse=True, key=lambda x: x[0])\n            best_score, best_item = flip_candidates[0]\n            new_solution[best_item] = 1 - new_solution[best_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high marginal gains in either objective, then applies a hybrid local search that combines item swaps and adaptive flips to explore the solution space while ensuring feasibility through dynamic weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution based on marginal gains\n    base_solution, base_obj = max(archive, key=lambda x: max(x[1][0], x[1][1]))\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swaps and adaptive flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # First, try to swap two items\n    if n_items >= 2:\n        idx1, idx2 = np.random.choice(n_items, 2, replace=False)\n        if new_solution[idx1] != new_solution[idx2]:\n            delta_weight = weight_lst[idx2] - weight_lst[idx1]\n            if current_weight + delta_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                return new_solution\n\n    # If swap didn't work, try adaptive flips\n    for _ in range(min(5, n_items)):\n        idx = np.random.randint(0, n_items)\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3930532305334172,
            5.942574769258499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution based on marginal gains\n    base_solution, base_obj = max(archive, key=lambda x: max(x[1][0], x[1][1]))\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swaps and adaptive flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # First, try to swap two items\n    if n_items >= 2:\n        idx1, idx2 = np.random.choice(n_items, 2, replace=False)\n        if new_solution[idx1] != new_solution[idx2]:\n            delta_weight = weight_lst[idx2] - weight_lst[idx1]\n            if current_weight + delta_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                return new_solution\n\n    # If swap didn't work, try adaptive flips\n    for _ in range(min(5, n_items)):\n        idx = np.random.randint(0, n_items)\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a hybrid of objective diversity and potential improvement, then applies a novel local search operator that combines item swaps with probabilistic bit flips to explore high-potential neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (diverse or under-explored)\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: probabilistic bit flips with item swaps\n    for _ in range(2):  # Perform 2 swaps\n        # Find items to swap (prioritize items with high value ratios)\n        value_ratio = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(-value_ratio)\n\n        # Select two items to swap (one in, one out)\n        in_items = np.where(base_solution == 0)[0]\n        out_items = np.where(base_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select high-value items to include and low-value items to exclude\n            candidate_in = in_items[np.argmax(value_ratio[in_items])]\n            candidate_out = out_items[np.argmin(value_ratio[out_items])]\n\n            # Check feasibility of swap\n            if (np.sum(weight_lst[base_solution == 1]) - weight_lst[candidate_out] + weight_lst[candidate_in]) <= capacity:\n                new_solution[candidate_out] = 0\n                new_solution[candidate_in] = 1\n\n    # Apply probabilistic bit flips to explore neighborhood\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip each bit\n            if new_solution[i] == 1:\n                if (np.sum(weight_lst[new_solution == 1]) - weight_lst[i]) <= capacity:\n                    new_solution[i] = 0\n            else:\n                if (np.sum(weight_lst[new_solution == 1]) + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.32452181093515436,
            6.3593597412109375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (diverse or under-explored)\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: probabilistic bit flips with item swaps\n    for _ in range(2):  # Perform 2 swaps\n        # Find items to swap (prioritize items with high value ratios)\n        value_ratio = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(-value_ratio)\n\n        # Select two items to swap (one in, one out)\n        in_items = np.where(base_solution == 0)[0]\n        out_items = np.where(base_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select high-value items to include and low-value items to exclude\n            candidate_in = in_items[np.argmax(value_ratio[in_items])]\n            candidate_out = out_items[np.argmin(value_ratio[out_items])]\n\n            # Check feasibility of swap\n            if (np.sum(weight_lst[base_solution == 1]) - weight_lst[candidate_out] + weight_lst[candidate_in]) <= capacity:\n                new_solution[candidate_out] = 0\n                new_solution[candidate_in] = 1\n\n    # Apply probabilistic bit flips to explore neighborhood\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip each bit\n            if new_solution[i] == 1:\n                if (np.sum(weight_lst[new_solution == 1]) - weight_lst[i]) <= capacity:\n                    new_solution[i] = 0\n            else:\n                if (np.sum(weight_lst[new_solution == 1]) + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify items that can be toggled (either added if feasible or removed)\n    total_weight = sum(weight_lst[selected_solution == 1])\n    available_weight = capacity - total_weight\n\n    # Find items that can be added (if they fit within available weight)\n    candidates = np.where((selected_solution == 0) & (weight_lst <= available_weight))[0]\n\n    # Find items that can be removed (if there are any)\n    removable = np.where(selected_solution == 1)[0]\n\n    # Toggle a random item (either add or remove)\n    if len(candidates) > 0 and len(removable) > 0:\n        if np.random.rand() < 0.5:\n            # Add a random feasible item\n            item_to_add = np.random.choice(candidates)\n            new_solution[item_to_add] = 1\n        else:\n            # Remove a random item\n            item_to_remove = np.random.choice(removable)\n            new_solution[item_to_remove] = 0\n    elif len(candidates) > 0:\n        # Only add items\n        item_to_add = np.random.choice(candidates)\n        new_solution[item_to_add] = 1\n    elif len(removable) > 0:\n        # Only remove items\n        item_to_remove = np.random.choice(removable)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7710769152848158,
            7.030646175146103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify items that can be toggled (either added if feasible or removed)\n    total_weight = sum(weight_lst[selected_solution == 1])\n    available_weight = capacity - total_weight\n\n    # Find items that can be added (if they fit within available weight)\n    candidates = np.where((selected_solution == 0) & (weight_lst <= available_weight))[0]\n\n    # Find items that can be removed (if there are any)\n    removable = np.where(selected_solution == 1)[0]\n\n    # Toggle a random item (either add or remove)\n    if len(candidates) > 0 and len(removable) > 0:\n        if np.random.rand() < 0.5:\n            # Add a random feasible item\n            item_to_add = np.random.choice(candidates)\n            new_solution[item_to_add] = 1\n        else:\n            # Remove a random item\n            item_to_remove = np.random.choice(removable)\n            new_solution[item_to_remove] = 0\n    elif len(candidates) > 0:\n        # Only add items\n        item_to_add = np.random.choice(candidates)\n        new_solution[item_to_add] = 1\n    elif len(removable) > 0:\n        # Only remove items\n        item_to_remove = np.random.choice(removable)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, applies a dynamic neighborhood exploration strategy combining item swaps and multi-objective-aware perturbations to generate high-quality feasible neighbors, while ensuring the solution remains non-dominated and weight-constrained.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and multi-objective perturbations\n    # Step 1: Randomly select a subset of items to flip\n    num_items = len(base_solution)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items\n\n    # Step 2: For each selected item, decide to flip based on potential improvement\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Step 3: Multi-objective-aware perturbation\n    # Randomly select a direction (value1 or value2) to prioritize\n    if random.random() < 0.5:\n        # Prioritize value1 improvement\n        candidate_items = np.where(base_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Add the item with highest value1 per weight ratio\n            ratios = value1_lst[candidate_items] / weight_lst[candidate_items]\n            best_item = candidate_items[np.argmax(ratios)]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n    else:\n        # Prioritize value2 improvement\n        candidate_items = np.where(base_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Add the item with highest value2 per weight ratio\n            ratios = value2_lst[candidate_items] / weight_lst[candidate_items]\n            best_item = candidate_items[np.argmax(ratios)]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.39973920112462025,
            2.0197793841362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and multi-objective perturbations\n    # Step 1: Randomly select a subset of items to flip\n    num_items = len(base_solution)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items\n\n    # Step 2: For each selected item, decide to flip based on potential improvement\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Step 3: Multi-objective-aware perturbation\n    # Randomly select a direction (value1 or value2) to prioritize\n    if random.random() < 0.5:\n        # Prioritize value1 improvement\n        candidate_items = np.where(base_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Add the item with highest value1 per weight ratio\n            ratios = value1_lst[candidate_items] / weight_lst[candidate_items]\n            best_item = candidate_items[np.argmax(ratios)]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n    else:\n        # Prioritize value2 improvement\n        candidate_items = np.where(base_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Add the item with highest value2 per weight ratio\n            ratios = value2_lst[candidate_items] / weight_lst[candidate_items]\n            best_item = candidate_items[np.argmax(ratios)]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, applies a dynamic neighborhood exploration strategy combining item swaps and multi-objective-aware perturbations to generate high-quality feasible neighbors, while ensuring the solution remains non-dominated and weight-constrained.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and multi-objective perturbations\n    # Step 1: Randomly select a subset of items to flip\n    num_items = len(base_solution)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items\n\n    # Step 2: For each selected item, decide to flip based on potential improvement\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Step 3: Multi-objective-aware perturbation\n    # Randomly select a direction (value1 or value2) to prioritize\n    if random.random() < 0.5:\n        # Prioritize value1 improvement\n        candidate_items = np.where(base_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Add the item with highest value1 per weight ratio\n            ratios = value1_lst[candidate_items] / weight_lst[candidate_items]\n            best_item = candidate_items[np.argmax(ratios)]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n    else:\n        # Prioritize value2 improvement\n        candidate_items = np.where(base_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Add the item with highest value2 per weight ratio\n            ratios = value2_lst[candidate_items] / weight_lst[candidate_items]\n            best_item = candidate_items[np.argmax(ratios)]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.39973920112462025,
            2.0197793841362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and multi-objective perturbations\n    # Step 1: Randomly select a subset of items to flip\n    num_items = len(base_solution)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items\n\n    # Step 2: For each selected item, decide to flip based on potential improvement\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Step 3: Multi-objective-aware perturbation\n    # Randomly select a direction (value1 or value2) to prioritize\n    if random.random() < 0.5:\n        # Prioritize value1 improvement\n        candidate_items = np.where(base_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Add the item with highest value1 per weight ratio\n            ratios = value1_lst[candidate_items] / weight_lst[candidate_items]\n            best_item = candidate_items[np.argmax(ratios)]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n    else:\n        # Prioritize value2 improvement\n        candidate_items = np.where(base_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Add the item with highest value2 per weight ratio\n            ratios = value2_lst[candidate_items] / weight_lst[candidate_items]\n            best_item = candidate_items[np.argmax(ratios)]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values, then applies a hybrid local search that combines item swapping and intensity-based perturbation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 or all if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine swapping and intensity-based perturbation\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Intensity-based perturbation (flip items with high marginal value)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n    top_items = np.argsort(-combined_marginal)[:max(1, len(weight_lst) // 10)]\n\n    for item in top_items:\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 2: Swap-based local search (try to swap items to improve both objectives)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Randomly select items to swap\n        swap_in = random.choice(in_items)\n        swap_out = random.choice(out_items)\n\n        if (current_weight - weight_lst[swap_in] + weight_lst[swap_out]) <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n            current_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n    return new_solution\n\n",
        "score": [
            -0.8632258656058571,
            3.678236186504364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 or all if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine swapping and intensity-based perturbation\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Intensity-based perturbation (flip items with high marginal value)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n    top_items = np.argsort(-combined_marginal)[:max(1, len(weight_lst) // 10)]\n\n    for item in top_items:\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 2: Swap-based local search (try to swap items to improve both objectives)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Randomly select items to swap\n        swap_in = random.choice(in_items)\n        swap_out = random.choice(out_items)\n\n        if (current_weight - weight_lst[swap_in] + weight_lst[swap_out]) <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n            current_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{The heuristic function first identifies promising solutions in the archive by evaluating their potential for improvement via a novel \"multi-objective swap and shift\" operator, which intelligently selects and swaps items based on their marginal contributions to both objectives while ensuring feasibility, then returns the highest-quality neighbor solution generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (here, randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be swapped or shifted\n    zero_indices = np.where(base_solution == 0)[0]\n    one_indices = np.where(base_solution == 1)[0]\n\n    # Try to swap one item from the knapsack with one not in it\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        swap_out_idx = random.choice(one_indices)\n        swap_in_idx = random.choice(zero_indices)\n        new_weight = current_weight - weight_lst[swap_out_idx] + weight_lst[swap_in_idx]\n\n        if new_weight <= capacity:\n            new_solution[swap_out_idx] = 0\n            new_solution[swap_in_idx] = 1\n            return new_solution\n\n    # If swap is not possible, try to shift items by moving one item out\n    if len(one_indices) > 1:\n        shift_out_idx = random.choice(one_indices)\n        new_weight = current_weight - weight_lst[shift_out_idx]\n\n        if new_weight <= capacity:\n            new_solution[shift_out_idx] = 0\n            return new_solution\n\n    # If no improvement found, return the base solution\n    return new_solution\n\n",
        "score": [
            -0.5601415356967703,
            3.2566865980625153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (here, randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be swapped or shifted\n    zero_indices = np.where(base_solution == 0)[0]\n    one_indices = np.where(base_solution == 1)[0]\n\n    # Try to swap one item from the knapsack with one not in it\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        swap_out_idx = random.choice(one_indices)\n        swap_in_idx = random.choice(zero_indices)\n        new_weight = current_weight - weight_lst[swap_out_idx] + weight_lst[swap_in_idx]\n\n        if new_weight <= capacity:\n            new_solution[swap_out_idx] = 0\n            new_solution[swap_in_idx] = 1\n            return new_solution\n\n    # If swap is not possible, try to shift items by moving one item out\n    if len(one_indices) > 1:\n        shift_out_idx = random.choice(one_indices)\n        new_weight = current_weight - weight_lst[shift_out_idx]\n\n        if new_weight <= capacity:\n            new_solution[shift_out_idx] = 0\n            return new_solution\n\n    # If no improvement found, return the base solution\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{A novel hybrid local search algorithm that intelligently balances exploration and exploitation by dynamically combining item swaps, random flips, and objective-aware perturbations to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (sum of normalized values)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        combined_scores = np.sum(normalized_obj, axis=1)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search strategy\n    action = random.choice(['swap', 'flip', 'perturb'])\n\n    if action == 'swap':\n        # Swap two items: one in the knapsack and one out\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            i = random.choice(in_items)\n            j = random.choice(out_items)\n\n            # Check if swapping makes it feasible\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif action == 'flip':\n        # Flip a random item (with probability biased towards improving objectives)\n        items = np.arange(len(base_solution))\n        np.random.shuffle(items)\n\n        for item in items:\n            if base_solution[item] == 1:\n                # Check if removing would make it feasible\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    break\n            else:\n                # Check if adding would make it feasible\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    elif action == 'perturb':\n        # Perturb by flipping k items (k is small, e.g., 2-3)\n        k = random.randint(2, 3)\n        items = np.arange(len(base_solution))\n        np.random.shuffle(items)\n\n        for item in items[:k]:\n            if base_solution[item] == 1:\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.2787073985461721,
            8.41334855556488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (sum of normalized values)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        combined_scores = np.sum(normalized_obj, axis=1)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search strategy\n    action = random.choice(['swap', 'flip', 'perturb'])\n\n    if action == 'swap':\n        # Swap two items: one in the knapsack and one out\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            i = random.choice(in_items)\n            j = random.choice(out_items)\n\n            # Check if swapping makes it feasible\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif action == 'flip':\n        # Flip a random item (with probability biased towards improving objectives)\n        items = np.arange(len(base_solution))\n        np.random.shuffle(items)\n\n        for item in items:\n            if base_solution[item] == 1:\n                # Check if removing would make it feasible\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    break\n            else:\n                # Check if adding would make it feasible\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    elif action == 'perturb':\n        # Perturb by flipping k items (k is small, e.g., 2-3)\n        k = random.randint(2, 3)\n        items = np.arange(len(base_solution))\n        np.random.shuffle(items)\n\n        for item in items[:k]:\n            if base_solution[item] == 1:\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_solutions = []\n    for sol, obj in archive:\n        # Check if the solution has at least one item not included (for addition) or one item included (for removal)\n        if np.sum(sol) < len(sol) or np.sum(sol) > 0:\n            potential_solutions.append((sol, obj))\n\n    if not potential_solutions:\n        return archive[0][0].copy()  # Return a copy of the first solution if no potential solutions\n\n    # Step 2: Select a solution with high potential for improvement (e.g., high objective values)\n    selected_sol, _ = max(potential_solutions, key=lambda x: sum(x[1]))\n\n    # Step 3: Generate a neighbor by flipping a subset of items intelligently\n    new_solution = selected_sol.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be added (not in solution and within capacity)\n    addable_items = np.where((new_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n\n    # Identify items that can be removed (in solution)\n    removable_items = np.where(new_solution == 1)[0]\n\n    # Randomly select a subset of items to flip (add or remove)\n    if len(addable_items) > 0 and len(removable_items) > 0:\n        # Flip a random item from addable and removable\n        flip_add = np.random.choice(addable_items)\n        flip_remove = np.random.choice(removable_items)\n        new_solution[flip_add] = 1\n        new_solution[flip_remove] = 0\n    elif len(addable_items) > 0:\n        # Only add items if possible\n        flip_add = np.random.choice(addable_items)\n        new_solution[flip_add] = 1\n    elif len(removable_items) > 0:\n        # Only remove items if possible\n        flip_remove = np.random.choice(removable_items)\n        new_solution[flip_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.749868176003154,
            5.680580258369446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_solutions = []\n    for sol, obj in archive:\n        # Check if the solution has at least one item not included (for addition) or one item included (for removal)\n        if np.sum(sol) < len(sol) or np.sum(sol) > 0:\n            potential_solutions.append((sol, obj))\n\n    if not potential_solutions:\n        return archive[0][0].copy()  # Return a copy of the first solution if no potential solutions\n\n    # Step 2: Select a solution with high potential for improvement (e.g., high objective values)\n    selected_sol, _ = max(potential_solutions, key=lambda x: sum(x[1]))\n\n    # Step 3: Generate a neighbor by flipping a subset of items intelligently\n    new_solution = selected_sol.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be added (not in solution and within capacity)\n    addable_items = np.where((new_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n\n    # Identify items that can be removed (in solution)\n    removable_items = np.where(new_solution == 1)[0]\n\n    # Randomly select a subset of items to flip (add or remove)\n    if len(addable_items) > 0 and len(removable_items) > 0:\n        # Flip a random item from addable and removable\n        flip_add = np.random.choice(addable_items)\n        flip_remove = np.random.choice(removable_items)\n        new_solution[flip_add] = 1\n        new_solution[flip_remove] = 0\n    elif len(addable_items) > 0:\n        # Only add items if possible\n        flip_add = np.random.choice(addable_items)\n        new_solution[flip_add] = 1\n    elif len(removable_items) > 0:\n        # Only remove items if possible\n        flip_remove = np.random.choice(removable_items)\n        new_solution[flip_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive, identifies high-impact items via a hybrid local search combining greedy improvement and random perturbation, then flips selected items while ensuring feasibility, ensuring diverse and high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential improvement metrics (e.g., marginal gains)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy improvement with random perturbation\n    # Step 1: Identify high-impact items to flip (greedy)\n    potential_flips = []\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                # Calculate potential improvement (normalized)\n                marginal_v1 = value1_lst[i]\n                marginal_v2 = value2_lst[i]\n                potential_flips.append((i, marginal_v1, marginal_v2, 'remove'))\n        else:\n            # Consider adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                # Calculate potential improvement (normalized)\n                marginal_v1 = value1_lst[i]\n                marginal_v2 = value2_lst[i]\n                potential_flips.append((i, marginal_v1, marginal_v2, 'add'))\n\n    # Step 2: Select top-k candidates (k=3) for flipping\n    if potential_flips:\n        # Sort by combined marginal gain (weighted sum)\n        potential_flips.sort(key=lambda x: x[1] + x[2], reverse=True)\n        top_candidates = potential_flips[:min(3, len(potential_flips))]\n\n        # Randomly select one candidate with probability proportional to its rank\n        selected_candidate = random.choices(\n            top_candidates,\n            weights=[1/(i+1) for i in range(len(top_candidates))],\n            k=1\n        )[0]\n\n        item_idx, _, _, action = selected_candidate\n        if action == 'remove':\n            new_solution[item_idx] = 0\n        else:\n            new_solution[item_idx] = 1\n\n    # Step 3: Random perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance\n        # Flip a random item (ensuring feasibility)\n        candidate_items = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n                candidate_items.append((i, 'remove'))\n            elif new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                candidate_items.append((i, 'add'))\n\n        if candidate_items:\n            item_idx, action = random.choice(candidate_items)\n            if action == 'remove':\n                new_solution[item_idx] = 0\n            else:\n                new_solution[item_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8959074827052844,
            4.360500812530518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential improvement metrics (e.g., marginal gains)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy improvement with random perturbation\n    # Step 1: Identify high-impact items to flip (greedy)\n    potential_flips = []\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                # Calculate potential improvement (normalized)\n                marginal_v1 = value1_lst[i]\n                marginal_v2 = value2_lst[i]\n                potential_flips.append((i, marginal_v1, marginal_v2, 'remove'))\n        else:\n            # Consider adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                # Calculate potential improvement (normalized)\n                marginal_v1 = value1_lst[i]\n                marginal_v2 = value2_lst[i]\n                potential_flips.append((i, marginal_v1, marginal_v2, 'add'))\n\n    # Step 2: Select top-k candidates (k=3) for flipping\n    if potential_flips:\n        # Sort by combined marginal gain (weighted sum)\n        potential_flips.sort(key=lambda x: x[1] + x[2], reverse=True)\n        top_candidates = potential_flips[:min(3, len(potential_flips))]\n\n        # Randomly select one candidate with probability proportional to its rank\n        selected_candidate = random.choices(\n            top_candidates,\n            weights=[1/(i+1) for i in range(len(top_candidates))],\n            k=1\n        )[0]\n\n        item_idx, _, _, action = selected_candidate\n        if action == 'remove':\n            new_solution[item_idx] = 0\n        else:\n            new_solution[item_idx] = 1\n\n    # Step 3: Random perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance\n        # Flip a random item (ensuring feasibility)\n        candidate_items = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n                candidate_items.append((i, 'remove'))\n            elif new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                candidate_items.append((i, 'add'))\n\n        if candidate_items:\n            item_idx, action = random.choice(candidate_items)\n            if action == 'remove':\n                new_solution[item_idx] = 0\n            else:\n                new_solution[item_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a random subset of items, ensuring feasibility\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # If no feasible flip, try a single random flip\n    if np.array_equal(new_solution, base_solution):\n        i = np.random.randint(0, n_items)\n        if new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n        elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3140029850058498,
            3.8182972073554993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a random subset of items, ensuring feasibility\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # If no feasible flip, try a single random flip\n    if np.array_equal(new_solution, base_solution):\n        i = np.random.randint(0, n_items)\n        if new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n        elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search that combines greedy improvement with a novel \"objective-aware\" flip strategy to explore high-potential neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (high objective values and low dominance)\n    # Calculate dominance counts (simplified approximation)\n    dominance = np.zeros(len(archive))\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominance[i] += 1\n\n    # Select solution with highest objective sum and lowest dominance\n    scores = np.array([(obj[0] + obj[1]) / (1 + dom) for (_, obj), dom in zip(archive, dominance)])\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate neighbor via hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Objective-aware flip strategy\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                delta_value1 = -value1_lst[i]\n                delta_value2 = -value2_lst[i]\n                candidates.append((i, delta_value1, delta_value2, -1))\n        else:\n            # Consider adding item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                delta_value1 = value1_lst[i]\n                delta_value2 = value2_lst[i]\n                candidates.append((i, delta_value1, delta_value2, 1))\n\n    if not candidates:\n        return base_solution\n\n    # Evaluate candidates using a weighted sum of objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random weight for objective 1\n    beta = 1 - alpha  # Weight for objective 2\n    scores = np.array([alpha * dv1 + beta * dv2 for (_, dv1, dv2, _) in candidates])\n    best_candidate = candidates[np.argmax(scores)]\n\n    # Apply the best flip\n    idx, _, _, flip = best_candidate\n    new_solution[idx] = flip\n\n    return new_solution\n\n",
        "score": [
            -0.719457308055452,
            8.754313915967941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (high objective values and low dominance)\n    # Calculate dominance counts (simplified approximation)\n    dominance = np.zeros(len(archive))\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominance[i] += 1\n\n    # Select solution with highest objective sum and lowest dominance\n    scores = np.array([(obj[0] + obj[1]) / (1 + dom) for (_, obj), dom in zip(archive, dominance)])\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate neighbor via hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Objective-aware flip strategy\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                delta_value1 = -value1_lst[i]\n                delta_value2 = -value2_lst[i]\n                candidates.append((i, delta_value1, delta_value2, -1))\n        else:\n            # Consider adding item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                delta_value1 = value1_lst[i]\n                delta_value2 = value2_lst[i]\n                candidates.append((i, delta_value1, delta_value2, 1))\n\n    if not candidates:\n        return base_solution\n\n    # Evaluate candidates using a weighted sum of objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random weight for objective 1\n    beta = 1 - alpha  # Weight for objective 2\n    scores = np.array([alpha * dv1 + beta * dv2 for (_, dv1, dv2, _) in candidates])\n    best_candidate = candidates[np.argmax(scores)]\n\n    # Apply the best flip\n    idx, _, _, flip = best_candidate\n    new_solution[idx] = flip\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst))\n        normalized_objectives.append(np.sum(norm_obj))\n    best_idx = np.argmax(normalized_objectives)\n    base_solution = archive[best_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Strategy 1: Randomly flip a subset of items to explore new regions\n    flip_indices = np.random.choice(len(new_solution), size=np.random.randint(1, len(new_solution)//2), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess_weight = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for item in excess_items:\n            if excess_weight <= 0:\n                break\n            new_solution[item] = 0\n            excess_weight -= weight_lst[item]\n\n    # Strategy 2: If no flip, try adding a new item if possible\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            candidate_weights = weight_lst[candidate_items]\n            feasible_candidates = candidate_items[candidate_weights <= capacity - np.sum(weight_lst[new_solution == 1])]\n            if len(feasible_candidates) > 0:\n                new_item = np.random.choice(feasible_candidates)\n                new_solution[new_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3381909178109338,
            5.480597078800201
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst))\n        normalized_objectives.append(np.sum(norm_obj))\n    best_idx = np.argmax(normalized_objectives)\n    base_solution = archive[best_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Strategy 1: Randomly flip a subset of items to explore new regions\n    flip_indices = np.random.choice(len(new_solution), size=np.random.randint(1, len(new_solution)//2), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess_weight = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for item in excess_items:\n            if excess_weight <= 0:\n                break\n            new_solution[item] = 0\n            excess_weight -= weight_lst[item]\n\n    # Strategy 2: If no flip, try adding a new item if possible\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            candidate_weights = weight_lst[candidate_items]\n            feasible_candidates = candidate_items[candidate_weights <= capacity - np.sum(weight_lst[new_solution == 1])]\n            if len(feasible_candidates) > 0:\n                new_item = np.random.choice(feasible_candidates)\n                new_solution[new_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{The heuristic selects a promising solution from the archive based on its dominance and potential for improvement, then applies a novel hybrid local search combining item swaps and adaptive perturbation to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with high objective values or potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swaps and perturbation\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_v1 = base_v1\n    current_v2 = base_v2\n\n    # Step 1: Adaptive item swaps (prioritize high-value items)\n    for _ in range(min(5, n_items // 2)):\n        # Select a random item to swap\n        item_to_swap = random.randint(0, n_items - 1)\n        if new_solution[item_to_swap] == 1:\n            # Try removing it\n            new_weight = current_weight - weight_lst[item_to_swap]\n            if new_weight <= capacity:\n                new_solution[item_to_swap] = 0\n                current_weight = new_weight\n                current_v1 -= value1_lst[item_to_swap]\n                current_v2 -= value2_lst[item_to_swap]\n        else:\n            # Try adding it\n            new_weight = current_weight + weight_lst[item_to_swap]\n            if new_weight <= capacity:\n                new_solution[item_to_swap] = 1\n                current_weight = new_weight\n                current_v1 += value1_lst[item_to_swap]\n                current_v2 += value2_lst[item_to_swap]\n\n    # Step 2: Adaptive perturbation (flip high-impact items)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        # Calculate marginal gains for each item\n        marginal_gains = np.zeros(n_items)\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                marginal_gains[i] = -weight_lst[i] / (value1_lst[i] + value2_lst[i] + 1e-6)\n            else:\n                marginal_gains[i] = weight_lst[i] / (value1_lst[i] + value2_lst[i] + 1e-6)\n\n        # Select top-k items to flip (k is adaptive based on problem size)\n        k = max(1, n_items // 10)\n        top_items = np.argsort(marginal_gains)[:k]\n\n        for i in top_items:\n            if new_solution[i] == 1:\n                # Try removing it\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                # Try adding it\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4141338864764974,
            3.620647668838501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with high objective values or potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swaps and perturbation\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_v1 = base_v1\n    current_v2 = base_v2\n\n    # Step 1: Adaptive item swaps (prioritize high-value items)\n    for _ in range(min(5, n_items // 2)):\n        # Select a random item to swap\n        item_to_swap = random.randint(0, n_items - 1)\n        if new_solution[item_to_swap] == 1:\n            # Try removing it\n            new_weight = current_weight - weight_lst[item_to_swap]\n            if new_weight <= capacity:\n                new_solution[item_to_swap] = 0\n                current_weight = new_weight\n                current_v1 -= value1_lst[item_to_swap]\n                current_v2 -= value2_lst[item_to_swap]\n        else:\n            # Try adding it\n            new_weight = current_weight + weight_lst[item_to_swap]\n            if new_weight <= capacity:\n                new_solution[item_to_swap] = 1\n                current_weight = new_weight\n                current_v1 += value1_lst[item_to_swap]\n                current_v2 += value2_lst[item_to_swap]\n\n    # Step 2: Adaptive perturbation (flip high-impact items)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        # Calculate marginal gains for each item\n        marginal_gains = np.zeros(n_items)\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                marginal_gains[i] = -weight_lst[i] / (value1_lst[i] + value2_lst[i] + 1e-6)\n            else:\n                marginal_gains[i] = weight_lst[i] / (value1_lst[i] + value2_lst[i] + 1e-6)\n\n        # Select top-k items to flip (k is adaptive based on problem size)\n        k = max(1, n_items // 10)\n        top_items = np.argsort(marginal_gains)[:k]\n\n        for i in top_items:\n            if new_solution[i] == 1:\n                # Try removing it\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                # Try adding it\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on its dominance and potential for improvement, then applies a hybrid local search operator that combines item swapping, insertion, and removal to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Step 2: Identify items to consider for modification\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Step 3: Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Option 1: Swap two items (included with excluded)\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        swap_in = random.choice(included_items)\n        swap_out = random.choice(excluded_items)\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[swap_in] + weight_lst[swap_out]\n        if total_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n            return new_solution\n\n    # Option 2: Insert a new item if possible\n    if len(excluded_items) > 0:\n        insert_item = random.choice(excluded_items)\n        total_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[insert_item]\n        if total_weight <= capacity:\n            new_solution[insert_item] = 1\n            return new_solution\n\n    # Option 3: Remove an item if it's not the only one\n    if len(included_items) > 1:\n        remove_item = random.choice(included_items)\n        new_solution[remove_item] = 0\n        return new_solution\n\n    # If no better move found, return the original solution\n    return base_solution\n\n",
        "score": [
            -0.31913954350412177,
            2.3071832954883575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Step 2: Identify items to consider for modification\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Step 3: Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Option 1: Swap two items (included with excluded)\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        swap_in = random.choice(included_items)\n        swap_out = random.choice(excluded_items)\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[swap_in] + weight_lst[swap_out]\n        if total_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n            return new_solution\n\n    # Option 2: Insert a new item if possible\n    if len(excluded_items) > 0:\n        insert_item = random.choice(excluded_items)\n        total_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[insert_item]\n        if total_weight <= capacity:\n            new_solution[insert_item] = 1\n            return new_solution\n\n    # Option 3: Remove an item if it's not the only one\n    if len(included_items) > 1:\n        remove_item = random.choice(included_items)\n        new_solution[remove_item] = 0\n        return new_solution\n\n    # If no better move found, return the original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swaps and random flips with probabilistic weight-based selection\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Identify items that can be added without exceeding capacity\n    feasible_additions = (weight_lst <= remaining_capacity) & (new_solution == 0)\n\n    # Identify items that can be removed to free up space\n    feasible_removals = (new_solution == 1)\n\n    if np.any(feasible_additions) and np.any(feasible_removals) and np.random.rand() < 0.7:\n        # Swap a high-value item with a low-value item (hybrid strategy)\n        add_candidates = np.where(feasible_additions)[0]\n        remove_candidates = np.where(feasible_removals)[0]\n\n        # Select items with highest value-to-weight ratio for addition\n        add_ratio = (value1_lst + value2_lst) / weight_lst\n        add_ratio[~feasible_additions] = -np.inf\n        add_idx = np.argmax(add_ratio)\n\n        # Select items with lowest value-to-weight ratio for removal\n        remove_ratio = (value1_lst + value2_lst) / weight_lst\n        remove_ratio[~feasible_removals] = np.inf\n        remove_idx = np.argmin(remove_ratio)\n\n        new_solution[remove_idx] = 0\n        new_solution[add_idx] = 1\n    else:\n        # Random flip with probabilistic selection based on value and weight\n        flip_prob = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        flip_prob[new_solution == 0] *= 0.3  # Lower probability for adding items\n        flip_prob[new_solution == 1] *= 0.7  # Higher probability for removing items\n        flip_prob /= np.sum(flip_prob)\n\n        flip_idx = np.random.choice(len(flip_prob), p=flip_prob)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            # Remove items with lowest value-to-weight ratio until feasible\n            while np.sum(weight_lst * new_solution) > capacity:\n                remove_ratio = (value1_lst + value2_lst) / weight_lst\n                remove_ratio[new_solution == 0] = np.inf\n                remove_idx = np.argmin(remove_ratio)\n                new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.36675668343566314,
            2.076353579759598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swaps and random flips with probabilistic weight-based selection\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Identify items that can be added without exceeding capacity\n    feasible_additions = (weight_lst <= remaining_capacity) & (new_solution == 0)\n\n    # Identify items that can be removed to free up space\n    feasible_removals = (new_solution == 1)\n\n    if np.any(feasible_additions) and np.any(feasible_removals) and np.random.rand() < 0.7:\n        # Swap a high-value item with a low-value item (hybrid strategy)\n        add_candidates = np.where(feasible_additions)[0]\n        remove_candidates = np.where(feasible_removals)[0]\n\n        # Select items with highest value-to-weight ratio for addition\n        add_ratio = (value1_lst + value2_lst) / weight_lst\n        add_ratio[~feasible_additions] = -np.inf\n        add_idx = np.argmax(add_ratio)\n\n        # Select items with lowest value-to-weight ratio for removal\n        remove_ratio = (value1_lst + value2_lst) / weight_lst\n        remove_ratio[~feasible_removals] = np.inf\n        remove_idx = np.argmin(remove_ratio)\n\n        new_solution[remove_idx] = 0\n        new_solution[add_idx] = 1\n    else:\n        # Random flip with probabilistic selection based on value and weight\n        flip_prob = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        flip_prob[new_solution == 0] *= 0.3  # Lower probability for adding items\n        flip_prob[new_solution == 1] *= 0.7  # Higher probability for removing items\n        flip_prob /= np.sum(flip_prob)\n\n        flip_idx = np.random.choice(len(flip_prob), p=flip_prob)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            # Remove items with lowest value-to-weight ratio until feasible\n            while np.sum(weight_lst * new_solution) > capacity:\n                remove_ratio = (value1_lst + value2_lst) / weight_lst\n                remove_ratio[new_solution == 0] = np.inf\n                remove_idx = np.argmin(remove_ratio)\n                new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid local search strategy that combines item swaps, flips, and guided perturbation to explore high-potential regions while ensuring feasibility, then generates a neighbor solution by intelligently flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on marginal contributions\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items to flip (items in the solution or not)\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: flip items with high marginal contribution\n    for _ in range(5):  # Limit the number of flips to avoid excessive computation\n        # Randomly select a candidate to flip (either include or exclude)\n        if random.random() < 0.5 and len(included_items) > 0:\n            # Try to exclude an item\n            item_to_exclude = random.choice(included_items)\n            new_weight = current_weight - weight_lst[item_to_exclude]\n            if new_weight <= capacity:\n                new_solution[item_to_exclude] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[item_to_exclude]\n                current_value2 -= value2_lst[item_to_exclude]\n                included_items = np.where(new_solution == 1)[0]\n        else:\n            # Try to include an item\n            if len(excluded_items) > 0:\n                item_to_include = random.choice(excluded_items)\n                new_weight = current_weight + weight_lst[item_to_include]\n                if new_weight <= capacity:\n                    new_solution[item_to_include] = 1\n                    current_weight = new_weight\n                    current_value1 += value1_lst[item_to_include]\n                    current_value2 += value2_lst[item_to_include]\n                    excluded_items = np.where(new_solution == 0)[0]\n\n    # Guided perturbation: flip items with high marginal contribution to both objectives\n    for item in range(len(base_solution)):\n        if new_solution[item] == 1:\n            # Check if excluding this item improves both objectives\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[item]\n                marginal_value2 = value2_lst[item]\n                # If excluding improves both objectives, do it\n                if marginal_value1 > 0 and marginal_value2 > 0:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n                    current_value1 -= marginal_value1\n                    current_value2 -= marginal_value2\n        else:\n            # Check if including this item improves both objectives\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[item]\n                marginal_value2 = value2_lst[item]\n                # If including improves both objectives, do it\n                if marginal_value1 > 0 and marginal_value2 > 0:\n                    new_solution[item] = 1\n                    current_weight = new_weight\n                    current_value1 += marginal_value1\n                    current_value2 += marginal_value2\n\n    return new_solution\n\n",
        "score": [
            -0.327260517650646,
            2.882842868566513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on marginal contributions\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items to flip (items in the solution or not)\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: flip items with high marginal contribution\n    for _ in range(5):  # Limit the number of flips to avoid excessive computation\n        # Randomly select a candidate to flip (either include or exclude)\n        if random.random() < 0.5 and len(included_items) > 0:\n            # Try to exclude an item\n            item_to_exclude = random.choice(included_items)\n            new_weight = current_weight - weight_lst[item_to_exclude]\n            if new_weight <= capacity:\n                new_solution[item_to_exclude] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[item_to_exclude]\n                current_value2 -= value2_lst[item_to_exclude]\n                included_items = np.where(new_solution == 1)[0]\n        else:\n            # Try to include an item\n            if len(excluded_items) > 0:\n                item_to_include = random.choice(excluded_items)\n                new_weight = current_weight + weight_lst[item_to_include]\n                if new_weight <= capacity:\n                    new_solution[item_to_include] = 1\n                    current_weight = new_weight\n                    current_value1 += value1_lst[item_to_include]\n                    current_value2 += value2_lst[item_to_include]\n                    excluded_items = np.where(new_solution == 0)[0]\n\n    # Guided perturbation: flip items with high marginal contribution to both objectives\n    for item in range(len(base_solution)):\n        if new_solution[item] == 1:\n            # Check if excluding this item improves both objectives\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[item]\n                marginal_value2 = value2_lst[item]\n                # If excluding improves both objectives, do it\n                if marginal_value1 > 0 and marginal_value2 > 0:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n                    current_value1 -= marginal_value1\n                    current_value2 -= marginal_value2\n        else:\n            # Check if including this item improves both objectives\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[item]\n                marginal_value2 = value2_lst[item]\n                # If including improves both objectives, do it\n                if marginal_value1 > 0 and marginal_value2 > 0:\n                    new_solution[item] = 1\n                    current_weight = new_weight\n                    current_value1 += marginal_value1\n                    current_value2 += marginal_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine random flip with value-guided selection\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that could potentially improve both objectives\n    candidate_items = np.where(base_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Calculate potential improvement for each objective\n        potential_value1 = value1_lst[candidate_items] / weight_lst[candidate_items]\n        potential_value2 = value2_lst[candidate_items] / weight_lst[candidate_items]\n\n        # Combine objectives with weighted sum (alternating weights)\n        combined_potential = (potential_value1 + potential_value2) / 2\n\n        # Select top 20% candidates for potential addition\n        num_candidates = max(1, len(candidate_items) // 5)\n        top_candidates = candidate_items[np.argsort(combined_potential)[-num_candidates:]]\n\n        # Randomly select one of the top candidates to add\n        selected_item = np.random.choice(top_candidates)\n        if total_weight + weight_lst[selected_item] <= capacity:\n            new_solution[selected_item] = 1\n\n    # Randomly select items to remove (up to 20% of current items)\n    current_items = np.where(new_solution == 1)[0]\n    if len(current_items) > 0:\n        num_to_remove = min(2, len(current_items) // 5)\n        if num_to_remove > 0:\n            items_to_remove = np.random.choice(current_items, size=num_to_remove, replace=False)\n            new_solution[items_to_remove] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        current_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(current_items)\n        for item in current_items:\n            if total_weight <= capacity:\n                break\n            new_solution[item] = 0\n            total_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8148712538413689,
            2.197267562150955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine random flip with value-guided selection\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that could potentially improve both objectives\n    candidate_items = np.where(base_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Calculate potential improvement for each objective\n        potential_value1 = value1_lst[candidate_items] / weight_lst[candidate_items]\n        potential_value2 = value2_lst[candidate_items] / weight_lst[candidate_items]\n\n        # Combine objectives with weighted sum (alternating weights)\n        combined_potential = (potential_value1 + potential_value2) / 2\n\n        # Select top 20% candidates for potential addition\n        num_candidates = max(1, len(candidate_items) // 5)\n        top_candidates = candidate_items[np.argsort(combined_potential)[-num_candidates:]]\n\n        # Randomly select one of the top candidates to add\n        selected_item = np.random.choice(top_candidates)\n        if total_weight + weight_lst[selected_item] <= capacity:\n            new_solution[selected_item] = 1\n\n    # Randomly select items to remove (up to 20% of current items)\n    current_items = np.where(new_solution == 1)[0]\n    if len(current_items) > 0:\n        num_to_remove = min(2, len(current_items) // 5)\n        if num_to_remove > 0:\n            items_to_remove = np.random.choice(current_items, size=num_to_remove, replace=False)\n            new_solution[items_to_remove] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        current_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(current_items)\n        for item in current_items:\n            if total_weight <= capacity:\n                break\n            new_solution[item] = 0\n            total_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{The algorithm first identifies the most promising solution in the archive by selecting one with high potential for local improvement, then applies a hybrid local search operator that combines random bit flips with a value-weighted selection strategy to generate a feasible neighbor solution while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    # Here, we select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Hybrid local search: random bit flip with value-weighted selection\n    # Step 1: Randomly select a subset of items to flip\n    flip_mask = np.random.rand(n_items) < 0.3  # 30% chance to flip each item\n\n    # Step 2: For flipped items, use value-weighted selection to balance objectives\n    for i in range(n_items):\n        if flip_mask[i]:\n            # Calculate potential change in objectives\n            if new_solution[i] == 1:\n                # Remove item i\n                delta_weight = -weight_lst[i]\n                delta_value1 = -value1_lst[i]\n                delta_value2 = -value2_lst[i]\n            else:\n                # Add item i\n                delta_weight = weight_lst[i]\n                delta_value1 = value1_lst[i]\n                delta_value2 = value2_lst[i]\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight + delta_weight\n            if new_weight <= capacity:\n                # Accept the flip with probability based on value improvement\n                # Combine objectives using a weighted sum\n                combined_value = 0.5 * delta_value1 + 0.5 * delta_value2\n                if combined_value > 0 or np.random.rand() < 0.2:  # Allow some exploration\n                    new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.31261341703769496,
            5.998839229345322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    # Here, we select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Hybrid local search: random bit flip with value-weighted selection\n    # Step 1: Randomly select a subset of items to flip\n    flip_mask = np.random.rand(n_items) < 0.3  # 30% chance to flip each item\n\n    # Step 2: For flipped items, use value-weighted selection to balance objectives\n    for i in range(n_items):\n        if flip_mask[i]:\n            # Calculate potential change in objectives\n            if new_solution[i] == 1:\n                # Remove item i\n                delta_weight = -weight_lst[i]\n                delta_value1 = -value1_lst[i]\n                delta_value2 = -value2_lst[i]\n            else:\n                # Add item i\n                delta_weight = weight_lst[i]\n                delta_value1 = value1_lst[i]\n                delta_value2 = value2_lst[i]\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight + delta_weight\n            if new_weight <= capacity:\n                # Accept the flip with probability based on value improvement\n                # Combine objectives using a weighted sum\n                combined_value = 0.5 * delta_value1 + 0.5 * delta_value2\n                if combined_value > 0 or np.random.rand() < 0.2:  # Allow some exploration\n                    new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high diversity in their objective values and applies a hybrid local search combining random swaps, item replacements, and objective-aware perturbations to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity in objectives\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([obj for _, obj in archive])\n\n    # Calculate diversity scores (distance from centroid)\n    centroid = np.mean(archive_objectives, axis=0)\n    diversity_scores = np.linalg.norm(archive_objectives - centroid, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random swaps, item replacements, and objective-aware perturbations\n    for _ in range(3):  # Number of perturbations\n        # Random swap\n        if len(np.where(new_solution == 1)[0]) >= 2:\n            a, b = random.sample(list(np.where(new_solution == 1)[0]), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Item replacement (add a new item if feasible)\n        zero_indices = np.where(new_solution == 0)[0]\n        if len(zero_indices) > 0:\n            candidate = random.choice(zero_indices)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n\n        # Objective-aware perturbation: Remove low-contribution items for the weaker objective\n        if len(np.where(new_solution == 1)[0]) > 0:\n            obj1, obj2 = archive_objectives[selected_idx]\n            if obj1 < obj2:\n                # Remove items with lowest value1 contribution\n                included_items = np.where(new_solution == 1)[0]\n                contributions = value1_lst[included_items]\n                if len(contributions) > 0:\n                    min_contrib_idx = np.argmin(contributions)\n                    new_solution[included_items[min_contrib_idx]] = 0\n            else:\n                # Remove items with lowest value2 contribution\n                included_items = np.where(new_solution == 1)[0]\n                contributions = value2_lst[included_items]\n                if len(contributions) > 0:\n                    min_contrib_idx = np.argmin(contributions)\n                    new_solution[included_items[min_contrib_idx]] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        included_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(included_items)\n        for item in included_items:\n            new_solution[item] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight <= capacity:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5094982334546646,
            2.267756849527359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity in objectives\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([obj for _, obj in archive])\n\n    # Calculate diversity scores (distance from centroid)\n    centroid = np.mean(archive_objectives, axis=0)\n    diversity_scores = np.linalg.norm(archive_objectives - centroid, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random swaps, item replacements, and objective-aware perturbations\n    for _ in range(3):  # Number of perturbations\n        # Random swap\n        if len(np.where(new_solution == 1)[0]) >= 2:\n            a, b = random.sample(list(np.where(new_solution == 1)[0]), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Item replacement (add a new item if feasible)\n        zero_indices = np.where(new_solution == 0)[0]\n        if len(zero_indices) > 0:\n            candidate = random.choice(zero_indices)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n\n        # Objective-aware perturbation: Remove low-contribution items for the weaker objective\n        if len(np.where(new_solution == 1)[0]) > 0:\n            obj1, obj2 = archive_objectives[selected_idx]\n            if obj1 < obj2:\n                # Remove items with lowest value1 contribution\n                included_items = np.where(new_solution == 1)[0]\n                contributions = value1_lst[included_items]\n                if len(contributions) > 0:\n                    min_contrib_idx = np.argmin(contributions)\n                    new_solution[included_items[min_contrib_idx]] = 0\n            else:\n                # Remove items with lowest value2 contribution\n                included_items = np.where(new_solution == 1)[0]\n                contributions = value2_lst[included_items]\n                if len(contributions) > 0:\n                    min_contrib_idx = np.argmin(contributions)\n                    new_solution[included_items[min_contrib_idx]] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        included_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(included_items)\n        for item in included_items:\n            new_solution[item] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight <= capacity:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal benefit\n    candidate_items = np.where(base_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Calculate marginal benefit for each candidate item\n        marginal_benefits = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n        # Select top 20% items with highest marginal benefit\n        top_items = candidate_items[np.argsort(marginal_benefits)[-max(1, len(marginal_benefits)//5):]]\n        # Randomly select one of the top items\n        selected_item = np.random.choice(top_items)\n        new_solution = base_solution.copy()\n        new_solution[selected_item] = 1\n        # Ensure feasibility\n        if np.sum(weight_lst[new_solution == 1]) <= capacity:\n            return new_solution\n\n    # If no addition works, try removing low-benefit items\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Calculate marginal cost for each item\n        marginal_costs = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n        # Select bottom 20% items with lowest marginal cost\n        low_items = candidate_items[np.argsort(marginal_costs)[:max(1, len(marginal_costs)//5)]]\n        # Randomly select one of the low items\n        selected_item = np.random.choice(low_items)\n        new_solution = base_solution.copy()\n        new_solution[selected_item] = 0\n        return new_solution\n\n    # If no changes possible, return original solution\n    return base_solution.copy()\n\n",
        "score": [
            -0.8427780746942641,
            2.3435185849666595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal benefit\n    candidate_items = np.where(base_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Calculate marginal benefit for each candidate item\n        marginal_benefits = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n        # Select top 20% items with highest marginal benefit\n        top_items = candidate_items[np.argsort(marginal_benefits)[-max(1, len(marginal_benefits)//5):]]\n        # Randomly select one of the top items\n        selected_item = np.random.choice(top_items)\n        new_solution = base_solution.copy()\n        new_solution[selected_item] = 1\n        # Ensure feasibility\n        if np.sum(weight_lst[new_solution == 1]) <= capacity:\n            return new_solution\n\n    # If no addition works, try removing low-benefit items\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Calculate marginal cost for each item\n        marginal_costs = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n        # Select bottom 20% items with lowest marginal cost\n        low_items = candidate_items[np.argsort(marginal_costs)[:max(1, len(marginal_costs)//5)]]\n        # Randomly select one of the low items\n        selected_item = np.random.choice(low_items)\n        new_solution = base_solution.copy()\n        new_solution[selected_item] = 0\n        return new_solution\n\n    # If no changes possible, return original solution\n    return base_solution.copy()\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines random item swaps with targeted flips of high-impact items, guided by a weighted objective score to ensure both feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias toward higher objective scores\n    scores = [sum(obj) for (_, obj) in archive]\n    if not scores:\n        base_idx = random.randint(0, len(archive) - 1)\n    else:\n        max_score = max(scores)\n        candidates = [i for i, score in enumerate(scores) if score >= max_score * 0.9]\n        base_idx = random.choice(candidates)\n\n    base_solution, base_obj = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: random swaps + targeted flips\n    for _ in range(5):  # Number of attempts\n        # Random swap of two items\n        if len(new_solution) >= 2:\n            idx1, idx2 = random.sample(range(len(new_solution)), 2)\n            temp_solution = new_solution.copy()\n            temp_solution[idx1], temp_solution[idx2] = temp_solution[idx2], temp_solution[idx1]\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n        # Targeted flip of high-impact items\n        impact_scores = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        for idx in np.argsort(impact_scores)[-3:]:  # Top 3 most impactful items\n            if new_solution[idx] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                temp_weight = np.sum(weight_lst * temp_solution)\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    temp_solution = new_solution.copy()\n                    temp_solution[idx] = 1\n                    new_solution = temp_solution\n                    current_weight = current_weight + weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3375223036893572,
            2.8004686534404755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias toward higher objective scores\n    scores = [sum(obj) for (_, obj) in archive]\n    if not scores:\n        base_idx = random.randint(0, len(archive) - 1)\n    else:\n        max_score = max(scores)\n        candidates = [i for i, score in enumerate(scores) if score >= max_score * 0.9]\n        base_idx = random.choice(candidates)\n\n    base_solution, base_obj = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: random swaps + targeted flips\n    for _ in range(5):  # Number of attempts\n        # Random swap of two items\n        if len(new_solution) >= 2:\n            idx1, idx2 = random.sample(range(len(new_solution)), 2)\n            temp_solution = new_solution.copy()\n            temp_solution[idx1], temp_solution[idx2] = temp_solution[idx2], temp_solution[idx1]\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n        # Targeted flip of high-impact items\n        impact_scores = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        for idx in np.argsort(impact_scores)[-3:]:  # Top 3 most impactful items\n            if new_solution[idx] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                temp_weight = np.sum(weight_lst * temp_solution)\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    temp_solution = new_solution.copy()\n                    temp_solution[idx] = 1\n                    new_solution = temp_solution\n                    current_weight = current_weight + weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomly swap items between objectives or perform a greedy addition/removal\n    for _ in range(3):  # Repeat a few times for diversification\n        # Randomly choose between two strategies: swap or greedy\n        if np.random.rand() < 0.5:\n            # Strategy 1: Randomly swap items between objectives\n            swap_indices = np.where(base_solution == 1)[0]\n            if len(swap_indices) > 1:\n                i, j = np.random.choice(swap_indices, 2, replace=False)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Strategy 2: Greedy addition/removal based on marginal contribution\n            # Calculate marginal values for each item\n            marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n            marginal2 = value2_lst / (weight_lst + 1e-6)\n\n            # Find items to add (not in solution and can fit)\n            remaining_weight = capacity - np.sum(weight_lst * base_solution)\n            candidate_add = np.where((base_solution == 0) & (weight_lst <= remaining_weight))[0]\n            if len(candidate_add) > 0:\n                best_add = candidate_add[np.argmax(marginal1[candidate_add] + marginal2[candidate_add])]\n                new_solution[best_add] = 1\n\n            # Find items to remove (in solution)\n            candidate_remove = np.where(base_solution == 1)[0]\n            if len(candidate_remove) > 0:\n                worst_remove = candidate_remove[np.argmin(marginal1[candidate_remove] + marginal2[candidate_remove])]\n                new_solution[worst_remove] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity:\n        # Remove heavy items until feasible\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) == 0:\n            break\n        to_remove = heavy_items[np.argmax(weight_lst[heavy_items])]\n        new_solution[to_remove] = 0\n        total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.4774108632686537,
            2.3649954199790955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomly swap items between objectives or perform a greedy addition/removal\n    for _ in range(3):  # Repeat a few times for diversification\n        # Randomly choose between two strategies: swap or greedy\n        if np.random.rand() < 0.5:\n            # Strategy 1: Randomly swap items between objectives\n            swap_indices = np.where(base_solution == 1)[0]\n            if len(swap_indices) > 1:\n                i, j = np.random.choice(swap_indices, 2, replace=False)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Strategy 2: Greedy addition/removal based on marginal contribution\n            # Calculate marginal values for each item\n            marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n            marginal2 = value2_lst / (weight_lst + 1e-6)\n\n            # Find items to add (not in solution and can fit)\n            remaining_weight = capacity - np.sum(weight_lst * base_solution)\n            candidate_add = np.where((base_solution == 0) & (weight_lst <= remaining_weight))[0]\n            if len(candidate_add) > 0:\n                best_add = candidate_add[np.argmax(marginal1[candidate_add] + marginal2[candidate_add])]\n                new_solution[best_add] = 1\n\n            # Find items to remove (in solution)\n            candidate_remove = np.where(base_solution == 1)[0]\n            if len(candidate_remove) > 0:\n                worst_remove = candidate_remove[np.argmin(marginal1[candidate_remove] + marginal2[candidate_remove])]\n                new_solution[worst_remove] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity:\n        # Remove heavy items until feasible\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) == 0:\n            break\n        to_remove = heavy_items[np.argmax(weight_lst[heavy_items])]\n        new_solution[to_remove] = 0\n        total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement by evaluating the density of each objective's value relative to weight, then applies a hybrid local search combining random item swaps with a greedy selection of high-density items to ensure feasibility and maximize both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (highest density)\n    densities = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        if total_weight == 0:\n            density1 = density2 = 0\n        else:\n            density1 = val1 / total_weight\n            density2 = val2 / total_weight\n        densities.append((density1 + density2) / 2)  # Average density\n\n    selected_idx = np.argmax(densities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly flip a subset of items\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            current_weight -= weight_lst[idx]\n            new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                current_weight += weight_lst[idx]\n                new_solution[idx] = 1\n\n    # Greedy selection of high-density items\n    included = set(np.where(new_solution == 1)[0])\n    excluded = set(np.where(new_solution == 0)[0])\n\n    # Try to add high-density items\n    for idx in excluded:\n        if current_weight + weight_lst[idx] <= capacity:\n            current_weight += weight_lst[idx]\n            new_solution[idx] = 1\n\n    # Try to remove low-density items\n    for idx in included:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            if current_weight <= capacity:\n                continue\n            else:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8054476699011613,
            3.202907681465149
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (highest density)\n    densities = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        if total_weight == 0:\n            density1 = density2 = 0\n        else:\n            density1 = val1 / total_weight\n            density2 = val2 / total_weight\n        densities.append((density1 + density2) / 2)  # Average density\n\n    selected_idx = np.argmax(densities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly flip a subset of items\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            current_weight -= weight_lst[idx]\n            new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                current_weight += weight_lst[idx]\n                new_solution[idx] = 1\n\n    # Greedy selection of high-density items\n    included = set(np.where(new_solution == 1)[0])\n    excluded = set(np.where(new_solution == 0)[0])\n\n    # Try to add high-density items\n    for idx in excluded:\n        if current_weight + weight_lst[idx] <= capacity:\n            current_weight += weight_lst[idx]\n            new_solution[idx] = 1\n\n    # Try to remove low-density items\n    for idx in included:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            if current_weight <= capacity:\n                continue\n            else:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high marginal improvement potential, then applies a hybrid local search that combines item swap and subset replacement to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high marginal improvement potential\n    def marginal_improvement(solution, objective):\n        total_weight = np.sum(weight_lst * solution)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity <= 0:\n            return 0.0\n        # Calculate potential improvement by adding the most valuable item within remaining capacity\n        feasible_items = (weight_lst <= remaining_capacity) & (solution == 0)\n        if not np.any(feasible_items):\n            return 0.0\n        max_value1 = np.max(value1_lst[feasible_items])\n        max_value2 = np.max(value2_lst[feasible_items])\n        # Weighted marginal improvement\n        return 0.5 * max_value1 + 0.5 * max_value2\n\n    # Sort archive by marginal improvement (descending)\n    archive_sorted = sorted(archive, key=lambda x: marginal_improvement(x[0], x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: swap + subset replacement\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random swap (local move)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility after swap\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove the heaviest item if over capacity\n        while total_weight > capacity:\n            heavy_items = np.where(new_solution == 1)[0]\n            if len(heavy_items) == 0:\n                break\n            heaviest = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Subset replacement (larger move)\n    if random.random() < 0.3:  # 30% chance to perform subset replacement\n        subset_size = min(3, n_items)\n        if subset_size > 0:\n            # Select a random subset of items to replace\n            subset_indices = random.sample(range(n_items), subset_size)\n            # Try to add the most valuable items within remaining capacity\n            remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n            if remaining_capacity > 0:\n                for i in subset_indices:\n                    if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                        new_solution[i] = 1\n                        remaining_capacity -= weight_lst[i]\n                        if remaining_capacity <= 0:\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.609525737483323,
            8.380706191062927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high marginal improvement potential\n    def marginal_improvement(solution, objective):\n        total_weight = np.sum(weight_lst * solution)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity <= 0:\n            return 0.0\n        # Calculate potential improvement by adding the most valuable item within remaining capacity\n        feasible_items = (weight_lst <= remaining_capacity) & (solution == 0)\n        if not np.any(feasible_items):\n            return 0.0\n        max_value1 = np.max(value1_lst[feasible_items])\n        max_value2 = np.max(value2_lst[feasible_items])\n        # Weighted marginal improvement\n        return 0.5 * max_value1 + 0.5 * max_value2\n\n    # Sort archive by marginal improvement (descending)\n    archive_sorted = sorted(archive, key=lambda x: marginal_improvement(x[0], x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: swap + subset replacement\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random swap (local move)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility after swap\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove the heaviest item if over capacity\n        while total_weight > capacity:\n            heavy_items = np.where(new_solution == 1)[0]\n            if len(heavy_items) == 0:\n                break\n            heaviest = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Subset replacement (larger move)\n    if random.random() < 0.3:  # 30% chance to perform subset replacement\n        subset_size = min(3, n_items)\n        if subset_size > 0:\n            # Select a random subset of items to replace\n            subset_indices = random.sample(range(n_items), subset_size)\n            # Try to add the most valuable items within remaining capacity\n            remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n            if remaining_capacity > 0:\n                for i in subset_indices:\n                    if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                        new_solution[i] = 1\n                        remaining_capacity -= weight_lst[i]\n                        if remaining_capacity <= 0:\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines adaptive item swapping and targeted removal of low-value items to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive item swapping and targeted removal\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Step 1: Adaptive swapping - swap low-value included items with high-value excluded items\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Calculate value ratios for included items (lower is better for removal)\n        included_value_ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        # Calculate value ratios for excluded items (higher is better for addition)\n        excluded_value_ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n\n        # Find the worst included item (lowest value ratio)\n        worst_included_idx = included_items[np.argmin(included_value_ratios)]\n        # Find the best excluded item (highest value ratio)\n        best_excluded_idx = excluded_items[np.argmax(excluded_value_ratios)]\n\n        # Check if swapping would maintain feasibility\n        if weight_lst[best_excluded_idx] <= weight_lst[worst_included_idx]:\n            new_solution[worst_included_idx] = 0\n            new_solution[best_excluded_idx] = 1\n\n    # Step 2: Targeted removal - remove items that contribute little to both objectives\n    if len(included_items) > 1:\n        # Calculate marginal contribution (value/weight) for each included item\n        marginal_contributions = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        # Find the least contributing item\n        least_contributing_idx = included_items[np.argmin(marginal_contributions)]\n        new_solution[least_contributing_idx] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, try to remove items until feasible\n        while total_weight > capacity and len(included_items) > 0:\n            # Remove the least contributing item\n            marginal_contributions = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            least_contributing_idx = included_items[np.argmin(marginal_contributions)]\n            new_solution[least_contributing_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n            included_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.31725960444679946,
            5.840894728899002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive item swapping and targeted removal\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Step 1: Adaptive swapping - swap low-value included items with high-value excluded items\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Calculate value ratios for included items (lower is better for removal)\n        included_value_ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        # Calculate value ratios for excluded items (higher is better for addition)\n        excluded_value_ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n\n        # Find the worst included item (lowest value ratio)\n        worst_included_idx = included_items[np.argmin(included_value_ratios)]\n        # Find the best excluded item (highest value ratio)\n        best_excluded_idx = excluded_items[np.argmax(excluded_value_ratios)]\n\n        # Check if swapping would maintain feasibility\n        if weight_lst[best_excluded_idx] <= weight_lst[worst_included_idx]:\n            new_solution[worst_included_idx] = 0\n            new_solution[best_excluded_idx] = 1\n\n    # Step 2: Targeted removal - remove items that contribute little to both objectives\n    if len(included_items) > 1:\n        # Calculate marginal contribution (value/weight) for each included item\n        marginal_contributions = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        # Find the least contributing item\n        least_contributing_idx = included_items[np.argmin(marginal_contributions)]\n        new_solution[least_contributing_idx] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, try to remove items until feasible\n        while total_weight > capacity and len(included_items) > 0:\n            # Remove the least contributing item\n            marginal_contributions = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            least_contributing_idx = included_items[np.argmin(marginal_contributions)]\n            new_solution[least_contributing_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n            included_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to balance exploration and exploitation\n        base_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Apply a hybrid local search operator: flip a random item if it improves at least one objective\n    for _ in range(10):  # Try up to 10 random flips\n        item = np.random.randint(0, len(new_solution))\n        current_status = new_solution[item]\n        new_status = 1 - current_status\n\n        if current_status == 1:\n            new_weight = total_weight - weight_lst[item]\n        else:\n            new_weight = total_weight + weight_lst[item]\n\n        if new_weight <= capacity:\n            # Calculate the change in both objectives\n            delta_value1 = (value1_lst[item] if new_status == 1 else -value1_lst[item])\n            delta_value2 = (value2_lst[item] if new_status == 1 else -value2_lst[item])\n\n            # Accept if at least one objective improves\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[item] = new_status\n                total_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.881488793877067,
            2.631185382604599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to balance exploration and exploitation\n        base_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Apply a hybrid local search operator: flip a random item if it improves at least one objective\n    for _ in range(10):  # Try up to 10 random flips\n        item = np.random.randint(0, len(new_solution))\n        current_status = new_solution[item]\n        new_status = 1 - current_status\n\n        if current_status == 1:\n            new_weight = total_weight - weight_lst[item]\n        else:\n            new_weight = total_weight + weight_lst[item]\n\n        if new_weight <= capacity:\n            # Calculate the change in both objectives\n            delta_value1 = (value1_lst[item] if new_status == 1 else -value1_lst[item])\n            delta_value2 = (value2_lst[item] if new_status == 1 else -value2_lst[item])\n\n            # Accept if at least one objective improves\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[item] = new_status\n                total_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not all items are selected)\n    candidates = [(sol, obj) for sol, obj in archive if np.sum(sol) < len(sol)]\n    if not candidates:\n        candidates = archive\n\n    # Randomly select a candidate with preference for higher diversity\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip multiple items based on marginal contributions\n    new_solution = base_solution.copy()\n    num_flips = min(3, len(base_solution))  # Limit the number of flips to avoid excessive changes\n\n    for _ in range(num_flips):\n        # Calculate marginal contributions for each item\n        marginal1 = value1_lst / weight_lst\n        marginal2 = value2_lst / weight_lst\n        marginal = marginal1 + marginal2  # Combined marginal contribution\n\n        # Prioritize flipping items with high marginal contribution\n        sorted_indices = np.argsort(-marginal)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                # Try removing the item\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n            else:\n                # Try adding the item\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8267569736256417,
            3.7594679296016693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not all items are selected)\n    candidates = [(sol, obj) for sol, obj in archive if np.sum(sol) < len(sol)]\n    if not candidates:\n        candidates = archive\n\n    # Randomly select a candidate with preference for higher diversity\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip multiple items based on marginal contributions\n    new_solution = base_solution.copy()\n    num_flips = min(3, len(base_solution))  # Limit the number of flips to avoid excessive changes\n\n    for _ in range(num_flips):\n        # Calculate marginal contributions for each item\n        marginal1 = value1_lst / weight_lst\n        marginal2 = value2_lst / weight_lst\n        marginal = marginal1 + marginal2  # Combined marginal contribution\n\n        # Prioritize flipping items with high marginal contribution\n        sorted_indices = np.argsort(-marginal)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                # Try removing the item\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n            else:\n                # Try adding the item\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_scores = np.array([(obj[0] + obj[1]) / (value1_lst.sum() + value2_lst.sum()) for _, obj in archive])\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to potentially swap or flip based on marginal gains\n    marginal_gains1 = value1_lst * (1 - new_solution) - value1_lst * new_solution\n    marginal_gains2 = value2_lst * (1 - new_solution) - value2_lst * new_solution\n    combined_gains = marginal_gains1 + marginal_gains2\n\n    # Select items with top gains that can be added without exceeding capacity\n    candidate_indices = np.argsort(-combined_gains)\n    for idx in candidate_indices:\n        if new_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            total_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Consider removing items with negative marginal gains\n            if combined_gains[idx] < 0:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Apply a random flip to escape local optima\n    flip_idx = np.random.choice(len(new_solution))\n    if new_solution[flip_idx] == 0 and total_weight + weight_lst[flip_idx] <= capacity:\n        new_solution[flip_idx] = 1\n    elif new_solution[flip_idx] == 1:\n        new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8406792520897887,
            6.381426155567169
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_scores = np.array([(obj[0] + obj[1]) / (value1_lst.sum() + value2_lst.sum()) for _, obj in archive])\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to potentially swap or flip based on marginal gains\n    marginal_gains1 = value1_lst * (1 - new_solution) - value1_lst * new_solution\n    marginal_gains2 = value2_lst * (1 - new_solution) - value2_lst * new_solution\n    combined_gains = marginal_gains1 + marginal_gains2\n\n    # Select items with top gains that can be added without exceeding capacity\n    candidate_indices = np.argsort(-combined_gains)\n    for idx in candidate_indices:\n        if new_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            total_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Consider removing items with negative marginal gains\n            if combined_gains[idx] < 0:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Apply a random flip to escape local optima\n    flip_idx = np.random.choice(len(new_solution))\n    if new_solution[flip_idx] == 0 and total_weight + weight_lst[flip_idx] <= capacity:\n        new_solution[flip_idx] = 1\n    elif new_solution[flip_idx] == 1:\n        new_solution[flip_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{A novel hybrid local search strategy combines adaptive perturbation with multi-objective guided swapping, prioritizing high-margin items in both objectives while dynamically adjusting the neighborhood size based on solution quality and archive diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (simplified: those with lower combined value are prioritized)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a solution that is not the best in either objective\n        selected_idx = random.randint(1, min(3, len(archive) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Determine neighborhood size based on solution quality\n    neighborhood_size = max(1, int(0.1 * len(new_solution)))\n\n    # Candidate items for perturbation\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(new_solution))\n\n    # Hybrid local search: guided swapping with adaptive perturbation\n    for _ in range(neighborhood_size):\n        # Select an item to swap or flip\n        item_idx = random.choice(candidate_items)\n\n        # Decide whether to add or remove the item based on marginal gains\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight <= capacity:\n                # Calculate marginal gains for both objectives\n                marginal_gain1 = -value1_lst[item_idx]\n                marginal_gain2 = -value2_lst[item_idx]\n\n                # Accept removal if it improves at least one objective\n                if marginal_gain1 > 0 or marginal_gain2 > 0:\n                    new_solution[item_idx] = 0\n                    current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                # Calculate marginal gains for both objectives\n                marginal_gain1 = value1_lst[item_idx]\n                marginal_gain2 = value2_lst[item_idx]\n\n                # Accept addition if it improves at least one objective\n                if marginal_gain1 > 0 or marginal_gain2 > 0:\n                    new_solution[item_idx] = 1\n                    current_weight = new_weight\n\n    # Additional perturbation to escape local optima\n    if random.random() < 0.3:\n        # Randomly flip a small number of items\n        flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n        for idx in flip_indices:\n            if new_solution[idx] == 1 and (current_weight - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n            elif new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8557515451174081,
            2.2904460430145264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (simplified: those with lower combined value are prioritized)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a solution that is not the best in either objective\n        selected_idx = random.randint(1, min(3, len(archive) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Determine neighborhood size based on solution quality\n    neighborhood_size = max(1, int(0.1 * len(new_solution)))\n\n    # Candidate items for perturbation\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(new_solution))\n\n    # Hybrid local search: guided swapping with adaptive perturbation\n    for _ in range(neighborhood_size):\n        # Select an item to swap or flip\n        item_idx = random.choice(candidate_items)\n\n        # Decide whether to add or remove the item based on marginal gains\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight <= capacity:\n                # Calculate marginal gains for both objectives\n                marginal_gain1 = -value1_lst[item_idx]\n                marginal_gain2 = -value2_lst[item_idx]\n\n                # Accept removal if it improves at least one objective\n                if marginal_gain1 > 0 or marginal_gain2 > 0:\n                    new_solution[item_idx] = 0\n                    current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                # Calculate marginal gains for both objectives\n                marginal_gain1 = value1_lst[item_idx]\n                marginal_gain2 = value2_lst[item_idx]\n\n                # Accept addition if it improves at least one objective\n                if marginal_gain1 > 0 or marginal_gain2 > 0:\n                    new_solution[item_idx] = 1\n                    current_weight = new_weight\n\n    # Additional perturbation to escape local optima\n    if random.random() < 0.3:\n        # Randomly flip a small number of items\n        flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n        for idx in flip_indices:\n            if new_solution[idx] == 1 and (current_weight - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n            elif new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This heuristic function selects a promising solution from the archive, identifies critical items via a hybrid local search strategy combining adaptive perturbation and multi-objective sensitivity analysis, and generates a neighbor solution by intelligently flipping items to balance trade-offs between objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high diversity potential\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify critical items (high impact on both objectives)\n    included = base_solution == 1\n    excluded = base_solution == 0\n\n    # Multi-objective sensitivity analysis\n    included_scores = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n    excluded_scores = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Remove low-impact items\n    if len(included_scores) > 0:\n        threshold = np.percentile(included_scores, 25)\n        low_impact = included_scores < threshold\n        new_solution[np.where(included)[0][low_impact]] = 0\n\n    # Step 2: Add high-impact items\n    if len(excluded_scores) > 0:\n        threshold = np.percentile(excluded_scores, 75)\n        high_impact = excluded_scores >= threshold\n        candidates = np.where(excluded)[0][high_impact]\n        np.random.shuffle(candidates)\n\n        for item in candidates:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 3: Balance trade-offs\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Prioritize items with good value-weight ratio for the underperforming objective\n        current_value1 = np.sum(value1_lst[new_solution == 1])\n        current_value2 = np.sum(value2_lst[new_solution == 1])\n\n        if current_value1 < current_value2:\n            # Strengthen objective 1\n            ratio = (value1_lst[excluded] / weight_lst[excluded])\n        else:\n            # Strengthen objective 2\n            ratio = (value2_lst[excluded] / weight_lst[excluded])\n\n        candidates = np.argsort(ratio)[::-1]\n        for item in candidates:\n            if excluded[item] and weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8600131771857036,
            8.67418059706688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high diversity potential\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify critical items (high impact on both objectives)\n    included = base_solution == 1\n    excluded = base_solution == 0\n\n    # Multi-objective sensitivity analysis\n    included_scores = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n    excluded_scores = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Remove low-impact items\n    if len(included_scores) > 0:\n        threshold = np.percentile(included_scores, 25)\n        low_impact = included_scores < threshold\n        new_solution[np.where(included)[0][low_impact]] = 0\n\n    # Step 2: Add high-impact items\n    if len(excluded_scores) > 0:\n        threshold = np.percentile(excluded_scores, 75)\n        high_impact = excluded_scores >= threshold\n        candidates = np.where(excluded)[0][high_impact]\n        np.random.shuffle(candidates)\n\n        for item in candidates:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 3: Balance trade-offs\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Prioritize items with good value-weight ratio for the underperforming objective\n        current_value1 = np.sum(value1_lst[new_solution == 1])\n        current_value2 = np.sum(value2_lst[new_solution == 1])\n\n        if current_value1 < current_value2:\n            # Strengthen objective 1\n            ratio = (value1_lst[excluded] / weight_lst[excluded])\n        else:\n            # Strengthen objective 2\n            ratio = (value2_lst[excluded] / weight_lst[excluded])\n\n        candidates = np.argsort(ratio)[::-1]\n        for item in candidates:\n            if excluded[item] and weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a weighted random selection favoring solutions with higher objective values and lower weights, then applies a novel \"adaptive flip and merge\" local search that intelligently flips multiple items and merges their effects to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with weighted randomness based on objective values and weight\n    weights = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Higher objective values and lower weight get higher selection probability\n        weight = (val1 + val2) / (1 + total_weight)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using adaptive flip and merge\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Determine flip candidates: items that can be flipped without violating capacity\n    flip_candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            if total_weight - weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n        else:\n            if total_weight + weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        return new_solution\n\n    # Select a subset of items to flip (adaptive size based on solution quality)\n    flip_size = min(3, max(1, int(0.2 * len(flip_candidates))))\n    flip_items = random.sample(flip_candidates, flip_size)\n\n    # Flip selected items\n    for i in flip_items:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Merge effect: adjust solution to improve both objectives\n    for _ in range(2):  # Limited iterations to avoid excessive computation\n        # Calculate potential improvements\n        improvements = []\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                # Check if removing this item improves both objectives\n                new_val1 = archive[selected_idx][1][0] - value1_lst[i]\n                new_val2 = archive[selected_idx][1][1] - value2_lst[i]\n                if new_val1 >= archive[selected_idx][1][0] and new_val2 >= archive[selected_idx][1][1]:\n                    improvements.append((i, -1, new_val1, new_val2))\n            else:\n                # Check if adding this item improves both objectives\n                if total_weight + weight_lst[i] <= capacity:\n                    new_val1 = archive[selected_idx][1][0] + value1_lst[i]\n                    new_val2 = archive[selected_idx][1][1] + value2_lst[i]\n                    if new_val1 >= archive[selected_idx][1][0] or new_val2 >= archive[selected_idx][1][1]:\n                        improvements.append((i, 1, new_val1, new_val2))\n\n        # Apply the best improvement\n        if improvements:\n            best_improvement = max(improvements, key=lambda x: (x[2] + x[3]))\n            i, action, _, _ = best_improvement\n            new_solution[i] = 1 if action == 1 else 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.2754177485082464,
            5.297405481338501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with weighted randomness based on objective values and weight\n    weights = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Higher objective values and lower weight get higher selection probability\n        weight = (val1 + val2) / (1 + total_weight)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using adaptive flip and merge\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Determine flip candidates: items that can be flipped without violating capacity\n    flip_candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            if total_weight - weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n        else:\n            if total_weight + weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        return new_solution\n\n    # Select a subset of items to flip (adaptive size based on solution quality)\n    flip_size = min(3, max(1, int(0.2 * len(flip_candidates))))\n    flip_items = random.sample(flip_candidates, flip_size)\n\n    # Flip selected items\n    for i in flip_items:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Merge effect: adjust solution to improve both objectives\n    for _ in range(2):  # Limited iterations to avoid excessive computation\n        # Calculate potential improvements\n        improvements = []\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                # Check if removing this item improves both objectives\n                new_val1 = archive[selected_idx][1][0] - value1_lst[i]\n                new_val2 = archive[selected_idx][1][1] - value2_lst[i]\n                if new_val1 >= archive[selected_idx][1][0] and new_val2 >= archive[selected_idx][1][1]:\n                    improvements.append((i, -1, new_val1, new_val2))\n            else:\n                # Check if adding this item improves both objectives\n                if total_weight + weight_lst[i] <= capacity:\n                    new_val1 = archive[selected_idx][1][0] + value1_lst[i]\n                    new_val2 = archive[selected_idx][1][1] + value2_lst[i]\n                    if new_val1 >= archive[selected_idx][1][0] or new_val2 >= archive[selected_idx][1][1]:\n                        improvements.append((i, 1, new_val1, new_val2))\n\n        # Apply the best improvement\n        if improvements:\n            best_improvement = max(improvements, key=lambda x: (x[2] + x[3]))\n            i, action, _, _ = best_improvement\n            new_solution[i] = 1 if action == 1 else 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(obj[0] / max(value1_lst), obj[1] / max(value2_lst)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a subset of items based on their marginal contribution\n    current_weight = np.sum(weight_lst * base_solution)\n    potential_items = np.where(base_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate marginal contribution for each potential item\n        marginal_contributions = []\n        for item in potential_items:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[item] / weight_lst[item]\n                marginal_value2 = value2_lst[item] / weight_lst[item]\n                marginal_contributions.append((marginal_value1 + marginal_value2, item))\n        if marginal_contributions:\n            marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n            top_items = [item for _, item in marginal_contributions[:min(3, len(marginal_contributions))]]\n            new_solution = base_solution.copy()\n            new_solution[top_items] = 1\n            return new_solution\n\n    # If no items can be added, try removing low-margin items\n    included_items = np.where(base_solution == 1)[0]\n    if len(included_items) > 0:\n        marginal_contributions = []\n        for item in included_items:\n            marginal_value1 = value1_lst[item] / weight_lst[item]\n            marginal_value2 = value2_lst[item] / weight_lst[item]\n            marginal_contributions.append((marginal_value1 + marginal_value2, item))\n        marginal_contributions.sort(key=lambda x: x[0])\n        bottom_items = [item for _, item in marginal_contributions[:min(3, len(marginal_contributions))]]\n        new_solution = base_solution.copy()\n        new_solution[bottom_items] = 0\n        return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9663077521191044,
            9.688194245100021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(obj[0] / max(value1_lst), obj[1] / max(value2_lst)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a subset of items based on their marginal contribution\n    current_weight = np.sum(weight_lst * base_solution)\n    potential_items = np.where(base_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate marginal contribution for each potential item\n        marginal_contributions = []\n        for item in potential_items:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[item] / weight_lst[item]\n                marginal_value2 = value2_lst[item] / weight_lst[item]\n                marginal_contributions.append((marginal_value1 + marginal_value2, item))\n        if marginal_contributions:\n            marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n            top_items = [item for _, item in marginal_contributions[:min(3, len(marginal_contributions))]]\n            new_solution = base_solution.copy()\n            new_solution[top_items] = 1\n            return new_solution\n\n    # If no items can be added, try removing low-margin items\n    included_items = np.where(base_solution == 1)[0]\n    if len(included_items) > 0:\n        marginal_contributions = []\n        for item in included_items:\n            marginal_value1 = value1_lst[item] / weight_lst[item]\n            marginal_value2 = value2_lst[item] / weight_lst[item]\n            marginal_contributions.append((marginal_value1 + marginal_value2, item))\n        marginal_contributions.sort(key=lambda x: x[0])\n        bottom_items = [item for _, item in marginal_contributions[:min(3, len(marginal_contributions))]]\n        new_solution = base_solution.copy()\n        new_solution[bottom_items] = 0\n        return new_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(obj[0] / max(value1_lst), obj[1] / max(value2_lst)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a subset of items based on their marginal contribution\n    current_weight = np.sum(weight_lst * base_solution)\n    potential_items = np.where(base_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate marginal contribution for each potential item\n        marginal_contributions = []\n        for item in potential_items:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[item] / weight_lst[item]\n                marginal_value2 = value2_lst[item] / weight_lst[item]\n                marginal_contributions.append((marginal_value1 + marginal_value2, item))\n        if marginal_contributions:\n            marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n            top_items = [item for _, item in marginal_contributions[:min(3, len(marginal_contributions))]]\n            new_solution = base_solution.copy()\n            new_solution[top_items] = 1\n            return new_solution\n\n    # If no items can be added, try removing low-margin items\n    included_items = np.where(base_solution == 1)[0]\n    if len(included_items) > 0:\n        marginal_contributions = []\n        for item in included_items:\n            marginal_value1 = value1_lst[item] / weight_lst[item]\n            marginal_value2 = value2_lst[item] / weight_lst[item]\n            marginal_contributions.append((marginal_value1 + marginal_value2, item))\n        marginal_contributions.sort(key=lambda x: x[0])\n        bottom_items = [item for _, item in marginal_contributions[:min(3, len(marginal_contributions))]]\n        new_solution = base_solution.copy()\n        new_solution[bottom_items] = 0\n        return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9663077521191044,
            9.688194245100021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(obj[0] / max(value1_lst), obj[1] / max(value2_lst)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a subset of items based on their marginal contribution\n    current_weight = np.sum(weight_lst * base_solution)\n    potential_items = np.where(base_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate marginal contribution for each potential item\n        marginal_contributions = []\n        for item in potential_items:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[item] / weight_lst[item]\n                marginal_value2 = value2_lst[item] / weight_lst[item]\n                marginal_contributions.append((marginal_value1 + marginal_value2, item))\n        if marginal_contributions:\n            marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n            top_items = [item for _, item in marginal_contributions[:min(3, len(marginal_contributions))]]\n            new_solution = base_solution.copy()\n            new_solution[top_items] = 1\n            return new_solution\n\n    # If no items can be added, try removing low-margin items\n    included_items = np.where(base_solution == 1)[0]\n    if len(included_items) > 0:\n        marginal_contributions = []\n        for item in included_items:\n            marginal_value1 = value1_lst[item] / weight_lst[item]\n            marginal_value2 = value2_lst[item] / weight_lst[item]\n            marginal_contributions.append((marginal_value1 + marginal_value2, item))\n        marginal_contributions.sort(key=lambda x: x[0])\n        bottom_items = [item for _, item in marginal_contributions[:min(3, len(marginal_contributions))]]\n        new_solution = base_solution.copy()\n        new_solution[bottom_items] = 0\n        return new_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    feasible_solutions = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            feasible_solutions.append((sol, total_weight))\n\n    if not feasible_solutions:\n        return archive[0][0].copy()  # Fallback if no feasible solutions\n\n    # Select the solution with the most \"room\" for improvement (weight closest to capacity but not exceeded)\n    base_solution = max(feasible_solutions, key=lambda x: x[1])[0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Flip a random subset of items (with adaptive size)\n    flip_size = max(1, int(np.sqrt(n_items)))  # Adaptive size based on problem size\n    flip_indices = np.random.choice(n_items, flip_size, replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Ensure feasibility when adding items\n            if np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Strategy 2: Add a high-value item if possible (biased toward value1 or value2 randomly)\n    if np.random.rand() < 0.5:\n        # Add highest value1 item not in solution\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(value1_lst[candidate_items])]\n            if np.sum(weight_lst * new_solution) + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n    else:\n        # Add highest value2 item not in solution\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(value2_lst[candidate_items])]\n            if np.sum(weight_lst * new_solution) + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.33770112911817757,
            5.927837014198303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    feasible_solutions = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            feasible_solutions.append((sol, total_weight))\n\n    if not feasible_solutions:\n        return archive[0][0].copy()  # Fallback if no feasible solutions\n\n    # Select the solution with the most \"room\" for improvement (weight closest to capacity but not exceeded)\n    base_solution = max(feasible_solutions, key=lambda x: x[1])[0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Flip a random subset of items (with adaptive size)\n    flip_size = max(1, int(np.sqrt(n_items)))  # Adaptive size based on problem size\n    flip_indices = np.random.choice(n_items, flip_size, replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Ensure feasibility when adding items\n            if np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Strategy 2: Add a high-value item if possible (biased toward value1 or value2 randomly)\n    if np.random.rand() < 0.5:\n        # Add highest value1 item not in solution\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(value1_lst[candidate_items])]\n            if np.sum(weight_lst * new_solution) + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n    else:\n        # Add highest value2 item not in solution\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(value2_lst[candidate_items])]\n            if np.sum(weight_lst * new_solution) + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{A hybrid local search strategy that combines adaptive item swapping with probabilistic mutation to explore high-potential regions of the solution space while ensuring feasibility through dynamic weight adjustment and multi-objective neighborhood evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and diversity\n    scores = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score combines normalized objectives and solution diversity\n        score = (val1 / np.max(value1_lst) + val2 / np.max(value2_lst)) * (1 - total_weight / capacity)\n        scores.append(score)\n\n    # Select top 20% solutions and pick one randomly\n    top_indices = np.argsort(scores)[-max(1, len(scores) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Adaptive item swapping (focus on high-value items)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        # Select items with highest value1 + value2\n        item_scores = value1_lst + value2_lst\n        sorted_items = np.argsort(-item_scores)\n        for i in sorted_items:\n            if new_solution[i] == 1:\n                # Try to remove this item\n                potential_weight = current_weight - weight_lst[i]\n                if potential_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = potential_weight\n                    # Try to add an item not in solution\n                    add_candidates = np.where(new_solution == 0)[0]\n                    if len(add_candidates) > 0:\n                        # Add item with highest value1 + value2\n                        add_item = add_candidates[np.argmax(item_scores[add_candidates])]\n                        if current_weight + weight_lst[add_item] <= capacity:\n                            new_solution[add_item] = 1\n                            current_weight += weight_lst[add_item]\n                    break\n\n    # Step 2: Probabilistic mutation (small chance to flip random bits)\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% mutation probability\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure solution is feasible (should be due to checks above, but verify)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.35340406298558363,
            4.996810495853424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and diversity\n    scores = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Score combines normalized objectives and solution diversity\n        score = (val1 / np.max(value1_lst) + val2 / np.max(value2_lst)) * (1 - total_weight / capacity)\n        scores.append(score)\n\n    # Select top 20% solutions and pick one randomly\n    top_indices = np.argsort(scores)[-max(1, len(scores) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Adaptive item swapping (focus on high-value items)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        # Select items with highest value1 + value2\n        item_scores = value1_lst + value2_lst\n        sorted_items = np.argsort(-item_scores)\n        for i in sorted_items:\n            if new_solution[i] == 1:\n                # Try to remove this item\n                potential_weight = current_weight - weight_lst[i]\n                if potential_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = potential_weight\n                    # Try to add an item not in solution\n                    add_candidates = np.where(new_solution == 0)[0]\n                    if len(add_candidates) > 0:\n                        # Add item with highest value1 + value2\n                        add_item = add_candidates[np.argmax(item_scores[add_candidates])]\n                        if current_weight + weight_lst[add_item] <= capacity:\n                            new_solution[add_item] = 1\n                            current_weight += weight_lst[add_item]\n                    break\n\n    # Step 2: Probabilistic mutation (small chance to flip random bits)\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% mutation probability\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure solution is feasible (should be due to checks above, but verify)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{Our heuristic function intelligently selects a promising solution from the archive, then applies a hybrid local search operator that combines item swapping with a novel \"weight-balanced\" perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = random.randint(0, min(2, len(archive)-1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping + weight-balanced perturbation\n    items_in = np.where(base_solution == 1)[0]\n    items_out = np.where(base_solution == 0)[0]\n\n    if len(items_in) > 1 and len(items_out) > 0:\n        # Randomly select items to swap (out with in)\n        swap_in = random.choice(items_in)\n        swap_out = random.choice(items_out)\n\n        # Calculate current total weight\n        current_weight = np.sum(weight_lst[base_solution == 1])\n\n        # Ensure feasibility after swap\n        if current_weight - weight_lst[swap_in] + weight_lst[swap_out] <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n\n    # Weight-balanced perturbation: adjust items to balance weight distribution\n    if len(items_in) > 2:\n        # Select two items to potentially swap for better weight balance\n        i, j = random.sample(list(items_in), 2)\n        weight_diff = abs(weight_lst[i] - weight_lst[j])\n\n        # Swap if it improves balance (simplified heuristic)\n        if weight_diff > 0.1 * np.mean(weight_lst[items_in]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.41356123643862686,
            6.493551969528198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = random.randint(0, min(2, len(archive)-1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping + weight-balanced perturbation\n    items_in = np.where(base_solution == 1)[0]\n    items_out = np.where(base_solution == 0)[0]\n\n    if len(items_in) > 1 and len(items_out) > 0:\n        # Randomly select items to swap (out with in)\n        swap_in = random.choice(items_in)\n        swap_out = random.choice(items_out)\n\n        # Calculate current total weight\n        current_weight = np.sum(weight_lst[base_solution == 1])\n\n        # Ensure feasibility after swap\n        if current_weight - weight_lst[swap_in] + weight_lst[swap_out] <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n\n    # Weight-balanced perturbation: adjust items to balance weight distribution\n    if len(items_in) > 2:\n        # Select two items to potentially swap for better weight balance\n        i, j = random.sample(list(items_in), 2)\n        weight_diff = abs(weight_lst[i] - weight_lst[j])\n\n        # Swap if it improves balance (simplified heuristic)\n        if weight_diff > 0.1 * np.mean(weight_lst[items_in]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combination of objective diversity and local improvement potential, then applies a hybrid local search operator that combines adaptive bit-flipping with a novel objective-balanced perturbation to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive bit-flipping with objective-balanced perturbation\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Adaptive bit-flipping based on objective values\n    for i in range(num_items):\n        if np.random.random() < 0.3:  # 30% chance to flip\n            if base_solution[i] == 1:\n                # Try removing item\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n            else:\n                # Try adding item\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    # Step 2: Objective-balanced perturbation\n    # Calculate objective ratios for items not in solution\n    not_in_solution = (new_solution == 0)\n    if np.any(not_in_solution):\n        # Calculate normalized objective scores for potential additions\n        obj1_scores = value1_lst[not_in_solution] / (weight_lst[not_in_solution] + 1e-6)\n        obj2_scores = value2_lst[not_in_solution] / (weight_lst[not_in_solution] + 1e-6)\n\n        # Combine scores with random weights to balance objectives\n        combined_scores = (np.random.uniform() * obj1_scores +\n                          (1 - np.random.uniform()) * obj2_scores)\n\n        # Select top 20% items to consider adding\n        num_consider = max(1, int(0.2 * np.sum(not_in_solution)))\n        top_indices = np.argsort(combined_scores)[-num_consider:]\n\n        # Try adding the top items if they fit\n        for idx in top_indices:\n            actual_idx = np.where(not_in_solution)[0][idx]\n            if current_weight + weight_lst[actual_idx] <= capacity:\n                new_solution[actual_idx] = 1\n                current_weight += weight_lst[actual_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4253353857875087,
            5.450844705104828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive bit-flipping with objective-balanced perturbation\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Adaptive bit-flipping based on objective values\n    for i in range(num_items):\n        if np.random.random() < 0.3:  # 30% chance to flip\n            if base_solution[i] == 1:\n                # Try removing item\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n            else:\n                # Try adding item\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    # Step 2: Objective-balanced perturbation\n    # Calculate objective ratios for items not in solution\n    not_in_solution = (new_solution == 0)\n    if np.any(not_in_solution):\n        # Calculate normalized objective scores for potential additions\n        obj1_scores = value1_lst[not_in_solution] / (weight_lst[not_in_solution] + 1e-6)\n        obj2_scores = value2_lst[not_in_solution] / (weight_lst[not_in_solution] + 1e-6)\n\n        # Combine scores with random weights to balance objectives\n        combined_scores = (np.random.uniform() * obj1_scores +\n                          (1 - np.random.uniform()) * obj2_scores)\n\n        # Select top 20% items to consider adding\n        num_consider = max(1, int(0.2 * np.sum(not_in_solution)))\n        top_indices = np.argsort(combined_scores)[-num_consider:]\n\n        # Try adding the top items if they fit\n        for idx in top_indices:\n            actual_idx = np.where(not_in_solution)[0][idx]\n            if current_weight + weight_lst[actual_idx] <= capacity:\n                new_solution[actual_idx] = 1\n                current_weight += weight_lst[actual_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with higher total values in either objective, then applies a hybrid local search that combines item swapping and perturbation to explore high-potential regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Prioritize solutions with higher total values in either objective\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n    N = len(weight_lst)\n\n    # Step 1: Randomly swap items to explore neighborhood\n    for _ in range(2):\n        i, j = random.sample(range(N), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Perturbation - randomly flip a few items to escape local optima\n    perturbation_count = min(3, N)\n    for _ in range(perturbation_count):\n        idx = random.randint(0, N-1)\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.29649533181662346,
            1.8002386391162872
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Prioritize solutions with higher total values in either objective\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n    N = len(weight_lst)\n\n    # Step 1: Randomly swap items to explore neighborhood\n    for _ in range(2):\n        i, j = random.sample(range(N), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Perturbation - randomly flip a few items to escape local optima\n    perturbation_count = min(3, N)\n    for _ in range(perturbation_count):\n        idx = random.randint(0, N-1)\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with higher total values in either objective, then applies a hybrid local search that combines item swapping and perturbation to explore high-potential regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Prioritize solutions with higher total values in either objective\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n    N = len(weight_lst)\n\n    # Step 1: Randomly swap items to explore neighborhood\n    for _ in range(2):\n        i, j = random.sample(range(N), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Perturbation - randomly flip a few items to escape local optima\n    perturbation_count = min(3, N)\n    for _ in range(perturbation_count):\n        idx = random.randint(0, N-1)\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.29649533181662346,
            1.8002386391162872
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Prioritize solutions with higher total values in either objective\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n    N = len(weight_lst)\n\n    # Step 1: Randomly swap items to explore neighborhood\n    for _ in range(2):\n        i, j = random.sample(range(N), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Perturbation - randomly flip a few items to escape local optima\n    perturbation_count = min(3, N)\n    for _ in range(perturbation_count):\n        idx = random.randint(0, N-1)\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search combining item swaps and probabilistic flips to explore high-potential neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low weights\n    archive.sort(key=lambda x: (-x[1][0] - x[1][1], np.sum(weight_lst[x[0] == 1])))\n    selected_solution = archive[0][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Swap two items (one included, one excluded) if feasible\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Select a random pair for swap\n        i = random.choice(included)\n        j = random.choice(excluded)\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        delta_weight = weight_lst[j] - weight_lst[i]\n\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistic flip of items based on potential improvement\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Check if removing this item is feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding this item is feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4916312567857951,
            10.080468833446503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low weights\n    archive.sort(key=lambda x: (-x[1][0] - x[1][1], np.sum(weight_lst[x[0] == 1])))\n    selected_solution = archive[0][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Swap two items (one included, one excluded) if feasible\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Select a random pair for swap\n        i = random.choice(included)\n        j = random.choice(excluded)\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        delta_weight = weight_lst[j] - weight_lst[i]\n\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistic flip of items based on potential improvement\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Check if removing this item is feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding this item is feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate improvement potential: sum of marginal gains per item\n    marginal_gains = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        potential_items = np.where((sol == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(potential_items) > 0:\n            marginal_value1 = np.sum(value1_lst[potential_items])\n            marginal_value2 = np.sum(value2_lst[potential_items])\n            marginal_gains.append((sol, marginal_value1 + marginal_value2))\n        else:\n            marginal_gains.append((sol, 0))\n\n    # Select solution with highest marginal gains\n    marginal_gains.sort(key=lambda x: -x[1])\n    base_solution = marginal_gains[0][0].copy()\n\n    # Step 2: Hybrid local search - Combine random swap and guided item addition\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Random swap: flip two random items\n    if np.random.rand() < 0.5:\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = np.random.choice(items, 2, replace=False)\n            new_weight = total_weight - weight_lst[i] + weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Guided addition: add highest marginal value item if possible\n    else:\n        remaining_capacity = capacity - total_weight\n        potential_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(potential_items) > 0:\n            # Calculate marginal gains for each potential item\n            marginal_values = (value1_lst[potential_items] + value2_lst[potential_items]) / weight_lst[potential_items]\n            best_item = potential_items[np.argmax(marginal_values)]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8458803527542957,
            6.468211382627487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate improvement potential: sum of marginal gains per item\n    marginal_gains = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        potential_items = np.where((sol == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(potential_items) > 0:\n            marginal_value1 = np.sum(value1_lst[potential_items])\n            marginal_value2 = np.sum(value2_lst[potential_items])\n            marginal_gains.append((sol, marginal_value1 + marginal_value2))\n        else:\n            marginal_gains.append((sol, 0))\n\n    # Select solution with highest marginal gains\n    marginal_gains.sort(key=lambda x: -x[1])\n    base_solution = marginal_gains[0][0].copy()\n\n    # Step 2: Hybrid local search - Combine random swap and guided item addition\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Random swap: flip two random items\n    if np.random.rand() < 0.5:\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = np.random.choice(items, 2, replace=False)\n            new_weight = total_weight - weight_lst[i] + weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Guided addition: add highest marginal value item if possible\n    else:\n        remaining_capacity = capacity - total_weight\n        potential_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(potential_items) > 0:\n            # Calculate marginal gains for each potential item\n            marginal_values = (value1_lst[potential_items] + value2_lst[potential_items]) / weight_lst[potential_items]\n            best_item = potential_items[np.argmax(marginal_values)]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search combining item swapping and random perturbation to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or flip random bits\n    if random.random() < 0.7:  # Higher probability for swapping\n        # Find items to swap (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items to swap\n            swap_in = random.choice(in_items)\n            swap_out = random.choice(out_items)\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n    else:\n        # Random perturbation: flip 1-3 random bits\n        flip_indices = random.sample(range(len(new_solution)), random.randint(1, 3))\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                # Check if removing this item keeps solution feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # Check if adding this item keeps solution feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.2899038393860003,
            7.945866644382477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or flip random bits\n    if random.random() < 0.7:  # Higher probability for swapping\n        # Find items to swap (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items to swap\n            swap_in = random.choice(in_items)\n            swap_out = random.choice(out_items)\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n    else:\n        # Random perturbation: flip 1-3 random bits\n        flip_indices = random.sample(range(len(new_solution)), random.randint(1, 3))\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                # Check if removing this item keeps solution feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # Check if adding this item keeps solution feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{A novel hybrid local search strategy intelligently selects a promising solution from the archive, applies a randomized item swap and swap-move operator to explore the solution space, and ensures feasibility by dynamically adjusting the neighborhood to avoid exceeding the capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: prioritize solutions with high combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid operator: Randomized item swap and swap-move\n    for _ in range(3):  # Perform multiple swaps to explore diverse neighbors\n        # Randomly select two items\n        i, j = random.sample(range(n_items), 2)\n\n        # Attempt to swap items i and j\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[temp_solution == 1])\n        if total_weight <= capacity:\n            new_solution = temp_solution\n            continue\n\n        # If swap fails, try swap-move: replace i with j if feasible\n        if new_solution[j] == 1 and new_solution[i] == 0:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_solution[j] = 0\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.4222216544602092,
            10.527281701564789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: prioritize solutions with high combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid operator: Randomized item swap and swap-move\n    for _ in range(3):  # Perform multiple swaps to explore diverse neighbors\n        # Randomly select two items\n        i, j = random.sample(range(n_items), 2)\n\n        # Attempt to swap items i and j\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[temp_solution == 1])\n        if total_weight <= capacity:\n            new_solution = temp_solution\n            continue\n\n        # If swap fails, try swap-move: replace i with j if feasible\n        if new_solution[j] == 1 and new_solution[i] == 0:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_solution[j] = 0\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0, len(archive)) / sum(np.linspace(1, 0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swapping and value-based perturbation\n    for _ in range(3):  # Perform multiple perturbations\n        # Identify items to potentially swap or flip\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            # Select a candidate item with higher probability for higher value items\n            probs = value1_lst[candidates] + value2_lst[candidates]\n            probs = probs / np.sum(probs)\n            item_idx = np.random.choice(candidates, p=probs)\n\n            # Flip the selected item\n            new_solution[item_idx] = 1 - new_solution[item_idx]\n\n            # Ensure feasibility by removing random items if capacity is exceeded\n            while np.sum(weight_lst[new_solution == 1]) > capacity:\n                excess_items = np.where(new_solution == 1)[0]\n                if len(excess_items) == 0:\n                    break\n                # Remove item with lowest value contribution\n                values = value1_lst[excess_items] + value2_lst[excess_items]\n                remove_idx = excess_items[np.argmin(values)]\n                new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9100052672536537,
            5.139431357383728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0, len(archive)) / sum(np.linspace(1, 0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swapping and value-based perturbation\n    for _ in range(3):  # Perform multiple perturbations\n        # Identify items to potentially swap or flip\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            # Select a candidate item with higher probability for higher value items\n            probs = value1_lst[candidates] + value2_lst[candidates]\n            probs = probs / np.sum(probs)\n            item_idx = np.random.choice(candidates, p=probs)\n\n            # Flip the selected item\n            new_solution[item_idx] = 1 - new_solution[item_idx]\n\n            # Ensure feasibility by removing random items if capacity is exceeded\n            while np.sum(weight_lst[new_solution == 1]) > capacity:\n                excess_items = np.where(new_solution == 1)[0]\n                if len(excess_items) == 0:\n                    break\n                # Remove item with lowest value contribution\n                values = value1_lst[excess_items] + value2_lst[excess_items]\n                remove_idx = excess_items[np.argmin(values)]\n                new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{A novel hybrid local search strategy combines adaptive neighborhood exploration with probabilistic item swapping, guided by objective-specific improvement metrics, to dynamically balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (higher potential = more room for improvement)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(x[0]) + 1e-6))\n        # Select a solution near the middle (not too extreme) for better exploration\n        base_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: probabilistic item swapping with objective-specific guidance\n    for _ in range(10):  # Number of local search steps\n        # Randomly select two items to swap (or flip)\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Calculate potential changes\n        if new_solution[item1] == 1:\n            delta_weight1 = -weight_lst[item1]\n            delta_value1 = -value1_lst[item1]\n            delta_value2 = -value2_lst[item1]\n        else:\n            delta_weight1 = weight_lst[item1]\n            delta_value1 = value1_lst[item1]\n            delta_value2 = value2_lst[item1]\n\n        if new_solution[item2] == 1:\n            delta_weight2 = -weight_lst[item2]\n            delta_value1 += -value1_lst[item2]\n            delta_value2 += -value2_lst[item2]\n        else:\n            delta_weight2 = weight_lst[item2]\n            delta_value1 += value1_lst[item2]\n            delta_value2 += value2_lst[item2]\n\n        total_delta_weight = delta_weight1 + delta_weight2\n\n        # Check feasibility and apply swap if beneficial\n        if current_weight + total_delta_weight <= capacity:\n            # Probabilistic acceptance based on potential improvement\n            if random.random() < 0.7:  # Higher chance for beneficial swaps\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += total_delta_weight\n            else:\n                # Random flip for diversification\n                if random.random() < 0.5:\n                    if new_solution[item1] == 1 and current_weight - weight_lst[item1] <= capacity:\n                        new_solution[item1] = 0\n                        current_weight -= weight_lst[item1]\n                    elif new_solution[item1] == 0 and current_weight + weight_lst[item1] <= capacity:\n                        new_solution[item1] = 1\n                        current_weight += weight_lst[item1]\n\n    return new_solution\n\n",
        "score": [
            -0.8880363794521988,
            3.8754407465457916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (higher potential = more room for improvement)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(x[0]) + 1e-6))\n        # Select a solution near the middle (not too extreme) for better exploration\n        base_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: probabilistic item swapping with objective-specific guidance\n    for _ in range(10):  # Number of local search steps\n        # Randomly select two items to swap (or flip)\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Calculate potential changes\n        if new_solution[item1] == 1:\n            delta_weight1 = -weight_lst[item1]\n            delta_value1 = -value1_lst[item1]\n            delta_value2 = -value2_lst[item1]\n        else:\n            delta_weight1 = weight_lst[item1]\n            delta_value1 = value1_lst[item1]\n            delta_value2 = value2_lst[item1]\n\n        if new_solution[item2] == 1:\n            delta_weight2 = -weight_lst[item2]\n            delta_value1 += -value1_lst[item2]\n            delta_value2 += -value2_lst[item2]\n        else:\n            delta_weight2 = weight_lst[item2]\n            delta_value1 += value1_lst[item2]\n            delta_value2 += value2_lst[item2]\n\n        total_delta_weight = delta_weight1 + delta_weight2\n\n        # Check feasibility and apply swap if beneficial\n        if current_weight + total_delta_weight <= capacity:\n            # Probabilistic acceptance based on potential improvement\n            if random.random() < 0.7:  # Higher chance for beneficial swaps\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += total_delta_weight\n            else:\n                # Random flip for diversification\n                if random.random() < 0.5:\n                    if new_solution[item1] == 1 and current_weight - weight_lst[item1] <= capacity:\n                        new_solution[item1] = 0\n                        current_weight -= weight_lst[item1]\n                    elif new_solution[item1] == 0 and current_weight + weight_lst[item1] <= capacity:\n                        new_solution[item1] = 1\n                        current_weight += weight_lst[item1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This algorithm selects a solution from the archive with the highest diversity in its neighborhood, then applies a hybrid local search combining item swaps and adaptive flips to explore high-potential regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in the neighborhood\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swaps and flips\n    n_items = len(base_solution)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Adaptive item swaps (swap items with high value ratios)\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2\n\n    # Identify top candidates for swaps\n    top_items = np.argsort(combined_ratio)[-min(5, n_items):]\n    for i in top_items:\n        if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            total_weight += weight_lst[i]\n        elif base_solution[i] == 1 and total_weight - weight_lst[i] + weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            total_weight -= weight_lst[i]\n\n    # Step 2: Adaptive flips (random flips with value-weighted probabilities)\n    flip_probs = combined_ratio / np.sum(combined_ratio)\n    for i in range(n_items):\n        if np.random.rand() < flip_probs[i] * 0.3:  # 30% chance to flip based on value\n            if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                total_weight += weight_lst[i]\n            elif base_solution[i] == 1 and total_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8543966033191874,
            5.0758363008499146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in the neighborhood\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swaps and flips\n    n_items = len(base_solution)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Adaptive item swaps (swap items with high value ratios)\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2\n\n    # Identify top candidates for swaps\n    top_items = np.argsort(combined_ratio)[-min(5, n_items):]\n    for i in top_items:\n        if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            total_weight += weight_lst[i]\n        elif base_solution[i] == 1 and total_weight - weight_lst[i] + weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            total_weight -= weight_lst[i]\n\n    # Step 2: Adaptive flips (random flips with value-weighted probabilities)\n    flip_probs = combined_ratio / np.sum(combined_ratio)\n    for i in range(n_items):\n        if np.random.rand() < flip_probs[i] * 0.3:  # 30% chance to flip based on value\n            if base_solution[i] == 0 and total_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                total_weight += weight_lst[i]\n            elif base_solution[i] == 1 and total_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values, then applies a hybrid local search combining item swaps and probabilistic flips to generate a feasible neighbor solution while exploring the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: swap items and flip with probability\n    for _ in range(3):  # Perform multiple operations\n        # Randomly select two items to swap\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic flip based on objective trade-off\n        if np.random.random() < 0.3:  # 30% chance to flip\n            k = np.random.randint(n_items)\n            if new_solution[k] == 1:\n                new_solution[k] = 0\n            else:\n                # Ensure weight constraint when adding\n                if np.sum(new_solution * weight_lst) + weight_lst[k] <= capacity:\n                    new_solution[k] = 1\n\n    # Ensure feasibility\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Remove random items until feasible\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break  # No items to remove\n        remove_idx = np.random.choice(candidates)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.37547269375707204,
            6.000889271497726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: swap items and flip with probability\n    for _ in range(3):  # Perform multiple operations\n        # Randomly select two items to swap\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic flip based on objective trade-off\n        if np.random.random() < 0.3:  # 30% chance to flip\n            k = np.random.randint(n_items)\n            if new_solution[k] == 1:\n                new_solution[k] = 0\n            else:\n                # Ensure weight constraint when adding\n                if np.sum(new_solution * weight_lst) + weight_lst[k] <= capacity:\n                    new_solution[k] = 1\n\n    # Ensure feasibility\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Remove random items until feasible\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break  # No items to remove\n        remove_idx = np.random.choice(candidates)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine item swaps and value-based flips\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for flipping\n    flip_candidates = np.where(base_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        if current_weight - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n            current_weight -= weight_lst[flip_idx]\n\n    # Step 2: Add items with high marginal value for either objective\n    zero_items = np.where(base_solution == 0)[0]\n    if len(zero_items) > 0:\n        # Compute marginal value for each objective\n        marginal_value1 = value1_lst[zero_items] / weight_lst[zero_items]\n        marginal_value2 = value2_lst[zero_items] / weight_lst[zero_items]\n\n        # Combine objectives using a weighted sum (random weights for diversity)\n        w1, w2 = np.random.random(), np.random.random()\n        combined_marginal = w1 * marginal_value1 + w2 * marginal_value2\n\n        # Select top-k items with highest combined marginal value\n        top_k = min(3, len(zero_items))\n        top_indices = np.argsort(combined_marginal)[-top_k:]\n\n        for idx in top_indices:\n            if current_weight + weight_lst[zero_items[idx]] <= capacity:\n                new_solution[zero_items[idx]] = 1\n                current_weight += weight_lst[zero_items[idx]]\n\n    return new_solution\n\n",
        "score": [
            -0.3415910629014608,
            2.224754184484482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine item swaps and value-based flips\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for flipping\n    flip_candidates = np.where(base_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        if current_weight - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n            current_weight -= weight_lst[flip_idx]\n\n    # Step 2: Add items with high marginal value for either objective\n    zero_items = np.where(base_solution == 0)[0]\n    if len(zero_items) > 0:\n        # Compute marginal value for each objective\n        marginal_value1 = value1_lst[zero_items] / weight_lst[zero_items]\n        marginal_value2 = value2_lst[zero_items] / weight_lst[zero_items]\n\n        # Combine objectives using a weighted sum (random weights for diversity)\n        w1, w2 = np.random.random(), np.random.random()\n        combined_marginal = w1 * marginal_value1 + w2 * marginal_value2\n\n        # Select top-k items with highest combined marginal value\n        top_k = min(3, len(zero_items))\n        top_indices = np.argsort(combined_marginal)[-top_k:]\n\n        for idx in top_indices:\n            if current_weight + weight_lst[zero_items[idx]] <= capacity:\n                new_solution[zero_items[idx]] = 1\n                current_weight += weight_lst[zero_items[idx]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if np.sum(sol) > 0.5 * len(sol)]  # Filter solutions with at least half items\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates)\n\n    # Generate a neighbor by selectively flipping items with high marginal utility\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items to consider for flipping (those not in the solution)\n    zero_indices = np.where(base_solution == 0)[0]\n    np.random.shuffle(zero_indices)\n\n    # Try adding items one by one if feasible\n    for idx in zero_indices:\n        if total_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            total_weight += weight_lst[idx]\n            break  # Only add one item at a time for simplicity\n\n    # Identify items to consider for removal (those in the solution)\n    one_indices = np.where(base_solution == 1)[0]\n    np.random.shuffle(one_indices)\n\n    # Try removing items one by one\n    for idx in one_indices:\n        if total_weight - weight_lst[idx] >= 0:  # Ensure no negative weight\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n            break  # Only remove one item at a time for simplicity\n\n    return new_solution\n\n",
        "score": [
            -0.7988792902826711,
            3.5579321086406708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if np.sum(sol) > 0.5 * len(sol)]  # Filter solutions with at least half items\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates)\n\n    # Generate a neighbor by selectively flipping items with high marginal utility\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items to consider for flipping (those not in the solution)\n    zero_indices = np.where(base_solution == 0)[0]\n    np.random.shuffle(zero_indices)\n\n    # Try adding items one by one if feasible\n    for idx in zero_indices:\n        if total_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            total_weight += weight_lst[idx]\n            break  # Only add one item at a time for simplicity\n\n    # Identify items to consider for removal (those in the solution)\n    one_indices = np.where(base_solution == 1)[0]\n    np.random.shuffle(one_indices)\n\n    # Try removing items one by one\n    for idx in one_indices:\n        if total_weight - weight_lst[idx] >= 0:  # Ensure no negative weight\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n            break  # Only remove one item at a time for simplicity\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search that intelligently flips a subset of items to balance the objectives while ensuring feasibility, using a combination of random and objective-driven flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high combined objective value\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Hybrid local search: flip items based on objective trade-offs\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, consider removing it if it doesn't improve objectives\n            if np.random.rand() < 0.3 or (value1_lst[idx] + value2_lst[idx]) < np.random.uniform(0, np.sum(value1_lst + value2_lst)):\n                new_weight = current_weight - weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n        else:\n            # If item is excluded, consider adding it if it improves objectives\n            if np.random.rand() < 0.7 or (value1_lst[idx] + value2_lst[idx]) > np.random.uniform(0, np.sum(value1_lst + value2_lst)):\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3091336463438362,
            2.2129288017749786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high combined objective value\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Hybrid local search: flip items based on objective trade-offs\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, consider removing it if it doesn't improve objectives\n            if np.random.rand() < 0.3 or (value1_lst[idx] + value2_lst[idx]) < np.random.uniform(0, np.sum(value1_lst + value2_lst)):\n                new_weight = current_weight - weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n        else:\n            # If item is excluded, consider adding it if it improves objectives\n            if np.random.rand() < 0.7 or (value1_lst[idx] + value2_lst[idx]) > np.random.uniform(0, np.sum(value1_lst + value2_lst)):\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search combining random item swaps and greedy value maximization to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined normalized objective value\n    def score(sol_obj):\n        sol, obj = sol_obj\n        total_weight = np.sum(weight_lst[sol == 1])\n        if total_weight > capacity:\n            return -np.inf\n        return (obj[0] + obj[1]) / (1 + 0.1 * total_weight)  # Penalize high weight\n\n    best_sol_obj = max(archive, key=score)\n    base_solution = best_sol_obj[0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: random swap with greedy value maximization\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Randomly swap a subset of items\n    if len(items) > 0:\n        swap_indices = random.sample(list(items), min(3, len(items)))\n        for idx in swap_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                # Greedily add the most valuable item that fits\n                remaining_capacity = capacity - current_weight\n                candidates = non_items[weight_lst[non_items] <= remaining_capacity]\n                if len(candidates) > 0:\n                    best_candidate = max(candidates, key=lambda x: value1_lst[x] + value2_lst[x])\n                    new_solution[best_candidate] = 1\n                    current_weight += weight_lst[best_candidate]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        # Remove the least valuable item\n        least_val_item = min(items_in, key=lambda x: value1_lst[x] + value2_lst[x])\n        new_solution[least_val_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.6622148518012417,
            5.358597278594971
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined normalized objective value\n    def score(sol_obj):\n        sol, obj = sol_obj\n        total_weight = np.sum(weight_lst[sol == 1])\n        if total_weight > capacity:\n            return -np.inf\n        return (obj[0] + obj[1]) / (1 + 0.1 * total_weight)  # Penalize high weight\n\n    best_sol_obj = max(archive, key=score)\n    base_solution = best_sol_obj[0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: random swap with greedy value maximization\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Randomly swap a subset of items\n    if len(items) > 0:\n        swap_indices = random.sample(list(items), min(3, len(items)))\n        for idx in swap_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                # Greedily add the most valuable item that fits\n                remaining_capacity = capacity - current_weight\n                candidates = non_items[weight_lst[non_items] <= remaining_capacity]\n                if len(candidates) > 0:\n                    best_candidate = max(candidates, key=lambda x: value1_lst[x] + value2_lst[x])\n                    new_solution[best_candidate] = 1\n                    current_weight += weight_lst[best_candidate]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        # Remove the least valuable item\n        least_val_item = min(items_in, key=lambda x: value1_lst[x] + value2_lst[x])\n        new_solution[least_val_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{The heuristic function intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swapping and targeted perturbation to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate the \"promise\" of each solution: sum of normalized objectives\n    max_val1 = max(obj[0] for _, obj in archive) if any(obj[0] for _, obj in archive) else 1.0\n    max_val2 = max(obj[1] for _, obj in archive) if any(obj[1] for _, obj in archive) else 1.0\n    promises = [(i, (obj[0] / max_val1 + obj[1] / max_val2) / 2) for i, (sol, obj) in enumerate(archive)]\n    selected_idx = max(promises, key=lambda x: x[1])[0] if random.random() < 0.7 else random.choice([x[0] for x in promises])\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Strategy: Perform a combination of item swapping and targeted perturbation\n    # - First, try to swap items to improve both objectives\n    # - Then, perturb the solution by flipping a few items to escape local optima\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Swap items to improve both objectives\n    if len(items_in) > 0 and len(items_out) > 0:\n        for _ in range(min(3, len(items_in), len(items_out))):  # Limit swaps to avoid excessive changes\n            in_item = random.choice(items_in)\n            out_item = random.choice(items_out)\n            # Check if swapping improves both objectives\n            if (value1_lst[in_item] < value1_lst[out_item] and value2_lst[in_item] < value2_lst[out_item]) or \\\n               (weight_lst[in_item] > weight_lst[out_item] and (value1_lst[in_item] + value2_lst[in_item]) < (value1_lst[out_item] + value2_lst[out_item])):\n                new_solution[in_item], new_solution[out_item] = new_solution[out_item], new_solution[in_item]\n\n    # Perturbation: Flip a few items to escape local optima\n    num_flips = min(2, len(new_solution))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items with lowest (value1 + value2) until feasible\n        while total_weight > capacity:\n            if np.sum(new_solution) == 0:\n                break\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            item_to_remove = min(items_in, key=lambda i: value1_lst[i] + value2_lst[i])\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.334212984885086,
            3.782688856124878
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate the \"promise\" of each solution: sum of normalized objectives\n    max_val1 = max(obj[0] for _, obj in archive) if any(obj[0] for _, obj in archive) else 1.0\n    max_val2 = max(obj[1] for _, obj in archive) if any(obj[1] for _, obj in archive) else 1.0\n    promises = [(i, (obj[0] / max_val1 + obj[1] / max_val2) / 2) for i, (sol, obj) in enumerate(archive)]\n    selected_idx = max(promises, key=lambda x: x[1])[0] if random.random() < 0.7 else random.choice([x[0] for x in promises])\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Strategy: Perform a combination of item swapping and targeted perturbation\n    # - First, try to swap items to improve both objectives\n    # - Then, perturb the solution by flipping a few items to escape local optima\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Swap items to improve both objectives\n    if len(items_in) > 0 and len(items_out) > 0:\n        for _ in range(min(3, len(items_in), len(items_out))):  # Limit swaps to avoid excessive changes\n            in_item = random.choice(items_in)\n            out_item = random.choice(items_out)\n            # Check if swapping improves both objectives\n            if (value1_lst[in_item] < value1_lst[out_item] and value2_lst[in_item] < value2_lst[out_item]) or \\\n               (weight_lst[in_item] > weight_lst[out_item] and (value1_lst[in_item] + value2_lst[in_item]) < (value1_lst[out_item] + value2_lst[out_item])):\n                new_solution[in_item], new_solution[out_item] = new_solution[out_item], new_solution[in_item]\n\n    # Perturbation: Flip a few items to escape local optima\n    num_flips = min(2, len(new_solution))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items with lowest (value1 + value2) until feasible\n        while total_weight > capacity:\n            if np.sum(new_solution) == 0:\n                break\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            item_to_remove = min(items_in, key=lambda i: value1_lst[i] + value2_lst[i])\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by evaluating marginal gains in both objectives, then applies a hybrid local search combining random flips and targeted swaps to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Evaluate potential improvement for each solution\n    potential_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        # Calculate marginal gains for items not in the solution\n        marginal_gains = (value1_lst + value2_lst) * (1 - sol)\n        # Score based on potential gains and remaining capacity\n        score = np.sum(marginal_gains * (weight_lst <= remaining_capacity))\n        potential_scores.append(score)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Random flip with probability based on potential\n    flip_prob = min(0.5, 0.1 + potential_scores[selected_idx] / (np.sum(value1_lst + value2_lst) * 0.5))\n    for i in range(n_items):\n        if random.random() < flip_prob:\n            if new_solution[i] == 0 and (np.sum(weight_lst * new_solution) + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n\n    # Targeted swap for better marginal gains\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    # Find items not in solution with good marginal gains\n    candidate_items = np.where((1 - new_solution) * (weight_lst <= remaining_capacity))[0]\n    if len(candidate_items) > 0:\n        # Select top 20% by marginal gain\n        marginal_gains = (value1_lst + value2_lst)[candidate_items]\n        top_items = candidate_items[np.argsort(marginal_gains)[-max(1, len(candidate_items) // 5):]]\n        # Randomly select one to add\n        if len(top_items) > 0:\n            item_to_add = random.choice(top_items)\n            new_solution[item_to_add] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random item to make feasible\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        item_to_remove = random.choice(included_items)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.364978310438915,
            7.895915985107422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Evaluate potential improvement for each solution\n    potential_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        # Calculate marginal gains for items not in the solution\n        marginal_gains = (value1_lst + value2_lst) * (1 - sol)\n        # Score based on potential gains and remaining capacity\n        score = np.sum(marginal_gains * (weight_lst <= remaining_capacity))\n        potential_scores.append(score)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Random flip with probability based on potential\n    flip_prob = min(0.5, 0.1 + potential_scores[selected_idx] / (np.sum(value1_lst + value2_lst) * 0.5))\n    for i in range(n_items):\n        if random.random() < flip_prob:\n            if new_solution[i] == 0 and (np.sum(weight_lst * new_solution) + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n\n    # Targeted swap for better marginal gains\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    # Find items not in solution with good marginal gains\n    candidate_items = np.where((1 - new_solution) * (weight_lst <= remaining_capacity))[0]\n    if len(candidate_items) > 0:\n        # Select top 20% by marginal gain\n        marginal_gains = (value1_lst + value2_lst)[candidate_items]\n        top_items = candidate_items[np.argsort(marginal_gains)[-max(1, len(candidate_items) // 5):]]\n        # Randomly select one to add\n        if len(top_items) > 0:\n            item_to_add = random.choice(top_items)\n            new_solution[item_to_add] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random item to make feasible\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        item_to_remove = random.choice(included_items)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search combining random swaps and greedy improvements to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance counts for each solution\n    dominance_counts = np.zeros(len(archive))\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j:\n                if obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                    dominance_counts[i] += 1\n\n    # Select solutions with high objective values and low dominance counts\n    candidates = []\n    for idx, (sol, obj) in enumerate(archive):\n        if dominance_counts[idx] == 0:  # Non-dominated solutions\n            candidates.append((idx, obj[0] + obj[1]))  # Sum of objectives as score\n\n    if not candidates:\n        candidates = [(idx, obj[0] + obj[1]) for idx, (sol, obj) in enumerate(archive)]\n\n    # Select the solution with the highest score\n    selected_idx = max(candidates, key=lambda x: x[1])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to flip (1-3 items)\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        if new_solution[idx] == 1:\n            # If item is included, try removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # If item is excluded, try adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Additional greedy improvement: add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    for idx in remaining_items:\n        new_weight = current_weight + weight_lst[idx]\n        if new_weight <= capacity:\n            # Check if adding the item improves both objectives\n            if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9774837863281409,
            3.476837158203125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance counts for each solution\n    dominance_counts = np.zeros(len(archive))\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j:\n                if obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                    dominance_counts[i] += 1\n\n    # Select solutions with high objective values and low dominance counts\n    candidates = []\n    for idx, (sol, obj) in enumerate(archive):\n        if dominance_counts[idx] == 0:  # Non-dominated solutions\n            candidates.append((idx, obj[0] + obj[1]))  # Sum of objectives as score\n\n    if not candidates:\n        candidates = [(idx, obj[0] + obj[1]) for idx, (sol, obj) in enumerate(archive)]\n\n    # Select the solution with the highest score\n    selected_idx = max(candidates, key=lambda x: x[1])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to flip (1-3 items)\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        if new_solution[idx] == 1:\n            # If item is included, try removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # If item is excluded, try adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Additional greedy improvement: add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    for idx in remaining_items:\n        new_weight = current_weight + weight_lst[idx]\n        if new_weight <= capacity:\n            # Check if adding the item improves both objectives\n            if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search combining random swaps and greedy improvements to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance counts for each solution\n    dominance_counts = np.zeros(len(archive))\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j:\n                if obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                    dominance_counts[i] += 1\n\n    # Select solutions with high objective values and low dominance counts\n    candidates = []\n    for idx, (sol, obj) in enumerate(archive):\n        if dominance_counts[idx] == 0:  # Non-dominated solutions\n            candidates.append((idx, obj[0] + obj[1]))  # Sum of objectives as score\n\n    if not candidates:\n        candidates = [(idx, obj[0] + obj[1]) for idx, (sol, obj) in enumerate(archive)]\n\n    # Select the solution with the highest score\n    selected_idx = max(candidates, key=lambda x: x[1])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to flip (1-3 items)\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        if new_solution[idx] == 1:\n            # If item is included, try removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # If item is excluded, try adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Additional greedy improvement: add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    for idx in remaining_items:\n        new_weight = current_weight + weight_lst[idx]\n        if new_weight <= capacity:\n            # Check if adding the item improves both objectives\n            if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9774837863281409,
            3.476837158203125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance counts for each solution\n    dominance_counts = np.zeros(len(archive))\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j:\n                if obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                    dominance_counts[i] += 1\n\n    # Select solutions with high objective values and low dominance counts\n    candidates = []\n    for idx, (sol, obj) in enumerate(archive):\n        if dominance_counts[idx] == 0:  # Non-dominated solutions\n            candidates.append((idx, obj[0] + obj[1]))  # Sum of objectives as score\n\n    if not candidates:\n        candidates = [(idx, obj[0] + obj[1]) for idx, (sol, obj) in enumerate(archive)]\n\n    # Select the solution with the highest score\n    selected_idx = max(candidates, key=lambda x: x[1])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to flip (1-3 items)\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        if new_solution[idx] == 1:\n            # If item is included, try removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # If item is excluded, try adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Additional greedy improvement: add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    for idx in remaining_items:\n        new_weight = current_weight + weight_lst[idx]\n        if new_weight <= capacity:\n            # Check if adding the item improves both objectives\n            if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_margin = -1\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        margin = capacity - total_weight\n        if margin > max_margin:\n            max_margin = margin\n            selected_solution = sol\n\n    if selected_solution is None:\n        return archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Flip a random subset of items with high marginal value\n    # Calculate marginal values for each item\n    marginal_values = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n\n    # Select items with high marginal value to flip\n    high_value_items = np.argsort(marginal_values)[-len(marginal_values)//3:]  # Top 1/3 items\n    flip_indices = np.random.choice(high_value_items, size=min(3, len(high_value_items)), replace=False)\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the item\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess_weight = total_weight - capacity\n        while excess_weight > 0:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.34015888563741614,
            2.2737667858600616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_margin = -1\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        margin = capacity - total_weight\n        if margin > max_margin:\n            max_margin = margin\n            selected_solution = sol\n\n    if selected_solution is None:\n        return archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Flip a random subset of items with high marginal value\n    # Calculate marginal values for each item\n    marginal_values = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n\n    # Select items with high marginal value to flip\n    high_value_items = np.argsort(marginal_values)[-len(marginal_values)//3:]  # Top 1/3 items\n    flip_indices = np.random.choice(high_value_items, size=min(3, len(high_value_items)), replace=False)\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the item\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess_weight = total_weight - capacity\n        while excess_weight > 0:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search that combines item swaps and probabilistic flips to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Hybrid local search: item swaps and probabilistic flips\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Perform item swaps (flip two items)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        i, j = random.sample(list(swap_candidates), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Check feasibility\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Revert\n\n    # Step 2: Probabilistic flip of items (add/remove with probability)\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.2954517975824277,
            1.7769840359687805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Hybrid local search: item swaps and probabilistic flips\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Perform item swaps (flip two items)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        i, j = random.sample(list(swap_candidates), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Check feasibility\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Revert\n\n    # Step 2: Probabilistic flip of items (add/remove with probability)\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search that combines item swaps and probabilistic flips to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Hybrid local search: item swaps and probabilistic flips\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Perform item swaps (flip two items)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        i, j = random.sample(list(swap_candidates), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Check feasibility\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Revert\n\n    # Step 2: Probabilistic flip of items (add/remove with probability)\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.2954517975824277,
            1.7769840359687805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Hybrid local search: item swaps and probabilistic flips\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Perform item swaps (flip two items)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        i, j = random.sample(list(swap_candidates), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Check feasibility\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Revert\n\n    # Step 2: Probabilistic flip of items (add/remove with probability)\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_value1, base_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Generate neighbor by flipping items with high marginal gain\n    new_solution = base_solution.copy()\n    candidates = np.where(base_solution == 0)[0]  # Items not in the solution\n    if len(candidates) > 0:\n        # Calculate marginal gains for each candidate\n        marginal_gains1 = value1_lst[candidates] / weight_lst[candidates]\n        marginal_gains2 = value2_lst[candidates] / weight_lst[candidates]\n        combined_gains = marginal_gains1 + marginal_gains2  # Hybrid gain metric\n\n        # Select top 20% candidates by combined gain\n        top_candidates = candidates[np.argsort(combined_gains)[-max(1, len(candidates) // 5):]]\n\n        # Randomly select one from top candidates\n        selected_item = np.random.choice(top_candidates)\n        if current_weight + weight_lst[selected_item] <= capacity:\n            new_solution[selected_item] = 1\n\n    # Consider removing low-value items\n    included_items = np.where(base_solution == 1)[0]\n    if len(included_items) > 0:\n        # Calculate marginal losses for each included item\n        marginal_losses1 = value1_lst[included_items] / weight_lst[included_items]\n        marginal_losses2 = value2_lst[included_items] / weight_lst[included_items]\n        combined_losses = marginal_losses1 + marginal_losses2\n\n        # Select bottom 20% items by combined loss\n        bottom_items = included_items[np.argsort(combined_losses)[:max(1, len(included_items) // 5)]]\n\n        # Randomly select one from bottom items\n        selected_item = np.random.choice(bottom_items)\n        new_solution[selected_item] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove random item if over capacity\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            remove_item = np.random.choice(included_items)\n            new_solution[remove_item] = 0\n        else:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8276118645881202,
            3.443925201892853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_value1, base_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Generate neighbor by flipping items with high marginal gain\n    new_solution = base_solution.copy()\n    candidates = np.where(base_solution == 0)[0]  # Items not in the solution\n    if len(candidates) > 0:\n        # Calculate marginal gains for each candidate\n        marginal_gains1 = value1_lst[candidates] / weight_lst[candidates]\n        marginal_gains2 = value2_lst[candidates] / weight_lst[candidates]\n        combined_gains = marginal_gains1 + marginal_gains2  # Hybrid gain metric\n\n        # Select top 20% candidates by combined gain\n        top_candidates = candidates[np.argsort(combined_gains)[-max(1, len(candidates) // 5):]]\n\n        # Randomly select one from top candidates\n        selected_item = np.random.choice(top_candidates)\n        if current_weight + weight_lst[selected_item] <= capacity:\n            new_solution[selected_item] = 1\n\n    # Consider removing low-value items\n    included_items = np.where(base_solution == 1)[0]\n    if len(included_items) > 0:\n        # Calculate marginal losses for each included item\n        marginal_losses1 = value1_lst[included_items] / weight_lst[included_items]\n        marginal_losses2 = value2_lst[included_items] / weight_lst[included_items]\n        combined_losses = marginal_losses1 + marginal_losses2\n\n        # Select bottom 20% items by combined loss\n        bottom_items = included_items[np.argsort(combined_losses)[:max(1, len(included_items) // 5)]]\n\n        # Randomly select one from bottom items\n        selected_item = np.random.choice(bottom_items)\n        new_solution[selected_item] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove random item if over capacity\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            remove_item = np.random.choice(included_items)\n            new_solution[remove_item] = 0\n        else:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating the diversity and non-dominated status of solutions, then applies a hybrid local search combining item swaps, multi-objective guided flips, and capacity-aware perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Multi-objective guided flip (flip items with high marginal value)\n    for _ in range(min(3, len(base_solution))):\n        # Calculate marginal values\n        marginal_value1 = value1_lst - (base_solution * value1_lst)\n        marginal_value2 = value2_lst - (base_solution * value2_lst)\n        # Combine objectives using a random weight\n        alpha = random.random()\n        combined_marginal = alpha * marginal_value1 + (1 - alpha) * marginal_value2\n\n        # Select items to flip\n        candidate_indices = np.argsort(combined_marginal)[-min(5, len(base_solution)):]\n        for idx in candidate_indices:\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Step 2: Capacity-aware perturbation (add/remove items near capacity)\n    if current_weight < capacity * 0.95:\n        # Try to add items\n        available_items = np.where((base_solution == 0) & (weight_lst <= capacity - current_weight))[0]\n        if len(available_items) > 0:\n            selected_item = random.choice(available_items)\n            new_solution[selected_item] = 1\n    else:\n        # Try to remove items\n        included_items = np.where(base_solution == 1)[0]\n        if len(included_items) > 0:\n            selected_item = random.choice(included_items)\n            new_solution[selected_item] = 0\n\n    # Step 3: Random swap for diversity\n    if random.random() < 0.3:\n        item1, item2 = random.sample(range(len(base_solution)), 2)\n        if (base_solution[item1] != base_solution[item2] and\n            abs(weight_lst[item1] - weight_lst[item2]) <= capacity - current_weight):\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n",
        "score": [
            -0.8960008733693853,
            3.122494727373123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Multi-objective guided flip (flip items with high marginal value)\n    for _ in range(min(3, len(base_solution))):\n        # Calculate marginal values\n        marginal_value1 = value1_lst - (base_solution * value1_lst)\n        marginal_value2 = value2_lst - (base_solution * value2_lst)\n        # Combine objectives using a random weight\n        alpha = random.random()\n        combined_marginal = alpha * marginal_value1 + (1 - alpha) * marginal_value2\n\n        # Select items to flip\n        candidate_indices = np.argsort(combined_marginal)[-min(5, len(base_solution)):]\n        for idx in candidate_indices:\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Step 2: Capacity-aware perturbation (add/remove items near capacity)\n    if current_weight < capacity * 0.95:\n        # Try to add items\n        available_items = np.where((base_solution == 0) & (weight_lst <= capacity - current_weight))[0]\n        if len(available_items) > 0:\n            selected_item = random.choice(available_items)\n            new_solution[selected_item] = 1\n    else:\n        # Try to remove items\n        included_items = np.where(base_solution == 1)[0]\n        if len(included_items) > 0:\n            selected_item = random.choice(included_items)\n            new_solution[selected_item] = 0\n\n    # Step 3: Random swap for diversity\n    if random.random() < 0.3:\n        item1, item2 = random.sample(range(len(base_solution)), 2)\n        if (base_solution[item1] != base_solution[item2] and\n            abs(weight_lst[item1] - weight_lst[item2]) <= capacity - current_weight):\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This algorithm selects a promising solution from the archive by identifying those with high potential for improvement, then applies a hybrid local search operator that combines adaptive item swaps and neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with high potential for improvement\n    selected_sol = None\n    max_potential = -1\n\n    for sol, _ in archive:\n        # Calculate potential as the sum of normalized value1 and value2 for items not in the solution\n        potential = np.sum((value1_lst + value2_lst) * (1 - sol))\n        if potential > max_potential:\n            max_potential = potential\n            selected_sol = sol.copy()\n\n    if selected_sol is None:\n        selected_sol = archive[0][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = selected_sol.copy()\n    current_weight = np.sum(weight_lst * selected_sol)\n\n    # Adaptive item swaps: try to swap items to improve both objectives\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Select a random item to consider swapping\n        idx = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Neighborhood exploration: try to replace items with better alternatives\n    for _ in range(5):\n        # Find items not in the solution\n        not_in_sol = np.where(new_solution == 0)[0]\n        if len(not_in_sol) == 0:\n            break\n\n        # Find items in the solution\n        in_sol = np.where(new_solution == 1)[0]\n        if len(in_sol) == 0:\n            break\n\n        # Select a random item to remove and a random item to add\n        remove_idx = random.choice(in_sol)\n        add_idx = random.choice(not_in_sol)\n\n        # Check feasibility\n        if (current_weight - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n            current_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.921067237847967,
            3.994694620370865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with high potential for improvement\n    selected_sol = None\n    max_potential = -1\n\n    for sol, _ in archive:\n        # Calculate potential as the sum of normalized value1 and value2 for items not in the solution\n        potential = np.sum((value1_lst + value2_lst) * (1 - sol))\n        if potential > max_potential:\n            max_potential = potential\n            selected_sol = sol.copy()\n\n    if selected_sol is None:\n        selected_sol = archive[0][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = selected_sol.copy()\n    current_weight = np.sum(weight_lst * selected_sol)\n\n    # Adaptive item swaps: try to swap items to improve both objectives\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Select a random item to consider swapping\n        idx = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Neighborhood exploration: try to replace items with better alternatives\n    for _ in range(5):\n        # Find items not in the solution\n        not_in_sol = np.where(new_solution == 0)[0]\n        if len(not_in_sol) == 0:\n            break\n\n        # Find items in the solution\n        in_sol = np.where(new_solution == 1)[0]\n        if len(in_sol) == 0:\n            break\n\n        # Select a random item to remove and a random item to add\n        remove_idx = random.choice(in_sol)\n        add_idx = random.choice(not_in_sol)\n\n        # Check feasibility\n        if (current_weight - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n            current_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search strategy combining random perturbation and greedy improvement\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to perturb\n    perturb_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in perturb_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Greedy improvement: try to add items that improve both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate potential gains for each item not in the solution\n        potential_gains = (value1_lst + value2_lst) * (1 - new_solution)\n        feasible_items = (weight_lst <= remaining_capacity) & (new_solution == 0)\n\n        if np.any(feasible_items):\n            best_item = np.argmax(potential_gains * feasible_items)\n            new_solution[best_item] = 1\n\n    # Ensure feasibility by removing items if over capacity\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the item with the smallest ratio of (value1 + value2) / weight\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        worst_item = included_items[np.argmin(ratios)]\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3286697124290623,
            2.372077912092209
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search strategy combining random perturbation and greedy improvement\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to perturb\n    perturb_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in perturb_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Greedy improvement: try to add items that improve both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate potential gains for each item not in the solution\n        potential_gains = (value1_lst + value2_lst) * (1 - new_solution)\n        feasible_items = (weight_lst <= remaining_capacity) & (new_solution == 0)\n\n        if np.any(feasible_items):\n            best_item = np.argmax(potential_gains * feasible_items)\n            new_solution[best_item] = 1\n\n    # Ensure feasibility by removing items if over capacity\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the item with the smallest ratio of (value1 + value2) / weight\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        worst_item = included_items[np.argmin(ratios)]\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{A novel hybrid local search strategy combines a randomized diversification step with a targeted intensification phase, where items are probabilistically swapped based on their marginal contributions to both objectives, ensuring feasibility while exploring the trade-off space more effectively than standard methods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[np.sum(archive[i][0] * (value1_lst + value2_lst)) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic swap and marginal contribution-based flip\n    for _ in range(5):  # Number of iterations\n        # Randomly select two items for potential swap\n        i, j = random.sample(range(len(base_solution)), 2)\n\n        # Calculate marginal contributions\n        current_weight = np.sum(base_solution * weight_lst)\n        if base_solution[i] == 1:\n            marginal_i = -(weight_lst[i] if current_weight - weight_lst[i] + weight_lst[j] <= capacity else 0)\n        else:\n            marginal_i = weight_lst[i] if current_weight + weight_lst[i] - weight_lst[j] <= capacity else 0\n\n        if base_solution[j] == 1:\n            marginal_j = -(weight_lst[j] if current_weight - weight_lst[j] + weight_lst[i] <= capacity else 0)\n        else:\n            marginal_j = weight_lst[j] if current_weight + weight_lst[j] - weight_lst[i] <= capacity else 0\n\n        # Probabilistic swap based on marginal contributions\n        if (marginal_i + marginal_j) > 0 and random.random() < 0.7:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Marginal contribution-based flip\n        for k in range(len(base_solution)):\n            if random.random() < 0.3:  # Probability of flipping\n                if base_solution[k] == 1:\n                    if current_weight - weight_lst[k] <= capacity:\n                        new_solution[k] = 0\n                else:\n                    if current_weight + weight_lst[k] <= capacity:\n                        new_solution[k] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8759011993790699,
            7.30219429731369
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[np.sum(archive[i][0] * (value1_lst + value2_lst)) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic swap and marginal contribution-based flip\n    for _ in range(5):  # Number of iterations\n        # Randomly select two items for potential swap\n        i, j = random.sample(range(len(base_solution)), 2)\n\n        # Calculate marginal contributions\n        current_weight = np.sum(base_solution * weight_lst)\n        if base_solution[i] == 1:\n            marginal_i = -(weight_lst[i] if current_weight - weight_lst[i] + weight_lst[j] <= capacity else 0)\n        else:\n            marginal_i = weight_lst[i] if current_weight + weight_lst[i] - weight_lst[j] <= capacity else 0\n\n        if base_solution[j] == 1:\n            marginal_j = -(weight_lst[j] if current_weight - weight_lst[j] + weight_lst[i] <= capacity else 0)\n        else:\n            marginal_j = weight_lst[j] if current_weight + weight_lst[j] - weight_lst[i] <= capacity else 0\n\n        # Probabilistic swap based on marginal contributions\n        if (marginal_i + marginal_j) > 0 and random.random() < 0.7:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Marginal contribution-based flip\n        for k in range(len(base_solution)):\n            if random.random() < 0.3:  # Probability of flipping\n                if base_solution[k] == 1:\n                    if current_weight - weight_lst[k] <= capacity:\n                        new_solution[k] = 0\n                else:\n                    if current_weight + weight_lst[k] <= capacity:\n                        new_solution[k] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, applies a combination of item swapping, probabilistic flipping, and targeted insertion to generate high-quality neighbors while ensuring feasibility through dynamic weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high objective diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj1 + obj2) for (sol, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of swapping, flipping, and insertion\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Probabilistic flipping of items\n    flip_prob = 0.3\n    for i in range(n_items):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                if current_weight > weight_lst[i]:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Targeted swapping of items\n    swap_candidates = np.where((base_solution == 1) & (new_solution == 0))[0]\n    if len(swap_candidates) > 0:\n        swap_idx = random.choice(swap_candidates)\n        if current_weight + weight_lst[swap_idx] <= capacity:\n            new_solution[swap_idx] = 1\n            current_weight += weight_lst[swap_idx]\n\n    # Step 3: Dynamic insertion of items\n    insertion_candidates = np.where((base_solution == 0) & (new_solution == 0))[0]\n    if len(insertion_candidates) > 0:\n        # Prioritize items with high combined value\n        candidate_values = value1_lst[insertion_candidates] + value2_lst[insertion_candidates]\n        sorted_indices = np.argsort(candidate_values)[::-1]\n        for idx in sorted_indices:\n            item_idx = insertion_candidates[idx]\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.3572944006366727,
            2.6520915031433105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high objective diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj1 + obj2) for (sol, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of swapping, flipping, and insertion\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Probabilistic flipping of items\n    flip_prob = 0.3\n    for i in range(n_items):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                if current_weight > weight_lst[i]:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Targeted swapping of items\n    swap_candidates = np.where((base_solution == 1) & (new_solution == 0))[0]\n    if len(swap_candidates) > 0:\n        swap_idx = random.choice(swap_candidates)\n        if current_weight + weight_lst[swap_idx] <= capacity:\n            new_solution[swap_idx] = 1\n            current_weight += weight_lst[swap_idx]\n\n    # Step 3: Dynamic insertion of items\n    insertion_candidates = np.where((base_solution == 0) & (new_solution == 0))[0]\n    if len(insertion_candidates) > 0:\n        # Prioritize items with high combined value\n        candidate_values = value1_lst[insertion_candidates] + value2_lst[insertion_candidates]\n        sorted_indices = np.argsort(candidate_values)[::-1]\n        for idx in sorted_indices:\n            item_idx = insertion_candidates[idx]\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining item swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on objective values and weight utilization\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    archive_weights = [np.sum(weight_lst[sol == 1]) for sol in archive_solutions]\n\n    # Prioritize solutions with high objective values and low weight utilization\n    scores = []\n    for i in range(len(archive_solutions)):\n        obj1, obj2 = archive_objectives[i]\n        weight_util = archive_weights[i] / capacity\n        score = (obj1 + obj2) / (1 + weight_util)  # Balance between objectives and weight\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swap, adaptive flip, and weight-based flip\n    n_items = len(base_solution)\n    if n_items == 0:\n        return new_solution\n\n    # Random swap\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Check feasibility after swap\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Revert swap if infeasible\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive flip: flip items based on their marginal contribution\n    for _ in range(2):  # Perform a few flips\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            i = random.randint(0, n_items - 1)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n\n    # Weight-based flip: prioritize flipping items with high value/weight ratio\n    if n_items > 0:\n        value_weight_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(-value_weight_ratios)  # Descending order\n        for i in sorted_indices:\n            if new_solution[i] == 0:\n                new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    break\n            elif new_solution[i] == 1:\n                new_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.44988458186009095,
            2.156894773244858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on objective values and weight utilization\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    archive_weights = [np.sum(weight_lst[sol == 1]) for sol in archive_solutions]\n\n    # Prioritize solutions with high objective values and low weight utilization\n    scores = []\n    for i in range(len(archive_solutions)):\n        obj1, obj2 = archive_objectives[i]\n        weight_util = archive_weights[i] / capacity\n        score = (obj1 + obj2) / (1 + weight_util)  # Balance between objectives and weight\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swap, adaptive flip, and weight-based flip\n    n_items = len(base_solution)\n    if n_items == 0:\n        return new_solution\n\n    # Random swap\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Check feasibility after swap\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Revert swap if infeasible\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive flip: flip items based on their marginal contribution\n    for _ in range(2):  # Perform a few flips\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            i = random.randint(0, n_items - 1)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n\n    # Weight-based flip: prioritize flipping items with high value/weight ratio\n    if n_items > 0:\n        value_weight_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(-value_weight_ratios)  # Descending order\n        for i in sorted_indices:\n            if new_solution[i] == 0:\n                new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    break\n            elif new_solution[i] == 1:\n                new_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search combining item swapping and dynamic subset replacement to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive (high objective values and low crowding distance)\n    selected_idx = 0\n    max_sum = -1\n    for i, (sol, obj) in enumerate(archive):\n        current_sum = obj[0] + obj[1]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly swap a subset of items\n    swap_mask = np.random.rand(n_items) < 0.3  # 30% chance to swap\n    new_solution[swap_mask] = 1 - new_solution[swap_mask]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Step 2: Dynamically replace items to reduce weight\n        excess_weight = total_weight - capacity\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            # Sort by weight/value ratio for both objectives\n            ratio1 = weight_lst[candidate_items] / value1_lst[candidate_items]\n            ratio2 = weight_lst[candidate_items] / value2_lst[candidate_items]\n            combined_ratio = ratio1 + ratio2\n            sorted_indices = np.argsort(combined_ratio)[::-1]  # Descending order\n            for idx in sorted_indices:\n                if excess_weight <= 0:\n                    break\n                item_idx = candidate_items[idx]\n                new_solution[item_idx] = 0\n                excess_weight -= weight_lst[item_idx]\n\n    # Step 3: Randomly add items if capacity allows\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            # Sort by combined value/weight ratio\n            ratio1 = value1_lst[available_items] / weight_lst[available_items]\n            ratio2 = value2_lst[available_items] / weight_lst[available_items]\n            combined_ratio = ratio1 + ratio2\n            sorted_indices = np.argsort(combined_ratio)[::-1]\n            for idx in sorted_indices:\n                item_idx = available_items[idx]\n                if weight_lst[item_idx] <= remaining_capacity:\n                    new_solution[item_idx] = 1\n                    remaining_capacity -= weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.36682294238814317,
            2.8113036155700684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive (high objective values and low crowding distance)\n    selected_idx = 0\n    max_sum = -1\n    for i, (sol, obj) in enumerate(archive):\n        current_sum = obj[0] + obj[1]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly swap a subset of items\n    swap_mask = np.random.rand(n_items) < 0.3  # 30% chance to swap\n    new_solution[swap_mask] = 1 - new_solution[swap_mask]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Step 2: Dynamically replace items to reduce weight\n        excess_weight = total_weight - capacity\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            # Sort by weight/value ratio for both objectives\n            ratio1 = weight_lst[candidate_items] / value1_lst[candidate_items]\n            ratio2 = weight_lst[candidate_items] / value2_lst[candidate_items]\n            combined_ratio = ratio1 + ratio2\n            sorted_indices = np.argsort(combined_ratio)[::-1]  # Descending order\n            for idx in sorted_indices:\n                if excess_weight <= 0:\n                    break\n                item_idx = candidate_items[idx]\n                new_solution[item_idx] = 0\n                excess_weight -= weight_lst[item_idx]\n\n    # Step 3: Randomly add items if capacity allows\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            # Sort by combined value/weight ratio\n            ratio1 = value1_lst[available_items] / weight_lst[available_items]\n            ratio2 = value2_lst[available_items] / weight_lst[available_items]\n            combined_ratio = ratio1 + ratio2\n            sorted_indices = np.argsort(combined_ratio)[::-1]\n            for idx in sorted_indices:\n                item_idx = available_items[idx]\n                if weight_lst[item_idx] <= remaining_capacity:\n                    new_solution[item_idx] = 1\n                    remaining_capacity -= weight_lst[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{My novel local search algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid strategy combining random flip and greedy selection to explore neighboring solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (prioritize those with higher potential)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Randomly select from top 30% of solutions\n        top_k = max(1, len(sorted_archive) // 3)\n        selected_idx = random.randint(0, top_k - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip with greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider flipping\n    flip_indices = random.sample(range(n_items), min(5, n_items))\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = current_weight - weight_lst[idx]\n\n            if temp_weight <= capacity:\n                # Calculate improvement in both objectives\n                v1_improvement = value1_lst[idx]\n                v2_improvement = value2_lst[idx]\n\n                # Accept if it improves at least one objective\n                if v1_improvement > 0 or v2_improvement > 0:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate improvement in both objectives\n                v1_improvement = value1_lst[idx]\n                v2_improvement = value2_lst[idx]\n\n                # Accept if it improves at least one objective\n                if v1_improvement > 0 or v2_improvement > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2786349971599642,
            1.3932369947433472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (prioritize those with higher potential)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Randomly select from top 30% of solutions\n        top_k = max(1, len(sorted_archive) // 3)\n        selected_idx = random.randint(0, top_k - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip with greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider flipping\n    flip_indices = random.sample(range(n_items), min(5, n_items))\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = current_weight - weight_lst[idx]\n\n            if temp_weight <= capacity:\n                # Calculate improvement in both objectives\n                v1_improvement = value1_lst[idx]\n                v2_improvement = value2_lst[idx]\n\n                # Accept if it improves at least one objective\n                if v1_improvement > 0 or v2_improvement > 0:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate improvement in both objectives\n                v1_improvement = value1_lst[idx]\n                v2_improvement = value2_lst[idx]\n\n                # Accept if it improves at least one objective\n                if v1_improvement > 0 or v2_improvement > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{My novel local search algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid strategy combining random flip and greedy selection to explore neighboring solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (prioritize those with higher potential)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Randomly select from top 30% of solutions\n        top_k = max(1, len(sorted_archive) // 3)\n        selected_idx = random.randint(0, top_k - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip with greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider flipping\n    flip_indices = random.sample(range(n_items), min(5, n_items))\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = current_weight - weight_lst[idx]\n\n            if temp_weight <= capacity:\n                # Calculate improvement in both objectives\n                v1_improvement = value1_lst[idx]\n                v2_improvement = value2_lst[idx]\n\n                # Accept if it improves at least one objective\n                if v1_improvement > 0 or v2_improvement > 0:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate improvement in both objectives\n                v1_improvement = value1_lst[idx]\n                v2_improvement = value2_lst[idx]\n\n                # Accept if it improves at least one objective\n                if v1_improvement > 0 or v2_improvement > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2786349971599642,
            1.3932369947433472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (prioritize those with higher potential)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Randomly select from top 30% of solutions\n        top_k = max(1, len(sorted_archive) // 3)\n        selected_idx = random.randint(0, top_k - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip with greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider flipping\n    flip_indices = random.sample(range(n_items), min(5, n_items))\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = current_weight - weight_lst[idx]\n\n            if temp_weight <= capacity:\n                # Calculate improvement in both objectives\n                v1_improvement = value1_lst[idx]\n                v2_improvement = value2_lst[idx]\n\n                # Accept if it improves at least one objective\n                if v1_improvement > 0 or v2_improvement > 0:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate improvement in both objectives\n                v1_improvement = value1_lst[idx]\n                v2_improvement = value2_lst[idx]\n\n                # Accept if it improves at least one objective\n                if v1_improvement > 0 or v2_improvement > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by combining randomness with objective-based scoring, then applies a hybrid local search that dynamically balances item swaps, flips, and group-based perturbations to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    def score_solution(solution, obj):\n        # Score based on how close it is to the Pareto front and its diversity\n        return (obj[0] + obj[1]) * (1 + random.uniform(0.1, 0.5))  # Add randomness to avoid bias\n\n    scored_solutions = [(score_solution(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: -x[0])  # Sort by score descending\n    selected_sol = scored_solutions[0][1].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Strategy 1: Randomly flip a group of items (balanced between inclusion/exclusion)\n    if random.random() < 0.5:\n        group_size = min(3, n_items)\n        indices = random.sample(range(n_items), group_size)\n        for i in indices:\n            if new_solution[i] == 1:\n                new_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n            else:\n                new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n\n    # Strategy 2: Swap two items (if feasible)\n    else:\n        if n_items >= 2:\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] != new_solution[j]:\n                # Check feasibility of swap\n                if new_solution[i] == 1 and new_solution[j] == 0:\n                    new_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[i] + weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                elif new_solution[i] == 0 and new_solution[j] == 1:\n                    new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i] - weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.32621291665111396,
            5.173925131559372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    def score_solution(solution, obj):\n        # Score based on how close it is to the Pareto front and its diversity\n        return (obj[0] + obj[1]) * (1 + random.uniform(0.1, 0.5))  # Add randomness to avoid bias\n\n    scored_solutions = [(score_solution(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: -x[0])  # Sort by score descending\n    selected_sol = scored_solutions[0][1].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Strategy 1: Randomly flip a group of items (balanced between inclusion/exclusion)\n    if random.random() < 0.5:\n        group_size = min(3, n_items)\n        indices = random.sample(range(n_items), group_size)\n        for i in indices:\n            if new_solution[i] == 1:\n                new_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n            else:\n                new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n\n    # Strategy 2: Swap two items (if feasible)\n    else:\n        if n_items >= 2:\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] != new_solution[j]:\n                # Check feasibility of swap\n                if new_solution[i] == 1 and new_solution[j] == 0:\n                    new_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[i] + weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                elif new_solution[i] == 0 and new_solution[j] == 1:\n                    new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i] - weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with probabilistic item flipping to explore diverse neighborhoods while ensuring feasibility, prioritizing solutions with high marginal gains in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Prioritize solutions with high marginal gains in both objectives\n        marginal_gains = []\n        for sol, obj in archive:\n            total_weight = np.sum(weight_lst * sol)\n            marginal_gain1 = obj[0] / total_weight if total_weight > 0 else 0\n            marginal_gain2 = obj[1] / total_weight if total_weight > 0 else 0\n            marginal_gains.append(marginal_gain1 + marginal_gain2)\n\n        # Select a solution with high marginal gains\n        selected_idx = np.argmax(marginal_gains)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swapping and probabilistic flipping\n    items = np.where(new_solution == 1)[0]\n    if len(items) > 1:\n        # Adaptive item swapping (swap two items)\n        i, j = random.sample(list(items), 2)\n        if weight_lst[i] <= weight_lst[j]:\n            # Swap i and j if feasible\n            if np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Swap j and i if feasible\n            if np.sum(weight_lst * new_solution) - weight_lst[j] + weight_lst[i] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic item flipping\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if random.random() < 0.3:  # 30% chance to flip\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        else:\n            if random.random() < 0.1:  # 10% chance to flip\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.376473706795146,
            7.2110190987586975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Prioritize solutions with high marginal gains in both objectives\n        marginal_gains = []\n        for sol, obj in archive:\n            total_weight = np.sum(weight_lst * sol)\n            marginal_gain1 = obj[0] / total_weight if total_weight > 0 else 0\n            marginal_gain2 = obj[1] / total_weight if total_weight > 0 else 0\n            marginal_gains.append(marginal_gain1 + marginal_gain2)\n\n        # Select a solution with high marginal gains\n        selected_idx = np.argmax(marginal_gains)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swapping and probabilistic flipping\n    items = np.where(new_solution == 1)[0]\n    if len(items) > 1:\n        # Adaptive item swapping (swap two items)\n        i, j = random.sample(list(items), 2)\n        if weight_lst[i] <= weight_lst[j]:\n            # Swap i and j if feasible\n            if np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Swap j and i if feasible\n            if np.sum(weight_lst * new_solution) - weight_lst[j] + weight_lst[i] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic item flipping\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if random.random() < 0.3:  # 30% chance to flip\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        else:\n            if random.random() < 0.1:  # 10% chance to flip\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{The heuristic function selects a solution from the archive based on its potential for improvement, then applies a novel hybrid local search operator that combines item swapping and probabilistic flipping to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic flipping and item swapping\n    for _ in range(3):  # Number of perturbations\n        # Probabilistic flipping\n        flip_prob = 0.3\n        for i in range(len(new_solution)):\n            if random.random() < flip_prob:\n                if new_solution[i] == 0:\n                    if np.dot(new_solution, weight_lst) + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                else:\n                    new_solution[i] = 0\n\n        # Item swapping\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = random.sample(list(items), 2)\n            if (np.dot(new_solution, weight_lst) - weight_lst[i] + weight_lst[j] <= capacity and\n                np.dot(new_solution, weight_lst) - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.dot(new_solution, weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess = total_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            items = np.where(new_solution == 1)[0]\n            i = random.choice(items)\n            if weight_lst[i] <= excess:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n            else:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.41802278347653277,
            6.901415109634399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic flipping and item swapping\n    for _ in range(3):  # Number of perturbations\n        # Probabilistic flipping\n        flip_prob = 0.3\n        for i in range(len(new_solution)):\n            if random.random() < flip_prob:\n                if new_solution[i] == 0:\n                    if np.dot(new_solution, weight_lst) + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                else:\n                    new_solution[i] = 0\n\n        # Item swapping\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = random.sample(list(items), 2)\n            if (np.dot(new_solution, weight_lst) - weight_lst[i] + weight_lst[j] <= capacity and\n                np.dot(new_solution, weight_lst) - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.dot(new_solution, weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess = total_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            items = np.where(new_solution == 1)[0]\n            i = random.choice(items)\n            if weight_lst[i] <= excess:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n            else:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search combining item swapping and adaptive perturbation to explore promising regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive perturbation - flip a random subset of items\n    num_items = len(weight_lst)\n    flip_count = min(3, num_items)  # Limit the number of flips for efficiency\n    flip_indices = random.sample(range(num_items), flip_count)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item if feasible\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Item swapping - swap items with high marginal contribution\n    current_weight = np.sum(new_solution * weight_lst)\n    for _ in range(2):  # Perform a limited number of swaps\n        # Identify items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items to swap based on marginal contribution\n        in_item = random.choice(in_items)\n        out_item = random.choice(out_items)\n\n        new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n        if new_weight <= capacity:\n            new_solution[out_item] = 0\n            new_solution[in_item] = 1\n            current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.29311184020463354,
            1.8375643193721771
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive perturbation - flip a random subset of items\n    num_items = len(weight_lst)\n    flip_count = min(3, num_items)  # Limit the number of flips for efficiency\n    flip_indices = random.sample(range(num_items), flip_count)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item if feasible\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Item swapping - swap items with high marginal contribution\n    current_weight = np.sum(new_solution * weight_lst)\n    for _ in range(2):  # Perform a limited number of swaps\n        # Identify items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items to swap based on marginal contribution\n        in_item = random.choice(in_items)\n        out_item = random.choice(out_items)\n\n        new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n        if new_weight <= capacity:\n            new_solution[out_item] = 0\n            new_solution[in_item] = 1\n            current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The heuristic function employs a multi-criteria selection strategy that prioritizes solutions with high marginal gains in either objective, followed by a hybrid local search that combines random bit flips with a guided perturbation to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal potential\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[archive[i][1][0] + archive[i][1][1] for i in range(len(archive))],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: random flip with guided perturbation\n    new_solution = base_solution.copy()\n    for _ in range(min(5, len(new_solution))):\n        # Random flip\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Guided perturbation: flip items with high marginal value\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                if random.random() < 0.3:  # 30% chance to add high-value item\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5584337362207124,
            5.518078118562698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal potential\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[archive[i][1][0] + archive[i][1][1] for i in range(len(archive))],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: random flip with guided perturbation\n    new_solution = base_solution.copy()\n    for _ in range(min(5, len(new_solution))):\n        # Random flip\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Guided perturbation: flip items with high marginal value\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                if random.random() < 0.3:  # 30% chance to add high-value item\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search combining item swaps and probabilistic flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high value, low weight)\n    archive.sort(key=lambda x: (-x[1][0] - x[1][1], np.sum(weight_lst * x[0])))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic flips and strategic swaps\n    for _ in range(2):  # Number of search steps\n        # Step 1: Probabilistic flip (higher chance for items with high marginal value)\n        values = np.abs(value1_lst + value2_lst)\n        probs = values / np.sum(values)\n        flip_idx = np.random.choice(len(weight_lst), p=probs)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove items randomly until feasible\n            while total_weight > capacity:\n                items_in = np.where(new_solution == 1)[0]\n                if len(items_in) == 0:\n                    break\n                remove_idx = np.random.choice(items_in)\n                new_solution[remove_idx] = 0\n                total_weight = np.sum(weight_lst * new_solution)\n\n        # Step 2: Strategic swap (swap two items if it improves both objectives)\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n        if len(items_in) > 0 and len(items_out) > 0:\n            swap_in = np.random.choice(items_in)\n            swap_out = np.random.choice(items_out)\n            if (weight_lst[swap_out] - weight_lst[swap_in]) <= (capacity - total_weight):\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.2860329324356435,
            4.3203162252902985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high value, low weight)\n    archive.sort(key=lambda x: (-x[1][0] - x[1][1], np.sum(weight_lst * x[0])))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic flips and strategic swaps\n    for _ in range(2):  # Number of search steps\n        # Step 1: Probabilistic flip (higher chance for items with high marginal value)\n        values = np.abs(value1_lst + value2_lst)\n        probs = values / np.sum(values)\n        flip_idx = np.random.choice(len(weight_lst), p=probs)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove items randomly until feasible\n            while total_weight > capacity:\n                items_in = np.where(new_solution == 1)[0]\n                if len(items_in) == 0:\n                    break\n                remove_idx = np.random.choice(items_in)\n                new_solution[remove_idx] = 0\n                total_weight = np.sum(weight_lst * new_solution)\n\n        # Step 2: Strategic swap (swap two items if it improves both objectives)\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n        if len(items_in) > 0 and len(items_out) > 0:\n            swap_in = np.random.choice(items_in)\n            swap_out = np.random.choice(items_out)\n            if (weight_lst[swap_out] - weight_lst[swap_in]) <= (capacity - total_weight):\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search combining random bit flipping, objective-specific perturbations, and adaptive neighborhood exploration to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest value in one objective, low weight)\n    archive.sort(key=lambda x: (-max(x[1][0], x[1][1]), sum(weight_lst * x[0])))\n    base_solution = archive[0][0].copy()\n    current_weight = sum(weight_lst * base_solution)\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random bit flip, objective-specific perturbation, and adaptive exploration\n    for _ in range(3):  # Number of perturbation attempts\n        # Random bit flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Objective-specific perturbation\n        if random.random() < 0.5:\n            # Perturb based on value1\n            candidate_items = np.where(value1_lst > np.mean(value1_lst))[0]\n        else:\n            # Perturb based on value2\n            candidate_items = np.where(value2_lst > np.mean(value2_lst))[0]\n\n        if len(candidate_items) > 0:\n            perturb_idx = random.choice(candidate_items)\n            new_solution[perturb_idx] = 1 - new_solution[perturb_idx]\n\n        # Ensure feasibility\n        new_weight = sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # Remove items until feasible\n            excess = new_weight - capacity\n            items_to_remove = np.where(new_solution == 1)[0]\n            if len(items_to_remove) > 0:\n                remove_idx = random.choice(items_to_remove)\n                new_solution[remove_idx] = 0\n                new_weight -= weight_lst[remove_idx]\n\n    # Adaptive exploration: flip items with high value-to-weight ratio\n    value_to_weight = (value1_lst + value2_lst) / weight_lst\n    high_ratio_items = np.argsort(-value_to_weight)[:max(1, len(new_solution) // 4)]\n    for idx in high_ratio_items:\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[idx] = 1 - new_solution[idx]\n            if sum(weight_lst * new_solution) > capacity:\n                new_solution[idx] = 1 - new_solution[idx]  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.5177635194027348,
            9.673630177974701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest value in one objective, low weight)\n    archive.sort(key=lambda x: (-max(x[1][0], x[1][1]), sum(weight_lst * x[0])))\n    base_solution = archive[0][0].copy()\n    current_weight = sum(weight_lst * base_solution)\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random bit flip, objective-specific perturbation, and adaptive exploration\n    for _ in range(3):  # Number of perturbation attempts\n        # Random bit flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Objective-specific perturbation\n        if random.random() < 0.5:\n            # Perturb based on value1\n            candidate_items = np.where(value1_lst > np.mean(value1_lst))[0]\n        else:\n            # Perturb based on value2\n            candidate_items = np.where(value2_lst > np.mean(value2_lst))[0]\n\n        if len(candidate_items) > 0:\n            perturb_idx = random.choice(candidate_items)\n            new_solution[perturb_idx] = 1 - new_solution[perturb_idx]\n\n        # Ensure feasibility\n        new_weight = sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # Remove items until feasible\n            excess = new_weight - capacity\n            items_to_remove = np.where(new_solution == 1)[0]\n            if len(items_to_remove) > 0:\n                remove_idx = random.choice(items_to_remove)\n                new_solution[remove_idx] = 0\n                new_weight -= weight_lst[remove_idx]\n\n    # Adaptive exploration: flip items with high value-to-weight ratio\n    value_to_weight = (value1_lst + value2_lst) / weight_lst\n    high_ratio_items = np.argsort(-value_to_weight)[:max(1, len(new_solution) // 4)]\n    for idx in high_ratio_items:\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[idx] = 1 - new_solution[idx]\n            if sum(weight_lst * new_solution) > capacity:\n                new_solution[idx] = 1 - new_solution[idx]  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swap and flip with objective-aware selection\n    total_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Identify items that could be swapped or flipped\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 0)[0]\n\n    # Select a random item to consider flipping\n    item_to_flip = np.random.choice(candidate_items)\n    if base_solution[item_to_flip] == 1:\n        # Try to remove the item if it doesn't violate capacity\n        new_solution[item_to_flip] = 0\n    else:\n        # Try to add the item if it fits within capacity\n        if weight_lst[item_to_flip] <= remaining_capacity:\n            new_solution[item_to_flip] = 1\n\n    # Additional swap operation for higher diversity\n    if len(candidate_items) > 1:\n        items_to_swap = np.random.choice(candidate_items, size=2, replace=False)\n        new_solution[items_to_swap[0]], new_solution[items_to_swap[1]] = new_solution[items_to_swap[1]], new_solution[items_to_swap[0]]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If over capacity, remove items with lowest marginal contribution\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Calculate marginal contribution for each objective\n            marginal_contrib = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            item_to_remove = included_items[np.argmin(marginal_contrib)]\n            new_solution[item_to_remove] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8330340296465515,
            3.220448523759842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swap and flip with objective-aware selection\n    total_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Identify items that could be swapped or flipped\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 0)[0]\n\n    # Select a random item to consider flipping\n    item_to_flip = np.random.choice(candidate_items)\n    if base_solution[item_to_flip] == 1:\n        # Try to remove the item if it doesn't violate capacity\n        new_solution[item_to_flip] = 0\n    else:\n        # Try to add the item if it fits within capacity\n        if weight_lst[item_to_flip] <= remaining_capacity:\n            new_solution[item_to_flip] = 1\n\n    # Additional swap operation for higher diversity\n    if len(candidate_items) > 1:\n        items_to_swap = np.random.choice(candidate_items, size=2, replace=False)\n        new_solution[items_to_swap[0]], new_solution[items_to_swap[1]] = new_solution[items_to_swap[1]], new_solution[items_to_swap[0]]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If over capacity, remove items with lowest marginal contribution\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Calculate marginal contribution for each objective\n            marginal_contrib = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            item_to_remove = included_items[np.argmin(marginal_contrib)]\n            new_solution[item_to_remove] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swapping and adaptive perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: item swapping + adaptive perturbation\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    if len(items) > 0 and len(non_items) > 0:\n        # Swap one item with a non-item if feasible\n        swap_item = random.choice(items)\n        swap_non_item = random.choice(non_items)\n\n        # Check feasibility of swap\n        if current_weight - weight_lst[swap_item] + weight_lst[swap_non_item] <= capacity:\n            new_solution[swap_item] = 0\n            new_solution[swap_non_item] = 1\n        else:\n            # If swap not feasible, try to remove one item and add a non-item\n            remove_item = random.choice(items)\n            new_solution[remove_item] = 0\n            current_weight -= weight_lst[remove_item]\n\n            # Find a non-item that can be added without exceeding capacity\n            available_non_items = [i for i in non_items if weight_lst[i] <= (capacity - current_weight)]\n            if available_non_items:\n                add_item = random.choice(available_non_items)\n                new_solution[add_item] = 1\n\n    # Adaptive perturbation: flip a small number of bits\n    perturbation_size = min(2, len(base_solution))\n    perturbation_indices = random.sample(range(len(base_solution)), perturbation_size)\n    for idx in perturbation_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3156448076911378,
            2.483899414539337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: item swapping + adaptive perturbation\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    if len(items) > 0 and len(non_items) > 0:\n        # Swap one item with a non-item if feasible\n        swap_item = random.choice(items)\n        swap_non_item = random.choice(non_items)\n\n        # Check feasibility of swap\n        if current_weight - weight_lst[swap_item] + weight_lst[swap_non_item] <= capacity:\n            new_solution[swap_item] = 0\n            new_solution[swap_non_item] = 1\n        else:\n            # If swap not feasible, try to remove one item and add a non-item\n            remove_item = random.choice(items)\n            new_solution[remove_item] = 0\n            current_weight -= weight_lst[remove_item]\n\n            # Find a non-item that can be added without exceeding capacity\n            available_non_items = [i for i in non_items if weight_lst[i] <= (capacity - current_weight)]\n            if available_non_items:\n                add_item = random.choice(available_non_items)\n                new_solution[add_item] = 1\n\n    # Adaptive perturbation: flip a small number of bits\n    perturbation_size = min(2, len(base_solution))\n    perturbation_indices = random.sample(range(len(base_solution)), perturbation_size)\n    for idx in perturbation_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_scores = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / np.sum(value1_lst), obj[1] / np.sum(value2_lst))\n        normalized_scores.append(np.sum(norm_obj))\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor by flipping items in a way that balances both objectives\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be added or removed without violating capacity\n    candidate_indices = np.where(new_solution == 1)[0]\n    np.random.shuffle(candidate_indices)\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = total_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                total_weight = temp_weight\n                break\n\n    # Try adding items that improve both objectives\n    candidate_indices = np.where(new_solution == 0)[0]\n    np.random.shuffle(candidate_indices)\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 0:\n            temp_weight = total_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                # Check if adding this item improves at least one objective\n                if (value1_lst[idx] > 0) or (value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    total_weight = temp_weight\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4223342412290349,
            9.227209478616714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_scores = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / np.sum(value1_lst), obj[1] / np.sum(value2_lst))\n        normalized_scores.append(np.sum(norm_obj))\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor by flipping items in a way that balances both objectives\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be added or removed without violating capacity\n    candidate_indices = np.where(new_solution == 1)[0]\n    np.random.shuffle(candidate_indices)\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = total_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                total_weight = temp_weight\n                break\n\n    # Try adding items that improve both objectives\n    candidate_indices = np.where(new_solution == 0)[0]\n    np.random.shuffle(candidate_indices)\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 0:\n            temp_weight = total_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                # Check if adding this item improves at least one objective\n                if (value1_lst[idx] > 0) or (value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    total_weight = temp_weight\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{The heuristic selects a solution from the archive based on its dominance and potential for local improvement, then applies a hybrid local search operator that combines item swaps and adaptive bit flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: adaptive bit flips and item swaps\n    # Step 1: Randomly select a subset of items to flip\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        num_flips = min(3, len(flip_candidates))  # Limit to 3 flips\n        flip_indices = np.random.choice(flip_candidates, num_flips, replace=False)\n        new_solution[flip_indices] = 0\n\n    # Step 2: Add items that improve both objectives without exceeding capacity\n    available_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(available_items)\n    for item in available_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Check if adding this item improves both objectives\n            if (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 3: Perform item swaps if beneficial\n    if np.sum(new_solution) > 1:\n        swap_candidates = np.where(new_solution == 1)[0]\n        np.random.shuffle(swap_candidates)\n        for i in range(len(swap_candidates) - 1):\n            item1, item2 = swap_candidates[i], swap_candidates[i+1]\n            # Check if swapping improves both objectives\n            delta1 = value1_lst[item2] - value1_lst[item1]\n            delta2 = value2_lst[item2] - value2_lst[item1]\n            if delta1 > 0 and delta2 > 0:\n                # Only swap if it doesn't violate capacity\n                if (current_weight - weight_lst[item1] + weight_lst[item2]) <= capacity:\n                    new_solution[item1], new_solution[item2] = 0, 1\n                    current_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n\n    return new_solution\n\n",
        "score": [
            -0.7785445266276239,
            3.382122218608856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: adaptive bit flips and item swaps\n    # Step 1: Randomly select a subset of items to flip\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        num_flips = min(3, len(flip_candidates))  # Limit to 3 flips\n        flip_indices = np.random.choice(flip_candidates, num_flips, replace=False)\n        new_solution[flip_indices] = 0\n\n    # Step 2: Add items that improve both objectives without exceeding capacity\n    available_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(available_items)\n    for item in available_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Check if adding this item improves both objectives\n            if (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 3: Perform item swaps if beneficial\n    if np.sum(new_solution) > 1:\n        swap_candidates = np.where(new_solution == 1)[0]\n        np.random.shuffle(swap_candidates)\n        for i in range(len(swap_candidates) - 1):\n            item1, item2 = swap_candidates[i], swap_candidates[i+1]\n            # Check if swapping improves both objectives\n            delta1 = value1_lst[item2] - value1_lst[item1]\n            delta2 = value2_lst[item2] - value2_lst[item1]\n            if delta1 > 0 and delta2 > 0:\n                # Only swap if it doesn't violate capacity\n                if (current_weight - weight_lst[item1] + weight_lst[item2]) <= capacity:\n                    new_solution[item1], new_solution[item2] = 0, 1\n                    current_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a combination of objective values and their potential for improvement, then applies a novel local search operator that intelligently flips item selections to balance the two objectives while ensuring feasibility, using a weighted random selection and a dynamic adjustment mechanism to explore the solution space effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the total weight of each solution in the archive\n    archive_weights = [np.sum(weight_lst[solution[0] == 1]) for solution in archive]\n\n    # Select solutions that are not at full capacity\n    candidates = [(solution, obj) for (solution, obj), weight in zip(archive, archive_weights) if weight < capacity]\n\n    if not candidates:\n        candidates = archive  # Fallback to all solutions if none are below capacity\n\n    # Select a solution with high potential for improvement (e.g., high diversity in objectives)\n    selected_solution, selected_obj = random.choice(candidates)\n    base_solution = selected_solution.copy()\n\n    # Generate a neighbor solution using a novel local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate the current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = selected_obj[0]\n    current_value2 = selected_obj[1]\n\n    # Determine items that can be flipped (added or removed)\n    # Items that are in the solution can be removed, items not in the solution can be added if weight allows\n    removable_items = np.where(new_solution == 1)[0]\n    addable_items = np.where(new_solution == 0)[0]\n\n    # Calculate potential additions and removals\n    potential_additions = [(i, weight_lst[i], value1_lst[i], value2_lst[i]) for i in addable_items if (current_weight + weight_lst[i]) <= capacity]\n    potential_removals = [(i, weight_lst[i], value1_lst[i], value2_lst[i]) for i in removable_items]\n\n    # Define a weighted random selection to balance the two objectives\n    def weighted_random_choice(options, weights):\n        if not options:\n            return None\n        return random.choices(options, weights=weights, k=1)[0]\n\n    # Apply the novel local search operator\n    # Option 1: Flip a removable item with high value in one objective and low in the other\n    if potential_removals:\n        # Calculate the \"balance\" of each removable item\n        balance_scores = []\n        for i, w, v1, v2 in potential_removals:\n            # Score based on the difference between the two objectives\n            balance_scores.append(abs(v1 - v2))\n\n        # Select a removable item with high balance score\n        selected_removal = weighted_random_choice(potential_removals, balance_scores)\n        if selected_removal:\n            i, w, v1, v2 = selected_removal\n            new_solution[i] = 0\n\n    # Option 2: Add an item that complements the current solution's objectives\n    if potential_additions:\n        # Calculate the \"complementarity\" of each addable item\n        complement_scores = []\n        for i, w, v1, v2 in potential_additions:\n            # Score based on how well the item complements the current solution's objectives\n            # For example, items that improve one objective while minimally affecting the other\n            if current_value1 == 0 or current_value2 == 0:\n                complement_scores.append(1.0)  # Default score if no current values\n            else:\n                # Normalize the values to avoid bias towards larger objectives\n                norm_v1 = v1 / current_value1 if current_value1 != 0 else 0\n                norm_v2 = v2 / current_value2 if current_value2 != 0 else 0\n                complement_scores.append(abs(norm_v1 - norm_v2))\n\n        # Select an addable item with high complement score\n        selected_addition = weighted_random_choice(potential_additions, complement_scores)\n        if selected_addition:\n            i, w, v1, v2 = selected_addition\n            new_solution[i] = 1\n\n    # Ensure the solution is feasible\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If the solution is infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7310607155807728,
            5.363934397697449
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the total weight of each solution in the archive\n    archive_weights = [np.sum(weight_lst[solution[0] == 1]) for solution in archive]\n\n    # Select solutions that are not at full capacity\n    candidates = [(solution, obj) for (solution, obj), weight in zip(archive, archive_weights) if weight < capacity]\n\n    if not candidates:\n        candidates = archive  # Fallback to all solutions if none are below capacity\n\n    # Select a solution with high potential for improvement (e.g., high diversity in objectives)\n    selected_solution, selected_obj = random.choice(candidates)\n    base_solution = selected_solution.copy()\n\n    # Generate a neighbor solution using a novel local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate the current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = selected_obj[0]\n    current_value2 = selected_obj[1]\n\n    # Determine items that can be flipped (added or removed)\n    # Items that are in the solution can be removed, items not in the solution can be added if weight allows\n    removable_items = np.where(new_solution == 1)[0]\n    addable_items = np.where(new_solution == 0)[0]\n\n    # Calculate potential additions and removals\n    potential_additions = [(i, weight_lst[i], value1_lst[i], value2_lst[i]) for i in addable_items if (current_weight + weight_lst[i]) <= capacity]\n    potential_removals = [(i, weight_lst[i], value1_lst[i], value2_lst[i]) for i in removable_items]\n\n    # Define a weighted random selection to balance the two objectives\n    def weighted_random_choice(options, weights):\n        if not options:\n            return None\n        return random.choices(options, weights=weights, k=1)[0]\n\n    # Apply the novel local search operator\n    # Option 1: Flip a removable item with high value in one objective and low in the other\n    if potential_removals:\n        # Calculate the \"balance\" of each removable item\n        balance_scores = []\n        for i, w, v1, v2 in potential_removals:\n            # Score based on the difference between the two objectives\n            balance_scores.append(abs(v1 - v2))\n\n        # Select a removable item with high balance score\n        selected_removal = weighted_random_choice(potential_removals, balance_scores)\n        if selected_removal:\n            i, w, v1, v2 = selected_removal\n            new_solution[i] = 0\n\n    # Option 2: Add an item that complements the current solution's objectives\n    if potential_additions:\n        # Calculate the \"complementarity\" of each addable item\n        complement_scores = []\n        for i, w, v1, v2 in potential_additions:\n            # Score based on how well the item complements the current solution's objectives\n            # For example, items that improve one objective while minimally affecting the other\n            if current_value1 == 0 or current_value2 == 0:\n                complement_scores.append(1.0)  # Default score if no current values\n            else:\n                # Normalize the values to avoid bias towards larger objectives\n                norm_v1 = v1 / current_value1 if current_value1 != 0 else 0\n                norm_v2 = v2 / current_value2 if current_value2 != 0 else 0\n                complement_scores.append(abs(norm_v1 - norm_v2))\n\n        # Select an addable item with high complement score\n        selected_addition = weighted_random_choice(potential_additions, complement_scores)\n        if selected_addition:\n            i, w, v1, v2 = selected_addition\n            new_solution[i] = 1\n\n    # Ensure the solution is feasible\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If the solution is infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive, performs a weighted random walk to explore the solution space, and applies a dynamic perturbation mechanism to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias towards solutions with higher values\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    selection_probs = total_values / total_values.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by flipping a random bit, ensuring feasibility\n    new_solution = base_solution.copy()\n    max_attempts = 100\n    attempts = 0\n\n    while attempts < max_attempts:\n        # Randomly select an item to flip\n        item_idx = random.randint(0, len(base_solution) - 1)\n        current_bit = new_solution[item_idx]\n\n        # Flip the bit and check feasibility\n        if current_bit == 1:\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight >= 0:\n                new_solution[item_idx] = 0\n                current_weight = new_weight\n                break\n        else:\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 1\n                current_weight = new_weight\n                break\n\n        attempts += 1\n\n    # If no feasible flip found, perform a weighted random walk\n    if attempts == max_attempts:\n        # Calculate weights for each item based on their marginal contribution\n        marginal_weights = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                marginal_weights.append(value1_lst[i] + value2_lst[i])\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    marginal_weights.append((value1_lst[i] + value2_lst[i]) / weight_lst[i])\n                else:\n                    marginal_weights.append(0)\n\n        # Normalize weights and select a candidate\n        marginal_weights = np.array(marginal_weights)\n        if marginal_weights.sum() > 0:\n            selection_probs = marginal_weights / marginal_weights.sum()\n            item_idx = np.random.choice(len(base_solution), p=selection_probs)\n            new_solution[item_idx] = 1 - new_solution[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8043850135490369,
            2.548498272895813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias towards solutions with higher values\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    selection_probs = total_values / total_values.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by flipping a random bit, ensuring feasibility\n    new_solution = base_solution.copy()\n    max_attempts = 100\n    attempts = 0\n\n    while attempts < max_attempts:\n        # Randomly select an item to flip\n        item_idx = random.randint(0, len(base_solution) - 1)\n        current_bit = new_solution[item_idx]\n\n        # Flip the bit and check feasibility\n        if current_bit == 1:\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight >= 0:\n                new_solution[item_idx] = 0\n                current_weight = new_weight\n                break\n        else:\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 1\n                current_weight = new_weight\n                break\n\n        attempts += 1\n\n    # If no feasible flip found, perform a weighted random walk\n    if attempts == max_attempts:\n        # Calculate weights for each item based on their marginal contribution\n        marginal_weights = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                marginal_weights.append(value1_lst[i] + value2_lst[i])\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    marginal_weights.append((value1_lst[i] + value2_lst[i]) / weight_lst[i])\n                else:\n                    marginal_weights.append(0)\n\n        # Normalize weights and select a candidate\n        marginal_weights = np.array(marginal_weights)\n        if marginal_weights.sum() > 0:\n            selection_probs = marginal_weights / marginal_weights.sum()\n            item_idx = np.random.choice(len(base_solution), p=selection_probs)\n            new_solution[item_idx] = 1 - new_solution[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity (e.g., least similar to others)\n    base_solution = archive[0][0]\n    max_similarity = -1\n    for sol, _ in archive:\n        similarity = np.sum(sol == base_solution) / len(sol)\n        if similarity > max_similarity:\n            max_similarity = similarity\n            base_solution = sol\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: flip a random subset of items, then apply a greedy improvement\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Greedy improvement: add items with highest marginal value-to-weight ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate marginal value-to-weight ratios\n        marginal_ratio1 = value1_lst / weight_lst\n        marginal_ratio2 = value2_lst / weight_lst\n\n        # Combine ratios using a weighted average (prioritize both objectives)\n        combined_ratio = (marginal_ratio1 + marginal_ratio2) / 2\n\n        # Sort items by combined ratio\n        sorted_indices = np.argsort(-combined_ratio)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.31743789409262946,
            8.378678947687149
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity (e.g., least similar to others)\n    base_solution = archive[0][0]\n    max_similarity = -1\n    for sol, _ in archive:\n        similarity = np.sum(sol == base_solution) / len(sol)\n        if similarity > max_similarity:\n            max_similarity = similarity\n            base_solution = sol\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: flip a random subset of items, then apply a greedy improvement\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Greedy improvement: add items with highest marginal value-to-weight ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate marginal value-to-weight ratios\n        marginal_ratio1 = value1_lst / weight_lst\n        marginal_ratio2 = value2_lst / weight_lst\n\n        # Combine ratios using a weighted average (prioritize both objectives)\n        combined_ratio = (marginal_ratio1 + marginal_ratio2) / 2\n\n        # Sort items by combined ratio\n        sorted_indices = np.argsort(-combined_ratio)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{A novel hybrid local search strategy that combines probabilistic item swaps with adaptive neighborhood exploration, guided by objective-specific dominance criteria and weight-aware perturbations to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: probabilistic item swaps with objective-aware perturbations\n    for _ in range(min(5, len(base_solution))):  # Limit iterations to prevent excessive computation\n        # Select items to swap based on objective dominance\n        if np.random.rand() < 0.7:  # 70% chance to focus on value1\n            candidate_items = np.argsort(value1_lst * (1 - base_solution))[-5:]  # Top 5 undominated items for value1\n        else:\n            candidate_items = np.argsort(value2_lst * (1 - base_solution))[-5:]  # Top 5 undominated items for value2\n\n        if len(candidate_items) == 0:\n            continue\n\n        # Randomly select an item to swap\n        item_to_swap = np.random.choice(candidate_items)\n\n        # Try to flip the item\n        if new_solution[item_to_swap] == 0:\n            # Add item if it fits\n            if current_weight + weight_lst[item_to_swap] <= capacity:\n                new_solution[item_to_swap] = 1\n                current_weight += weight_lst[item_to_swap]\n        else:\n            # Remove item\n            new_solution[item_to_swap] = 0\n            current_weight -= weight_lst[item_to_swap]\n\n    # Additional perturbation for diversification\n    if np.random.rand() < 0.3:  # 30% chance for additional perturbation\n        # Select a random subset of items to flip\n        perturbation_size = min(3, len(base_solution))  # Limit perturbation size\n        perturbation_items = np.random.choice(len(base_solution), size=perturbation_size, replace=False)\n\n        for item in perturbation_items:\n            if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n            elif new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.38988620165169596,
            10.48756691813469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: probabilistic item swaps with objective-aware perturbations\n    for _ in range(min(5, len(base_solution))):  # Limit iterations to prevent excessive computation\n        # Select items to swap based on objective dominance\n        if np.random.rand() < 0.7:  # 70% chance to focus on value1\n            candidate_items = np.argsort(value1_lst * (1 - base_solution))[-5:]  # Top 5 undominated items for value1\n        else:\n            candidate_items = np.argsort(value2_lst * (1 - base_solution))[-5:]  # Top 5 undominated items for value2\n\n        if len(candidate_items) == 0:\n            continue\n\n        # Randomly select an item to swap\n        item_to_swap = np.random.choice(candidate_items)\n\n        # Try to flip the item\n        if new_solution[item_to_swap] == 0:\n            # Add item if it fits\n            if current_weight + weight_lst[item_to_swap] <= capacity:\n                new_solution[item_to_swap] = 1\n                current_weight += weight_lst[item_to_swap]\n        else:\n            # Remove item\n            new_solution[item_to_swap] = 0\n            current_weight -= weight_lst[item_to_swap]\n\n    # Additional perturbation for diversification\n    if np.random.rand() < 0.3:  # 30% chance for additional perturbation\n        # Select a random subset of items to flip\n        perturbation_size = min(3, len(base_solution))  # Limit perturbation size\n        perturbation_items = np.random.choice(len(base_solution), size=perturbation_size, replace=False)\n\n        for item in perturbation_items:\n            if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n            elif new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with a dynamic weight adjustment mechanism to explore the solution space intelligently, balancing exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive swaps with dynamic weight adjustment\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n    max_attempts = min(10, num_items)\n\n    for _ in range(max_attempts):\n        # Randomly select two items to swap\n        idx1, idx2 = random.sample(range(num_items), 2)\n\n        # Calculate new weight if we swap items\n        if new_solution[idx1] == new_solution[idx2]:\n            continue  # No change if both are same\n\n        delta_weight = (weight_lst[idx2] - weight_lst[idx1]) if new_solution[idx1] == 1 else (weight_lst[idx1] - weight_lst[idx2])\n\n        if current_weight + delta_weight <= capacity:\n            # Perform swap if feasible\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            current_weight += delta_weight\n\n            # Dynamic adjustment: prefer swaps that improve both objectives\n            if (value1_lst[idx2] > value1_lst[idx1] and value2_lst[idx2] > value2_lst[idx1]) or \\\n               (value1_lst[idx1] > value1_lst[idx2] and value2_lst[idx1] > value2_lst[idx2]):\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.540488139815194,
            1.6155480742454529
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive swaps with dynamic weight adjustment\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n    max_attempts = min(10, num_items)\n\n    for _ in range(max_attempts):\n        # Randomly select two items to swap\n        idx1, idx2 = random.sample(range(num_items), 2)\n\n        # Calculate new weight if we swap items\n        if new_solution[idx1] == new_solution[idx2]:\n            continue  # No change if both are same\n\n        delta_weight = (weight_lst[idx2] - weight_lst[idx1]) if new_solution[idx1] == 1 else (weight_lst[idx1] - weight_lst[idx2])\n\n        if current_weight + delta_weight <= capacity:\n            # Perform swap if feasible\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            current_weight += delta_weight\n\n            # Dynamic adjustment: prefer swaps that improve both objectives\n            if (value1_lst[idx2] > value1_lst[idx1] and value2_lst[idx2] > value2_lst[idx1]) or \\\n               (value1_lst[idx1] > value1_lst[idx2] and value2_lst[idx1] > value2_lst[idx2]):\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by prioritizing those with the highest combined objective values, then applies a hybrid local search operator that combines item swaps with probabilistic flips to explore diverse neighborhoods while ensuring feasibility through weight-constrained adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly select a subset of items to flip (with probability)\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                # Check if adding this item would exceed capacity\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Perform a probabilistic swap between two items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Swap and check feasibility\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            # If swap violates capacity, undo it\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight > capacity:\n                new_solution[j] = new_solution[i]\n                new_solution[i] = temp\n\n    # Step 3: Add a random item if there's remaining capacity\n    zero_indices = np.where(new_solution == 0)[0]\n    if len(zero_indices) > 0:\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity > 0:\n            candidates = [i for i in zero_indices if weight_lst[i] <= remaining_capacity]\n            if candidates:\n                item_to_add = random.choice(candidates)\n                new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4222821704177963,
            6.396967589855194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly select a subset of items to flip (with probability)\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                # Check if adding this item would exceed capacity\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Perform a probabilistic swap between two items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Swap and check feasibility\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            # If swap violates capacity, undo it\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight > capacity:\n                new_solution[j] = new_solution[i]\n                new_solution[i] = temp\n\n    # Step 3: Add a random item if there's remaining capacity\n    zero_indices = np.where(new_solution == 0)[0]\n    if len(zero_indices) > 0:\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity > 0:\n            candidates = [i for i in zero_indices if weight_lst[i] <= remaining_capacity]\n            if candidates:\n                item_to_add = random.choice(candidates)\n                new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: adaptive flip and swap\n    if np.random.random() < 0.7:  # 70% chance for flip\n        # Adaptive flip: flip items with high marginal utility\n        marginal_utility = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_items = np.argsort(marginal_utility)[::-1]\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n    else:  # 30% chance for swap\n        # Adaptive swap: swap items between objectives\n        obj1_items = np.where(base_solution == 1)[0]\n        obj2_items = np.where(base_solution == 0)[0]\n        if len(obj1_items) > 0 and len(obj2_items) > 0:\n            swap_item1 = np.random.choice(obj1_items)\n            swap_item2 = np.random.choice(obj2_items)\n            if (np.sum(weight_lst * new_solution) - weight_lst[swap_item1] + weight_lst[swap_item2]) <= capacity:\n                new_solution[swap_item1], new_solution[swap_item2] = new_solution[swap_item2], new_solution[swap_item1]\n\n    return new_solution\n\n",
        "score": [
            -0.41086529174064973,
            2.2128539383411407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: adaptive flip and swap\n    if np.random.random() < 0.7:  # 70% chance for flip\n        # Adaptive flip: flip items with high marginal utility\n        marginal_utility = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_items = np.argsort(marginal_utility)[::-1]\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n    else:  # 30% chance for swap\n        # Adaptive swap: swap items between objectives\n        obj1_items = np.where(base_solution == 1)[0]\n        obj2_items = np.where(base_solution == 0)[0]\n        if len(obj1_items) > 0 and len(obj2_items) > 0:\n            swap_item1 = np.random.choice(obj1_items)\n            swap_item2 = np.random.choice(obj2_items)\n            if (np.sum(weight_lst * new_solution) - weight_lst[swap_item1] + weight_lst[swap_item2]) <= capacity:\n                new_solution[swap_item1], new_solution[swap_item2] = new_solution[swap_item2], new_solution[swap_item1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{A hybrid local search strategy that combines random item swaps with adaptive neighborhood exploration, prioritizing solutions with high marginal gains in either objective to generate diverse, high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal potential\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(sol * weight_lst)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            continue\n        # Calculate marginal gains for items not in the solution\n        marginal1 = value1_lst * (1 - sol)\n        marginal2 = value2_lst * (1 - sol)\n        # Prioritize solutions with high marginal gains\n        score = np.sum(marginal1 + marginal2) / (1 + current_weight)\n        candidates.append((sol, score))\n\n    if not candidates:\n        # Fallback: select a random solution if no candidates with remaining capacity\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest marginal score\n        base_solution = max(candidates, key=lambda x: x[1])[0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Perform hybrid local search\n    # Step 1: Random swap with high-marginal items\n    possible_items = np.where((1 - new_solution) * weight_lst <= remaining_capacity)[0]\n    if len(possible_items) > 0:\n        high_marginal_items = possible_items[np.argsort(-(value1_lst[possible_items] + value2_lst[possible_items]))[:max(1, len(possible_items)//2)]]\n        if len(high_marginal_items) > 0:\n            swap_item = random.choice(high_marginal_items)\n            new_solution[swap_item] = 1 - new_solution[swap_item]  # Flip the item\n            current_weight = np.sum(new_solution * weight_lst)\n            remaining_capacity = capacity - current_weight\n\n    # Step 2: Add/remove items with adaptive neighborhood\n    if remaining_capacity > 0:\n        # Try to add items with high marginal value\n        add_candidates = np.where((1 - new_solution) * weight_lst <= remaining_capacity)[0]\n        if len(add_candidates) > 0:\n            best_add = max(add_candidates, key=lambda x: value1_lst[x] + value2_lst[x])\n            new_solution[best_add] = 1\n    else:\n        # Try to remove items with low marginal value\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            worst_remove = min(remove_candidates, key=lambda x: value1_lst[x] + value2_lst[x])\n            new_solution[worst_remove] = 0\n\n    # Ensure feasibility\n    while np.sum(new_solution * weight_lst) > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break  # No items left to remove\n        worst_remove = min(remove_candidates, key=lambda x: value1_lst[x] + value2_lst[x])\n        new_solution[worst_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8619480787409902,
            7.05458602309227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal potential\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(sol * weight_lst)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            continue\n        # Calculate marginal gains for items not in the solution\n        marginal1 = value1_lst * (1 - sol)\n        marginal2 = value2_lst * (1 - sol)\n        # Prioritize solutions with high marginal gains\n        score = np.sum(marginal1 + marginal2) / (1 + current_weight)\n        candidates.append((sol, score))\n\n    if not candidates:\n        # Fallback: select a random solution if no candidates with remaining capacity\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest marginal score\n        base_solution = max(candidates, key=lambda x: x[1])[0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Perform hybrid local search\n    # Step 1: Random swap with high-marginal items\n    possible_items = np.where((1 - new_solution) * weight_lst <= remaining_capacity)[0]\n    if len(possible_items) > 0:\n        high_marginal_items = possible_items[np.argsort(-(value1_lst[possible_items] + value2_lst[possible_items]))[:max(1, len(possible_items)//2)]]\n        if len(high_marginal_items) > 0:\n            swap_item = random.choice(high_marginal_items)\n            new_solution[swap_item] = 1 - new_solution[swap_item]  # Flip the item\n            current_weight = np.sum(new_solution * weight_lst)\n            remaining_capacity = capacity - current_weight\n\n    # Step 2: Add/remove items with adaptive neighborhood\n    if remaining_capacity > 0:\n        # Try to add items with high marginal value\n        add_candidates = np.where((1 - new_solution) * weight_lst <= remaining_capacity)[0]\n        if len(add_candidates) > 0:\n            best_add = max(add_candidates, key=lambda x: value1_lst[x] + value2_lst[x])\n            new_solution[best_add] = 1\n    else:\n        # Try to remove items with low marginal value\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            worst_remove = min(remove_candidates, key=lambda x: value1_lst[x] + value2_lst[x])\n            new_solution[worst_remove] = 0\n\n    # Ensure feasibility\n    while np.sum(new_solution * weight_lst) > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break  # No items left to remove\n        worst_remove = min(remove_candidates, key=lambda x: value1_lst[x] + value2_lst[x])\n        new_solution[worst_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, combines adaptive perturbation with a dynamic neighborhood exploration strategy to generate high-quality neighbors while ensuring feasibility, and incorporates objective-specific diversification to balance exploration and exploitation across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution (intelligently random selection)\n    # Prefer solutions with high potential for improvement (e.g., those with low weight utilization)\n    current_weights = [np.sum(weight_lst[s[0] == 1]) for s in archive]\n    weight_utilization = [w / capacity for w in current_weights]\n    # Select solutions with low weight utilization (more room for improvement)\n    candidates = [i for i, util in enumerate(weight_utilization) if util < 0.9]\n    if not candidates:\n        candidates = list(range(len(archive)))\n    selected_idx = random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 2.1: Adaptive perturbation (flip a subset of items)\n    # Determine flip probability based on current weight utilization\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    flip_prob = max(0.1, 0.5 * (1 - current_weight / capacity))\n\n    # Flip items with probability flip_prob\n    for i in range(n_items):\n        if random.random() < flip_prob:\n            if base_solution[i] == 1:\n                # Try to remove item if feasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add item if feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2.2: Dynamic neighborhood exploration (swap items between objectives)\n    # Identify items with high marginal contribution to either objective\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst[included_items] / weight_lst[included_items]\n    marginal2 = value2_lst[included_items] / weight_lst[included_items]\n\n    # Sort by marginal contribution (descending)\n    sorted_included = included_items[np.argsort(-np.maximum(marginal1, marginal2))]\n\n    # Try to swap low-contribution items with high-contribution excluded items\n    for i in sorted_included[-min(3, len(sorted_included)):]:  # Consider bottom 3 items\n        for j in excluded_items:\n            if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                # Swap items\n                new_solution[i] = 0\n                new_solution[j] = 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.40894740944958397,
            2.183033138513565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution (intelligently random selection)\n    # Prefer solutions with high potential for improvement (e.g., those with low weight utilization)\n    current_weights = [np.sum(weight_lst[s[0] == 1]) for s in archive]\n    weight_utilization = [w / capacity for w in current_weights]\n    # Select solutions with low weight utilization (more room for improvement)\n    candidates = [i for i, util in enumerate(weight_utilization) if util < 0.9]\n    if not candidates:\n        candidates = list(range(len(archive)))\n    selected_idx = random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 2.1: Adaptive perturbation (flip a subset of items)\n    # Determine flip probability based on current weight utilization\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    flip_prob = max(0.1, 0.5 * (1 - current_weight / capacity))\n\n    # Flip items with probability flip_prob\n    for i in range(n_items):\n        if random.random() < flip_prob:\n            if base_solution[i] == 1:\n                # Try to remove item if feasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add item if feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2.2: Dynamic neighborhood exploration (swap items between objectives)\n    # Identify items with high marginal contribution to either objective\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst[included_items] / weight_lst[included_items]\n    marginal2 = value2_lst[included_items] / weight_lst[included_items]\n\n    # Sort by marginal contribution (descending)\n    sorted_included = included_items[np.argsort(-np.maximum(marginal1, marginal2))]\n\n    # Try to swap low-contribution items with high-contribution excluded items\n    for i in sorted_included[-min(3, len(sorted_included)):]:  # Consider bottom 3 items\n        for j in excluded_items:\n            if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                # Swap items\n                new_solution[i] = 0\n                new_solution[j] = 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining item swaps and probabilistic flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for sol, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: item swaps and probabilistic flips\n    for _ in range(3):  # Number of perturbation steps\n        # Randomly select two items to swap\n        i, j = random.sample(range(n_items), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Check feasibility\n        if np.dot(new_solution, weight_lst) > capacity:\n            # If infeasible, undo the swap and try flipping\n            new_solution[j] = new_solution[i]\n            new_solution[i] = temp\n            # Flip a random item with probability based on its value\n            k = random.randint(0, n_items-1)\n            if random.random() < (value1_lst[k] + value2_lst[k]) / (np.sum(value1_lst) + np.sum(value2_lst)):\n                new_solution[k] = 1 - new_solution[k]\n                # Ensure feasibility after flip\n                if np.dot(new_solution, weight_lst) > capacity:\n                    new_solution[k] = 1 - new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.4542553160358305,
            6.491006523370743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for sol, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: item swaps and probabilistic flips\n    for _ in range(3):  # Number of perturbation steps\n        # Randomly select two items to swap\n        i, j = random.sample(range(n_items), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Check feasibility\n        if np.dot(new_solution, weight_lst) > capacity:\n            # If infeasible, undo the swap and try flipping\n            new_solution[j] = new_solution[i]\n            new_solution[i] = temp\n            # Flip a random item with probability based on its value\n            k = random.randint(0, n_items-1)\n            if random.random() < (value1_lst[k] + value2_lst[k]) / (np.sum(value1_lst) + np.sum(value2_lst)):\n                new_solution[k] = 1 - new_solution[k]\n                # Ensure feasibility after flip\n                if np.dot(new_solution, weight_lst) > capacity:\n                    new_solution[k] = 1 - new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps, random flips, and adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by a combination of objective values (e.g., sum of normalized values)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(int(len(sorted_archive) * 0.2), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: Combine item swaps, random flips, and adaptive exploration\n    # 1. Randomly select a subset of items to flip\n    flip_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Check if adding the item is feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # 2. Adaptive exploration: Swap items between different regions\n    if len(weight_lst) > 1:\n        # Identify items with high value1 and low value2, and vice versa\n        high_value1_low_value2 = (value1_lst > np.mean(value1_lst)) & (value2_lst < np.mean(value2_lst))\n        high_value2_low_value1 = (value2_lst > np.mean(value2_lst)) & (value1_lst < np.mean(value1_lst))\n\n        # Swap items between these regions if feasible\n        for i in np.where(high_value1_low_value2 & (new_solution == 1))[0]:\n            for j in np.where(high_value2_low_value1 & (new_solution == 0))[0]:\n                if weight_lst[i] <= weight_lst[j]:\n                    # Swap items i and j\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(excess_items) > 0:\n            idx = np.random.choice(excess_items)\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n            excess_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.8594318586399066,
            3.7055764496326447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by a combination of objective values (e.g., sum of normalized values)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(int(len(sorted_archive) * 0.2), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: Combine item swaps, random flips, and adaptive exploration\n    # 1. Randomly select a subset of items to flip\n    flip_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Check if adding the item is feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # 2. Adaptive exploration: Swap items between different regions\n    if len(weight_lst) > 1:\n        # Identify items with high value1 and low value2, and vice versa\n        high_value1_low_value2 = (value1_lst > np.mean(value1_lst)) & (value2_lst < np.mean(value2_lst))\n        high_value2_low_value1 = (value2_lst > np.mean(value2_lst)) & (value1_lst < np.mean(value1_lst))\n\n        # Swap items between these regions if feasible\n        for i in np.where(high_value1_low_value2 & (new_solution == 1))[0]:\n            for j in np.where(high_value2_low_value1 & (new_solution == 0))[0]:\n                if weight_lst[i] <= weight_lst[j]:\n                    # Swap items i and j\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(excess_items) > 0:\n            idx = np.random.choice(excess_items)\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n            excess_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping with probabilistic item flipping, where promising items are intelligently selected based on their marginal contributions to both objectives, ensuring feasibility while exploring diverse neighborhoods to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement\n        values = np.array([obj[0] + obj[1] for _, obj in archive])\n        prob = values / np.sum(values)\n        selected_idx = np.random.choice(len(archive), p=prob)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items to potentially swap or flip\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: adaptive swapping + probabilistic flipping\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Adaptive swapping: swap an item with high marginal contribution\n        swap_in = np.random.choice(included_items)\n        swap_out = np.random.choice(excluded_items)\n\n        # Check feasibility of swap\n        new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n        if new_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n            return new_solution\n\n    # Probabilistic flipping: flip items with high marginal contribution\n    for item in included_items:\n        # Calculate marginal contribution for both objectives\n        marginal1 = value1_lst[item] / weight_lst[item]\n        marginal2 = value2_lst[item] / weight_lst[item]\n\n        # Probability of flipping based on marginal contributions\n        flip_prob = 0.3 * (marginal1 + marginal2) / (np.max(value1_lst) + np.max(value2_lst))\n        if np.random.rand() < flip_prob:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight >= 0:  # Ensure non-negative weight (though capacity check is more important)\n                new_solution[item] = 0\n                return new_solution\n\n    # If no improvements found, perform a random flip\n    if len(included_items) > 0:\n        random_item = np.random.choice(included_items)\n        if current_weight - weight_lst[random_item] >= 0:\n            new_solution[random_item] = 0\n            return new_solution\n\n    # If all else fails, add a random excluded item if feasible\n    if len(excluded_items) > 0:\n        random_item = np.random.choice(excluded_items)\n        if current_weight + weight_lst[random_item] <= capacity:\n            new_solution[random_item] = 1\n            return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.561895068254312,
            2.0049189031124115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement\n        values = np.array([obj[0] + obj[1] for _, obj in archive])\n        prob = values / np.sum(values)\n        selected_idx = np.random.choice(len(archive), p=prob)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items to potentially swap or flip\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: adaptive swapping + probabilistic flipping\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Adaptive swapping: swap an item with high marginal contribution\n        swap_in = np.random.choice(included_items)\n        swap_out = np.random.choice(excluded_items)\n\n        # Check feasibility of swap\n        new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n        if new_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n            return new_solution\n\n    # Probabilistic flipping: flip items with high marginal contribution\n    for item in included_items:\n        # Calculate marginal contribution for both objectives\n        marginal1 = value1_lst[item] / weight_lst[item]\n        marginal2 = value2_lst[item] / weight_lst[item]\n\n        # Probability of flipping based on marginal contributions\n        flip_prob = 0.3 * (marginal1 + marginal2) / (np.max(value1_lst) + np.max(value2_lst))\n        if np.random.rand() < flip_prob:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight >= 0:  # Ensure non-negative weight (though capacity check is more important)\n                new_solution[item] = 0\n                return new_solution\n\n    # If no improvements found, perform a random flip\n    if len(included_items) > 0:\n        random_item = np.random.choice(included_items)\n        if current_weight - weight_lst[random_item] >= 0:\n            new_solution[random_item] = 0\n            return new_solution\n\n    # If all else fails, add a random excluded item if feasible\n    if len(excluded_items) > 0:\n        random_item = np.random.choice(excluded_items)\n        if current_weight + weight_lst[random_item] <= capacity:\n            new_solution[random_item] = 1\n            return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive with high potential for improvement, then applies a hybrid local search strategy combining random item swaps with value-based perturbations to generate a feasible neighbor solution that explores trade-offs between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            # Prefer solutions that are not already extreme in either objective\n            candidates.append((sol, v1, v2, total_weight))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Sort by diversity in objectives (prioritize middle solutions)\n    candidates.sort(key=lambda x: abs(x[1] - x[2]))\n    selected = candidates[len(candidates)//2][0]  # Middle solution\n\n    new_solution = selected.copy()\n    n_items = len(new_solution)\n\n    # Hybrid local search: random swaps + value-based perturbations\n    for _ in range(min(5, n_items)):  # Limit perturbations\n        # Random swap\n        i, j = random.sample(range(n_items), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Check feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            # If infeasible, undo and try value-based perturbation\n            new_solution[j] = new_solution[i]\n            new_solution[i] = temp\n            # Flip a low-value item to high-value item if possible\n            low_value_items = np.where((value1_lst + value2_lst) < np.median(value1_lst + value2_lst))[0]\n            for item in low_value_items:\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    if np.sum(weight_lst * new_solution) <= capacity:\n                        break\n                    new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8196873257568317,
            3.4658045768737793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            # Prefer solutions that are not already extreme in either objective\n            candidates.append((sol, v1, v2, total_weight))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Sort by diversity in objectives (prioritize middle solutions)\n    candidates.sort(key=lambda x: abs(x[1] - x[2]))\n    selected = candidates[len(candidates)//2][0]  # Middle solution\n\n    new_solution = selected.copy()\n    n_items = len(new_solution)\n\n    # Hybrid local search: random swaps + value-based perturbations\n    for _ in range(min(5, n_items)):  # Limit perturbations\n        # Random swap\n        i, j = random.sample(range(n_items), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Check feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            # If infeasible, undo and try value-based perturbation\n            new_solution[j] = new_solution[i]\n            new_solution[i] = temp\n            # Flip a low-value item to high-value item if possible\n            low_value_items = np.where((value1_lst + value2_lst) < np.median(value1_lst + value2_lst))[0]\n            for item in low_value_items:\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    if np.sum(weight_lst * new_solution) <= capacity:\n                        break\n                    new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive item swapping with a probabilistic exploration of trade-off regions to generate high-quality neighbors by intelligently selecting and flipping items based on their marginal contributions to both objectives, while dynamically adjusting the exploration radius to balance exploitation and exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be flipped (either 0->1 or 1->0)\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, 'remove'))\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 'add'))\n\n    if not candidates:\n        return base_solution  # No feasible moves\n\n    # Select a candidate based on marginal contribution to both objectives\n    best_candidate = None\n    best_score = -float('inf')\n\n    for i, action in candidates:\n        if action == 'remove':\n            new_weight = current_weight - weight_lst[i]\n            new_value1 = current_value1 - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i]\n        else:  # 'add'\n            new_weight = current_weight + weight_lst[i]\n            new_value1 = current_value1 + value1_lst[i]\n            new_value2 = current_value2 + value2_lst[i]\n\n        # Score based on normalized marginal contribution to both objectives\n        delta_value1 = (new_value1 - current_value1) / (np.max(value1_lst) if np.max(value1_lst) != 0 else 1)\n        delta_value2 = (new_value2 - current_value2) / (np.max(value2_lst) if np.max(value2_lst) != 0 else 1)\n        score = delta_value1 + delta_value2\n\n        if score > best_score:\n            best_score = score\n            best_candidate = (i, action)\n\n    if best_candidate is not None:\n        i, action = best_candidate\n        if action == 'remove':\n            new_solution[i] = 0\n        else:\n            new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8743026250949176,
            10.930178612470627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be flipped (either 0->1 or 1->0)\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, 'remove'))\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 'add'))\n\n    if not candidates:\n        return base_solution  # No feasible moves\n\n    # Select a candidate based on marginal contribution to both objectives\n    best_candidate = None\n    best_score = -float('inf')\n\n    for i, action in candidates:\n        if action == 'remove':\n            new_weight = current_weight - weight_lst[i]\n            new_value1 = current_value1 - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i]\n        else:  # 'add'\n            new_weight = current_weight + weight_lst[i]\n            new_value1 = current_value1 + value1_lst[i]\n            new_value2 = current_value2 + value2_lst[i]\n\n        # Score based on normalized marginal contribution to both objectives\n        delta_value1 = (new_value1 - current_value1) / (np.max(value1_lst) if np.max(value1_lst) != 0 else 1)\n        delta_value2 = (new_value2 - current_value2) / (np.max(value2_lst) if np.max(value2_lst) != 0 else 1)\n        score = delta_value1 + delta_value2\n\n        if score > best_score:\n            best_score = score\n            best_candidate = (i, action)\n\n    if best_candidate is not None:\n        i, action = best_candidate\n        if action == 'remove':\n            new_solution[i] = 0\n        else:\n            new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{The heuristic selects a solution from the archive with high potential for local improvement by prioritizing solutions with the highest sum of normalized objective values, then applies a hybrid local search combining item swaps and adaptive flips, ensuring feasibility and non-dominated neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive flips and item swaps\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Adaptive flip: more likely to flip items with higher marginal value\n        items = np.where(base_solution == 1)[0]\n        if len(items) > 0:\n            item_to_flip = random.choice(items)\n            new_solution[item_to_flip] = 1 - new_solution[item_to_flip]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Undo if infeasible and try again\n            new_solution[item_to_flip] = base_solution[item_to_flip]\n            continue\n\n        # Item swap: exchange items between selected and unselected\n        selected_items = np.where(new_solution == 1)[0]\n        unselected_items = np.where(new_solution == 0)[0]\n\n        if len(selected_items) > 0 and len(unselected_items) > 0:\n            swap_out = random.choice(selected_items)\n            swap_in = random.choice(unselected_items)\n\n            # Try swapping\n            temp_solution = new_solution.copy()\n            temp_solution[swap_out] = 0\n            temp_solution[swap_in] = 1\n\n            # Check feasibility\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5096721622940189,
            3.4485625624656677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive flips and item swaps\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Adaptive flip: more likely to flip items with higher marginal value\n        items = np.where(base_solution == 1)[0]\n        if len(items) > 0:\n            item_to_flip = random.choice(items)\n            new_solution[item_to_flip] = 1 - new_solution[item_to_flip]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Undo if infeasible and try again\n            new_solution[item_to_flip] = base_solution[item_to_flip]\n            continue\n\n        # Item swap: exchange items between selected and unselected\n        selected_items = np.where(new_solution == 1)[0]\n        unselected_items = np.where(new_solution == 0)[0]\n\n        if len(selected_items) > 0 and len(unselected_items) > 0:\n            swap_out = random.choice(selected_items)\n            swap_in = random.choice(unselected_items)\n\n            # Try swapping\n            temp_solution = new_solution.copy()\n            temp_solution[swap_out] = 0\n            temp_solution[swap_in] = 1\n\n            # Check feasibility\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive, identifies critical items based on their contribution to both objectives, and performs a hybrid local search by either flipping a subset of items with high marginal utility or swapping items between high- and low-contribution categories to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal utilities for each item\n    marginal_util1 = value1_lst / (weight_lst + 1e-6)\n    marginal_util2 = value2_lst / (weight_lst + 1e-6)\n    combined_util = marginal_util1 + marginal_util2\n\n    # Identify high and low utility items\n    high_util_items = np.where(combined_util > np.percentile(combined_util, 75))[0]\n    low_util_items = np.where(combined_util <= np.percentile(combined_util, 25))[0]\n\n    # Hybrid local search: either flip high utility items or swap between high and low utility items\n    if np.random.rand() < 0.7:\n        # Flip high utility items (with probability inversely proportional to their weight)\n        flip_prob = 1 / (weight_lst[high_util_items] + 1e-6)\n        flip_mask = np.random.rand(len(high_util_items)) < flip_prob\n        flip_items = high_util_items[flip_mask]\n\n        # Flip selected items while maintaining feasibility\n        for item in flip_items:\n            if new_solution[item] == 1:\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n    else:\n        # Swap between high and low utility items\n        if len(high_util_items) > 0 and len(low_util_items) > 0:\n            high_item = np.random.choice(high_util_items)\n            low_item = np.random.choice(low_util_items)\n\n            if new_solution[high_item] == 1 and new_solution[low_item] == 0:\n                if current_weight - weight_lst[high_item] + weight_lst[low_item] <= capacity:\n                    new_solution[high_item] = 0\n                    new_solution[low_item] = 1\n            elif new_solution[high_item] == 0 and new_solution[low_item] == 1:\n                if current_weight - weight_lst[low_item] + weight_lst[high_item] <= capacity:\n                    new_solution[high_item] = 1\n                    new_solution[low_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.47924122635414257,
            5.1386673748493195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal utilities for each item\n    marginal_util1 = value1_lst / (weight_lst + 1e-6)\n    marginal_util2 = value2_lst / (weight_lst + 1e-6)\n    combined_util = marginal_util1 + marginal_util2\n\n    # Identify high and low utility items\n    high_util_items = np.where(combined_util > np.percentile(combined_util, 75))[0]\n    low_util_items = np.where(combined_util <= np.percentile(combined_util, 25))[0]\n\n    # Hybrid local search: either flip high utility items or swap between high and low utility items\n    if np.random.rand() < 0.7:\n        # Flip high utility items (with probability inversely proportional to their weight)\n        flip_prob = 1 / (weight_lst[high_util_items] + 1e-6)\n        flip_mask = np.random.rand(len(high_util_items)) < flip_prob\n        flip_items = high_util_items[flip_mask]\n\n        # Flip selected items while maintaining feasibility\n        for item in flip_items:\n            if new_solution[item] == 1:\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n    else:\n        # Swap between high and low utility items\n        if len(high_util_items) > 0 and len(low_util_items) > 0:\n            high_item = np.random.choice(high_util_items)\n            low_item = np.random.choice(low_util_items)\n\n            if new_solution[high_item] == 1 and new_solution[low_item] == 0:\n                if current_weight - weight_lst[high_item] + weight_lst[low_item] <= capacity:\n                    new_solution[high_item] = 0\n                    new_solution[low_item] = 1\n            elif new_solution[high_item] == 0 and new_solution[low_item] == 1:\n                if current_weight - weight_lst[low_item] + weight_lst[high_item] <= capacity:\n                    new_solution[high_item] = 1\n                    new_solution[low_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{The heuristic selects a solution from the archive with the highest combined normalized objective values, then applies a hybrid local search combining random item swaps and a greedy improvement step to explore promising neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined normalized objective\n    max_norm = -1\n    selected_solution = None\n    for sol, obj in archive:\n        norm = (obj[0] + obj[1]) / (np.sum(value1_lst) + np.sum(value2_lst))\n        if norm > max_norm:\n            max_norm = norm\n            selected_solution = sol\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy improvement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Random swaps (exploration)\n    for _ in range(min(5, n_items)):\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                current_value1 -= value1_lst[i]\n                current_value2 -= value2_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                current_value1 += value1_lst[i]\n                current_value2 += value2_lst[i]\n\n    # Greedy improvement (exploitation)\n    improved = True\n    while improved:\n        improved = False\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                # Try removing item i\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_value1 = current_value1 - value1_lst[i]\n                    new_value2 = current_value2 - value2_lst[i]\n                    # Check if any solution in archive has better objectives\n                    better = True\n                    for _, obj in archive:\n                        if obj[0] >= new_value1 and obj[1] >= new_value2 and (obj[0] > new_value1 or obj[1] > new_value2):\n                            better = False\n                            break\n                    if better:\n                        new_solution[i] = 0\n                        current_weight = new_weight\n                        current_value1 = new_value1\n                        current_value2 = new_value2\n                        improved = True\n                        break\n            else:\n                # Try adding item i\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_value1 = current_value1 + value1_lst[i]\n                    new_value2 = current_value2 + value2_lst[i]\n                    # Check if any solution in archive has better objectives\n                    better = True\n                    for _, obj in archive:\n                        if obj[0] >= new_value1 and obj[1] >= new_value2 and (obj[0] > new_value1 or obj[1] > new_value2):\n                            better = False\n                            break\n                    if better:\n                        new_solution[i] = 1\n                        current_weight = new_weight\n                        current_value1 = new_value1\n                        current_value2 = new_value2\n                        improved = True\n                        break\n        if improved:\n            break  # Only one improvement per iteration to avoid excessive computation\n\n    return new_solution\n\n",
        "score": [
            -0.3440474996457686,
            8.56318774819374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined normalized objective\n    max_norm = -1\n    selected_solution = None\n    for sol, obj in archive:\n        norm = (obj[0] + obj[1]) / (np.sum(value1_lst) + np.sum(value2_lst))\n        if norm > max_norm:\n            max_norm = norm\n            selected_solution = sol\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy improvement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Random swaps (exploration)\n    for _ in range(min(5, n_items)):\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                current_value1 -= value1_lst[i]\n                current_value2 -= value2_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                current_value1 += value1_lst[i]\n                current_value2 += value2_lst[i]\n\n    # Greedy improvement (exploitation)\n    improved = True\n    while improved:\n        improved = False\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                # Try removing item i\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_value1 = current_value1 - value1_lst[i]\n                    new_value2 = current_value2 - value2_lst[i]\n                    # Check if any solution in archive has better objectives\n                    better = True\n                    for _, obj in archive:\n                        if obj[0] >= new_value1 and obj[1] >= new_value2 and (obj[0] > new_value1 or obj[1] > new_value2):\n                            better = False\n                            break\n                    if better:\n                        new_solution[i] = 0\n                        current_weight = new_weight\n                        current_value1 = new_value1\n                        current_value2 = new_value2\n                        improved = True\n                        break\n            else:\n                # Try adding item i\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_value1 = current_value1 + value1_lst[i]\n                    new_value2 = current_value2 + value2_lst[i]\n                    # Check if any solution in archive has better objectives\n                    better = True\n                    for _, obj in archive:\n                        if obj[0] >= new_value1 and obj[1] >= new_value2 and (obj[0] > new_value1 or obj[1] > new_value2):\n                            better = False\n                            break\n                    if better:\n                        new_solution[i] = 1\n                        current_weight = new_weight\n                        current_value1 = new_value1\n                        current_value2 = new_value2\n                        improved = True\n                        break\n        if improved:\n            break  # Only one improvement per iteration to avoid excessive computation\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing those with high marginal gains in either objective, then applies a hybrid local search combining item swaps and flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n\n    # Calculate marginal gains for each item\n    marginal_v1 = value1_lst * (1 - base_solution) - value1_lst * base_solution\n    marginal_v2 = value2_lst * (1 - base_solution) - value2_lst * base_solution\n\n    # Combine marginal gains into a single score\n    scores = marginal_v1 + marginal_v2\n    promising_items = np.argsort(scores)[-max(3, len(scores) // 5):]  # Top 20% or 3 items\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    if len(promising_items) > 0:\n        # Swap a random promising item\n        swap_idx = random.choice(promising_items)\n        new_solution[swap_idx] = 1 - new_solution[swap_idx]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If infeasible, flip another item to make it feasible\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                flip_idx = random.choice(candidate_items)\n                new_solution[flip_idx] = 0\n\n    # If no promising items or swap didn't work, try a random flip\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(base_solution == 0)[0]\n        if len(candidate_items) > 0:\n            flip_idx = random.choice(candidate_items)\n            new_solution[flip_idx] = 1\n            total_weight = np.sum(weight_lst * new_solution)\n            if total_weight > capacity:\n                new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3230461277757606,
            4.5286601185798645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n\n    # Calculate marginal gains for each item\n    marginal_v1 = value1_lst * (1 - base_solution) - value1_lst * base_solution\n    marginal_v2 = value2_lst * (1 - base_solution) - value2_lst * base_solution\n\n    # Combine marginal gains into a single score\n    scores = marginal_v1 + marginal_v2\n    promising_items = np.argsort(scores)[-max(3, len(scores) // 5):]  # Top 20% or 3 items\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    if len(promising_items) > 0:\n        # Swap a random promising item\n        swap_idx = random.choice(promising_items)\n        new_solution[swap_idx] = 1 - new_solution[swap_idx]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If infeasible, flip another item to make it feasible\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                flip_idx = random.choice(candidate_items)\n                new_solution[flip_idx] = 0\n\n    # If no promising items or swap didn't work, try a random flip\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(base_solution == 0)[0]\n        if len(candidate_items) > 0:\n            flip_idx = random.choice(candidate_items)\n            new_solution[flip_idx] = 1\n            total_weight = np.sum(weight_lst * new_solution)\n            if total_weight > capacity:\n                new_solution[flip_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with the highest aggregate objective values, then applies a hybrid local search combining item swapping and probabilistic flipping to explore high-potential neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution, _ = archive[0]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: swap two items if feasible, otherwise flip a random item\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Try swapping two items\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        i, j = random.sample(range(n_items), 2)\n        if selected_solution[i] == selected_solution[j]:\n            continue  # No change if both are same\n\n        # Calculate new weight and values\n        if selected_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n        else:\n            new_weight = current_weight + weight_lst[i] - weight_lst[j]\n\n        if new_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            return new_solution\n\n    # If swap fails, try flipping a random item\n    for _ in range(10):\n        i = random.randint(0, n_items - 1)\n        if selected_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i]\n        else:\n            new_weight = current_weight + weight_lst[i]\n\n        if new_weight <= capacity:\n            new_solution[i] = 1 - new_solution[i]\n            return new_solution\n\n    # If all attempts fail, return the original solution\n    return selected_solution.copy()\n\n",
        "score": [
            -0.33400980597488444,
            1.739454597234726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution, _ = archive[0]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: swap two items if feasible, otherwise flip a random item\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Try swapping two items\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        i, j = random.sample(range(n_items), 2)\n        if selected_solution[i] == selected_solution[j]:\n            continue  # No change if both are same\n\n        # Calculate new weight and values\n        if selected_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n        else:\n            new_weight = current_weight + weight_lst[i] - weight_lst[j]\n\n        if new_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            return new_solution\n\n    # If swap fails, try flipping a random item\n    for _ in range(10):\n        i = random.randint(0, n_items - 1)\n        if selected_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i]\n        else:\n            new_weight = current_weight + weight_lst[i]\n\n        if new_weight <= capacity:\n            new_solution[i] = 1 - new_solution[i]\n            return new_solution\n\n    # If all attempts fail, return the original solution\n    return selected_solution.copy()\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This heuristic selects a solution from the archive with high objective diversity, applies a hybrid local search combining item swapping and adaptive neighborhood exploration to generate a feasible neighbor solution, ensuring both objectives are improved or maintained while respecting the weight constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective diversity\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    current_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[current_solution == 1])\n    current_value1 = np.sum(value1_lst[current_solution == 1])\n    current_value2 = np.sum(value2_lst[current_solution == 1])\n\n    # Hybrid local search: adaptive item swapping and neighborhood exploration\n    for _ in range(10):  # Number of iterations\n        # Randomly select a subset of items to consider for swapping\n        candidate_indices = np.where(current_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            break\n\n        # Select a random item to remove\n        remove_idx = np.random.choice(candidate_indices)\n        new_solution = current_solution.copy()\n        new_solution[remove_idx] = 0\n\n        # Find items that can be added without exceeding capacity\n        remaining_capacity = capacity - (current_weight - weight_lst[remove_idx])\n        available_items = np.where((current_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n        if len(available_items) > 0:\n            # Select an item to add based on value improvement\n            add_idx = np.random.choice(available_items)\n            new_solution[add_idx] = 1\n\n            # Check feasibility and improvement\n            new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n            if new_weight <= capacity:\n                # Accept if at least one objective improves\n                new_value1 = current_value1 - value1_lst[remove_idx] + value1_lst[add_idx]\n                new_value2 = current_value2 - value2_lst[remove_idx] + value2_lst[add_idx]\n\n                if (new_value1 > current_value1) or (new_value2 > current_value2):\n                    current_solution = new_solution\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return current_solution\n\n",
        "score": [
            -0.538584607580847,
            6.531243056058884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective diversity\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    current_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[current_solution == 1])\n    current_value1 = np.sum(value1_lst[current_solution == 1])\n    current_value2 = np.sum(value2_lst[current_solution == 1])\n\n    # Hybrid local search: adaptive item swapping and neighborhood exploration\n    for _ in range(10):  # Number of iterations\n        # Randomly select a subset of items to consider for swapping\n        candidate_indices = np.where(current_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            break\n\n        # Select a random item to remove\n        remove_idx = np.random.choice(candidate_indices)\n        new_solution = current_solution.copy()\n        new_solution[remove_idx] = 0\n\n        # Find items that can be added without exceeding capacity\n        remaining_capacity = capacity - (current_weight - weight_lst[remove_idx])\n        available_items = np.where((current_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n        if len(available_items) > 0:\n            # Select an item to add based on value improvement\n            add_idx = np.random.choice(available_items)\n            new_solution[add_idx] = 1\n\n            # Check feasibility and improvement\n            new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n            if new_weight <= capacity:\n                # Accept if at least one objective improves\n                new_value1 = current_value1 - value1_lst[remove_idx] + value1_lst[add_idx]\n                new_value2 = current_value2 - value2_lst[remove_idx] + value2_lst[add_idx]\n\n                if (new_value1 > current_value1) or (new_value2 > current_value2):\n                    current_solution = new_solution\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return current_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with the highest potential for improvement, then applies a hybrid local search operator that combines item swapping and adaptive perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[0]) / len(x[0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Swap one item in with one item out\n        swap_in = np.random.choice(items_in)\n        swap_out = np.random.choice(items_out)\n\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n        if new_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n        else:\n            # Adaptive perturbation: remove low-value items if swap is infeasible\n            low_value_items = np.argsort(value1_lst + value2_lst)[::-1]\n            for item in low_value_items:\n                if new_solution[item] == 1:\n                    new_weight = current_weight - weight_lst[item]\n                    if new_weight <= capacity:\n                        new_solution[item] = 0\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.5636966816069452,
            8.907817423343658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[0]) / len(x[0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Swap one item in with one item out\n        swap_in = np.random.choice(items_in)\n        swap_out = np.random.choice(items_out)\n\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n        if new_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n        else:\n            # Adaptive perturbation: remove low-value items if swap is infeasible\n            low_value_items = np.argsort(value1_lst + value2_lst)[::-1]\n            for item in low_value_items:\n                if new_solution[item] == 1:\n                    new_weight = current_weight - weight_lst[item]\n                    if new_weight <= capacity:\n                        new_solution[item] = 0\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high objective values and low crowding distances, then applies a hybrid local search combining random item swaps and adaptive neighborhood exploration to generate a feasible neighbor solution with improved objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution (highest combined objective value)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    def crowding_distance(objectives):\n        n = len(objectives)\n        if n <= 2:\n            return [float('inf')] * n\n        distances = [0.0] * n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, n-1):\n                if objectives[sorted_idx[-1]][m] == objectives[sorted_idx[0]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n        return distances\n\n    distances = crowding_distance(archive_objectives)\n    combined_scores = [obj[0] + obj[1] + dist for obj, dist in zip(archive_objectives, distances)]\n    best_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Randomly select a subset of items to consider for swap\n    if len(items) > 0 and len(non_items) > 0:\n        k = min(3, len(items))  # Number of items to consider for swap\n        selected_items = np.random.choice(items, size=k, replace=False)\n        selected_non_items = np.random.choice(non_items, size=k, replace=False)\n\n        # Try to swap items for better trade-offs\n        for i in selected_items:\n            for j in selected_non_items:\n                if (weight_lst[j] - weight_lst[i]) <= (capacity - np.sum(weight_lst * base_solution)):\n                    new_solution[i] = 0\n                    new_solution[j] = 1\n                    # Check if this improves at least one objective\n                    delta_v1 = value1_lst[j] - value1_lst[i]\n                    delta_v2 = value2_lst[j] - value2_lst[i]\n                    if delta_v1 > 0 or delta_v2 > 0:\n                        break\n                else:\n                    new_solution[i] = 0\n                    new_solution[j] = 1\n                    # Try to find a feasible swap even if it doesn't improve objectives\n                    if np.sum(weight_lst * new_solution) <= capacity:\n                        break\n\n    # If no improvement found, perform a random flip to maintain diversity\n    if np.array_equal(new_solution, base_solution):\n        if len(items) > 0:\n            flip_idx = np.random.choice(items)\n            new_solution[flip_idx] = 0\n        elif len(non_items) > 0:\n            flip_idx = np.random.choice(non_items)\n            new_solution[flip_idx] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        if np.sum(new_solution) == 0:\n            break\n        remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.6805482036258055,
            7.660990983247757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution (highest combined objective value)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    def crowding_distance(objectives):\n        n = len(objectives)\n        if n <= 2:\n            return [float('inf')] * n\n        distances = [0.0] * n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, n-1):\n                if objectives[sorted_idx[-1]][m] == objectives[sorted_idx[0]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n        return distances\n\n    distances = crowding_distance(archive_objectives)\n    combined_scores = [obj[0] + obj[1] + dist for obj, dist in zip(archive_objectives, distances)]\n    best_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Randomly select a subset of items to consider for swap\n    if len(items) > 0 and len(non_items) > 0:\n        k = min(3, len(items))  # Number of items to consider for swap\n        selected_items = np.random.choice(items, size=k, replace=False)\n        selected_non_items = np.random.choice(non_items, size=k, replace=False)\n\n        # Try to swap items for better trade-offs\n        for i in selected_items:\n            for j in selected_non_items:\n                if (weight_lst[j] - weight_lst[i]) <= (capacity - np.sum(weight_lst * base_solution)):\n                    new_solution[i] = 0\n                    new_solution[j] = 1\n                    # Check if this improves at least one objective\n                    delta_v1 = value1_lst[j] - value1_lst[i]\n                    delta_v2 = value2_lst[j] - value2_lst[i]\n                    if delta_v1 > 0 or delta_v2 > 0:\n                        break\n                else:\n                    new_solution[i] = 0\n                    new_solution[j] = 1\n                    # Try to find a feasible swap even if it doesn't improve objectives\n                    if np.sum(weight_lst * new_solution) <= capacity:\n                        break\n\n    # If no improvement found, perform a random flip to maintain diversity\n    if np.array_equal(new_solution, base_solution):\n        if len(items) > 0:\n            flip_idx = np.random.choice(items)\n            new_solution[flip_idx] = 0\n        elif len(non_items) > 0:\n            flip_idx = np.random.choice(non_items)\n            new_solution[flip_idx] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        if np.sum(new_solution) == 0:\n            break\n        remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(x[0]))[0].copy()\n\n    # Generate neighbor by randomly swapping or replacing items\n    new_solution = selected_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    if len(items) > 0 and len(non_items) > 0:\n        # Randomly select an item to remove and an item to add\n        remove_idx = np.random.choice(items)\n        add_idx = np.random.choice(non_items)\n\n        # Check feasibility of the swap\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if (current_weight - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n        else:\n            # If swap is infeasible, try to replace with a lighter item\n            lighter_items = [i for i in non_items if weight_lst[i] <= (capacity - current_weight + weight_lst[remove_idx])]\n            if lighter_items:\n                add_idx = np.random.choice(lighter_items)\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5179145533646285,
            3.6444191932678223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(x[0]))[0].copy()\n\n    # Generate neighbor by randomly swapping or replacing items\n    new_solution = selected_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    if len(items) > 0 and len(non_items) > 0:\n        # Randomly select an item to remove and an item to add\n        remove_idx = np.random.choice(items)\n        add_idx = np.random.choice(non_items)\n\n        # Check feasibility of the swap\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if (current_weight - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n        else:\n            # If swap is infeasible, try to replace with a lighter item\n            lighter_items = [i for i in non_items if weight_lst[i] <= (capacity - current_weight + weight_lst[remove_idx])]\n            if lighter_items:\n                add_idx = np.random.choice(lighter_items)\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and applies a hybrid local search strategy combining item swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of items to swap or flip\n    if len(items) > 0 and len(non_items) > 0:\n        # Swap one item with one non-item\n        swap_idx = random.choice(items)\n        add_idx = random.choice(non_items)\n        new_weight = current_weight - weight_lst[swap_idx] + weight_lst[add_idx]\n        if new_weight <= capacity:\n            new_solution[swap_idx] = 0\n            new_solution[add_idx] = 1\n            return new_solution\n\n    # If swap is not feasible, try flipping a single item\n    if len(items) > 0:\n        flip_idx = random.choice(items)\n        new_weight = current_weight - weight_lst[flip_idx]\n        if new_weight <= capacity:\n            new_solution[flip_idx] = 0\n            return new_solution\n\n    # If all else fails, return the base solution\n    return base_solution\n\n",
        "score": [
            -0.4280653992657289,
            1.8272488117218018
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of items to swap or flip\n    if len(items) > 0 and len(non_items) > 0:\n        # Swap one item with one non-item\n        swap_idx = random.choice(items)\n        add_idx = random.choice(non_items)\n        new_weight = current_weight - weight_lst[swap_idx] + weight_lst[add_idx]\n        if new_weight <= capacity:\n            new_solution[swap_idx] = 0\n            new_solution[add_idx] = 1\n            return new_solution\n\n    # If swap is not feasible, try flipping a single item\n    if len(items) > 0:\n        flip_idx = random.choice(items)\n        new_weight = current_weight - weight_lst[flip_idx]\n        if new_weight <= capacity:\n            new_solution[flip_idx] = 0\n            return new_solution\n\n    # If all else fails, return the base solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{The heuristic selects a solution from the archive with high potential for improvement by prioritizing those with low diversity or high objective values, then applies a novel hybrid local search that combines item swaps and probabilistic flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: probabilistic flips and swaps\n    n_items = len(new_solution)\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Probabilistic flip: randomly flip items with high marginal contribution\n    for i in range(n_items):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                if total_weight - weight_lst[i] >= 0:  # Check feasibility\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n            else:\n                if total_weight + weight_lst[i] <= capacity:  # Check feasibility\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n\n    # Swap items to improve both objectives\n    for _ in range(3):  # Perform 3 swaps\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility\n            if (new_solution[i] == 1 and total_weight - weight_lst[i] + weight_lst[j] <= capacity) or \\\n               (new_solution[j] == 1 and total_weight - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3751896747412753,
            5.29896205663681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: probabilistic flips and swaps\n    n_items = len(new_solution)\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Probabilistic flip: randomly flip items with high marginal contribution\n    for i in range(n_items):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                if total_weight - weight_lst[i] >= 0:  # Check feasibility\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n            else:\n                if total_weight + weight_lst[i] <= capacity:  # Check feasibility\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n\n    # Swap items to improve both objectives\n    for _ in range(3):  # Perform 3 swaps\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility\n            if (new_solution[i] == 1 and total_weight - weight_lst[i] + weight_lst[j] <= capacity) or \\\n               (new_solution[j] == 1 and total_weight - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high diversity in their objective values, then applies a hybrid local search operator that combines item swapping with a probabilistic weight-balancing mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)  # High diversity in both objectives\n    selected_idx = np.argmax(np.sum(objectives * diversity_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: swap items with probabilistic weight balancing\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    if len(candidates) > 0:\n        # Try to swap out a random item from current solution\n        swap_out = np.random.choice(candidates)\n        new_solution[swap_out] = 0\n        current_weight -= weight_lst[swap_out]\n\n        # Add items until capacity is reached or no more items can be added\n        np.random.shuffle(non_candidates)\n        for item in non_candidates:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # If no improvement, perform a random flip\n    if np.array_equal(new_solution, base_solution):\n        flip_idx = np.random.randint(0, len(new_solution))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.37262299098102375,
            1.431747317314148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)  # High diversity in both objectives\n    selected_idx = np.argmax(np.sum(objectives * diversity_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: swap items with probabilistic weight balancing\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    if len(candidates) > 0:\n        # Try to swap out a random item from current solution\n        swap_out = np.random.choice(candidates)\n        new_solution[swap_out] = 0\n        current_weight -= weight_lst[swap_out]\n\n        # Add items until capacity is reached or no more items can be added\n        np.random.shuffle(non_candidates)\n        for item in non_candidates:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # If no improvement, perform a random flip\n    if np.array_equal(new_solution, base_solution):\n        flip_idx = np.random.randint(0, len(new_solution))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{A hybrid local search algorithm that intelligently selects solutions with high potential for improvement by combining a randomized exploration with a novel neighborhood structure that considers both objective values and weight constraints, ensuring feasibility through adaptive flipping of items based on their marginal contribution across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    # Prioritize solutions with high marginal potential (e.g., those with unused capacity)\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            continue  # Skip infeasible solutions\n\n        # Calculate potential improvement: sum of items that could fit\n        potential_value1 = np.sum(value1_lst * (1 - sol) * (weight_lst <= remaining_capacity))\n        potential_value2 = np.sum(value2_lst * (1 - sol) * (weight_lst <= remaining_capacity))\n        total_potential = potential_value1 + potential_value2\n\n        if total_potential > max_potential:\n            max_potential = total_potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        # If no high-potential solution found, pick randomly\n        selected_solution = random.choice(archive)[0]\n\n    # Generate neighbor using a hybrid local search\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Flip items based on their marginal contribution to both objectives\n    # Prioritize items that improve both objectives or have high marginal value\n    items_to_consider = np.where((1 - new_solution) * (weight_lst <= remaining_capacity))[0]\n\n    if len(items_to_consider) > 0:\n        # Calculate marginal value per weight for both objectives\n        marginal_value1 = value1_lst[items_to_consider] / weight_lst[items_to_consider]\n        marginal_value2 = value2_lst[items_to_consider] / weight_lst[items_to_consider]\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Select top-k items with highest combined marginal value\n        top_k = min(3, len(items_to_consider))  # Adjust k as needed\n        top_items = np.argsort(combined_marginal)[-top_k:]\n\n        # Flip selected items if they fit\n        for idx in top_items:\n            item_idx = items_to_consider[idx]\n            if weight_lst[item_idx] <= remaining_capacity:\n                new_solution[item_idx] = 1\n                remaining_capacity -= weight_lst[item_idx]\n\n    # Also consider removing items that have low marginal contribution\n    items_in_solution = np.where(new_solution)[0]\n    if len(items_in_solution) > 0:\n        # Calculate marginal value per weight for items in solution\n        marginal_value1 = value1_lst[items_in_solution] / weight_lst[items_in_solution]\n        marginal_value2 = value2_lst[items_in_solution] / weight_lst[items_in_solution]\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Select items with lowest combined marginal value to remove\n        bottom_k = min(2, len(items_in_solution))  # Adjust k as needed\n        bottom_items = np.argsort(combined_marginal)[:bottom_k]\n\n        for idx in bottom_items:\n            item_idx = items_in_solution[idx]\n            new_solution[item_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9350546930346908,
            6.6185974180698395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    # Prioritize solutions with high marginal potential (e.g., those with unused capacity)\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            continue  # Skip infeasible solutions\n\n        # Calculate potential improvement: sum of items that could fit\n        potential_value1 = np.sum(value1_lst * (1 - sol) * (weight_lst <= remaining_capacity))\n        potential_value2 = np.sum(value2_lst * (1 - sol) * (weight_lst <= remaining_capacity))\n        total_potential = potential_value1 + potential_value2\n\n        if total_potential > max_potential:\n            max_potential = total_potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        # If no high-potential solution found, pick randomly\n        selected_solution = random.choice(archive)[0]\n\n    # Generate neighbor using a hybrid local search\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Flip items based on their marginal contribution to both objectives\n    # Prioritize items that improve both objectives or have high marginal value\n    items_to_consider = np.where((1 - new_solution) * (weight_lst <= remaining_capacity))[0]\n\n    if len(items_to_consider) > 0:\n        # Calculate marginal value per weight for both objectives\n        marginal_value1 = value1_lst[items_to_consider] / weight_lst[items_to_consider]\n        marginal_value2 = value2_lst[items_to_consider] / weight_lst[items_to_consider]\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Select top-k items with highest combined marginal value\n        top_k = min(3, len(items_to_consider))  # Adjust k as needed\n        top_items = np.argsort(combined_marginal)[-top_k:]\n\n        # Flip selected items if they fit\n        for idx in top_items:\n            item_idx = items_to_consider[idx]\n            if weight_lst[item_idx] <= remaining_capacity:\n                new_solution[item_idx] = 1\n                remaining_capacity -= weight_lst[item_idx]\n\n    # Also consider removing items that have low marginal contribution\n    items_in_solution = np.where(new_solution)[0]\n    if len(items_in_solution) > 0:\n        # Calculate marginal value per weight for items in solution\n        marginal_value1 = value1_lst[items_in_solution] / weight_lst[items_in_solution]\n        marginal_value2 = value2_lst[items_in_solution] / weight_lst[items_in_solution]\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Select items with lowest combined marginal value to remove\n        bottom_k = min(2, len(items_in_solution))  # Adjust k as needed\n        bottom_items = np.argsort(combined_marginal)[:bottom_k]\n\n        for idx in bottom_items:\n            item_idx = items_in_solution[idx]\n            new_solution[item_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Randomly flip items with high marginal value-to-weight ratio\n    marginal_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_ratios)[::-1]\n\n    # Apply a novel operator: Randomly select a subset of top items and flip their selection\n    flip_candidates = sorted_indices[:max(1, len(sorted_indices) // 3)]\n    np.random.shuffle(flip_candidates)\n    flip_indices = flip_candidates[:np.random.randint(1, len(flip_candidates) + 1)]\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        excess_weight = total_weight - capacity\n        # Remove items with lowest marginal ratio until feasible\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.520551795283001,
            1.1142440438270569
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Randomly flip items with high marginal value-to-weight ratio\n    marginal_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_ratios)[::-1]\n\n    # Apply a novel operator: Randomly select a subset of top items and flip their selection\n    flip_candidates = sorted_indices[:max(1, len(sorted_indices) // 3)]\n    np.random.shuffle(flip_candidates)\n    flip_indices = flip_candidates[:np.random.randint(1, len(flip_candidates) + 1)]\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        excess_weight = total_weight - capacity\n        # Remove items with lowest marginal ratio until feasible\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Randomly flip items with high marginal value-to-weight ratio\n    marginal_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_ratios)[::-1]\n\n    # Apply a novel operator: Randomly select a subset of top items and flip their selection\n    flip_candidates = sorted_indices[:max(1, len(sorted_indices) // 3)]\n    np.random.shuffle(flip_candidates)\n    flip_indices = flip_candidates[:np.random.randint(1, len(flip_candidates) + 1)]\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        excess_weight = total_weight - capacity\n        # Remove items with lowest marginal ratio until feasible\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.520551795283001,
            1.1142440438270569
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Randomly flip items with high marginal value-to-weight ratio\n    marginal_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_ratios)[::-1]\n\n    # Apply a novel operator: Randomly select a subset of top items and flip their selection\n    flip_candidates = sorted_indices[:max(1, len(sorted_indices) // 3)]\n    np.random.shuffle(flip_candidates)\n    flip_indices = flip_candidates[:np.random.randint(1, len(flip_candidates) + 1)]\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        excess_weight = total_weight - capacity\n        # Remove items with lowest marginal ratio until feasible\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_score = -1\n    selected_solution = None\n    for sol, obj in archive:\n        # Normalize objectives and compute score\n        score = (obj[0] / np.max(value1_lst)) + (obj[1] / np.max(value2_lst))\n        if score > max_score:\n            max_score = score\n            selected_solution = sol.copy()\n\n    # Generate neighbor by flipping a random item with high marginal gain\n    new_solution = selected_solution.copy()\n    total_weight = np.sum(weight_lst * selected_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Identify items not in the solution\n    candidate_items = np.where(selected_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Compute marginal gains for candidate items\n        marginal_gains = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n        # Select item with highest marginal gain that fits\n        valid_items = candidate_items[marginal_gains > 0]\n        if len(valid_items) > 0:\n            # Select the item with highest marginal gain that fits within remaining capacity\n            best_item = valid_items[np.argmax(marginal_gains[marginal_gains > 0])]\n            if weight_lst[best_item] <= remaining_capacity:\n                new_solution[best_item] = 1\n\n    # If no item can be added, try removing a low-value item\n    if np.array_equal(new_solution, selected_solution):\n        # Identify items in the solution\n        current_items = np.where(selected_solution == 1)[0]\n        if len(current_items) > 0:\n            # Compute marginal losses for current items\n            marginal_losses = (value1_lst[current_items] + value2_lst[current_items]) / weight_lst[current_items]\n            # Select item with lowest marginal loss to remove\n            worst_item = current_items[np.argmin(marginal_losses)]\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9241067554205267,
            1.5694327652454376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_score = -1\n    selected_solution = None\n    for sol, obj in archive:\n        # Normalize objectives and compute score\n        score = (obj[0] / np.max(value1_lst)) + (obj[1] / np.max(value2_lst))\n        if score > max_score:\n            max_score = score\n            selected_solution = sol.copy()\n\n    # Generate neighbor by flipping a random item with high marginal gain\n    new_solution = selected_solution.copy()\n    total_weight = np.sum(weight_lst * selected_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Identify items not in the solution\n    candidate_items = np.where(selected_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Compute marginal gains for candidate items\n        marginal_gains = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n        # Select item with highest marginal gain that fits\n        valid_items = candidate_items[marginal_gains > 0]\n        if len(valid_items) > 0:\n            # Select the item with highest marginal gain that fits within remaining capacity\n            best_item = valid_items[np.argmax(marginal_gains[marginal_gains > 0])]\n            if weight_lst[best_item] <= remaining_capacity:\n                new_solution[best_item] = 1\n\n    # If no item can be added, try removing a low-value item\n    if np.array_equal(new_solution, selected_solution):\n        # Identify items in the solution\n        current_items = np.where(selected_solution == 1)[0]\n        if len(current_items) > 0:\n            # Compute marginal losses for current items\n            marginal_losses = (value1_lst[current_items] + value2_lst[current_items]) / weight_lst[current_items]\n            # Select item with lowest marginal loss to remove\n            worst_item = current_items[np.argmin(marginal_losses)]\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This algorithm selects a promising solution from the archive using a hybrid local search strategy that combines a novel item-swap operator with a dynamic neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., random with bias towards higher objectives)\n    selected_idx = random.choices(range(len(archive)), weights=[sum(obj) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic swap with feasibility check\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Randomly select items to swap\n        swap_in = random.choice(items_in)\n        swap_out = random.choice(items_out)\n\n        # Calculate new weight\n        new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n        if new_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n\n    # If no swap occurred, try adding a new item if possible\n    if np.array_equal(new_solution, base_solution):\n        for item in items_out:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.393574825352148,
            4.285655111074448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., random with bias towards higher objectives)\n    selected_idx = random.choices(range(len(archive)), weights=[sum(obj) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic swap with feasibility check\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Randomly select items to swap\n        swap_in = random.choice(items_in)\n        swap_out = random.choice(items_out)\n\n        # Calculate new weight\n        new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n        if new_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n\n    # If no swap occurred, try adding a new item if possible\n    if np.array_equal(new_solution, base_solution):\n        for item in items_out:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on its potential for improvement, then applies a combination of item swapping and value-driven perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not all items are included)\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by swapping items with high value ratios\n    new_solution = base_solution.copy()\n    value_ratio = value1_lst / (value2_lst + 1e-6)  # Avoid division by zero\n    sorted_indices = np.argsort(-value_ratio)  # Sort by descending value ratio\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try to exclude the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to include the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Apply a perturbation: randomly flip a small number of items\n    num_perturbations = max(1, len(base_solution) // 10)\n    perturbation_indices = np.random.choice(len(base_solution), num_perturbations, replace=False)\n\n    for idx in perturbation_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5489894902183842,
            3.1131544411182404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not all items are included)\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by swapping items with high value ratios\n    new_solution = base_solution.copy()\n    value_ratio = value1_lst / (value2_lst + 1e-6)  # Avoid division by zero\n    sorted_indices = np.argsort(-value_ratio)  # Sort by descending value ratio\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try to exclude the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to include the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Apply a perturbation: randomly flip a small number of items\n    num_perturbations = max(1, len(base_solution) // 10)\n    perturbation_indices = np.random.choice(len(base_solution), num_perturbations, replace=False)\n\n    for idx in perturbation_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining random item swaps and targeted flips to explore the solution space while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their objective values (prioritize high values)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n\n    # Select top 20% of solutions for potential candidates\n    candidate_count = max(1, len(sorted_archive) // 5)\n    candidates = sorted_archive[:candidate_count]\n\n    # Select a random candidate with probability proportional to its objective values\n    total_score = sum(x[1][0] + x[1][1] for x in candidates)\n    if total_score == 0:\n        selected_solution = random.choice(candidates)[0].copy()\n    else:\n        weights = [x[1][0] + x[1][1] / total_score for x in candidates]\n        selected_solution = random.choices(candidates, weights=weights, k=1)[0][0].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly flip a small number of items (1-3)\n    flip_count = random.randint(1, min(3, n_items))\n    flip_indices = random.sample(range(n_items), flip_count)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item if feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Perform targeted flips based on objective improvement\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that could improve the solution\n    candidate_items = []\n    for i in range(n_items):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            candidate_items.append(i)\n        elif new_solution[i] == 1:\n            # Consider removing items that might allow better additions\n            if current_weight - weight_lst[i] + weight_lst[np.logical_and(new_solution == 0, weight_lst <= remaining_capacity + weight_lst[i])].sum() > current_weight:\n                candidate_items.append(i)\n\n    if candidate_items:\n        # Randomly select a candidate to flip\n        flip_idx = random.choice(candidate_items)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2873436099416186,
            10.977056950330734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their objective values (prioritize high values)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n\n    # Select top 20% of solutions for potential candidates\n    candidate_count = max(1, len(sorted_archive) // 5)\n    candidates = sorted_archive[:candidate_count]\n\n    # Select a random candidate with probability proportional to its objective values\n    total_score = sum(x[1][0] + x[1][1] for x in candidates)\n    if total_score == 0:\n        selected_solution = random.choice(candidates)[0].copy()\n    else:\n        weights = [x[1][0] + x[1][1] / total_score for x in candidates]\n        selected_solution = random.choices(candidates, weights=weights, k=1)[0][0].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly flip a small number of items (1-3)\n    flip_count = random.randint(1, min(3, n_items))\n    flip_indices = random.sample(range(n_items), flip_count)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item if feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Perform targeted flips based on objective improvement\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that could improve the solution\n    candidate_items = []\n    for i in range(n_items):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            candidate_items.append(i)\n        elif new_solution[i] == 1:\n            # Consider removing items that might allow better additions\n            if current_weight - weight_lst[i] + weight_lst[np.logical_and(new_solution == 0, weight_lst <= remaining_capacity + weight_lst[i])].sum() > current_weight:\n                candidate_items.append(i)\n\n    if candidate_items:\n        # Randomly select a candidate to flip\n        flip_idx = random.choice(candidate_items)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{The heuristic selects a solution from the archive with the highest combined value ratio (value1 + value2) per weight, then applies a novel \"weight-balanced swap\" local search that intelligently swaps items between high-value1 and high-value2 categories while ensuring feasibility, balancing objective improvements, and avoiding redundant swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined value ratio (value1 + value2) per weight\n    best_solution = None\n    best_ratio = -1\n    for solution, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst[solution == 1])\n        if total_weight > capacity:\n            continue\n        ratio = (v1 + v2) / total_weight if total_weight > 0 else 0\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_solution = solution\n\n    if best_solution is None:\n        best_solution = archive[0][0]\n\n    current_solution = best_solution.copy()\n    current_weight = np.sum(weight_lst[current_solution == 1])\n    current_value1 = np.sum(value1_lst[current_solution == 1])\n    current_value2 = np.sum(value2_lst[current_solution == 1])\n\n    # Identify items in the solution and not in the solution\n    in_items = np.where(current_solution == 1)[0]\n    out_items = np.where(current_solution == 0)[0]\n\n    # Categorize items by objective dominance\n    v1_dominant = value1_lst > value2_lst\n    v2_dominant = value2_lst > value1_lst\n    balanced = value1_lst == value2_lst\n\n    # Weight-balanced swap strategy\n    for i in in_items:\n        for j in out_items:\n            if weight_lst[j] <= weight_lst[i]:\n                new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                if new_weight <= capacity:\n                    delta_v1 = value1_lst[j] - value1_lst[i]\n                    delta_v2 = value2_lst[j] - value2_lst[i]\n\n                    # Prefer swaps that improve both objectives or maintain balance\n                    if (delta_v1 > 0 and delta_v2 > 0) or (abs(delta_v1 - delta_v2) <= 0.1 * (current_value1 + current_value2)):\n                        current_solution[i] = 0\n                        current_solution[j] = 1\n                        current_weight = new_weight\n                        current_value1 += delta_v1\n                        current_value2 += delta_v2\n                        break\n\n    return current_solution\n\n",
        "score": [
            -0.8076583697390978,
            6.806148886680603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined value ratio (value1 + value2) per weight\n    best_solution = None\n    best_ratio = -1\n    for solution, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst[solution == 1])\n        if total_weight > capacity:\n            continue\n        ratio = (v1 + v2) / total_weight if total_weight > 0 else 0\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_solution = solution\n\n    if best_solution is None:\n        best_solution = archive[0][0]\n\n    current_solution = best_solution.copy()\n    current_weight = np.sum(weight_lst[current_solution == 1])\n    current_value1 = np.sum(value1_lst[current_solution == 1])\n    current_value2 = np.sum(value2_lst[current_solution == 1])\n\n    # Identify items in the solution and not in the solution\n    in_items = np.where(current_solution == 1)[0]\n    out_items = np.where(current_solution == 0)[0]\n\n    # Categorize items by objective dominance\n    v1_dominant = value1_lst > value2_lst\n    v2_dominant = value2_lst > value1_lst\n    balanced = value1_lst == value2_lst\n\n    # Weight-balanced swap strategy\n    for i in in_items:\n        for j in out_items:\n            if weight_lst[j] <= weight_lst[i]:\n                new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                if new_weight <= capacity:\n                    delta_v1 = value1_lst[j] - value1_lst[i]\n                    delta_v2 = value2_lst[j] - value2_lst[i]\n\n                    # Prefer swaps that improve both objectives or maintain balance\n                    if (delta_v1 > 0 and delta_v2 > 0) or (abs(delta_v1 - delta_v2) <= 0.1 * (current_value1 + current_value2)):\n                        current_solution[i] = 0\n                        current_solution[j] = 1\n                        current_weight = new_weight\n                        current_value1 += delta_v1\n                        current_value2 += delta_v2\n                        break\n\n    return current_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{The algorithm first identifies promising solutions in the archive by evaluating their potential for improvement through a hybrid local search strategy that combines item swaps, flips, and guided randomness, then generates a neighbor solution by intelligently perturbing the selected solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., random with bias towards higher objectives)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Hybrid local search strategy: flip items with high marginal gains, then swap items\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Step 2.1: Flip items with high marginal gains\n    for _ in range(min(3, n_items)):\n        # Select an item to flip (0->1 or 1->0)\n        item_idx = random.randint(0, n_items - 1)\n        if new_solution[item_idx] == 1:\n            # Try to remove the item\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[item_idx]\n                current_value2 -= value2_lst[item_idx]\n        else:\n            # Try to add the item\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[item_idx]\n                current_value2 += value2_lst[item_idx]\n\n    # Step 2.2: Perform a guided item swap\n    for _ in range(min(2, n_items // 2)):\n        # Select two items to swap\n        item1, item2 = random.sample(range(n_items), 2)\n        if new_solution[item1] != new_solution[item2]:\n            # Swap items if feasible\n            delta_weight = weight_lst[item2] - weight_lst[item1]\n            new_weight = current_weight + delta_weight\n            if new_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = new_weight\n                current_value1 += value1_lst[item2] - value1_lst[item1]\n                current_value2 += value2_lst[item2] - value2_lst[item1]\n\n    return new_solution\n\n",
        "score": [
            -0.433014027023509,
            2.5921081602573395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., random with bias towards higher objectives)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Hybrid local search strategy: flip items with high marginal gains, then swap items\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Step 2.1: Flip items with high marginal gains\n    for _ in range(min(3, n_items)):\n        # Select an item to flip (0->1 or 1->0)\n        item_idx = random.randint(0, n_items - 1)\n        if new_solution[item_idx] == 1:\n            # Try to remove the item\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[item_idx]\n                current_value2 -= value2_lst[item_idx]\n        else:\n            # Try to add the item\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[item_idx]\n                current_value2 += value2_lst[item_idx]\n\n    # Step 2.2: Perform a guided item swap\n    for _ in range(min(2, n_items // 2)):\n        # Select two items to swap\n        item1, item2 = random.sample(range(n_items), 2)\n        if new_solution[item1] != new_solution[item2]:\n            # Swap items if feasible\n            delta_weight = weight_lst[item2] - weight_lst[item1]\n            new_weight = current_weight + delta_weight\n            if new_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = new_weight\n                current_value1 += value1_lst[item2] - value1_lst[item1]\n                current_value2 += value2_lst[item2] - value2_lst[item1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with the highest combined value-to-weight ratios and applies a novel \"multi-objective flip-and-rebalance\" local search operator, which flips a subset of items to improve both objectives while ensuring feasibility by rebalancing the knapsack weight through intelligent item swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest combined value-to-weight ratio)\n    selected_idx = np.argmax([(obj[0] + obj[1]) / np.sum(weight_lst * sol) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_values = archive[selected_idx][1]\n\n    # Generate neighbor via multi-objective flip-and-rebalance\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to flip (prioritize those that improve both objectives)\n    flip_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item improves both objectives\n            new_total_weight = total_weight - weight_lst[i]\n            if new_total_weight <= capacity:\n                new_value1 = current_values[0] - value1_lst[i]\n                new_value2 = current_values[1] - value2_lst[i]\n                flip_candidates.append((i, new_value1, new_value2, new_total_weight))\n        else:\n            # Check if adding this item improves both objectives\n            new_total_weight = total_weight + weight_lst[i]\n            if new_total_weight <= capacity:\n                new_value1 = current_values[0] + value1_lst[i]\n                new_value2 = current_values[1] + value2_lst[i]\n                flip_candidates.append((i, new_value1, new_value2, new_total_weight))\n\n    if not flip_candidates:\n        # No immediate improvement, perform a random flip\n        flip_idx = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[flip_idx] = 0\n        return new_solution\n\n    # Select the flip that maximizes the sum of normalized improvements\n    max_improvement = -1\n    best_flip = None\n    for i, new_v1, new_v2, new_w in flip_candidates:\n        # Normalize improvements (avoid division by zero)\n        norm_improvement_v1 = (new_v1 - current_values[0]) / (current_values[0] + 1e-6)\n        norm_improvement_v2 = (new_v2 - current_values[1]) / (current_values[1] + 1e-6)\n        total_improvement = norm_improvement_v1 + norm_improvement_v2\n        if total_improvement > max_improvement:\n            max_improvement = total_improvement\n            best_flip = i\n\n    if best_flip is not None:\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Rebalance the knapsack to ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the least valuable item (prioritize objective with lower value)\n        if current_values[0] < current_values[1]:\n            remove_candidates = np.where(new_solution == 1)[0]\n            least_val = np.argmin(value1_lst[remove_candidates])\n            new_solution[remove_candidates[least_val]] = 0\n        else:\n            remove_candidates = np.where(new_solution == 1)[0]\n            least_val = np.argmin(value2_lst[remove_candidates])\n            new_solution[remove_candidates[least_val]] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9450960915849733,
            5.377312570810318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest combined value-to-weight ratio)\n    selected_idx = np.argmax([(obj[0] + obj[1]) / np.sum(weight_lst * sol) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_values = archive[selected_idx][1]\n\n    # Generate neighbor via multi-objective flip-and-rebalance\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to flip (prioritize those that improve both objectives)\n    flip_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item improves both objectives\n            new_total_weight = total_weight - weight_lst[i]\n            if new_total_weight <= capacity:\n                new_value1 = current_values[0] - value1_lst[i]\n                new_value2 = current_values[1] - value2_lst[i]\n                flip_candidates.append((i, new_value1, new_value2, new_total_weight))\n        else:\n            # Check if adding this item improves both objectives\n            new_total_weight = total_weight + weight_lst[i]\n            if new_total_weight <= capacity:\n                new_value1 = current_values[0] + value1_lst[i]\n                new_value2 = current_values[1] + value2_lst[i]\n                flip_candidates.append((i, new_value1, new_value2, new_total_weight))\n\n    if not flip_candidates:\n        # No immediate improvement, perform a random flip\n        flip_idx = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[flip_idx] = 0\n        return new_solution\n\n    # Select the flip that maximizes the sum of normalized improvements\n    max_improvement = -1\n    best_flip = None\n    for i, new_v1, new_v2, new_w in flip_candidates:\n        # Normalize improvements (avoid division by zero)\n        norm_improvement_v1 = (new_v1 - current_values[0]) / (current_values[0] + 1e-6)\n        norm_improvement_v2 = (new_v2 - current_values[1]) / (current_values[1] + 1e-6)\n        total_improvement = norm_improvement_v1 + norm_improvement_v2\n        if total_improvement > max_improvement:\n            max_improvement = total_improvement\n            best_flip = i\n\n    if best_flip is not None:\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Rebalance the knapsack to ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the least valuable item (prioritize objective with lower value)\n        if current_values[0] < current_values[1]:\n            remove_candidates = np.where(new_solution == 1)[0]\n            least_val = np.argmin(value1_lst[remove_candidates])\n            new_solution[remove_candidates[least_val]] = 0\n        else:\n            remove_candidates = np.where(new_solution == 1)[0]\n            least_val = np.argmin(value2_lst[remove_candidates])\n            new_solution[remove_candidates[least_val]] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of objective diversity and potential improvement, then applies a novel local search operator that strategically flips a subset of items to balance the two objectives while ensuring feasibility, leveraging both objective-specific and weight-aware selection criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and potential improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be flipped (either in or out) without exceeding capacity\n    flip_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item is feasible\n            if current_weight - weight_lst[i] >= 0:\n                flip_candidates.append((i, -1))  # Mark for removal\n        else:\n            # Check if adding this item is feasible\n            if weight_lst[i] <= remaining_capacity:\n                flip_candidates.append((i, 1))  # Mark for addition\n\n    if not flip_candidates:\n        # If no flips are possible, return the base solution\n        return base_solution.copy()\n\n    # Hybrid selection: prioritize items that improve both objectives or trade-off one for the other\n    flip_indices = [i for i, _ in flip_candidates]\n    flip_directions = [d for _, d in flip_candidates]\n\n    # Calculate potential improvements for each candidate\n    improvements = []\n    for idx, direction in zip(flip_indices, flip_directions):\n        if direction == 1:\n            # Adding item idx\n            new_v1 = current_v1 + value1_lst[idx]\n            new_v2 = current_v2 + value2_lst[idx]\n        else:\n            # Removing item idx\n            new_v1 = current_v1 - value1_lst[idx]\n            new_v2 = current_v2 - value2_lst[idx]\n\n        # Calculate improvement score (combining both objectives)\n        improvement_score = (new_v1 - current_v1) + (new_v2 - current_v2)\n        improvements.append(improvement_score)\n\n    # Select top candidates based on improvement score\n    top_candidates = np.argsort(improvements)[-min(3, len(improvements)):]  # Select top 3 or fewer\n\n    # Randomly select one of the top candidates\n    selected = np.random.choice(top_candidates)\n    idx, direction = flip_indices[selected], flip_directions[selected]\n\n    # Apply the flip\n    new_solution[idx] = 1 if direction == 1 else 0\n\n    # Ensure feasibility (should always be true due to checks above)\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Fallback: if somehow infeasible, revert to base solution\n        return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8670904429433899,
            2.2153070867061615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and potential improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be flipped (either in or out) without exceeding capacity\n    flip_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item is feasible\n            if current_weight - weight_lst[i] >= 0:\n                flip_candidates.append((i, -1))  # Mark for removal\n        else:\n            # Check if adding this item is feasible\n            if weight_lst[i] <= remaining_capacity:\n                flip_candidates.append((i, 1))  # Mark for addition\n\n    if not flip_candidates:\n        # If no flips are possible, return the base solution\n        return base_solution.copy()\n\n    # Hybrid selection: prioritize items that improve both objectives or trade-off one for the other\n    flip_indices = [i for i, _ in flip_candidates]\n    flip_directions = [d for _, d in flip_candidates]\n\n    # Calculate potential improvements for each candidate\n    improvements = []\n    for idx, direction in zip(flip_indices, flip_directions):\n        if direction == 1:\n            # Adding item idx\n            new_v1 = current_v1 + value1_lst[idx]\n            new_v2 = current_v2 + value2_lst[idx]\n        else:\n            # Removing item idx\n            new_v1 = current_v1 - value1_lst[idx]\n            new_v2 = current_v2 - value2_lst[idx]\n\n        # Calculate improvement score (combining both objectives)\n        improvement_score = (new_v1 - current_v1) + (new_v2 - current_v2)\n        improvements.append(improvement_score)\n\n    # Select top candidates based on improvement score\n    top_candidates = np.argsort(improvements)[-min(3, len(improvements)):]  # Select top 3 or fewer\n\n    # Randomly select one of the top candidates\n    selected = np.random.choice(top_candidates)\n    idx, direction = flip_indices[selected], flip_directions[selected]\n\n    # Apply the flip\n    new_solution[idx] = 1 if direction == 1 else 0\n\n    # Ensure feasibility (should always be true due to checks above)\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Fallback: if somehow infeasible, revert to base solution\n        return base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        potential1 = np.sum(value1_lst * (1 - sol))  # Potential value1 if all remaining items are added\n        potential2 = np.sum(value2_lst * (1 - sol))  # Potential value2 if all remaining items are added\n        candidates.append((sol, obj, potential1, potential2, total_weight))\n\n    # Sort by a combined score of potential improvement and current objective values\n    candidates.sort(key=lambda x: (x[2] + x[3]) * (1 - x[4] / capacity), reverse=True)\n    base_solution = candidates[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search: flip a subset of items with high marginal contribution\n    new_solution = base_solution.copy()\n    marginal_contributions = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n    sorted_indices = np.argsort(marginal_contributions)[::-1]  # Sort by descending marginal contribution\n\n    # Flip top-k items with high marginal contribution (k is randomly chosen between 1 and 3)\n    k = np.random.randint(1, 4)\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            new_solution[idx] = 1\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[idx] = 0  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.8282065117505493,
            6.193437486886978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        potential1 = np.sum(value1_lst * (1 - sol))  # Potential value1 if all remaining items are added\n        potential2 = np.sum(value2_lst * (1 - sol))  # Potential value2 if all remaining items are added\n        candidates.append((sol, obj, potential1, potential2, total_weight))\n\n    # Sort by a combined score of potential improvement and current objective values\n    candidates.sort(key=lambda x: (x[2] + x[3]) * (1 - x[4] / capacity), reverse=True)\n    base_solution = candidates[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search: flip a subset of items with high marginal contribution\n    new_solution = base_solution.copy()\n    marginal_contributions = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n    sorted_indices = np.argsort(marginal_contributions)[::-1]  # Sort by descending marginal contribution\n\n    # Flip top-k items with high marginal contribution (k is randomly chosen between 1 and 3)\n    k = np.random.randint(1, 4)\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            new_solution[idx] = 1\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[idx] = 0  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{The heuristic function selects a solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining item swapping and probabilistic flipping to generate a neighbor solution, ensuring feasibility by always checking weight constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (diversity-aware)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap two items or flip a random item with probability\n    if random.random() < 0.7:  # Higher probability for swap\n        # Find two items to swap (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate potential weight changes\n            swap_pair = (random.choice(in_items), random.choice(out_items))\n            current_weight = np.sum(weight_lst * new_solution)\n            new_weight = current_weight - weight_lst[swap_pair[0]] + weight_lst[swap_pair[1]]\n\n            if new_weight <= capacity:\n                new_solution[swap_pair[0]] = 0\n                new_solution[swap_pair[1]] = 1\n    else:\n        # Probabilistic flip of a random item\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            # Remove item if space allows\n            if np.sum(weight_lst * new_solution) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            # Add item if capacity allows\n            if np.sum(weight_lst * new_solution) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4407045698385841,
            1.9131194353103638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (diversity-aware)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap two items or flip a random item with probability\n    if random.random() < 0.7:  # Higher probability for swap\n        # Find two items to swap (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate potential weight changes\n            swap_pair = (random.choice(in_items), random.choice(out_items))\n            current_weight = np.sum(weight_lst * new_solution)\n            new_weight = current_weight - weight_lst[swap_pair[0]] + weight_lst[swap_pair[1]]\n\n            if new_weight <= capacity:\n                new_solution[swap_pair[0]] = 0\n                new_solution[swap_pair[1]] = 1\n    else:\n        # Probabilistic flip of a random item\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            # Remove item if space allows\n            if np.sum(weight_lst * new_solution) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            # Add item if capacity allows\n            if np.sum(weight_lst * new_solution) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and applies a hybrid local search combining item swaps with random perturbations to generate a feasible neighbor solution while ensuring the total weight does not exceed capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Normalize objectives to prioritize high-value solutions\n    max_value1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_value2 = max(obj[1] for _, obj in archive) if archive else 1.0\n    normalized_scores = [\n        (obj[0] / max_value1 + obj[1] / max_value2 if max_value1 > 0 and max_value2 > 0 else 0.0)\n        for _, obj in archive\n    ]\n    best_idx = np.argmax(normalized_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Generate a neighbor by performing a hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n\n    # Randomly select a subset of items to swap or perturb\n    if len(items) > 0:\n        num_swaps = min(3, len(items))  # Limit the number of swaps\n        for _ in range(num_swaps):\n            # Randomly choose an item to remove\n            item_to_remove = random.choice(items)\n            new_solution[item_to_remove] = 0\n\n            # Find a random item to add that doesn't exceed capacity\n            remaining_items = np.where(new_solution == 0)[0]\n            np.random.shuffle(remaining_items)\n            for item in remaining_items:\n                if (np.sum(new_solution * weight_lst) + weight_lst[item]) <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    # Ensure feasibility by removing excess weight\n    total_weight = np.sum(new_solution * weight_lst)\n    while total_weight > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        item_to_remove = random.choice(excess_items)\n        new_solution[item_to_remove] = 0\n        total_weight = np.sum(new_solution * weight_lst)\n\n    return new_solution\n\n",
        "score": [
            -0.3461815253977306,
            3.4685303568840027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Normalize objectives to prioritize high-value solutions\n    max_value1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_value2 = max(obj[1] for _, obj in archive) if archive else 1.0\n    normalized_scores = [\n        (obj[0] / max_value1 + obj[1] / max_value2 if max_value1 > 0 and max_value2 > 0 else 0.0)\n        for _, obj in archive\n    ]\n    best_idx = np.argmax(normalized_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Generate a neighbor by performing a hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n\n    # Randomly select a subset of items to swap or perturb\n    if len(items) > 0:\n        num_swaps = min(3, len(items))  # Limit the number of swaps\n        for _ in range(num_swaps):\n            # Randomly choose an item to remove\n            item_to_remove = random.choice(items)\n            new_solution[item_to_remove] = 0\n\n            # Find a random item to add that doesn't exceed capacity\n            remaining_items = np.where(new_solution == 0)[0]\n            np.random.shuffle(remaining_items)\n            for item in remaining_items:\n                if (np.sum(new_solution * weight_lst) + weight_lst[item]) <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    # Ensure feasibility by removing excess weight\n    total_weight = np.sum(new_solution * weight_lst)\n    while total_weight > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        item_to_remove = random.choice(excess_items)\n        new_solution[item_to_remove] = 0\n        total_weight = np.sum(new_solution * weight_lst)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high marginal gains in either objective, then applies a hybrid local search operator that combines item swaps and random perturbations to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high marginal gains\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (current_value1, current_value2) = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: swap items with high marginal gains and random perturbations\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to swap or perturb\n    candidates = np.where(new_solution == 1)[0]\n    if len(candidates) > 0:\n        # Swap one item out and one item in\n        out_item = random.choice(candidates)\n        new_solution[out_item] = 0\n        total_weight -= weight_lst[out_item]\n\n        # Find a candidate item to add (not already in the solution)\n        possible_adds = np.where(new_solution == 0)[0]\n        if len(possible_adds) > 0:\n            # Filter items that can be added without exceeding capacity\n            feasible_adds = [item for item in possible_adds if total_weight + weight_lst[item] <= capacity]\n            if feasible_adds:\n                in_item = random.choice(feasible_adds)\n                new_solution[in_item] = 1\n\n    # Random perturbation to escape local optima\n    if random.random() < 0.3:\n        perturb_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[perturb_idx] == 1:\n            new_solution[perturb_idx] = 0\n        else:\n            if total_weight + weight_lst[perturb_idx] <= capacity:\n                new_solution[perturb_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4423161870513099,
            1.3468480110168457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high marginal gains\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (current_value1, current_value2) = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: swap items with high marginal gains and random perturbations\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to swap or perturb\n    candidates = np.where(new_solution == 1)[0]\n    if len(candidates) > 0:\n        # Swap one item out and one item in\n        out_item = random.choice(candidates)\n        new_solution[out_item] = 0\n        total_weight -= weight_lst[out_item]\n\n        # Find a candidate item to add (not already in the solution)\n        possible_adds = np.where(new_solution == 0)[0]\n        if len(possible_adds) > 0:\n            # Filter items that can be added without exceeding capacity\n            feasible_adds = [item for item in possible_adds if total_weight + weight_lst[item] <= capacity]\n            if feasible_adds:\n                in_item = random.choice(feasible_adds)\n                new_solution[in_item] = 1\n\n    # Random perturbation to escape local optima\n    if random.random() < 0.3:\n        perturb_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[perturb_idx] == 1:\n            new_solution[perturb_idx] = 0\n        else:\n            if total_weight + weight_lst[perturb_idx] <= capacity:\n                new_solution[perturb_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, then applies a dynamic perturbation mechanism to flip a subset of items based on their marginal contribution to both objectives, ensuring feasibility while balancing exploration and exploitation for multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (either included or excluded without violating capacity)\n    flip_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if excluding this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n        else:\n            # Check if including this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        return new_solution  # No feasible flip possible\n\n    # Select a subset of items to flip based on their marginal contribution\n    flip_count = min(3, len(flip_candidates))  # Flip up to 3 items\n    selected_flips = np.random.choice(flip_candidates, size=flip_count, replace=False)\n\n    # Flip the selected items\n    for i in selected_flips:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility (re-check in case of multiple flips)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, undo the last flip (simplistic repair)\n        for i in selected_flips[::-1]:\n            if total_weight <= capacity:\n                break\n            new_solution[i] = 1 - new_solution[i]\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7473777630569689,
            1.80864417552948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (either included or excluded without violating capacity)\n    flip_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if excluding this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n        else:\n            # Check if including this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        return new_solution  # No feasible flip possible\n\n    # Select a subset of items to flip based on their marginal contribution\n    flip_count = min(3, len(flip_candidates))  # Flip up to 3 items\n    selected_flips = np.random.choice(flip_candidates, size=flip_count, replace=False)\n\n    # Flip the selected items\n    for i in selected_flips:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility (re-check in case of multiple flips)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, undo the last flip (simplistic repair)\n        for i in selected_flips[::-1]:\n            if total_weight <= capacity:\n                break\n            new_solution[i] = 1 - new_solution[i]\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping with probabilistic neighborhood exploration, prioritizing solutions with high potential for multi-objective improvement while ensuring feasibility through dynamic weight constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objective values (promising candidates)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-10), reverse=True)\n        # Select top 20% candidates\n        top_candidates = archive_sorted[:max(1, len(archive) // 5)]\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive neighborhood exploration\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two items (one included, one excluded)\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) == 0 or len(excluded_items) == 0:\n            break\n\n        i = random.choice(included_items)\n        j = random.choice(excluded_items)\n\n        # Calculate potential weight change\n        delta_weight = weight_lst[j] - weight_lst[i]\n\n        # Check feasibility and probabilistic acceptance\n        if (current_weight + delta_weight <= capacity) or (random.random() < 0.3):  # 30% chance to accept infeasible move\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.6708409760792792,
            2.0789184868335724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objective values (promising candidates)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-10), reverse=True)\n        # Select top 20% candidates\n        top_candidates = archive_sorted[:max(1, len(archive) // 5)]\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive neighborhood exploration\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two items (one included, one excluded)\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) == 0 or len(excluded_items) == 0:\n            break\n\n        i = random.choice(included_items)\n        j = random.choice(excluded_items)\n\n        # Calculate potential weight change\n        delta_weight = weight_lst[j] - weight_lst[i]\n\n        # Check feasibility and probabilistic acceptance\n        if (current_weight + delta_weight <= capacity) or (random.random() < 0.3):  # 30% chance to accept infeasible move\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values, then applies a hybrid local search combining random swaps and greedy item replacements to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Get current weight and available items\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    available_items = np.where(base_solution == 0)[0]\n    current_items = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: random swap + greedy replacement\n    if len(current_items) > 0 and len(available_items) > 0:\n        # Randomly select an item to remove\n        remove_idx = random.choice(current_items)\n        new_solution[remove_idx] = 0\n        new_weight = current_weight - weight_lst[remove_idx]\n\n        # Greedily add the best available item that fits\n        best_item = None\n        best_value_ratio = -1\n        for item in available_items:\n            if new_weight + weight_lst[item] <= capacity:\n                # Calculate combined value ratio (weighted sum of both objectives)\n                value_ratio = (value1_lst[item] + value2_lst[item]) / weight_lst[item]\n                if value_ratio > best_value_ratio:\n                    best_value_ratio = value_ratio\n                    best_item = item\n\n        if best_item is not None:\n            new_solution[best_item] = 1\n\n    # If no improvement, perform a random flip\n    else:\n        if len(available_items) > 0:\n            flip_item = random.choice(available_items)\n            if current_weight + weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 1\n        elif len(current_items) > 0:\n            flip_item = random.choice(current_items)\n            new_solution[flip_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.36689798891717346,
            2.2049233317375183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Get current weight and available items\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    available_items = np.where(base_solution == 0)[0]\n    current_items = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: random swap + greedy replacement\n    if len(current_items) > 0 and len(available_items) > 0:\n        # Randomly select an item to remove\n        remove_idx = random.choice(current_items)\n        new_solution[remove_idx] = 0\n        new_weight = current_weight - weight_lst[remove_idx]\n\n        # Greedily add the best available item that fits\n        best_item = None\n        best_value_ratio = -1\n        for item in available_items:\n            if new_weight + weight_lst[item] <= capacity:\n                # Calculate combined value ratio (weighted sum of both objectives)\n                value_ratio = (value1_lst[item] + value2_lst[item]) / weight_lst[item]\n                if value_ratio > best_value_ratio:\n                    best_value_ratio = value_ratio\n                    best_item = item\n\n        if best_item is not None:\n            new_solution[best_item] = 1\n\n    # If no improvement, perform a random flip\n    else:\n        if len(available_items) > 0:\n            flip_item = random.choice(available_items)\n            if current_weight + weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 1\n        elif len(current_items) > 0:\n            flip_item = random.choice(current_items)\n            new_solution[flip_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{The heuristic selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search operator that intelligently flips item selections based on marginal gains in both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using a novel local search operator\n    new_solution = base_solution.copy()\n    items = np.arange(len(base_solution))\n\n    # Calculate marginal gains for both objectives\n    marginal_gains = np.zeros((len(base_solution), 2))\n    for i in items:\n        if base_solution[i] == 1:\n            marginal_gains[i, 0] = -value1_lst[i]\n            marginal_gains[i, 1] = -value2_lst[i]\n        else:\n            marginal_gains[i, 0] = value1_lst[i]\n            marginal_gains[i, 1] = value2_lst[i]\n\n    # Rank items based on combined marginal gain\n    combined_gains = marginal_gains[:, 0] + marginal_gains[:, 1]\n    ranked_items = np.argsort(combined_gains)[::-1]\n\n    # Apply flips to the top items that maintain feasibility\n    for i in ranked_items:\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9151155780175084,
            3.1462905406951904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using a novel local search operator\n    new_solution = base_solution.copy()\n    items = np.arange(len(base_solution))\n\n    # Calculate marginal gains for both objectives\n    marginal_gains = np.zeros((len(base_solution), 2))\n    for i in items:\n        if base_solution[i] == 1:\n            marginal_gains[i, 0] = -value1_lst[i]\n            marginal_gains[i, 1] = -value2_lst[i]\n        else:\n            marginal_gains[i, 0] = value1_lst[i]\n            marginal_gains[i, 1] = value2_lst[i]\n\n    # Rank items based on combined marginal gain\n    combined_gains = marginal_gains[:, 0] + marginal_gains[:, 1]\n    ranked_items = np.argsort(combined_gains)[::-1]\n\n    # Apply flips to the top items that maintain feasibility\n    for i in ranked_items:\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{The algorithm selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps and probabilistic flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on potential for improvement\n    selected_solution, _ = max(archive, key=lambda x: sum(x[0]) / len(x[0]))  # Select solution with highest density\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic flips and swaps\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Probabilistic flip: randomly flip items with low contribution\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Swap operator: swap two items if it improves both objectives\n    for _ in range(3):  # Perform up to 3 swaps\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3777973254494361,
            1.8084352612495422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on potential for improvement\n    selected_solution, _ = max(archive, key=lambda x: sum(x[0]) / len(x[0]))  # Select solution with highest density\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic flips and swaps\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Probabilistic flip: randomly flip items with low contribution\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Swap operator: swap two items if it improves both objectives\n    for _ in range(3):  # Perform up to 3 swaps\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{A novel hybrid local search strategy combines multi-objective diversification with adaptive neighborhood exploration, iteratively flipping items based on their marginal contributions to both objectives while ensuring feasibility through dynamic weight adjustments and objective-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to consider for flipping\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Adaptive neighborhood exploration\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        item_idx = np.random.choice(candidate_items)\n\n        # Calculate marginal contributions\n        marginal_weight = weight_lst[item_idx]\n        marginal_value1 = value1_lst[item_idx]\n        marginal_value2 = value2_lst[item_idx]\n\n        # Determine flip direction based on marginal contributions\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            if current_weight - marginal_weight <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= marginal_weight\n                current_value1 -= marginal_value1\n                current_value2 -= marginal_value2\n        else:\n            # Try adding the item\n            if current_weight + marginal_weight <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += marginal_weight\n                current_value1 += marginal_value1\n                current_value2 += marginal_value2\n\n    return new_solution\n\n",
        "score": [
            -0.8574967376737948,
            3.32459032535553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to consider for flipping\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Adaptive neighborhood exploration\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        item_idx = np.random.choice(candidate_items)\n\n        # Calculate marginal contributions\n        marginal_weight = weight_lst[item_idx]\n        marginal_value1 = value1_lst[item_idx]\n        marginal_value2 = value2_lst[item_idx]\n\n        # Determine flip direction based on marginal contributions\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            if current_weight - marginal_weight <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= marginal_weight\n                current_value1 -= marginal_value1\n                current_value2 -= marginal_value2\n        else:\n            # Try adding the item\n            if current_weight + marginal_weight <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += marginal_weight\n                current_value1 += marginal_value1\n                current_value2 += marginal_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{The algorithm intelligently selects a high-potential solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining adaptive item swaps and weight-balanced flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on high objective values and low weight utilization\n    scores = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        score = (v1 + v2) / (1 + total_weight)  # Balance between objectives and weight\n        scores.append(score)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Adaptive item swaps (flip two items if beneficial)\n    for _ in range(2):\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    # Step 2: Weight-balanced flips (flip items to balance weight and objectives)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight < capacity * 0.9:  # If underutilized, add items\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            for i in candidate_items:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n    elif total_weight > capacity * 0.7:  # If overutilized, remove items\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            for i in candidate_items:\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8796069543869447,
            3.121783584356308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on high objective values and low weight utilization\n    scores = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        score = (v1 + v2) / (1 + total_weight)  # Balance between objectives and weight\n        scores.append(score)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Adaptive item swaps (flip two items if beneficial)\n    for _ in range(2):\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    # Step 2: Weight-balanced flips (flip items to balance weight and objectives)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight < capacity * 0.9:  # If underutilized, add items\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            for i in candidate_items:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n    elif total_weight > capacity * 0.7:  # If overutilized, remove items\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            for i in candidate_items:\n                if total_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current total weight and values\n    total_weight = np.sum(base_solution * weight_lst)\n    total_value1 = np.sum(base_solution * value1_lst)\n    total_value2 = np.sum(base_solution * value2_lst)\n\n    # Generate neighbor by flipping items with high marginal value-to-weight ratios\n    marginal_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_ratios)[::-1]\n\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            new_weight = total_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                total_weight = new_weight\n                total_value1 -= value1_lst[idx]\n                total_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            new_weight = total_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                total_weight = new_weight\n                total_value1 += value1_lst[idx]\n                total_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8716126035773328,
            2.807987719774246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current total weight and values\n    total_weight = np.sum(base_solution * weight_lst)\n    total_value1 = np.sum(base_solution * value1_lst)\n    total_value2 = np.sum(base_solution * value2_lst)\n\n    # Generate neighbor by flipping items with high marginal value-to-weight ratios\n    marginal_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_ratios)[::-1]\n\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            new_weight = total_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                total_weight = new_weight\n                total_value1 -= value1_lst[idx]\n                total_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            new_weight = total_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                total_weight = new_weight\n                total_value1 += value1_lst[idx]\n                total_value2 += value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Randomly flip items, then apply a greedy improvement step\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Random flip (local perturbation)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Greedy improvement: Add the most promising item not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Score items by their normalized objective values\n        remaining_weights = weight_lst[remaining_items]\n        remaining_value1 = value1_lst[remaining_items]\n        remaining_value2 = value2_lst[remaining_items]\n\n        # Normalize values\n        norm_value1 = (remaining_value1 - remaining_value1.min()) / (remaining_value1.max() - remaining_value1.min() + 1e-10)\n        norm_value2 = (remaining_value2 - remaining_value2.min()) / (remaining_value2.max() - remaining_value2.min() + 1e-10)\n        scores = norm_value1 + norm_value2\n\n        # Sort by score (descending)\n        sorted_indices = np.argsort(scores)[::-1]\n\n        # Try to add items in order of score\n        for idx in sorted_indices:\n            if np.sum(weight_lst[new_solution == 1]) + remaining_weights[idx] <= capacity:\n                new_solution[remaining_items[idx]] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.3178898264983382,
            8.962488144636154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Randomly flip items, then apply a greedy improvement step\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Random flip (local perturbation)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Greedy improvement: Add the most promising item not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Score items by their normalized objective values\n        remaining_weights = weight_lst[remaining_items]\n        remaining_value1 = value1_lst[remaining_items]\n        remaining_value2 = value2_lst[remaining_items]\n\n        # Normalize values\n        norm_value1 = (remaining_value1 - remaining_value1.min()) / (remaining_value1.max() - remaining_value1.min() + 1e-10)\n        norm_value2 = (remaining_value2 - remaining_value2.min()) / (remaining_value2.max() - remaining_value2.min() + 1e-10)\n        scores = norm_value1 + norm_value2\n\n        # Sort by score (descending)\n        sorted_indices = np.argsort(scores)[::-1]\n\n        # Try to add items in order of score\n        for idx in sorted_indices:\n            if np.sum(weight_lst[new_solution == 1]) + remaining_weights[idx] <= capacity:\n                new_solution[remaining_items[idx]] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel adaptive local search that dynamically balances item swaps and insertions to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding[sorted_indices[i]] += (objectives[sorted_indices[i + 1], m] - objectives[sorted_indices[i - 1], m])\n\n    # Select solutions with high crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using adaptive local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Determine the number of changes based on solution density\n    density = np.mean(base_solution)\n    num_changes = max(1, int(2 * (1 - density)))  # More changes for denser solutions\n\n    for _ in range(num_changes):\n        # Choose between swap, insertion, or removal\n        operation = random.choices(['swap', 'insert', 'remove'], weights=[0.4, 0.3, 0.3])[0]\n\n        if operation == 'swap':\n            # Swap two items (one in, one out)\n            in_items = np.where(base_solution == 0)[0]\n            out_items = np.where(base_solution == 1)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                in_item = random.choice(in_items)\n                out_item = random.choice(out_items)\n\n                if current_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                    new_solution[out_item] = 0\n                    new_solution[in_item] = 1\n                    current_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n\n        elif operation == 'insert':\n            # Insert a new item if possible\n            in_items = np.where(base_solution == 0)[0]\n            if len(in_items) > 0:\n                in_item = random.choice(in_items)\n                if current_weight + weight_lst[in_item] <= capacity:\n                    new_solution[in_item] = 1\n                    current_weight += weight_lst[in_item]\n\n        elif operation == 'remove':\n            # Remove an item if possible\n            out_items = np.where(base_solution == 1)[0]\n            if len(out_items) > 0:\n                out_item = random.choice(out_items)\n                new_solution[out_item] = 0\n                current_weight -= weight_lst[out_item]\n\n    return new_solution\n\n",
        "score": [
            -0.6268762960278845,
            2.3993865251541138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding[sorted_indices[i]] += (objectives[sorted_indices[i + 1], m] - objectives[sorted_indices[i - 1], m])\n\n    # Select solutions with high crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using adaptive local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Determine the number of changes based on solution density\n    density = np.mean(base_solution)\n    num_changes = max(1, int(2 * (1 - density)))  # More changes for denser solutions\n\n    for _ in range(num_changes):\n        # Choose between swap, insertion, or removal\n        operation = random.choices(['swap', 'insert', 'remove'], weights=[0.4, 0.3, 0.3])[0]\n\n        if operation == 'swap':\n            # Swap two items (one in, one out)\n            in_items = np.where(base_solution == 0)[0]\n            out_items = np.where(base_solution == 1)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                in_item = random.choice(in_items)\n                out_item = random.choice(out_items)\n\n                if current_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                    new_solution[out_item] = 0\n                    new_solution[in_item] = 1\n                    current_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n\n        elif operation == 'insert':\n            # Insert a new item if possible\n            in_items = np.where(base_solution == 0)[0]\n            if len(in_items) > 0:\n                in_item = random.choice(in_items)\n                if current_weight + weight_lst[in_item] <= capacity:\n                    new_solution[in_item] = 1\n                    current_weight += weight_lst[in_item]\n\n        elif operation == 'remove':\n            # Remove an item if possible\n            out_items = np.where(base_solution == 1)[0]\n            if len(out_items) > 0:\n                out_item = random.choice(out_items)\n                new_solution[out_item] = 0\n                current_weight -= weight_lst[out_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with higher total objective values and lower total weights, then applies a hybrid local search that combines random swaps of items with a greedy selection based on marginal improvement in both objectives, ensuring feasibility by rejecting any moves that exceed the capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Sort solutions by total objective values (sum of both objectives) and weight (lower weight preferred)\n    archive_sorted = sorted(archive, key=lambda x: (-sum(x[1]), np.dot(x[0], weight_lst)))\n\n    # Select top 10% of solutions (or at least 1 if archive is small)\n    top_k = max(1, len(archive) // 10)\n    top_solutions = archive_sorted[:top_k]\n\n    # Randomly select one from top solutions\n    selected_idx = np.random.randint(0, len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Perform random swaps with greedy selection\n    for _ in range(min(5, n_items // 2)):  # Limit number of swaps\n        # Randomly select two items to swap\n        idx1, idx2 = np.random.choice(n_items, size=2, replace=False)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[idx1], candidate[idx2] = candidate[idx2], candidate[idx1]\n\n        # Check feasibility\n        if np.dot(candidate, weight_lst) <= capacity:\n            # Evaluate marginal improvement in both objectives\n            delta_value1 = np.dot(candidate, value1_lst) - np.dot(new_solution, value1_lst)\n            delta_value2 = np.dot(candidate, value2_lst) - np.dot(new_solution, value2_lst)\n\n            # Accept if either objective improves\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution = candidate\n\n    # If no improvement, perform a random flip (add/remove) to escape local optima\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(3):  # Try up to 3 random flips\n            idx = np.random.randint(0, n_items)\n            candidate = new_solution.copy()\n            candidate[idx] = 1 - candidate[idx]  # Flip\n\n            if np.dot(candidate, weight_lst) <= capacity:\n                new_solution = candidate\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.34008931377888374,
            5.650040239095688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Sort solutions by total objective values (sum of both objectives) and weight (lower weight preferred)\n    archive_sorted = sorted(archive, key=lambda x: (-sum(x[1]), np.dot(x[0], weight_lst)))\n\n    # Select top 10% of solutions (or at least 1 if archive is small)\n    top_k = max(1, len(archive) // 10)\n    top_solutions = archive_sorted[:top_k]\n\n    # Randomly select one from top solutions\n    selected_idx = np.random.randint(0, len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Perform random swaps with greedy selection\n    for _ in range(min(5, n_items // 2)):  # Limit number of swaps\n        # Randomly select two items to swap\n        idx1, idx2 = np.random.choice(n_items, size=2, replace=False)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[idx1], candidate[idx2] = candidate[idx2], candidate[idx1]\n\n        # Check feasibility\n        if np.dot(candidate, weight_lst) <= capacity:\n            # Evaluate marginal improvement in both objectives\n            delta_value1 = np.dot(candidate, value1_lst) - np.dot(new_solution, value1_lst)\n            delta_value2 = np.dot(candidate, value2_lst) - np.dot(new_solution, value2_lst)\n\n            # Accept if either objective improves\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution = candidate\n\n    # If no improvement, perform a random flip (add/remove) to escape local optima\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(3):  # Try up to 3 random flips\n            idx = np.random.randint(0, n_items)\n            candidate = new_solution.copy()\n            candidate[idx] = 1 - candidate[idx]  # Flip\n\n            if np.dot(candidate, weight_lst) <= capacity:\n                new_solution = candidate\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items to potentially swap or modify\n    zero_items = np.where(base_solution == 0)[0]\n    one_items = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: combination of swap and add/remove\n    if len(one_items) > 0 and len(zero_items) > 0:\n        # Randomly choose to swap or add/remove\n        if np.random.rand() > 0.5:\n            # Swap operation\n            swap_idx = np.random.choice(one_items)\n            add_idx = np.random.choice(zero_items)\n            if current_weight - weight_lst[swap_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[swap_idx] = 0\n                new_solution[add_idx] = 1\n        else:\n            # Add/remove operation\n            if np.random.rand() > 0.5 and len(one_items) > 1:\n                # Remove an item\n                remove_idx = np.random.choice(one_items)\n                new_solution[remove_idx] = 0\n            else:\n                # Add an item if capacity allows\n                add_idx = np.random.choice(zero_items)\n                if current_weight + weight_lst[add_idx] <= capacity:\n                    new_solution[add_idx] = 1\n    else:\n        # If all items are either 0 or 1, just flip a random item\n        flip_idx = np.random.randint(len(base_solution))\n        if base_solution[flip_idx] == 0 and current_weight + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n        elif base_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.33998884057358464,
            3.0228214859962463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items to potentially swap or modify\n    zero_items = np.where(base_solution == 0)[0]\n    one_items = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: combination of swap and add/remove\n    if len(one_items) > 0 and len(zero_items) > 0:\n        # Randomly choose to swap or add/remove\n        if np.random.rand() > 0.5:\n            # Swap operation\n            swap_idx = np.random.choice(one_items)\n            add_idx = np.random.choice(zero_items)\n            if current_weight - weight_lst[swap_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[swap_idx] = 0\n                new_solution[add_idx] = 1\n        else:\n            # Add/remove operation\n            if np.random.rand() > 0.5 and len(one_items) > 1:\n                # Remove an item\n                remove_idx = np.random.choice(one_items)\n                new_solution[remove_idx] = 0\n            else:\n                # Add an item if capacity allows\n                add_idx = np.random.choice(zero_items)\n                if current_weight + weight_lst[add_idx] <= capacity:\n                    new_solution[add_idx] = 1\n    else:\n        # If all items are either 0 or 1, just flip a random item\n        flip_idx = np.random.randint(len(base_solution))\n        if base_solution[flip_idx] == 0 and current_weight + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n        elif base_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{A hybrid local search strategy that intelligently selects a non-dominated solution from the archive, then applies a novel combination of item swaps, insertions, and deletions to generate a high-quality neighbor while ensuring feasibility through dynamic weight tracking and adaptive perturbation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high combined objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Hybrid local search: combination of swaps, insertions, and deletions\n    # Step 1: Randomly select a subset of items to perturb\n    perturb_indices = np.where(new_solution == 1)[0]\n    if len(perturb_indices) > 0:\n        num_perturb = min(3, len(perturb_indices))  # Limit perturbation size\n        perturb_items = np.random.choice(perturb_indices, size=num_perturb, replace=False)\n\n        # Step 2: Remove selected items (with weight check)\n        for idx in perturb_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Step 3: Add new items (greedy selection based on marginal value)\n        available_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(available_items)\n\n        for idx in available_items:\n            if weight_lst[idx] <= remaining_capacity:\n                # Calculate marginal value for both objectives\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n\n                # Simple heuristic: accept if either objective improves\n                if marginal_value1 > 0 or marginal_value2 > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    remaining_capacity = capacity - current_weight\n\n    # Final check to ensure feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If infeasible, perform a greedy repair\n        included_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(included_items)\n        for idx in included_items:\n            if np.sum(weight_lst[new_solution == 1]) > capacity:\n                new_solution[idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7302750090646901,
            1.5279655754566193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high combined objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Hybrid local search: combination of swaps, insertions, and deletions\n    # Step 1: Randomly select a subset of items to perturb\n    perturb_indices = np.where(new_solution == 1)[0]\n    if len(perturb_indices) > 0:\n        num_perturb = min(3, len(perturb_indices))  # Limit perturbation size\n        perturb_items = np.random.choice(perturb_indices, size=num_perturb, replace=False)\n\n        # Step 2: Remove selected items (with weight check)\n        for idx in perturb_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Step 3: Add new items (greedy selection based on marginal value)\n        available_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(available_items)\n\n        for idx in available_items:\n            if weight_lst[idx] <= remaining_capacity:\n                # Calculate marginal value for both objectives\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n\n                # Simple heuristic: accept if either objective improves\n                if marginal_value1 > 0 or marginal_value2 > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    remaining_capacity = capacity - current_weight\n\n    # Final check to ensure feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If infeasible, perform a greedy repair\n        included_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(included_items)\n        for idx in included_items:\n            if np.sum(weight_lst[new_solution == 1]) > capacity:\n                new_solution[idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected = archive[0][0].copy()\n\n    # Step 2: Identify critical items to flip (items with high marginal contribution)\n    current_weight = np.sum(weight_lst[selected == 1])\n    marginal_contribution = (value1_lst + value2_lst) * (1 - selected)  # Items not in the solution\n    marginal_contribution[weight_lst > (capacity - current_weight)] = 0  # Filter infeasible additions\n\n    # Step 3: Hybrid local search - flip critical items and perform a limited swap\n    new_solution = selected.copy()\n    critical_items = np.argsort(marginal_contribution)[-min(3, len(marginal_contribution)):]  # Top 3 critical items\n    for item in critical_items:\n        if marginal_contribution[item] > 0:\n            new_solution[item] = 1 - new_solution[item]\n\n    # Step 4: Perform a limited swap operation to explore neighborhood\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Swap one item from zero to one and one from one to zero\n        swap_zero = np.random.choice(zero_indices)\n        swap_one = np.random.choice(one_indices)\n        if (current_weight - weight_lst[swap_one] + weight_lst[swap_zero]) <= capacity:\n            new_solution[swap_zero] = 1\n            new_solution[swap_one] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3035896858038336,
            2.1307513415813446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected = archive[0][0].copy()\n\n    # Step 2: Identify critical items to flip (items with high marginal contribution)\n    current_weight = np.sum(weight_lst[selected == 1])\n    marginal_contribution = (value1_lst + value2_lst) * (1 - selected)  # Items not in the solution\n    marginal_contribution[weight_lst > (capacity - current_weight)] = 0  # Filter infeasible additions\n\n    # Step 3: Hybrid local search - flip critical items and perform a limited swap\n    new_solution = selected.copy()\n    critical_items = np.argsort(marginal_contribution)[-min(3, len(marginal_contribution)):]  # Top 3 critical items\n    for item in critical_items:\n        if marginal_contribution[item] > 0:\n            new_solution[item] = 1 - new_solution[item]\n\n    # Step 4: Perform a limited swap operation to explore neighborhood\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Swap one item from zero to one and one from one to zero\n        swap_zero = np.random.choice(zero_indices)\n        swap_one = np.random.choice(one_indices)\n        if (current_weight - weight_lst[swap_one] + weight_lst[swap_zero]) <= capacity:\n            new_solution[swap_zero] = 1\n            new_solution[swap_one] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on potential for improvement\n    # We prioritize solutions with high potential for improvement in either objective\n    # by considering the ratio of current value to possible maximum value\n    max_value1 = np.sum(value1_lst)\n    max_value2 = np.sum(value2_lst)\n    selected_idx = 0\n    best_score = 0\n\n    for i, (solution, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential improvement scores for both objectives\n        potential1 = (max_value1 - obj1) / max_value1 if max_value1 > 0 else 0\n        potential2 = (max_value2 - obj2) / max_value2 if max_value2 > 0 else 0\n        # Combine scores with a bias towards the objective with more room for improvement\n        score = max(potential1, potential2) * 0.7 + min(potential1, potential2) * 0.3\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    # This operator combines two strategies:\n    # 1. Randomized item swapping based on value-to-weight ratio\n    # 2. Greedy addition of items with high marginal value\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # First, try to swap items with high value-to-weight ratio\n    # Calculate value-to-weight ratios for all items\n    ratios1 = value1_lst / (weight_lst + 1e-10)  # avoid division by zero\n    ratios2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine ratios with a bias towards the objective with more room for improvement\n    if (max_value1 - current_value1) > (max_value2 - current_value2):\n        combined_ratios = ratios1 * 0.7 + ratios2 * 0.3\n    else:\n        combined_ratios = ratios1 * 0.3 + ratios2 * 0.7\n\n    # Find items to swap (randomly select from top 30% items)\n    top_items = np.argsort(combined_ratios)[-max(1, len(combined_ratios) // 3):]\n    np.random.shuffle(top_items)\n\n    for item in top_items:\n        if new_solution[item] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 += value1_lst[item]\n                current_value2 += value2_lst[item]\n\n    # Second, try to greedily add items with high marginal value\n    # Calculate marginal value ratios for all items\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal ratios with the same bias as before\n    if (max_value1 - current_value1) > (max_value2 - current_value2):\n        combined_marginal = marginal1 * 0.7 + marginal2 * 0.3\n    else:\n        combined_marginal = marginal1 * 0.3 + marginal2 * 0.7\n\n    # Sort items by combined marginal value\n    sorted_items = np.argsort(combined_marginal)[::-1]\n\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n            # No need to update current_value1 and current_value2 since we're not using them for selection\n\n    return new_solution\n\n",
        "score": [
            -0.4601963144845278,
            2.460957497358322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on potential for improvement\n    # We prioritize solutions with high potential for improvement in either objective\n    # by considering the ratio of current value to possible maximum value\n    max_value1 = np.sum(value1_lst)\n    max_value2 = np.sum(value2_lst)\n    selected_idx = 0\n    best_score = 0\n\n    for i, (solution, (obj1, obj2)) in enumerate(archive):\n        # Calculate potential improvement scores for both objectives\n        potential1 = (max_value1 - obj1) / max_value1 if max_value1 > 0 else 0\n        potential2 = (max_value2 - obj2) / max_value2 if max_value2 > 0 else 0\n        # Combine scores with a bias towards the objective with more room for improvement\n        score = max(potential1, potential2) * 0.7 + min(potential1, potential2) * 0.3\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    # This operator combines two strategies:\n    # 1. Randomized item swapping based on value-to-weight ratio\n    # 2. Greedy addition of items with high marginal value\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # First, try to swap items with high value-to-weight ratio\n    # Calculate value-to-weight ratios for all items\n    ratios1 = value1_lst / (weight_lst + 1e-10)  # avoid division by zero\n    ratios2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine ratios with a bias towards the objective with more room for improvement\n    if (max_value1 - current_value1) > (max_value2 - current_value2):\n        combined_ratios = ratios1 * 0.7 + ratios2 * 0.3\n    else:\n        combined_ratios = ratios1 * 0.3 + ratios2 * 0.7\n\n    # Find items to swap (randomly select from top 30% items)\n    top_items = np.argsort(combined_ratios)[-max(1, len(combined_ratios) // 3):]\n    np.random.shuffle(top_items)\n\n    for item in top_items:\n        if new_solution[item] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 += value1_lst[item]\n                current_value2 += value2_lst[item]\n\n    # Second, try to greedily add items with high marginal value\n    # Calculate marginal value ratios for all items\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal ratios with the same bias as before\n    if (max_value1 - current_value1) > (max_value2 - current_value2):\n        combined_marginal = marginal1 * 0.7 + marginal2 * 0.3\n    else:\n        combined_marginal = marginal1 * 0.3 + marginal2 * 0.7\n\n    # Sort items by combined marginal value\n    sorted_items = np.argsort(combined_marginal)[::-1]\n\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n            # No need to update current_value1 and current_value2 since we're not using them for selection\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of objective values, then applies a hybrid local search operator that combines random item swaps with a probabilistic exploration of item additions/removals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on a weighted combination of objectives\n    weights = np.array([0.7, 0.3])  # Prefer solutions with higher value1\n    scores = np.array([np.dot(obj, weights) for _, obj in archive])\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search operator\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an operation: swap, add, or remove\n        operation = random.choice(['swap', 'add', 'remove'])\n\n        if operation == 'swap':\n            # Randomly select two items to swap\n            items = np.where(new_solution == 1)[0]\n            if len(items) >= 2:\n                i, j = random.sample(list(items), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'add':\n            # Randomly select an item not in the solution\n            items = np.where(new_solution == 0)[0]\n            if len(items) > 0:\n                i = random.choice(items)\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n        elif operation == 'remove':\n            # Randomly select an item in the solution\n            items = np.where(new_solution == 1)[0]\n            if len(items) > 0:\n                i = random.choice(items)\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n        # Check feasibility and revert if necessary\n        if current_weight > capacity:\n            # Undo the last operation\n            if operation == 'swap':\n                i, j = random.sample(list(np.where(new_solution == 1)[0]), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif operation == 'add':\n                i = random.choice(np.where(new_solution == 1)[0])\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif operation == 'remove':\n                i = random.choice(np.where(new_solution == 0)[0])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3669928134678533,
            1.652444839477539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on a weighted combination of objectives\n    weights = np.array([0.7, 0.3])  # Prefer solutions with higher value1\n    scores = np.array([np.dot(obj, weights) for _, obj in archive])\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search operator\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an operation: swap, add, or remove\n        operation = random.choice(['swap', 'add', 'remove'])\n\n        if operation == 'swap':\n            # Randomly select two items to swap\n            items = np.where(new_solution == 1)[0]\n            if len(items) >= 2:\n                i, j = random.sample(list(items), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'add':\n            # Randomly select an item not in the solution\n            items = np.where(new_solution == 0)[0]\n            if len(items) > 0:\n                i = random.choice(items)\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n        elif operation == 'remove':\n            # Randomly select an item in the solution\n            items = np.where(new_solution == 1)[0]\n            if len(items) > 0:\n                i = random.choice(items)\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n        # Check feasibility and revert if necessary\n        if current_weight > capacity:\n            # Undo the last operation\n            if operation == 'swap':\n                i, j = random.sample(list(np.where(new_solution == 1)[0]), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif operation == 'add':\n                i = random.choice(np.where(new_solution == 1)[0])\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif operation == 'remove':\n                i = random.choice(np.where(new_solution == 0)[0])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * (np.sum(value1_lst * x[0]) + np.sum(value2_lst * x[0])))\n\n    # Generate a candidate set of items to flip\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Randomly select a subset of items to flip (with higher probability for lower-weight items)\n    flip_indices = np.random.choice(candidate_items, size=min(3, len(candidate_items)), replace=False)\n\n    # Create a new solution by flipping the selected items\n    new_solution = base_solution.copy()\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items until weight constraint is satisfied\n    current_weight = np.sum(weight_lst * new_solution)\n    while current_weight > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n        current_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9022678257763982,
            4.179442316293716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * (np.sum(value1_lst * x[0]) + np.sum(value2_lst * x[0])))\n\n    # Generate a candidate set of items to flip\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Randomly select a subset of items to flip (with higher probability for lower-weight items)\n    flip_indices = np.random.choice(candidate_items, size=min(3, len(candidate_items)), replace=False)\n\n    # Create a new solution by flipping the selected items\n    new_solution = base_solution.copy()\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items until weight constraint is satisfied\n    current_weight = np.sum(weight_lst * new_solution)\n    while current_weight > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n        current_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines swap-based and insertion-based moves, while ensuring feasibility and diversity in the neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[np.sum(sol[0]) for sol in archive],  # Prefer solutions with more items\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.5:  # 50% chance for swap-based move\n        # Select two items to swap (one included, one excluded)\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n\n            # Check feasibility\n            if weight_lst[j] <= capacity - (np.sum(weight_lst[base_solution == 1]) - weight_lst[i]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 50% chance for insertion-based move\n        # Select an item to insert (from excluded) and a position to insert (from included)\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            j = random.choice(excluded)\n            i = random.choice(included)\n\n            # Check feasibility\n            if weight_lst[j] <= capacity - np.sum(weight_lst[base_solution == 1]):\n                new_solution[j] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.38809079684034514,
            7.127484738826752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[np.sum(sol[0]) for sol in archive],  # Prefer solutions with more items\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.5:  # 50% chance for swap-based move\n        # Select two items to swap (one included, one excluded)\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n\n            # Check feasibility\n            if weight_lst[j] <= capacity - (np.sum(weight_lst[base_solution == 1]) - weight_lst[i]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 50% chance for insertion-based move\n        # Select an item to insert (from excluded) and a position to insert (from included)\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            j = random.choice(excluded)\n            i = random.choice(included)\n\n            # Check feasibility\n            if weight_lst[j] <= capacity - np.sum(weight_lst[base_solution == 1]):\n                new_solution[j] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low total weight, then applies a hybrid local search operator that combines item swaps and flips with a probabilistic acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Sort solutions by a combined score (prioritize high value and low weight)\n    def score(solution_obj):\n        total_value = solution_obj[1][0] + solution_obj[1][1]\n        total_weight = np.dot(solution_obj[0], weight_lst)\n        return total_value - total_weight\n\n    archive_sorted = sorted(archive, key=score, reverse=True)\n    selected = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = selected.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Probabilistic item swap\n    if len(items) > 0 and len(non_items) > 0:\n        item_to_remove = random.choice(items)\n        item_to_add = random.choice(non_items)\n        current_weight = np.dot(new_solution, weight_lst)\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n\n        if new_weight <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[item_to_add] = 1\n\n    # Random flip with feasibility check\n    if len(items) > 0:\n        item_to_flip = random.choice(items)\n        current_weight = np.dot(new_solution, weight_lst)\n        new_weight = current_weight - weight_lst[item_to_flip]\n\n        if new_weight <= capacity and random.random() < 0.5:  # 50% chance to flip\n            new_solution[item_to_flip] = 0\n\n    # Random addition with feasibility check\n    if len(non_items) > 0:\n        item_to_add = random.choice(non_items)\n        current_weight = np.dot(new_solution, weight_lst)\n        new_weight = current_weight + weight_lst[item_to_add]\n\n        if new_weight <= capacity and random.random() < 0.3:  # 30% chance to add\n            new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.321506021871624,
            3.98266938328743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Sort solutions by a combined score (prioritize high value and low weight)\n    def score(solution_obj):\n        total_value = solution_obj[1][0] + solution_obj[1][1]\n        total_weight = np.dot(solution_obj[0], weight_lst)\n        return total_value - total_weight\n\n    archive_sorted = sorted(archive, key=score, reverse=True)\n    selected = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = selected.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Probabilistic item swap\n    if len(items) > 0 and len(non_items) > 0:\n        item_to_remove = random.choice(items)\n        item_to_add = random.choice(non_items)\n        current_weight = np.dot(new_solution, weight_lst)\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n\n        if new_weight <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[item_to_add] = 1\n\n    # Random flip with feasibility check\n    if len(items) > 0:\n        item_to_flip = random.choice(items)\n        current_weight = np.dot(new_solution, weight_lst)\n        new_weight = current_weight - weight_lst[item_to_flip]\n\n        if new_weight <= capacity and random.random() < 0.5:  # 50% chance to flip\n            new_solution[item_to_flip] = 0\n\n    # Random addition with feasibility check\n    if len(non_items) > 0:\n        item_to_add = random.choice(non_items)\n        current_weight = np.dot(new_solution, weight_lst)\n        new_weight = current_weight + weight_lst[item_to_add]\n\n        if new_weight <= capacity and random.random() < 0.3:  # 30% chance to add\n            new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted randomness favoring solutions with higher objective values and lower weights, then applies a hybrid local search operator that combines item swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights for random selection based on objectives and current weight\n    objectives = np.array([obj for _, obj in archive])\n    weights = objectives[:, 0] + objectives[:, 1]  # Sum of objectives\n    weights = weights - np.min(weights) + 1e-6  # Normalize to avoid zero weights\n    weights = weights / np.sum(weights)  # Convert to probabilities\n\n    # Select a base solution with weighted randomness\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly swap two items (if feasible)\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, 2, replace=False)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = temp_weight\n\n    # Step 2: Adaptive flip of items based on their marginal contribution\n    if np.random.rand() < 0.5:  # 50% chance for flip\n        # Calculate marginal contributions for each item\n        marginal1 = value1_lst / (weight_lst + 1e-6)\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n        marginal = marginal1 + marginal2\n\n        # Sort items by descending marginal contribution\n        sorted_indices = np.argsort(-marginal)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                # Try removing the item\n                temp_weight = current_weight - weight_lst[idx]\n                if temp_weight >= 0:\n                    new_solution[idx] = 0\n                    current_weight = temp_weight\n            else:\n                # Try adding the item\n                temp_weight = current_weight + weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.29162674507485925,
            2.908126175403595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights for random selection based on objectives and current weight\n    objectives = np.array([obj for _, obj in archive])\n    weights = objectives[:, 0] + objectives[:, 1]  # Sum of objectives\n    weights = weights - np.min(weights) + 1e-6  # Normalize to avoid zero weights\n    weights = weights / np.sum(weights)  # Convert to probabilities\n\n    # Select a base solution with weighted randomness\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly swap two items (if feasible)\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, 2, replace=False)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = temp_weight\n\n    # Step 2: Adaptive flip of items based on their marginal contribution\n    if np.random.rand() < 0.5:  # 50% chance for flip\n        # Calculate marginal contributions for each item\n        marginal1 = value1_lst / (weight_lst + 1e-6)\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n        marginal = marginal1 + marginal2\n\n        # Sort items by descending marginal contribution\n        sorted_indices = np.argsort(-marginal)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                # Try removing the item\n                temp_weight = current_weight - weight_lst[idx]\n                if temp_weight >= 0:\n                    new_solution[idx] = 0\n                    current_weight = temp_weight\n            else:\n                # Try adding the item\n                temp_weight = current_weight + weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{A novel hybrid local search algorithm that combines weighted random selection of critical items with adaptive perturbation and feasibility-aware swaps to explore high-potential regions in the objective space while ensuring solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution with weighted randomness based on objective diversity\n    weights = np.array([(v1 + v2) for (s, (v1, v2)) in archive])\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Identify critical items (those with high value-to-weight ratio)\n    value_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-value_ratios)\n    critical_items = sorted_indices[:max(1, len(sorted_indices) // 5)]\n\n    # Step 3: Perform adaptive perturbation\n    for item in critical_items:\n        if random.random() < 0.3:  # 30% chance to flip critical items\n            new_solution[item] = 1 - new_solution[item]\n\n    # Step 4: Ensure feasibility with feasibility-aware swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Find items to remove to reduce weight\n        for item in np.argsort(weight_lst * new_solution)[::-1]:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    # Step 5: Additional random swap to explore neighborhood\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If still infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.3996548344326769,
            1.5791760087013245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution with weighted randomness based on objective diversity\n    weights = np.array([(v1 + v2) for (s, (v1, v2)) in archive])\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Identify critical items (those with high value-to-weight ratio)\n    value_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-value_ratios)\n    critical_items = sorted_indices[:max(1, len(sorted_indices) // 5)]\n\n    # Step 3: Perform adaptive perturbation\n    for item in critical_items:\n        if random.random() < 0.3:  # 30% chance to flip critical items\n            new_solution[item] = 1 - new_solution[item]\n\n    # Step 4: Ensure feasibility with feasibility-aware swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Find items to remove to reduce weight\n        for item in np.argsort(weight_lst * new_solution)[::-1]:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    # Step 5: Additional random swap to explore neighborhood\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If still infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel hybrid local search combining random item swaps and targeted profit-based flips to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (prioritize high value, low weight)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst[x[0] == 1]) + 1e-6))[0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        np.random.shuffle(candidate_indices)\n        candidate_indices = candidate_indices[:max(1, len(candidate_indices) // 2)]\n\n    # For each candidate, consider adding or removing based on value-to-weight ratio\n    for i in candidate_indices:\n        if new_solution[i] == 1:\n            # Consider removing this item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:\n            # Consider adding this item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                # Add items with high combined value-to-weight ratio\n                if (value1_lst[i] / (weight_lst[i] + 1e-6) + value2_lst[i] / (weight_lst[i] + 1e-6)) > 1:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    # Additional random flips to explore neighborhood\n    for _ in range(min(3, len(weight_lst))):\n        i = random.randint(0, len(weight_lst) - 1)\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.88126632339778,
            2.588921457529068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (prioritize high value, low weight)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst[x[0] == 1]) + 1e-6))[0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        np.random.shuffle(candidate_indices)\n        candidate_indices = candidate_indices[:max(1, len(candidate_indices) // 2)]\n\n    # For each candidate, consider adding or removing based on value-to-weight ratio\n    for i in candidate_indices:\n        if new_solution[i] == 1:\n            # Consider removing this item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:\n            # Consider adding this item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                # Add items with high combined value-to-weight ratio\n                if (value1_lst[i] / (weight_lst[i] + 1e-6) + value2_lst[i] / (weight_lst[i] + 1e-6)) > 1:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    # Additional random flips to explore neighborhood\n    for _ in range(min(3, len(weight_lst))):\n        i = random.randint(0, len(weight_lst) - 1)\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random flipping of items with a biased selection towards items that improve both objectives, ensuring feasibility by always checking the weight constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the frontier)\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip items with high marginal value and random flips\n    new_solution = base_solution.copy()\n    candidate_items = np.where(base_solution == 1)[0]\n\n    # Flip items with high marginal value for both objectives\n    for item in candidate_items:\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[item] = 0\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                current_weight = new_weight\n            else:\n                new_solution[item] = 1\n\n    # Add items not in the solution with high marginal value\n    not_in_solution = np.where(base_solution == 0)[0]\n    for item in not_in_solution:\n        if random.random() < 0.1:  # 10% chance to add\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.45131832991687215,
            1.3686537742614746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the frontier)\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip items with high marginal value and random flips\n    new_solution = base_solution.copy()\n    candidate_items = np.where(base_solution == 1)[0]\n\n    # Flip items with high marginal value for both objectives\n    for item in candidate_items:\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[item] = 0\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                current_weight = new_weight\n            else:\n                new_solution[item] = 1\n\n    # Add items not in the solution with high marginal value\n    not_in_solution = np.where(base_solution == 0)[0]\n    for item in not_in_solution:\n        if random.random() < 0.1:  # 10% chance to add\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid local search strategy combining adaptive neighborhood exploration and objective-driven perturbation, then generates a neighbor solution by intelligently flipping a subset of items to maximize both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by their objective values (prioritize solutions with higher combined values)\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% of solutions to choose from\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one of the top candidates\n        base_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - total_weight\n\n    # Identify items that can be added without exceeding capacity\n    available_items = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n    # Identify items that can be removed\n    removable_items = np.where(new_solution == 1)[0]\n\n    # Hybrid local search strategy:\n    # 1. First try to add items with high marginal value-to-weight ratio for both objectives\n    # 2. Then try to remove items with low marginal value-to-weight ratio\n    # 3. Finally, perform a random flip to escape local optima\n\n    # Step 1: Add items with high marginal value\n    if len(available_items) > 0:\n        # Calculate marginal value-to-weight ratio for both objectives\n        marginal_value1 = value1_lst[available_items] / weight_lst[available_items]\n        marginal_value2 = value2_lst[available_items] / weight_lst[available_items]\n        # Combine both objectives (could use weighted sum or other approach)\n        combined_marginal = marginal_value1 + marginal_value2\n        # Sort items by combined marginal value\n        sorted_items = available_items[np.argsort(-combined_marginal)]\n        # Try to add top items until capacity is exceeded\n        for item in sorted_items:\n            if weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n                if remaining_capacity <= 0:\n                    break\n\n    # Step 2: Remove items with low marginal value\n    if len(removable_items) > 0:\n        # Calculate marginal value-to-weight ratio for both objectives\n        marginal_value1 = value1_lst[removable_items] / weight_lst[removable_items]\n        marginal_value2 = value2_lst[removable_items] / weight_lst[removable_items]\n        combined_marginal = marginal_value1 + marginal_value2\n        # Sort items by combined marginal value (ascending to remove worst items first)\n        sorted_items = removable_items[np.argsort(combined_marginal)]\n        # Try to remove items with lowest marginal value\n        for item in sorted_items:\n            new_solution[item] = 0\n            # Verify feasibility (should always be feasible after removal)\n            if np.sum(weight_lst[new_solution == 1]) <= capacity:\n                break  # Only remove one item to maintain diversity\n            else:\n                new_solution[item] = 1  # Revert if infeasible\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:  # 30% chance of random flip\n        # Select a random item to flip\n        item = random.randint(0, len(new_solution) - 1)\n        if new_solution[item] == 1:\n            # Try to remove it (must ensure feasibility)\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            # Try to add it (must not exceed capacity)\n            if weight_lst[item] <= capacity - np.sum(weight_lst[new_solution == 1]):\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3864158825537738,
            1.2361597120761871
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by their objective values (prioritize solutions with higher combined values)\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% of solutions to choose from\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one of the top candidates\n        base_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - total_weight\n\n    # Identify items that can be added without exceeding capacity\n    available_items = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n    # Identify items that can be removed\n    removable_items = np.where(new_solution == 1)[0]\n\n    # Hybrid local search strategy:\n    # 1. First try to add items with high marginal value-to-weight ratio for both objectives\n    # 2. Then try to remove items with low marginal value-to-weight ratio\n    # 3. Finally, perform a random flip to escape local optima\n\n    # Step 1: Add items with high marginal value\n    if len(available_items) > 0:\n        # Calculate marginal value-to-weight ratio for both objectives\n        marginal_value1 = value1_lst[available_items] / weight_lst[available_items]\n        marginal_value2 = value2_lst[available_items] / weight_lst[available_items]\n        # Combine both objectives (could use weighted sum or other approach)\n        combined_marginal = marginal_value1 + marginal_value2\n        # Sort items by combined marginal value\n        sorted_items = available_items[np.argsort(-combined_marginal)]\n        # Try to add top items until capacity is exceeded\n        for item in sorted_items:\n            if weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n                if remaining_capacity <= 0:\n                    break\n\n    # Step 2: Remove items with low marginal value\n    if len(removable_items) > 0:\n        # Calculate marginal value-to-weight ratio for both objectives\n        marginal_value1 = value1_lst[removable_items] / weight_lst[removable_items]\n        marginal_value2 = value2_lst[removable_items] / weight_lst[removable_items]\n        combined_marginal = marginal_value1 + marginal_value2\n        # Sort items by combined marginal value (ascending to remove worst items first)\n        sorted_items = removable_items[np.argsort(combined_marginal)]\n        # Try to remove items with lowest marginal value\n        for item in sorted_items:\n            new_solution[item] = 0\n            # Verify feasibility (should always be feasible after removal)\n            if np.sum(weight_lst[new_solution == 1]) <= capacity:\n                break  # Only remove one item to maintain diversity\n            else:\n                new_solution[item] = 1  # Revert if infeasible\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:  # 30% chance of random flip\n        # Select a random item to flip\n        item = random.randint(0, len(new_solution) - 1)\n        if new_solution[item] == 1:\n            # Try to remove it (must ensure feasibility)\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            # Try to add it (must not exceed capacity)\n            if weight_lst[item] <= capacity - np.sum(weight_lst[new_solution == 1]):\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of objective values (heuristic for potential)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    base_solution, _ = archive_sorted[0]\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to flip (with higher probability for items with high marginal value)\n    n_items = len(weight_lst)\n    flip_prob = np.zeros(n_items)\n\n    # Calculate marginal value for each item (value / weight)\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    marginal = marginal1 + marginal2\n\n    # Assign higher flip probability to items with high marginal value\n    flip_prob = marginal / marginal.sum()\n\n    # Randomly select items to flip\n    flip_mask = np.random.rand(n_items) < flip_prob\n\n    # Flip selected items while ensuring feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in range(n_items):\n        if flip_mask[i]:\n            if new_solution[i] == 1:\n                # Try to remove the item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add the item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 3: Apply a second phase of local search (swap-based)\n    # Find items to swap (one in, one out) to improve both objectives\n    for i in range(n_items):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            for j in range(n_items):\n                if new_solution[j] == 1:\n                    if (current_weight - weight_lst[j] + weight_lst[i]) <= capacity:\n                        # Check if swap improves both objectives\n                        delta1 = value1_lst[i] - value1_lst[j]\n                        delta2 = value2_lst[i] - value2_lst[j]\n                        if delta1 > 0 and delta2 > 0:\n                            new_solution[i] = 1\n                            new_solution[j] = 0\n                            current_weight = current_weight - weight_lst[j] + weight_lst[i]\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.31510507643257646,
            8.271227359771729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of objective values (heuristic for potential)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    base_solution, _ = archive_sorted[0]\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to flip (with higher probability for items with high marginal value)\n    n_items = len(weight_lst)\n    flip_prob = np.zeros(n_items)\n\n    # Calculate marginal value for each item (value / weight)\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    marginal = marginal1 + marginal2\n\n    # Assign higher flip probability to items with high marginal value\n    flip_prob = marginal / marginal.sum()\n\n    # Randomly select items to flip\n    flip_mask = np.random.rand(n_items) < flip_prob\n\n    # Flip selected items while ensuring feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in range(n_items):\n        if flip_mask[i]:\n            if new_solution[i] == 1:\n                # Try to remove the item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add the item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 3: Apply a second phase of local search (swap-based)\n    # Find items to swap (one in, one out) to improve both objectives\n    for i in range(n_items):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            for j in range(n_items):\n                if new_solution[j] == 1:\n                    if (current_weight - weight_lst[j] + weight_lst[i]) <= capacity:\n                        # Check if swap improves both objectives\n                        delta1 = value1_lst[i] - value1_lst[j]\n                        delta2 = value2_lst[i] - value2_lst[j]\n                        if delta1 > 0 and delta2 > 0:\n                            new_solution[i] = 1\n                            new_solution[j] = 0\n                            current_weight = current_weight - weight_lst[j] + weight_lst[i]\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{A heuristic function that selects a promising solution from the archive, identifies critical items based on their marginal contributions to both objectives, and applies a hybrid local search strategy combining item swaps, flips, and guided perturbations to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Identify critical items based on marginal contributions\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) == 0:\n        # If no items are included, randomly select some\n        candidate_items = np.random.choice(len(weight_lst), size=min(10, len(weight_lst)), replace=False)\n        for item in candidate_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n        return new_solution\n\n    # Calculate marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Hybrid local search strategy\n    for _ in range(3):  # Perform multiple perturbations\n        # Strategy 1: Swap items between included and excluded\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            swap_out = np.random.choice(included_items)\n            swap_in = np.random.choice(excluded_items)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight - weight_lst[swap_out] + weight_lst[swap_in] <= capacity:\n                new_solution[swap_out] = 0\n                new_solution[swap_in] = 1\n\n        # Strategy 2: Flip items with high marginal contributions\n        top_items = np.argsort(combined_marginal)[-min(5, len(combined_marginal)):]\n        for item in top_items:\n            if new_solution[item] == 0 and weight_lst[item] <= capacity:\n                new_solution[item] = 1\n            elif new_solution[item] == 1:\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n\n        # Strategy 3: Guided perturbation - add/remove based on objective balance\n        obj1, obj2 = archive[selected_idx][1]\n        if obj1 > obj2:\n            # Prefer items with higher value1\n            candidate_items = np.argsort(marginal_value1)[-min(3, len(marginal_value1)):]\n        else:\n            # Prefer items with higher value2\n            candidate_items = np.argsort(marginal_value2)[-min(3, len(marginal_value2)):]\n\n        for item in candidate_items:\n            if new_solution[item] == 0 and weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4149407834739205,
            4.447198003530502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Identify critical items based on marginal contributions\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) == 0:\n        # If no items are included, randomly select some\n        candidate_items = np.random.choice(len(weight_lst), size=min(10, len(weight_lst)), replace=False)\n        for item in candidate_items:\n            if weight_lst[item] <= capacity:\n                new_solution[item] = 1\n        return new_solution\n\n    # Calculate marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Hybrid local search strategy\n    for _ in range(3):  # Perform multiple perturbations\n        # Strategy 1: Swap items between included and excluded\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            swap_out = np.random.choice(included_items)\n            swap_in = np.random.choice(excluded_items)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight - weight_lst[swap_out] + weight_lst[swap_in] <= capacity:\n                new_solution[swap_out] = 0\n                new_solution[swap_in] = 1\n\n        # Strategy 2: Flip items with high marginal contributions\n        top_items = np.argsort(combined_marginal)[-min(5, len(combined_marginal)):]\n        for item in top_items:\n            if new_solution[item] == 0 and weight_lst[item] <= capacity:\n                new_solution[item] = 1\n            elif new_solution[item] == 1:\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n\n        # Strategy 3: Guided perturbation - add/remove based on objective balance\n        obj1, obj2 = archive[selected_idx][1]\n        if obj1 > obj2:\n            # Prefer items with higher value1\n            candidate_items = np.argsort(marginal_value1)[-min(3, len(marginal_value1)):]\n        else:\n            # Prefer items with higher value2\n            candidate_items = np.argsort(marginal_value2)[-min(3, len(marginal_value2)):]\n\n        for item in candidate_items:\n            if new_solution[item] == 0 and weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swaps and guided item additions/removals to explore diverse neighborhoods while ensuring feasibility, ultimately generating a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., not on the Pareto front)\n        # Here, we randomly select a solution that is not the best in either objective\n        max_val1 = max(obj[0] for _, obj in archive)\n        max_val2 = max(obj[1] for _, obj in archive)\n        candidates = [sol for sol, obj in archive if not (obj[0] == max_val1 or obj[1] == max_val2)]\n        if not candidates:\n            candidates = [sol for sol, _ in archive]\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly swap two items (if possible)\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n    if len(items_in) >= 2 and len(items_out) >= 1:\n        swap_indices = random.sample(list(items_in), 2)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[swap_indices[1]] = 1  # Revert the swap\n    # Step 2: Add or remove an item to further explore the neighborhood\n    if random.random() < 0.5:  # 50% chance to add an item\n        # Select an item not in the knapsack with highest value-to-weight ratio\n        candidates = [i for i in items_out if weight_lst[i] <= capacity - np.sum(weight_lst * new_solution)]\n        if candidates:\n            best_item = max(candidates, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[best_item] = 1\n    else:  # 50% chance to remove an item\n        # Select an item to remove based on its contribution to both objectives\n        if len(items_in) > 0:\n            worst_item = min(items_in, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[worst_item] = 0\n\n    # Ensure the solution is feasible\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the item with the lowest value-to-weight ratio\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        worst_item = min(items_in, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.6387392572985937,
            9.868028670549393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., not on the Pareto front)\n        # Here, we randomly select a solution that is not the best in either objective\n        max_val1 = max(obj[0] for _, obj in archive)\n        max_val2 = max(obj[1] for _, obj in archive)\n        candidates = [sol for sol, obj in archive if not (obj[0] == max_val1 or obj[1] == max_val2)]\n        if not candidates:\n            candidates = [sol for sol, _ in archive]\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly swap two items (if possible)\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n    if len(items_in) >= 2 and len(items_out) >= 1:\n        swap_indices = random.sample(list(items_in), 2)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[swap_indices[1]] = 1  # Revert the swap\n    # Step 2: Add or remove an item to further explore the neighborhood\n    if random.random() < 0.5:  # 50% chance to add an item\n        # Select an item not in the knapsack with highest value-to-weight ratio\n        candidates = [i for i in items_out if weight_lst[i] <= capacity - np.sum(weight_lst * new_solution)]\n        if candidates:\n            best_item = max(candidates, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[best_item] = 1\n    else:  # 50% chance to remove an item\n        # Select an item to remove based on its contribution to both objectives\n        if len(items_in) > 0:\n            worst_item = min(items_in, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[worst_item] = 0\n\n    # Ensure the solution is feasible\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the item with the lowest value-to-weight ratio\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        worst_item = min(items_in, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high variance in objective values, then applies a hybrid local search operator that combines random item swaps with a greedy improvement step to ensure feasibility and multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with high variance in objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: random swaps + greedy improvement\n    new_solution = base_solution.copy()\n    num_items = len(base_solution)\n\n    # Randomly select a subset of items to swap\n    swap_indices = random.sample(range(num_items), min(3, num_items))\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy improvement: add items with highest combined value/weight ratio if feasible\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        value_ratio = (value1_lst + value2_lst) / weight_lst\n        feasible_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(feasible_items) > 0:\n            best_item = feasible_items[np.argmax(value_ratio[feasible_items])]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.36907840813411985,
            2.241756021976471
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with high variance in objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: random swaps + greedy improvement\n    new_solution = base_solution.copy()\n    num_items = len(base_solution)\n\n    # Randomly select a subset of items to swap\n    swap_indices = random.sample(range(num_items), min(3, num_items))\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy improvement: add items with highest combined value/weight ratio if feasible\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        value_ratio = (value1_lst + value2_lst) / weight_lst\n        feasible_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(feasible_items) > 0:\n            best_item = feasible_items[np.argmax(value_ratio[feasible_items])]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{A novel hybrid local search strategy that combines a weighted objective-driven swap with a probabilistic diversification step to intelligently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by performing a weighted objective-driven swap\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Randomly select items to swap (if possible)\n    if len(items) > 0 and len(non_items) > 0:\n        # Weighted probability based on marginal improvement potential\n        item_to_remove = random.choice(items)\n        non_item_to_add = random.choice(non_items)\n\n        # Check feasibility before swapping\n        if (current_weight - weight_lst[item_to_remove] + weight_lst[non_item_to_add]) <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[non_item_to_add] = 1\n\n    # Apply probabilistic diversification: randomly flip one bit to escape local optima\n    if random.random() < 0.3:\n        flip_idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[flip_idx] == 1:\n            if (current_weight - weight_lst[flip_idx]) <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if (current_weight + weight_lst[flip_idx]) <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.41606947077577056,
            1.601588487625122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by performing a weighted objective-driven swap\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Randomly select items to swap (if possible)\n    if len(items) > 0 and len(non_items) > 0:\n        # Weighted probability based on marginal improvement potential\n        item_to_remove = random.choice(items)\n        non_item_to_add = random.choice(non_items)\n\n        # Check feasibility before swapping\n        if (current_weight - weight_lst[item_to_remove] + weight_lst[non_item_to_add]) <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[non_item_to_add] = 1\n\n    # Apply probabilistic diversification: randomly flip one bit to escape local optima\n    if random.random() < 0.3:\n        flip_idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[flip_idx] == 1:\n            if (current_weight - weight_lst[flip_idx]) <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if (current_weight + weight_lst[flip_idx]) <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping with probabilistic multi-objective exploration, where solutions are selectively perturbed based on their objective dominance and weight efficiency, while ensuring feasibility through dynamic constraint handling.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective dominance and weight efficiency\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_sol, selected_obj = archive[selected_idx]\n    base_solution = selected_sol.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be swapped or flipped\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Hybrid local search: adaptive swapping or flipping\n    new_solution = base_solution.copy()\n    if random.random() < 0.7:  # Higher probability for swapping\n        # Swap two items (one in, one out)\n        item_out = random.choice(candidate_items)\n        new_solution[item_out] = 0\n        total_weight -= weight_lst[item_out]\n\n        # Find feasible items to add\n        feasible_items = np.where((base_solution == 0) & (weight_lst <= (capacity - total_weight)))[0]\n        if len(feasible_items) > 0:\n            item_in = random.choice(feasible_items)\n            new_solution[item_in] = 1\n    else:\n        # Flip a single item (if feasible)\n        item_to_flip = random.choice(candidate_items)\n        if base_solution[item_to_flip] == 1:\n            if total_weight - weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 0\n        else:\n            if total_weight + weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        item_to_remove = random.choice(items_in)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4898714392202609,
            1.1273418962955475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective dominance and weight efficiency\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_sol, selected_obj = archive[selected_idx]\n    base_solution = selected_sol.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be swapped or flipped\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Hybrid local search: adaptive swapping or flipping\n    new_solution = base_solution.copy()\n    if random.random() < 0.7:  # Higher probability for swapping\n        # Swap two items (one in, one out)\n        item_out = random.choice(candidate_items)\n        new_solution[item_out] = 0\n        total_weight -= weight_lst[item_out]\n\n        # Find feasible items to add\n        feasible_items = np.where((base_solution == 0) & (weight_lst <= (capacity - total_weight)))[0]\n        if len(feasible_items) > 0:\n            item_in = random.choice(feasible_items)\n            new_solution[item_in] = 1\n    else:\n        # Flip a single item (if feasible)\n        item_to_flip = random.choice(candidate_items)\n        if base_solution[item_to_flip] == 1:\n            if total_weight - weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 0\n        else:\n            if total_weight + weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        item_to_remove = random.choice(items_in)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This algorithm intelligently selects a solution from the archive, prioritizes items with high marginal utility ratios for both objectives, and applies a hybrid local search that combines random swaps with a novel objective-aware perturbation strategy to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a base solution from the archive (here, randomly for simplicity)\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal utility ratios for both objectives\n    marginal_ratio1 = value1_lst / weight_lst\n    marginal_ratio2 = value2_lst / weight_lst\n\n    # Combine marginal ratios for selection probability\n    combined_ratio = marginal_ratio1 + marginal_ratio2\n\n    # Identify items to consider for flipping (0 to 1 or 1 to 0)\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) == 0:\n        flip_candidates = np.where(new_solution == 0)[0]\n\n    # Randomly select a candidate to flip\n    if len(flip_candidates) > 0:\n        idx = random.choice(flip_candidates)\n        if new_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n            else:\n                # If removing is not feasible, try adding another item\n                add_candidates = np.where(new_solution == 0)[0]\n                if len(add_candidates) > 0:\n                    # Select the best candidate based on combined marginal ratio\n                    best_candidate = add_candidates[np.argmax(combined_ratio[add_candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n        else:\n            # Try to add the item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n            else:\n                # If adding is not feasible, try removing another item\n                remove_candidates = np.where(new_solution == 1)[0]\n                if len(remove_candidates) > 0:\n                    # Select the worst candidate based on combined marginal ratio\n                    worst_candidate = remove_candidates[np.argmin(combined_ratio[remove_candidates])]\n                    if current_weight - weight_lst[worst_candidate] <= capacity:\n                        new_solution[worst_candidate] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8076843981231165,
            0.8908890187740326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a base solution from the archive (here, randomly for simplicity)\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal utility ratios for both objectives\n    marginal_ratio1 = value1_lst / weight_lst\n    marginal_ratio2 = value2_lst / weight_lst\n\n    # Combine marginal ratios for selection probability\n    combined_ratio = marginal_ratio1 + marginal_ratio2\n\n    # Identify items to consider for flipping (0 to 1 or 1 to 0)\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) == 0:\n        flip_candidates = np.where(new_solution == 0)[0]\n\n    # Randomly select a candidate to flip\n    if len(flip_candidates) > 0:\n        idx = random.choice(flip_candidates)\n        if new_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n            else:\n                # If removing is not feasible, try adding another item\n                add_candidates = np.where(new_solution == 0)[0]\n                if len(add_candidates) > 0:\n                    # Select the best candidate based on combined marginal ratio\n                    best_candidate = add_candidates[np.argmax(combined_ratio[add_candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n        else:\n            # Try to add the item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n            else:\n                # If adding is not feasible, try removing another item\n                remove_candidates = np.where(new_solution == 1)[0]\n                if len(remove_candidates) > 0:\n                    # Select the worst candidate based on combined marginal ratio\n                    worst_candidate = remove_candidates[np.argmin(combined_ratio[remove_candidates])]\n                    if current_weight - weight_lst[worst_candidate] <= capacity:\n                        new_solution[worst_candidate] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This algorithm intelligently selects a solution from the archive, prioritizes items with high marginal utility ratios for both objectives, and applies a hybrid local search that combines random swaps with a novel objective-aware perturbation strategy to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a base solution from the archive (here, randomly for simplicity)\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal utility ratios for both objectives\n    marginal_ratio1 = value1_lst / weight_lst\n    marginal_ratio2 = value2_lst / weight_lst\n\n    # Combine marginal ratios for selection probability\n    combined_ratio = marginal_ratio1 + marginal_ratio2\n\n    # Identify items to consider for flipping (0 to 1 or 1 to 0)\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) == 0:\n        flip_candidates = np.where(new_solution == 0)[0]\n\n    # Randomly select a candidate to flip\n    if len(flip_candidates) > 0:\n        idx = random.choice(flip_candidates)\n        if new_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n            else:\n                # If removing is not feasible, try adding another item\n                add_candidates = np.where(new_solution == 0)[0]\n                if len(add_candidates) > 0:\n                    # Select the best candidate based on combined marginal ratio\n                    best_candidate = add_candidates[np.argmax(combined_ratio[add_candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n        else:\n            # Try to add the item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n            else:\n                # If adding is not feasible, try removing another item\n                remove_candidates = np.where(new_solution == 1)[0]\n                if len(remove_candidates) > 0:\n                    # Select the worst candidate based on combined marginal ratio\n                    worst_candidate = remove_candidates[np.argmin(combined_ratio[remove_candidates])]\n                    if current_weight - weight_lst[worst_candidate] <= capacity:\n                        new_solution[worst_candidate] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8076843981231165,
            0.8908890187740326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a base solution from the archive (here, randomly for simplicity)\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal utility ratios for both objectives\n    marginal_ratio1 = value1_lst / weight_lst\n    marginal_ratio2 = value2_lst / weight_lst\n\n    # Combine marginal ratios for selection probability\n    combined_ratio = marginal_ratio1 + marginal_ratio2\n\n    # Identify items to consider for flipping (0 to 1 or 1 to 0)\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) == 0:\n        flip_candidates = np.where(new_solution == 0)[0]\n\n    # Randomly select a candidate to flip\n    if len(flip_candidates) > 0:\n        idx = random.choice(flip_candidates)\n        if new_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n            else:\n                # If removing is not feasible, try adding another item\n                add_candidates = np.where(new_solution == 0)[0]\n                if len(add_candidates) > 0:\n                    # Select the best candidate based on combined marginal ratio\n                    best_candidate = add_candidates[np.argmax(combined_ratio[add_candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n        else:\n            # Try to add the item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n            else:\n                # If adding is not feasible, try removing another item\n                remove_candidates = np.where(new_solution == 1)[0]\n                if len(remove_candidates) > 0:\n                    # Select the worst candidate based on combined marginal ratio\n                    worst_candidate = remove_candidates[np.argmin(combined_ratio[remove_candidates])]\n                    if current_weight - weight_lst[worst_candidate] <= capacity:\n                        new_solution[worst_candidate] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, performs a weighted random walk to explore promising regions, and applies a dynamic flip-and-swap operator to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Intelligent selection: prioritize solutions with higher crowding distance or better objective values\n    selected_idx = random.choices(range(len(archive)), weights=[(i+1) for i in range(len(archive))], k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Perform a weighted random walk to explore promising regions\n    num_items = len(weight_lst)\n    for _ in range(min(3, num_items // 2)):\n        candidate = new_solution.copy()\n        idx = random.randint(0, num_items - 1)\n        candidate[idx] = 1 - candidate[idx]\n\n        # Check feasibility\n        if np.sum(weight_lst[candidate == 1]) <= capacity:\n            new_solution = candidate\n\n    # Step 3: Apply a dynamic flip-and-swap operator\n    # Select a random subset of items to flip and swap\n    flip_indices = random.sample(range(num_items), min(2, num_items))\n    swap_indices = random.sample(range(num_items), min(2, num_items))\n\n    for idx in flip_indices:\n        candidate = new_solution.copy()\n        candidate[idx] = 1 - candidate[idx]\n        if np.sum(weight_lst[candidate == 1]) <= capacity:\n            new_solution = candidate\n\n    for i, j in zip(swap_indices[:1], swap_indices[1:]):\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n        if np.sum(weight_lst[candidate == 1]) <= capacity:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.34072900700028674,
            1.4131353199481964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Intelligent selection: prioritize solutions with higher crowding distance or better objective values\n    selected_idx = random.choices(range(len(archive)), weights=[(i+1) for i in range(len(archive))], k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Perform a weighted random walk to explore promising regions\n    num_items = len(weight_lst)\n    for _ in range(min(3, num_items // 2)):\n        candidate = new_solution.copy()\n        idx = random.randint(0, num_items - 1)\n        candidate[idx] = 1 - candidate[idx]\n\n        # Check feasibility\n        if np.sum(weight_lst[candidate == 1]) <= capacity:\n            new_solution = candidate\n\n    # Step 3: Apply a dynamic flip-and-swap operator\n    # Select a random subset of items to flip and swap\n    flip_indices = random.sample(range(num_items), min(2, num_items))\n    swap_indices = random.sample(range(num_items), min(2, num_items))\n\n    for idx in flip_indices:\n        candidate = new_solution.copy()\n        candidate[idx] = 1 - candidate[idx]\n        if np.sum(weight_lst[candidate == 1]) <= capacity:\n            new_solution = candidate\n\n    for i, j in zip(swap_indices[:1], swap_indices[1:]):\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n        if np.sum(weight_lst[candidate == 1]) <= capacity:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining item swapping and adaptive perturbation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    base_solution = random.choice(archive_solutions).copy()\n\n    # Calculate current weight and potential items to swap\n    current_weight = np.sum(weight_lst * base_solution)\n    available_items = np.where(base_solution == 0)[0]\n    included_items = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: swap items or perturb based on potential\n    new_solution = base_solution.copy()\n\n    if len(included_items) > 1 and len(available_items) > 0:\n        # Swap two items if it improves both objectives\n        i, j = random.sample(list(included_items), 1)[0], random.choice(available_items)\n        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perturb by flipping a random item if feasible\n        perturb_item = random.choice(np.where(base_solution == 1)[0]) if len(included_items) > 0 else random.choice(available_items)\n        if (base_solution[perturb_item] == 0 and (current_weight + weight_lst[perturb_item]) <= capacity) or \\\n           (base_solution[perturb_item] == 1 and (current_weight - weight_lst[perturb_item]) >= 0):\n            new_solution[perturb_item] = 1 - new_solution[perturb_item]\n\n    return new_solution\n\n",
        "score": [
            -0.5693940788720073,
            1.4828943610191345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    base_solution = random.choice(archive_solutions).copy()\n\n    # Calculate current weight and potential items to swap\n    current_weight = np.sum(weight_lst * base_solution)\n    available_items = np.where(base_solution == 0)[0]\n    included_items = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: swap items or perturb based on potential\n    new_solution = base_solution.copy()\n\n    if len(included_items) > 1 and len(available_items) > 0:\n        # Swap two items if it improves both objectives\n        i, j = random.sample(list(included_items), 1)[0], random.choice(available_items)\n        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perturb by flipping a random item if feasible\n        perturb_item = random.choice(np.where(base_solution == 1)[0]) if len(included_items) > 0 else random.choice(available_items)\n        if (base_solution[perturb_item] == 0 and (current_weight + weight_lst[perturb_item]) <= capacity) or \\\n           (base_solution[perturb_item] == 1 and (current_weight - weight_lst[perturb_item]) >= 0):\n            new_solution[perturb_item] = 1 - new_solution[perturb_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This heuristic selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining item swapping and adaptive perturbation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards higher objectives)\n    selected_idx = random.choices(range(len(archive)), weights=[(v1 + v2) for (s, (v1, v2)) in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = archive[selected_idx][1][0]\n    current_value2 = archive[selected_idx][1][1]\n\n    # Hybrid local search: swap items and adaptively perturb\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Step 1: Randomly swap items between included and excluded\n    if len(items) > 0 and len(non_items) > 0:\n        swap_item = random.choice(items)\n        swap_non_item = random.choice(non_items)\n        if current_weight - weight_lst[swap_item] + weight_lst[swap_non_item] <= capacity:\n            new_solution[swap_item] = 0\n            new_solution[swap_non_item] = 1\n\n    # Step 2: Adaptive perturbation - flip items with high marginal contribution\n    for _ in range(2):  # Limit perturbation steps\n        marginal_contributions = []\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1:\n                marginal_contributions.append((value1_lst[i] + value2_lst[i], i))\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    marginal_contributions.append((value1_lst[i] + value2_lst[i], i))\n        if not marginal_contributions:\n            break\n        marginal_contributions.sort(reverse=True)\n        flip_candidate = marginal_contributions[0][1]\n        new_solution[flip_candidate] = 1 - new_solution[flip_candidate]\n\n    return new_solution\n\n",
        "score": [
            -0.8608712449492438,
            2.6625261306762695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards higher objectives)\n    selected_idx = random.choices(range(len(archive)), weights=[(v1 + v2) for (s, (v1, v2)) in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = archive[selected_idx][1][0]\n    current_value2 = archive[selected_idx][1][1]\n\n    # Hybrid local search: swap items and adaptively perturb\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Step 1: Randomly swap items between included and excluded\n    if len(items) > 0 and len(non_items) > 0:\n        swap_item = random.choice(items)\n        swap_non_item = random.choice(non_items)\n        if current_weight - weight_lst[swap_item] + weight_lst[swap_non_item] <= capacity:\n            new_solution[swap_item] = 0\n            new_solution[swap_non_item] = 1\n\n    # Step 2: Adaptive perturbation - flip items with high marginal contribution\n    for _ in range(2):  # Limit perturbation steps\n        marginal_contributions = []\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1:\n                marginal_contributions.append((value1_lst[i] + value2_lst[i], i))\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    marginal_contributions.append((value1_lst[i] + value2_lst[i], i))\n        if not marginal_contributions:\n            break\n        marginal_contributions.sort(reverse=True)\n        flip_candidate = marginal_contributions[0][1]\n        new_solution[flip_candidate] = 1 - new_solution[flip_candidate]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if np.sum(sol) < len(sol)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search: combine item swaps and flips with objective-aware perturbations\n    new_solution = base_solution.copy()\n    remaining_capacity = capacity - np.dot(new_solution, weight_lst)\n\n    # Step 1: Objective-aware item flipping (prioritize items with high marginal gains)\n    for _ in range(3):  # Perform 3 random flips\n        item_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[item_idx] == 1:\n            new_solution[item_idx] = 0\n        elif weight_lst[item_idx] <= remaining_capacity:\n            new_solution[item_idx] = 1\n            remaining_capacity -= weight_lst[item_idx]\n\n    # Step 2: Objective-aware item swaps (prioritize swaps that improve both objectives)\n    for _ in range(2):  # Perform 2 random swaps\n        in_idx = random.choice(np.where(new_solution == 1)[0])\n        out_idx = random.choice(np.where(new_solution == 0)[0])\n        if weight_lst[out_idx] - weight_lst[in_idx] <= remaining_capacity:\n            new_solution[in_idx], new_solution[out_idx] = 0, 1\n            remaining_capacity -= (weight_lst[out_idx] - weight_lst[in_idx])\n\n    # Step 3: Ensure feasibility (if violated, remove heaviest items)\n    while np.dot(new_solution, weight_lst) > capacity:\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) == 0:\n            break\n        to_remove = heavy_items[np.argmax(weight_lst[heavy_items])]\n        new_solution[to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3978591654474831,
            2.3151153326034546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if np.sum(sol) < len(sol)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search: combine item swaps and flips with objective-aware perturbations\n    new_solution = base_solution.copy()\n    remaining_capacity = capacity - np.dot(new_solution, weight_lst)\n\n    # Step 1: Objective-aware item flipping (prioritize items with high marginal gains)\n    for _ in range(3):  # Perform 3 random flips\n        item_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[item_idx] == 1:\n            new_solution[item_idx] = 0\n        elif weight_lst[item_idx] <= remaining_capacity:\n            new_solution[item_idx] = 1\n            remaining_capacity -= weight_lst[item_idx]\n\n    # Step 2: Objective-aware item swaps (prioritize swaps that improve both objectives)\n    for _ in range(2):  # Perform 2 random swaps\n        in_idx = random.choice(np.where(new_solution == 1)[0])\n        out_idx = random.choice(np.where(new_solution == 0)[0])\n        if weight_lst[out_idx] - weight_lst[in_idx] <= remaining_capacity:\n            new_solution[in_idx], new_solution[out_idx] = 0, 1\n            remaining_capacity -= (weight_lst[out_idx] - weight_lst[in_idx])\n\n    # Step 3: Ensure feasibility (if violated, remove heaviest items)\n    while np.dot(new_solution, weight_lst) > capacity:\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) == 0:\n            break\n        to_remove = heavy_items[np.argmax(weight_lst[heavy_items])]\n        new_solution[to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive bit-flipping with guided item swapping, prioritizing high-potential items based on their marginal contributions to both objectives while ensuring feasibility through dynamic capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that could be flipped (added or removed)\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item would stay feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item would stay feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        return base_solution.copy()  # No feasible moves\n\n    # Select a candidate with high marginal contribution\n    best_candidate = None\n    best_score = -np.inf\n\n    for item, op in candidate_items:\n        if op == 1:\n            # Adding item: calculate marginal contribution\n            marginal1 = value1_lst[item]\n            marginal2 = value2_lst[item]\n        else:\n            # Removing item: calculate marginal contribution (negative)\n            marginal1 = -value1_lst[item]\n            marginal2 = -value2_lst[item]\n\n        # Score based on normalized marginal contributions\n        score = (marginal1 / (np.max(value1_lst) + 1e-6)) + (marginal2 / (np.max(value2_lst) + 1e-6))\n\n        if score > best_score:\n            best_score = score\n            best_candidate = (item, op)\n\n    if best_candidate is None:\n        return base_solution.copy()\n\n    # Apply the best move\n    new_solution = base_solution.copy()\n    item, op = best_candidate\n    new_solution[item] = op if op == 1 else 0\n\n    # Optional: Apply a guided swap if possible\n    if np.random.rand() < 0.3:  # 30% chance to try a swap\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1 and i != item:\n                # Check if swapping with another item is feasible\n                new_weight = current_weight - weight_lst[item] + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8108556692208909,
            5.71488693356514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that could be flipped (added or removed)\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item would stay feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item would stay feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        return base_solution.copy()  # No feasible moves\n\n    # Select a candidate with high marginal contribution\n    best_candidate = None\n    best_score = -np.inf\n\n    for item, op in candidate_items:\n        if op == 1:\n            # Adding item: calculate marginal contribution\n            marginal1 = value1_lst[item]\n            marginal2 = value2_lst[item]\n        else:\n            # Removing item: calculate marginal contribution (negative)\n            marginal1 = -value1_lst[item]\n            marginal2 = -value2_lst[item]\n\n        # Score based on normalized marginal contributions\n        score = (marginal1 / (np.max(value1_lst) + 1e-6)) + (marginal2 / (np.max(value2_lst) + 1e-6))\n\n        if score > best_score:\n            best_score = score\n            best_candidate = (item, op)\n\n    if best_candidate is None:\n        return base_solution.copy()\n\n    # Apply the best move\n    new_solution = base_solution.copy()\n    item, op = best_candidate\n    new_solution[item] = op if op == 1 else 0\n\n    # Optional: Apply a guided swap if possible\n    if np.random.rand() < 0.3:  # 30% chance to try a swap\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1 and i != item:\n                # Check if swapping with another item is feasible\n                new_weight = current_weight - weight_lst[item] + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search operator combining randomized item swaps and a greedy improvement phase to generate a feasible neighbor solution, ensuring the total weight does not exceed the capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    def crowding_distance(sol_obj):\n        # Calculate crowding distance for the solution in the objective space\n        # This is a simplified version, actual crowding distance calculation would require sorting\n        # Here, we approximate by considering the distance to the origin\n        return np.sqrt(sol_obj[0]**2 + sol_obj[1]**2)\n\n    # Sort solutions by objective values and crowding distance\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1], crowding_distance(x[1])))\n\n    # Select the top 20% of solutions with the highest objective values and good diversity\n    top_k = max(1, len(archive) // 5)\n    selected_solutions = archive_sorted[:top_k]\n\n    # Randomly select one solution from the top candidates\n    selected_idx = np.random.randint(0, len(selected_solutions))\n    base_solution, base_obj = selected_solutions[selected_idx]\n\n    # Generate a neighbor solution\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: Randomized swaps followed by greedy improvement\n    for _ in range(5):  # Perform 5 random swaps\n        # Randomly select two distinct items\n        item1, item2 = np.random.choice(len(new_solution), size=2, replace=False)\n\n        # Try swapping the items\n        temp_solution = new_solution.copy()\n        temp_solution[item1], temp_solution[item2] = temp_solution[item2], temp_solution[item1]\n\n        # Check feasibility\n        temp_weight = np.sum(weight_lst * temp_solution)\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            current_weight = temp_weight\n\n    # Greedy improvement phase: Add or remove items to improve objectives\n    for _ in range(3):  # Perform 3 greedy steps\n        # Calculate marginal gains for each item\n        gains1 = value1_lst - (value1_lst * new_solution)\n        gains2 = value2_lst - (value2_lst * new_solution)\n\n        # Combine gains using a simple weighted sum (could be more sophisticated)\n        combined_gains = gains1 + gains2\n\n        # Find the best item to add or remove\n        best_idx = np.argmax(combined_gains)\n\n        # Try adding the best item if it's not already in\n        if new_solution[best_idx] == 0:\n            temp_solution = new_solution.copy()\n            temp_solution[best_idx] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # If adding didn't work, try removing the worst item\n        worst_idx = np.argmin(combined_gains)\n        if new_solution[worst_idx] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[worst_idx] = 0\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.2660149294329105,
            2.9214147329330444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    def crowding_distance(sol_obj):\n        # Calculate crowding distance for the solution in the objective space\n        # This is a simplified version, actual crowding distance calculation would require sorting\n        # Here, we approximate by considering the distance to the origin\n        return np.sqrt(sol_obj[0]**2 + sol_obj[1]**2)\n\n    # Sort solutions by objective values and crowding distance\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1], crowding_distance(x[1])))\n\n    # Select the top 20% of solutions with the highest objective values and good diversity\n    top_k = max(1, len(archive) // 5)\n    selected_solutions = archive_sorted[:top_k]\n\n    # Randomly select one solution from the top candidates\n    selected_idx = np.random.randint(0, len(selected_solutions))\n    base_solution, base_obj = selected_solutions[selected_idx]\n\n    # Generate a neighbor solution\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: Randomized swaps followed by greedy improvement\n    for _ in range(5):  # Perform 5 random swaps\n        # Randomly select two distinct items\n        item1, item2 = np.random.choice(len(new_solution), size=2, replace=False)\n\n        # Try swapping the items\n        temp_solution = new_solution.copy()\n        temp_solution[item1], temp_solution[item2] = temp_solution[item2], temp_solution[item1]\n\n        # Check feasibility\n        temp_weight = np.sum(weight_lst * temp_solution)\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            current_weight = temp_weight\n\n    # Greedy improvement phase: Add or remove items to improve objectives\n    for _ in range(3):  # Perform 3 greedy steps\n        # Calculate marginal gains for each item\n        gains1 = value1_lst - (value1_lst * new_solution)\n        gains2 = value2_lst - (value2_lst * new_solution)\n\n        # Combine gains using a simple weighted sum (could be more sophisticated)\n        combined_gains = gains1 + gains2\n\n        # Find the best item to add or remove\n        best_idx = np.argmax(combined_gains)\n\n        # Try adding the best item if it's not already in\n        if new_solution[best_idx] == 0:\n            temp_solution = new_solution.copy()\n            temp_solution[best_idx] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # If adding didn't work, try removing the worst item\n        worst_idx = np.argmin(combined_gains)\n        if new_solution[worst_idx] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[worst_idx] = 0\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search strategy that combines random perturbation with a greedy selection step to generate a feasible neighbor solution, ensuring both objectives are optimized while respecting the weight constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation followed by greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly flip a few items\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy improvement: add items that improve at least one objective\n    for idx in range(n_items):\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Check if adding this item improves at least one objective\n            if (value1_lst[idx] > 0) or (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.32692828716858097,
            4.215036034584045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation followed by greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly flip a few items\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy improvement: add items that improve at least one objective\n    for idx in range(n_items):\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Check if adding this item improves at least one objective\n            if (value1_lst[idx] > 0) or (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{A novel hybrid local search algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a dynamic neighborhood exploration strategy combining item swaps and value-based perturbations to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - mean_obj, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Dynamic neighborhood exploration\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Strategy 1: Randomly swap items with high value ratios\n    value_ratio = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-value_ratio)\n\n    for i in sorted_indices:\n        if base_solution[i] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                current_value1 -= value1_lst[i]\n                current_value2 -= value2_lst[i]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                current_value1 += value1_lst[i]\n                current_value2 += value2_lst[i]\n\n    # Strategy 2: Randomly flip a small subset of items (to escape local optima)\n    num_flips = min(3, num_items)\n    flip_indices = random.sample(range(num_items), num_flips)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.882573729056342,
            2.5183248817920685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - mean_obj, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Dynamic neighborhood exploration\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Strategy 1: Randomly swap items with high value ratios\n    value_ratio = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-value_ratio)\n\n    for i in sorted_indices:\n        if base_solution[i] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                current_value1 -= value1_lst[i]\n                current_value2 -= value2_lst[i]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                current_value1 += value1_lst[i]\n                current_value2 += value2_lst[i]\n\n    # Strategy 2: Randomly flip a small subset of items (to escape local optima)\n    num_flips = min(3, num_items)\n    flip_indices = random.sample(range(num_items), num_flips)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This heuristic selects a promising solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining random swaps and greedy additions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items (with probability 0.2 per item)\n    mask = np.random.rand(len(new_solution)) < 0.2\n    new_solution[mask] = 1 - new_solution[mask]\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            excess = total_weight - capacity\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) == 0:\n                break\n            remove_idx = np.random.choice(candidates)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Step 2: Greedily add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    for item in remaining_items:\n        if weight_lst[item] + total_weight <= capacity:\n            # Calculate potential improvement in both objectives\n            v1_improvement = value1_lst[item]\n            v2_improvement = value2_lst[item]\n            # If both objectives improve, add the item\n            if v1_improvement > 0 and v2_improvement > 0:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4666051262229011,
            5.078268498182297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items (with probability 0.2 per item)\n    mask = np.random.rand(len(new_solution)) < 0.2\n    new_solution[mask] = 1 - new_solution[mask]\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            excess = total_weight - capacity\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) == 0:\n                break\n            remove_idx = np.random.choice(candidates)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Step 2: Greedily add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    for item in remaining_items:\n        if weight_lst[item] + total_weight <= capacity:\n            # Calculate potential improvement in both objectives\n            v1_improvement = value1_lst[item]\n            v2_improvement = value2_lst[item]\n            # If both objectives improve, add the item\n            if v1_improvement > 0 and v2_improvement > 0:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive based on its potential for improvement, then applies a combination of item swaps and random flips to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the potential for improvement for each solution\n    potential_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        remaining_capacity = capacity - total_weight\n        # Score based on remaining capacity and objective values\n        score = (remaining_capacity / capacity) * (obj[0] + obj[1]) / (np.sum(value1_lst) + np.sum(value2_lst))\n        potential_scores.append(score)\n\n    # Select the solution with the highest potential score\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of item swaps and random flips\n    # First, perform item swaps between included and excluded items\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select an included item to remove\n        remove_idx = random.choice(included_items)\n        # Randomly select an excluded item to add\n        add_idx = random.choice(excluded_items)\n\n        # Check feasibility of the swap\n        current_weight = np.sum(weight_lst[base_solution == 1])\n        new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n        if new_weight <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Then, perform random flips with a probability based on remaining capacity\n    remaining_capacity = capacity - np.sum(weight_lst[new_solution == 1])\n    flip_prob = min(0.3, remaining_capacity / capacity)  # Higher probability if more capacity available\n\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # Try to remove the item\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n            else:\n                # Try to add the item\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3746366299807703,
            9.624086707830429
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the potential for improvement for each solution\n    potential_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        remaining_capacity = capacity - total_weight\n        # Score based on remaining capacity and objective values\n        score = (remaining_capacity / capacity) * (obj[0] + obj[1]) / (np.sum(value1_lst) + np.sum(value2_lst))\n        potential_scores.append(score)\n\n    # Select the solution with the highest potential score\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of item swaps and random flips\n    # First, perform item swaps between included and excluded items\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select an included item to remove\n        remove_idx = random.choice(included_items)\n        # Randomly select an excluded item to add\n        add_idx = random.choice(excluded_items)\n\n        # Check feasibility of the swap\n        current_weight = np.sum(weight_lst[base_solution == 1])\n        new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n        if new_weight <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Then, perform random flips with a probability based on remaining capacity\n    remaining_capacity = capacity - np.sum(weight_lst[new_solution == 1])\n    flip_prob = min(0.3, remaining_capacity / capacity)  # Higher probability if more capacity available\n\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # Try to remove the item\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n            else:\n                # Try to add the item\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{The heuristic selects a solution from the archive with the highest combined objective value, then applies a novel hybrid local search that combines random item swaps with a value-aware greedy selection to explore high-potential neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: random swaps with value-aware selection\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a number of items to swap (1-3)\n    num_swaps = random.randint(1, min(3, n_items))\n\n    for _ in range(num_swaps):\n        # Find items that can be swapped (either in or out)\n        candidates = []\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                # Consider removing this item\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    candidates.append((i, -1))  # -1 indicates removal\n            else:\n                # Consider adding this item\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    candidates.append((i, 1))  # 1 indicates addition\n\n        if not candidates:\n            break  # No feasible swaps possible\n\n        # Select the candidate with the highest value improvement\n        best_candidate = max(candidates, key=lambda x: (value1_lst[x[0]] + value2_lst[x[0]]) if x[1] == 1 else -(value1_lst[x[0]] + value2_lst[x[0]]))\n\n        # Perform the swap\n        item_idx, change = best_candidate\n        new_solution[item_idx] = 1 if change == 1 else 0\n        current_weight += change * weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.25756597201765075,
            7.681185692548752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: random swaps with value-aware selection\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a number of items to swap (1-3)\n    num_swaps = random.randint(1, min(3, n_items))\n\n    for _ in range(num_swaps):\n        # Find items that can be swapped (either in or out)\n        candidates = []\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                # Consider removing this item\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    candidates.append((i, -1))  # -1 indicates removal\n            else:\n                # Consider adding this item\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    candidates.append((i, 1))  # 1 indicates addition\n\n        if not candidates:\n            break  # No feasible swaps possible\n\n        # Select the candidate with the highest value improvement\n        best_candidate = max(candidates, key=lambda x: (value1_lst[x[0]] + value2_lst[x[0]]) if x[1] == 1 else -(value1_lst[x[0]] + value2_lst[x[0]]))\n\n        # Perform the swap\n        item_idx, change = best_candidate\n        new_solution[item_idx] = 1 if change == 1 else 0\n        current_weight += change * weight_lst[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.random.choice(np.where(scores == scores.max())[0])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (combination of flip and swap)\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Flip operator: flip a random item if it improves at least one objective\n    flip_candidate = np.random.choice(n_items)\n    if new_solution[flip_candidate] == 1:\n        new_solution[flip_candidate] = 0\n    else:\n        if np.dot(new_solution, weight_lst) + weight_lst[flip_candidate] <= capacity:\n            new_solution[flip_candidate] = 1\n\n    # Swap operator: swap two random items if it improves both objectives\n    swap_candidates = np.random.choice(n_items, 2, replace=False)\n    i, j = swap_candidates\n    if new_solution[i] != new_solution[j]:\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Check feasibility\n        if np.dot(new_solution, weight_lst) > capacity:\n            new_solution[j] = new_solution[i]\n            new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.3440512111428777,
            3.5115395188331604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.random.choice(np.where(scores == scores.max())[0])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (combination of flip and swap)\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Flip operator: flip a random item if it improves at least one objective\n    flip_candidate = np.random.choice(n_items)\n    if new_solution[flip_candidate] == 1:\n        new_solution[flip_candidate] = 0\n    else:\n        if np.dot(new_solution, weight_lst) + weight_lst[flip_candidate] <= capacity:\n            new_solution[flip_candidate] = 1\n\n    # Swap operator: swap two random items if it improves both objectives\n    swap_candidates = np.random.choice(n_items, 2, replace=False)\n    i, j = swap_candidates\n    if new_solution[i] != new_solution[j]:\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Check feasibility\n        if np.dot(new_solution, weight_lst) > capacity:\n            new_solution[j] = new_solution[i]\n            new_solution[i] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{The algorithm selects a promising solution from the archive, identifies a critical subset of items to flip (based on a heuristic combining both objectives), and performs a guided local search by flipping items in a way that balances both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (randomly weighted by objective dominance)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify critical items (highest value/weight ratio for both objectives)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Heuristic: Flip items with highest combined marginal gain\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Calculate marginal gains for included items (removing)\n        marginal_gains_removal = []\n        for idx in included_items:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains_removal.append((gain1 + gain2, idx))\n\n        # Calculate marginal gains for excluded items (adding)\n        marginal_gains_addition = []\n        for idx in excluded_items:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains_addition.append((gain1 + gain2, idx))\n\n        # Select best flip candidate\n        if marginal_gains_removal or marginal_gains_addition:\n            candidates = []\n            if marginal_gains_removal:\n                candidates.extend(marginal_gains_removal)\n            if marginal_gains_addition:\n                candidates.extend(marginal_gains_addition)\n\n            # Sort by combined gain and select top candidate\n            candidates.sort(reverse=True, key=lambda x: x[0])\n            best_gain, best_idx = candidates[0]\n\n            # Perform the flip\n            if best_idx in included_items:\n                new_solution[best_idx] = 0\n            else:\n                new_solution[best_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8857221242484796,
            1.647358387708664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (randomly weighted by objective dominance)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify critical items (highest value/weight ratio for both objectives)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Heuristic: Flip items with highest combined marginal gain\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Calculate marginal gains for included items (removing)\n        marginal_gains_removal = []\n        for idx in included_items:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains_removal.append((gain1 + gain2, idx))\n\n        # Calculate marginal gains for excluded items (adding)\n        marginal_gains_addition = []\n        for idx in excluded_items:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains_addition.append((gain1 + gain2, idx))\n\n        # Select best flip candidate\n        if marginal_gains_removal or marginal_gains_addition:\n            candidates = []\n            if marginal_gains_removal:\n                candidates.extend(marginal_gains_removal)\n            if marginal_gains_addition:\n                candidates.extend(marginal_gains_addition)\n\n            # Sort by combined gain and select top candidate\n            candidates.sort(reverse=True, key=lambda x: x[0])\n            best_gain, best_idx = candidates[0]\n\n            # Perform the flip\n            if best_idx in included_items:\n                new_solution[best_idx] = 0\n            else:\n                new_solution[best_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search combining random perturbations and adaptive swaps to generate a feasible neighbor solution while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(v1 + v2) / (w + 1e-6) for _, (v1, v2), w in [(sol, obj, np.sum(sol * weight_lst)) for sol, obj in archive]],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Randomly flip a small subset of items\n    num_flips = max(1, int(0.1 * len(weight_lst)))\n    flip_indices = random.sample(range(len(weight_lst)), num_flips)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Adaptive swap of items based on value/weight ratio\n    current_weight = np.sum(new_solution * weight_lst)\n    for _ in range(3):\n        if current_weight >= capacity:\n            break\n        # Calculate value/weight ratios\n        ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        # Find best item to add\n        best_add = np.argmax((new_solution == 0) * ratios)\n        if new_solution[best_add] == 0 and current_weight + weight_lst[best_add] <= capacity:\n            new_solution[best_add] = 1\n            current_weight += weight_lst[best_add]\n        else:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.42553621333381375,
            3.1204403042793274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(v1 + v2) / (w + 1e-6) for _, (v1, v2), w in [(sol, obj, np.sum(sol * weight_lst)) for sol, obj in archive]],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Randomly flip a small subset of items\n    num_flips = max(1, int(0.1 * len(weight_lst)))\n    flip_indices = random.sample(range(len(weight_lst)), num_flips)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Adaptive swap of items based on value/weight ratio\n    current_weight = np.sum(new_solution * weight_lst)\n    for _ in range(3):\n        if current_weight >= capacity:\n            break\n        # Calculate value/weight ratios\n        ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        # Find best item to add\n        best_add = np.argmax((new_solution == 0) * ratios)\n        if new_solution[best_add] == 0 and current_weight + weight_lst[best_add] <= capacity:\n            new_solution[best_add] = 1\n            current_weight += weight_lst[best_add]\n        else:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{A novel hybrid local search heuristic that combines adaptive item swapping with dynamic objective-weighted perturbations to intelligently explore the solution space while ensuring feasibility, prioritizing solutions with high potential for improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Determine objective weights based on the solution's position in the archive\n    obj_weight1 = 0.5 + 0.5 * (current_value1 / (current_value1 + current_value2 + 1e-6))\n    obj_weight2 = 1.0 - obj_weight1\n\n    # Generate candidate items for swap/perturbation\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search operator: swap or perturb with objective-weighted probability\n    new_solution = base_solution.copy()\n    if random.random() < 0.7:  # Higher probability for swap\n        # Adaptive swap: prioritize items with high marginal gain\n        marginal_gains = (obj_weight1 * value1_lst + obj_weight2 * value2_lst) / (weight_lst + 1e-6)\n        sorted_items = np.argsort(marginal_gains)[::-1]\n\n        for item in sorted_items:\n            if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n            elif base_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n    else:\n        # Dynamic perturbation: flip a random subset of items\n        num_flips = min(3, len(candidate_items))\n        flip_indices = np.random.choice(candidate_items, num_flips, replace=False)\n        for idx in flip_indices:\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8456116588152692,
            1.0932813882827759
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Determine objective weights based on the solution's position in the archive\n    obj_weight1 = 0.5 + 0.5 * (current_value1 / (current_value1 + current_value2 + 1e-6))\n    obj_weight2 = 1.0 - obj_weight1\n\n    # Generate candidate items for swap/perturbation\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search operator: swap or perturb with objective-weighted probability\n    new_solution = base_solution.copy()\n    if random.random() < 0.7:  # Higher probability for swap\n        # Adaptive swap: prioritize items with high marginal gain\n        marginal_gains = (obj_weight1 * value1_lst + obj_weight2 * value2_lst) / (weight_lst + 1e-6)\n        sorted_items = np.argsort(marginal_gains)[::-1]\n\n        for item in sorted_items:\n            if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n            elif base_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n    else:\n        # Dynamic perturbation: flip a random subset of items\n        num_flips = min(3, len(candidate_items))\n        flip_indices = np.random.choice(candidate_items, num_flips, replace=False)\n        for idx in flip_indices:\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution (here, we select a random one for simplicity)\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Identify items that can be flipped (added or removed) without violating capacity\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # If item is in the solution, check if removing it keeps it feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # Mark for removal\n        else:\n            # If item is not in the solution, check if adding it keeps it feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # Mark for addition\n\n    if not candidates:\n        return base_solution\n\n    # Step 3: Randomly select a candidate to flip\n    flip_idx, flip_action = candidates[np.random.randint(0, len(candidates))]\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 if flip_action == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8865971289693362,
            1.3412191569805145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution (here, we select a random one for simplicity)\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Identify items that can be flipped (added or removed) without violating capacity\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # If item is in the solution, check if removing it keeps it feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # Mark for removal\n        else:\n            # If item is not in the solution, check if adding it keeps it feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # Mark for addition\n\n    if not candidates:\n        return base_solution\n\n    # Step 3: Randomly select a candidate to flip\n    flip_idx, flip_action = candidates[np.random.randint(0, len(candidates))]\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 if flip_action == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    promising_indices = np.argsort(scores)[-max(1, len(archive) // 3):]  # Select top 1/3 of solutions\n\n    # Step 2: Randomly select a promising solution\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Strategy 1: Randomly flip a subset of items (with a bias towards improving both objectives)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Check feasibility if adding the item\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Strategy 2: Apply a greedy improvement step for one objective\n    if np.random.rand() < 0.5:  # 50% chance to apply greedy step\n        objective_to_improve = np.random.choice([0, 1])  # 0 for value1, 1 for value2\n        value_lst = value1_lst if objective_to_improve == 0 else value2_lst\n        current_value = archive[selected_idx][1][objective_to_improve]\n        best_value = current_value\n        best_idx = -1\n\n        for i in range(n_items):\n            if base_solution[i] == 1:\n                # Check if removing improves the objective\n                new_value = current_value - value_lst[i]\n                if new_value > best_value:\n                    best_value = new_value\n                    best_idx = i\n            else:\n                # Check if adding (if feasible) improves the objective\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_value = current_value + value_lst[i]\n                    if new_value > best_value:\n                        best_value = new_value\n                        best_idx = i\n\n        if best_idx != -1:\n            new_solution[best_idx] = 1 - new_solution[best_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3268104661918774,
            6.425060868263245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    promising_indices = np.argsort(scores)[-max(1, len(archive) // 3):]  # Select top 1/3 of solutions\n\n    # Step 2: Randomly select a promising solution\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Strategy 1: Randomly flip a subset of items (with a bias towards improving both objectives)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Check feasibility if adding the item\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Strategy 2: Apply a greedy improvement step for one objective\n    if np.random.rand() < 0.5:  # 50% chance to apply greedy step\n        objective_to_improve = np.random.choice([0, 1])  # 0 for value1, 1 for value2\n        value_lst = value1_lst if objective_to_improve == 0 else value2_lst\n        current_value = archive[selected_idx][1][objective_to_improve]\n        best_value = current_value\n        best_idx = -1\n\n        for i in range(n_items):\n            if base_solution[i] == 1:\n                # Check if removing improves the objective\n                new_value = current_value - value_lst[i]\n                if new_value > best_value:\n                    best_value = new_value\n                    best_idx = i\n            else:\n                # Check if adding (if feasible) improves the objective\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_value = current_value + value_lst[i]\n                    if new_value > best_value:\n                        best_value = new_value\n                        best_idx = i\n\n        if best_idx != -1:\n            new_solution[best_idx] = 1 - new_solution[best_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{A novel heuristic local search operator that intelligently selects a solution from the archive, identifies critical items with high marginal contributions, and performs a hybrid swap and shift operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value, low weight)\n    critical_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Marginal contribution (value per unit weight)\n            marginal1 = value1_lst[i] / weight_lst[i]\n            marginal2 = value2_lst[i] / weight_lst[i]\n            critical_items.append((i, marginal1 + marginal2))\n\n    # Sort critical items by combined marginal contribution\n    critical_items.sort(key=lambda x: -x[1])\n\n    # Perform hybrid operation: swap top critical item with a non-critical item\n    if len(critical_items) > 0 and np.sum(base_solution) > 1:\n        # Select top critical item\n        critical_idx = critical_items[0][0]\n\n        # Find a non-critical item to swap with\n        non_critical_items = [i for i in range(len(base_solution)) if base_solution[i] == 0 and weight_lst[i] <= (capacity - total_weight + weight_lst[critical_idx])]\n\n        if non_critical_items:\n            # Select a random non-critical item\n            swap_idx = random.choice(non_critical_items)\n\n            # Perform swap\n            new_solution[critical_idx] = 0\n            new_solution[swap_idx] = 1\n\n            # Ensure feasibility\n            new_total_weight = total_weight - weight_lst[critical_idx] + weight_lst[swap_idx]\n            if new_total_weight > capacity:\n                # If swap violates capacity, revert\n                new_solution[critical_idx] = 1\n                new_solution[swap_idx] = 0\n\n    # If no swap was made, perform a shift operation\n    if np.array_equal(new_solution, base_solution):\n        # Find items to shift (randomly select a subset of included items)\n        included_items = [i for i in range(len(base_solution)) if base_solution[i] == 1]\n        if len(included_items) > 1:\n            # Select a random subset of included items to potentially remove\n            shift_size = random.randint(1, min(3, len(included_items)))\n            shift_indices = random.sample(included_items, shift_size)\n\n            # Remove selected items\n            for idx in shift_indices:\n                new_solution[idx] = 0\n\n            # Add new items until capacity is reached\n            available_items = [i for i in range(len(base_solution)) if base_solution[i] == 0]\n            random.shuffle(available_items)\n\n            for idx in available_items:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8277513543360437,
            6.881996065378189
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value, low weight)\n    critical_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Marginal contribution (value per unit weight)\n            marginal1 = value1_lst[i] / weight_lst[i]\n            marginal2 = value2_lst[i] / weight_lst[i]\n            critical_items.append((i, marginal1 + marginal2))\n\n    # Sort critical items by combined marginal contribution\n    critical_items.sort(key=lambda x: -x[1])\n\n    # Perform hybrid operation: swap top critical item with a non-critical item\n    if len(critical_items) > 0 and np.sum(base_solution) > 1:\n        # Select top critical item\n        critical_idx = critical_items[0][0]\n\n        # Find a non-critical item to swap with\n        non_critical_items = [i for i in range(len(base_solution)) if base_solution[i] == 0 and weight_lst[i] <= (capacity - total_weight + weight_lst[critical_idx])]\n\n        if non_critical_items:\n            # Select a random non-critical item\n            swap_idx = random.choice(non_critical_items)\n\n            # Perform swap\n            new_solution[critical_idx] = 0\n            new_solution[swap_idx] = 1\n\n            # Ensure feasibility\n            new_total_weight = total_weight - weight_lst[critical_idx] + weight_lst[swap_idx]\n            if new_total_weight > capacity:\n                # If swap violates capacity, revert\n                new_solution[critical_idx] = 1\n                new_solution[swap_idx] = 0\n\n    # If no swap was made, perform a shift operation\n    if np.array_equal(new_solution, base_solution):\n        # Find items to shift (randomly select a subset of included items)\n        included_items = [i for i in range(len(base_solution)) if base_solution[i] == 1]\n        if len(included_items) > 1:\n            # Select a random subset of included items to potentially remove\n            shift_size = random.randint(1, min(3, len(included_items)))\n            shift_indices = random.sample(included_items, shift_size)\n\n            # Remove selected items\n            for idx in shift_indices:\n                new_solution[idx] = 0\n\n            # Add new items until capacity is reached\n            available_items = [i for i in range(len(base_solution)) if base_solution[i] == 0]\n            random.shuffle(available_items)\n\n            for idx in available_items:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: flip a random subset of items with high marginal utility\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    # Calculate marginal utility for each item\n    marginal_utils = []\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                marginal_utils.append((idx, -weight_lst[idx], -value1_lst[idx], -value2_lst[idx]))\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                marginal_utils.append((idx, weight_lst[idx], value1_lst[idx], value2_lst[idx]))\n\n    if marginal_utils:\n        # Sort by combined marginal utility (weighted sum of both objectives)\n        marginal_utils.sort(key=lambda x: (0.5 * x[2] + 0.5 * x[3]) / (x[1] + 1e-10), reverse=True)\n        # Flip top 20% of items with highest marginal utility\n        flip_count = max(1, int(0.2 * len(marginal_utils)))\n        for idx, _, _, _ in marginal_utils[:flip_count]:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.794333418536366,
            1.7994048297405243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: flip a random subset of items with high marginal utility\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    # Calculate marginal utility for each item\n    marginal_utils = []\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                marginal_utils.append((idx, -weight_lst[idx], -value1_lst[idx], -value2_lst[idx]))\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                marginal_utils.append((idx, weight_lst[idx], value1_lst[idx], value2_lst[idx]))\n\n    if marginal_utils:\n        # Sort by combined marginal utility (weighted sum of both objectives)\n        marginal_utils.sort(key=lambda x: (0.5 * x[2] + 0.5 * x[3]) / (x[1] + 1e-10), reverse=True)\n        # Flip top 20% of items with highest marginal utility\n        flip_count = max(1, int(0.2 * len(marginal_utils)))\n        for idx, _, _, _ in marginal_utils[:flip_count]:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Find items not in the solution\n    not_included = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: swap or add items with high marginal gain\n    if len(not_included) > 0:\n        # Calculate marginal gains for adding items\n        marginal_gains = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(marginal_gains[not_included])[::-1]\n\n        for idx in sorted_indices:\n            item = not_included[idx]\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n\n    # If no addition possible, try removing low marginal gain items\n    if np.array_equal(new_solution, base_solution):\n        included = np.where(base_solution == 1)[0]\n        if len(included) > 0:\n            marginal_gains = (value1_lst + value2_lst) / weight_lst\n            sorted_indices = np.argsort(marginal_gains[included])\n\n            for idx in sorted_indices:\n                item = included[idx]\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9003323419187462,
            2.3704795241355896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Find items not in the solution\n    not_included = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: swap or add items with high marginal gain\n    if len(not_included) > 0:\n        # Calculate marginal gains for adding items\n        marginal_gains = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(marginal_gains[not_included])[::-1]\n\n        for idx in sorted_indices:\n            item = not_included[idx]\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n\n    # If no addition possible, try removing low marginal gain items\n    if np.array_equal(new_solution, base_solution):\n        included = np.where(base_solution == 1)[0]\n        if len(included) > 0:\n            marginal_gains = (value1_lst + value2_lst) / weight_lst\n            sorted_indices = np.argsort(marginal_gains[included])\n\n            for idx in sorted_indices:\n                item = included[idx]\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement by prioritizing solutions with higher crowding distances or those near the Pareto front, then applies a hybrid local search strategy combining item swaps, flips, and guided random perturbations to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Intelligently select a promising solution from the archive\n    # Select the solution with the highest crowding distance (or random if all distances are zero)\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [0] * len(solutions)\n        sorted_solutions = sorted(solutions, key=lambda x: (x[1][0], x[1][1]))\n        distances = [0] * len(solutions)\n        for obj in [0, 1]:\n            sorted_solutions.sort(key=lambda x: x[1][obj])\n            min_obj = sorted_solutions[0][1][obj]\n            max_obj = sorted_solutions[-1][1][obj]\n            if max_obj == min_obj:\n                continue\n            distances[0] = distances[-1] = float('inf')\n            for i in range(1, len(solutions) - 1):\n                distances[i] += (sorted_solutions[i+1][1][obj] - sorted_solutions[i-1][1][obj]) / (max_obj - min_obj)\n        return distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    max_distance = max(crowding_distances)\n    candidates = [i for i, dist in enumerate(crowding_distances) if dist == max_distance]\n    if not candidates:\n        candidates = list(range(len(archive)))\n    selected_idx = random.choice(candidates)\n    base_solution, _ = archive[selected_idx]\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    items = np.arange(len(new_solution))\n\n    # Strategy 1: Randomly flip items with a bias towards improving both objectives\n    for _ in range(3):\n        item = random.choice(items)\n        if new_solution[item] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = new_weight\n\n    # Strategy 2: Guided perturbation - swap items with high potential for improvement\n    for _ in range(2):\n        # Identify items that could improve the solution\n        potential_items = []\n        for i in items:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                potential_items.append(i)\n        if potential_items:\n            item = random.choice(potential_items)\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Strategy 3: Randomly flip a small subset of items for diversity\n    flip_indices = random.sample(list(items), min(3, len(items)))\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.36558124135496195,
            2.2015517950057983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Intelligently select a promising solution from the archive\n    # Select the solution with the highest crowding distance (or random if all distances are zero)\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [0] * len(solutions)\n        sorted_solutions = sorted(solutions, key=lambda x: (x[1][0], x[1][1]))\n        distances = [0] * len(solutions)\n        for obj in [0, 1]:\n            sorted_solutions.sort(key=lambda x: x[1][obj])\n            min_obj = sorted_solutions[0][1][obj]\n            max_obj = sorted_solutions[-1][1][obj]\n            if max_obj == min_obj:\n                continue\n            distances[0] = distances[-1] = float('inf')\n            for i in range(1, len(solutions) - 1):\n                distances[i] += (sorted_solutions[i+1][1][obj] - sorted_solutions[i-1][1][obj]) / (max_obj - min_obj)\n        return distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    max_distance = max(crowding_distances)\n    candidates = [i for i, dist in enumerate(crowding_distances) if dist == max_distance]\n    if not candidates:\n        candidates = list(range(len(archive)))\n    selected_idx = random.choice(candidates)\n    base_solution, _ = archive[selected_idx]\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    items = np.arange(len(new_solution))\n\n    # Strategy 1: Randomly flip items with a bias towards improving both objectives\n    for _ in range(3):\n        item = random.choice(items)\n        if new_solution[item] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = new_weight\n\n    # Strategy 2: Guided perturbation - swap items with high potential for improvement\n    for _ in range(2):\n        # Identify items that could improve the solution\n        potential_items = []\n        for i in items:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                potential_items.append(i)\n        if potential_items:\n            item = random.choice(potential_items)\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Strategy 3: Randomly flip a small subset of items for diversity\n    flip_indices = random.sample(list(items), min(3, len(items)))\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on a hybrid of diversity and objective improvement potential, then applies a novel local search operator that combines randomized bit flips with a greedy selection of items based on their marginal value-to-weight ratios across both objectives, ensuring feasibility and potentially yielding high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by flipping bits with a hybrid strategy\n    new_solution = base_solution.copy()\n    items = np.arange(len(weight_lst))\n    np.random.shuffle(items)\n\n    for i in items:\n        if new_solution[i] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                # Greedy selection based on marginal value-to-weight ratio\n                marginal_ratio1 = value1_lst[i] / weight_lst[i]\n                marginal_ratio2 = value2_lst[i] / weight_lst[i]\n                if random.random() < 0.5:  # Randomly prioritize one objective\n                    if marginal_ratio1 > marginal_ratio2:\n                        new_solution[i] = 1\n                        current_weight = new_weight\n                else:\n                    if marginal_ratio2 > marginal_ratio1:\n                        new_solution[i] = 1\n                        current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.6552876544928742,
            2.075248599052429
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by flipping bits with a hybrid strategy\n    new_solution = base_solution.copy()\n    items = np.arange(len(weight_lst))\n    np.random.shuffle(items)\n\n    for i in items:\n        if new_solution[i] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                # Greedy selection based on marginal value-to-weight ratio\n                marginal_ratio1 = value1_lst[i] / weight_lst[i]\n                marginal_ratio2 = value2_lst[i] / weight_lst[i]\n                if random.random() < 0.5:  # Randomly prioritize one objective\n                    if marginal_ratio1 > marginal_ratio2:\n                        new_solution[i] = 1\n                        current_weight = new_weight\n                else:\n                    if marginal_ratio2 > marginal_ratio1:\n                        new_solution[i] = 1\n                        current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a combination of objective diversity and local improvement potential, then applies a hybrid local search operator that combines item swaps and value-based perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with high potential for improvement\n    base_solution, base_objective = random.choices(\n        archive,\n        weights=[(1 / (1 + np.linalg.norm(obj))) for _, obj in archive],  # Prefer solutions with lower norm\n        k=1\n    )[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine item swaps and value-based perturbations\n    # Step 1: Randomly select a subset of items to consider for swapping\n    n_items = len(new_solution)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) < 2:\n        swap_candidates = np.arange(n_items)\n\n    # Step 2: Perform a value-weighted swap\n    if len(swap_candidates) > 1:\n        i, j = random.sample(list(swap_candidates), 2)\n        # Swap if it maintains feasibility\n        current_weight = np.sum(new_solution * weight_lst)\n        if (new_solution[i] == 1 and new_solution[j] == 0 and\n            current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Value-based perturbation - flip items with high marginal contribution\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Try removing item if it's not critical\n                if np.sum(new_solution * weight_lst) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Try adding item if it fits\n                if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                    # Check if adding this item improves at least one objective\n                    current_v1 = np.sum(new_solution * value1_lst)\n                    current_v2 = np.sum(new_solution * value2_lst)\n                    new_v1 = current_v1 + value1_lst[i]\n                    new_v2 = current_v2 + value2_lst[i]\n                    if (new_v1 > current_v1) or (new_v2 > current_v2):\n                        new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.442810476976069,
            7.353046506643295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with high potential for improvement\n    base_solution, base_objective = random.choices(\n        archive,\n        weights=[(1 / (1 + np.linalg.norm(obj))) for _, obj in archive],  # Prefer solutions with lower norm\n        k=1\n    )[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine item swaps and value-based perturbations\n    # Step 1: Randomly select a subset of items to consider for swapping\n    n_items = len(new_solution)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) < 2:\n        swap_candidates = np.arange(n_items)\n\n    # Step 2: Perform a value-weighted swap\n    if len(swap_candidates) > 1:\n        i, j = random.sample(list(swap_candidates), 2)\n        # Swap if it maintains feasibility\n        current_weight = np.sum(new_solution * weight_lst)\n        if (new_solution[i] == 1 and new_solution[j] == 0 and\n            current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Value-based perturbation - flip items with high marginal contribution\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Try removing item if it's not critical\n                if np.sum(new_solution * weight_lst) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Try adding item if it fits\n                if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                    # Check if adding this item improves at least one objective\n                    current_v1 = np.sum(new_solution * value1_lst)\n                    current_v2 = np.sum(new_solution * value2_lst)\n                    new_v1 = current_v1 + value1_lst[i]\n                    new_v2 = current_v2 + value2_lst[i]\n                    if (new_v1 > current_v1) or (new_v2 > current_v2):\n                        new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines item swaps and random perturbations to explore the solution space while ensuring feasibility and diversity in the neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = np.array([sol_obj[1] for sol_obj in archive])\n    objective_sums = archive_objectives.sum(axis=1)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Randomly flip a small subset of items (exploration)\n    num_flips = min(3, len(new_solution))\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Step 2: Greedy improvement (exploitation)\n    # Try to add items that improve both objectives\n    for idx in np.where(new_solution == 0)[0]:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            current_value1 += value1_lst[idx]\n            current_value2 += value2_lst[idx]\n\n    # Step 3: Remove items that don't contribute to both objectives\n    for idx in np.where(new_solution == 1)[0]:\n        if value1_lst[idx] == 0 or value2_lst[idx] == 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            current_value1 -= value1_lst[idx]\n            current_value2 -= value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.33556286651503114,
            5.205714106559753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = np.array([sol_obj[1] for sol_obj in archive])\n    objective_sums = archive_objectives.sum(axis=1)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Step 1: Randomly flip a small subset of items (exploration)\n    num_flips = min(3, len(new_solution))\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Step 2: Greedy improvement (exploitation)\n    # Try to add items that improve both objectives\n    for idx in np.where(new_solution == 0)[0]:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            current_value1 += value1_lst[idx]\n            current_value2 += value2_lst[idx]\n\n    # Step 3: Remove items that don't contribute to both objectives\n    for idx in np.where(new_solution == 1)[0]:\n        if value1_lst[idx] == 0 or value2_lst[idx] == 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            current_value1 -= value1_lst[idx]\n            current_value2 -= value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a novel hybrid local search strategy that combines adaptive item swapping and probabilistic neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential improvement scores for each solution\n    scores = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        potential_add = np.sum((1 - sol) * weight_lst * (value1_lst + value2_lst) / (weight_lst + 1e-6))\n        potential_remove = np.sum(sol * weight_lst * (value1_lst + value2_lst) / (weight_lst + 1e-6))\n        score = potential_add - potential_remove\n        scores.append(score)\n\n    # Normalize scores to get probabilities\n    scores = np.array(scores)\n    scores = scores - np.min(scores) + 1e-6  # Ensure positive scores\n    probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Adaptive item swapping\n    for _ in range(3):  # Number of swaps\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) < 2:\n            break\n        i, j = np.random.choice(candidates, size=2, replace=False)\n        if weight_lst[j] - weight_lst[i] + current_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Probabilistic neighborhood exploration\n    for _ in range(5):  # Number of perturbations\n        if random.random() < 0.5:  # Add item\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                i = np.random.choice(candidates)\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n        else:  # Remove item\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                i = np.random.choice(candidates)\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.41508018992646767,
            6.969737470149994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential improvement scores for each solution\n    scores = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        potential_add = np.sum((1 - sol) * weight_lst * (value1_lst + value2_lst) / (weight_lst + 1e-6))\n        potential_remove = np.sum(sol * weight_lst * (value1_lst + value2_lst) / (weight_lst + 1e-6))\n        score = potential_add - potential_remove\n        scores.append(score)\n\n    # Normalize scores to get probabilities\n    scores = np.array(scores)\n    scores = scores - np.min(scores) + 1e-6  # Ensure positive scores\n    probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Adaptive item swapping\n    for _ in range(3):  # Number of swaps\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) < 2:\n            break\n        i, j = np.random.choice(candidates, size=2, replace=False)\n        if weight_lst[j] - weight_lst[i] + current_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Probabilistic neighborhood exploration\n    for _ in range(5):  # Number of perturbations\n        if random.random() < 0.5:  # Add item\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                i = np.random.choice(candidates)\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n        else:  # Remove item\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                i = np.random.choice(candidates)\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of random flips and value-based flips\n    # Step 1: Randomly flip a subset of items\n    flip_mask = np.random.rand(len(new_solution)) < 0.2\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest marginal value (value/weight) until feasible\n        while current_weight > capacity:\n            marginal_values = (value1_lst + value2_lst) / weight_lst\n            marginal_values[new_solution == 0] = np.inf  # Only consider included items\n            worst_item = np.argmin(marginal_values)\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    # Step 3: Value-based flip: add items with highest marginal value\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        marginal_values = (value1_lst + value2_lst) / weight_lst\n        marginal_values[new_solution == 1] = -np.inf  # Only consider excluded items\n        candidate_items = np.argsort(marginal_values)[-10:]  # Top 10 candidates\n        np.random.shuffle(candidate_items)\n        for item in candidate_items:\n            if weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n                if remaining_capacity <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4090218543808717,
            2.7158132195472717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of random flips and value-based flips\n    # Step 1: Randomly flip a subset of items\n    flip_mask = np.random.rand(len(new_solution)) < 0.2\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest marginal value (value/weight) until feasible\n        while current_weight > capacity:\n            marginal_values = (value1_lst + value2_lst) / weight_lst\n            marginal_values[new_solution == 0] = np.inf  # Only consider included items\n            worst_item = np.argmin(marginal_values)\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    # Step 3: Value-based flip: add items with highest marginal value\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        marginal_values = (value1_lst + value2_lst) / weight_lst\n        marginal_values[new_solution == 1] = -np.inf  # Only consider excluded items\n        candidate_items = np.argsort(marginal_values)[-10:]  # Top 10 candidates\n        np.random.shuffle(candidate_items)\n        for item in candidate_items:\n            if weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n                if remaining_capacity <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a novel local search operator that intelligently flips a subset of items based on their marginal contributions to both objectives, ensuring feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    best_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (consider both inclusion and exclusion)\n    flip_candidates = np.where(base_solution == 1)[0]\n    if len(flip_candidates) == 0:\n        flip_candidates = np.where(base_solution == 0)[0]\n\n    # Select a subset of items to flip based on marginal contributions\n    num_flips = min(3, len(flip_candidates))\n    flip_indices = np.random.choice(flip_candidates, size=num_flips, replace=False, p=combined_marginal[flip_candidates]/np.sum(combined_marginal[flip_candidates]))\n\n    new_solution = base_solution.copy()\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6958635243448741,
            2.331139922142029
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    best_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (consider both inclusion and exclusion)\n    flip_candidates = np.where(base_solution == 1)[0]\n    if len(flip_candidates) == 0:\n        flip_candidates = np.where(base_solution == 0)[0]\n\n    # Select a subset of items to flip based on marginal contributions\n    num_flips = min(3, len(flip_candidates))\n    flip_indices = np.random.choice(flip_candidates, size=num_flips, replace=False, p=combined_marginal[flip_candidates]/np.sum(combined_marginal[flip_candidates]))\n\n    new_solution = base_solution.copy()\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive, applies a hybrid local search strategy that combines random flipping of item selections with a greedy improvement step to ensure feasibility and multi-objective optimization, and returns the improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligently select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_v1 = np.sum(value1_lst * base_solution)\n    current_v2 = np.sum(value2_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip followed by greedy improvement\n    # Step 1: Randomly flip a subset of items\n    flip_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Greedy improvement to maximize both objectives\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        improved = False\n        for idx in range(len(weight_lst)):\n            if new_solution[idx] == 0:\n                if current_weight + weight_lst[idx] <= capacity:\n                    # Evaluate potential improvement\n                    new_v1 = current_v1 + value1_lst[idx]\n                    new_v2 = current_v2 + value2_lst[idx]\n                    # Check if adding this item improves at least one objective\n                    if (new_v1 > current_v1 and new_v2 >= current_v2) or (new_v1 >= current_v1 and new_v2 > current_v2):\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n                        current_v1 = new_v1\n                        current_v2 = new_v2\n                        improved = True\n                        break\n            else:\n                # Evaluate potential improvement by removing\n                new_v1 = current_v1 - value1_lst[idx]\n                new_v2 = current_v2 - value2_lst[idx]\n                # Check if removing this item does not worsen both objectives\n                if (new_v1 >= current_v1 and new_v2 >= current_v2) and (new_v1 > current_v1 or new_v2 > current_v2):\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    current_v1 = new_v1\n                    current_v2 = new_v2\n                    improved = True\n                    break\n        if not improved:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5599884277257731,
            6.782558172941208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligently select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_v1 = np.sum(value1_lst * base_solution)\n    current_v2 = np.sum(value2_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip followed by greedy improvement\n    # Step 1: Randomly flip a subset of items\n    flip_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Greedy improvement to maximize both objectives\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        improved = False\n        for idx in range(len(weight_lst)):\n            if new_solution[idx] == 0:\n                if current_weight + weight_lst[idx] <= capacity:\n                    # Evaluate potential improvement\n                    new_v1 = current_v1 + value1_lst[idx]\n                    new_v2 = current_v2 + value2_lst[idx]\n                    # Check if adding this item improves at least one objective\n                    if (new_v1 > current_v1 and new_v2 >= current_v2) or (new_v1 >= current_v1 and new_v2 > current_v2):\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n                        current_v1 = new_v1\n                        current_v2 = new_v2\n                        improved = True\n                        break\n            else:\n                # Evaluate potential improvement by removing\n                new_v1 = current_v1 - value1_lst[idx]\n                new_v2 = current_v2 - value2_lst[idx]\n                # Check if removing this item does not worsen both objectives\n                if (new_v1 >= current_v1 and new_v2 >= current_v2) and (new_v1 > current_v1 or new_v2 > current_v2):\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    current_v1 = new_v1\n                    current_v2 = new_v2\n                    improved = True\n                    break\n        if not improved:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{A novel hybrid local search algorithm combines a biased random walk with a dynamic neighborhood exploration, prioritizing items with high marginal value ratios in both objectives while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: sum(x[0] * (value1_lst + value2_lst) / (weight_lst + 1e-6)))\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic neighborhood exploration with biased random walk\n    for _ in range(10):  # Number of local search steps\n        # Calculate marginal value ratios for both objectives\n        marginal1 = value1_lst / (weight_lst + 1e-6)\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal1 + marginal2\n\n        # Select candidates for flip with probability based on marginal value\n        probs = combined_marginal * (1 - new_solution) + combined_marginal * new_solution * 0.3\n        probs = probs / np.sum(probs)\n\n        # Select an item to flip\n        item = np.random.choice(len(weight_lst), p=probs)\n\n        if new_solution[item] == 1:\n            # Remove item if it's in the solution\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        else:\n            # Add item if it fits\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.39873940135313923,
            9.351507365703583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: sum(x[0] * (value1_lst + value2_lst) / (weight_lst + 1e-6)))\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic neighborhood exploration with biased random walk\n    for _ in range(10):  # Number of local search steps\n        # Calculate marginal value ratios for both objectives\n        marginal1 = value1_lst / (weight_lst + 1e-6)\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal1 + marginal2\n\n        # Select candidates for flip with probability based on marginal value\n        probs = combined_marginal * (1 - new_solution) + combined_marginal * new_solution * 0.3\n        probs = probs / np.sum(probs)\n\n        # Select an item to flip\n        item = np.random.choice(len(weight_lst), p=probs)\n\n        if new_solution[item] == 1:\n            # Remove item if it's in the solution\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        else:\n            # Add item if it fits\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search strategy combining item swapping and adaptive perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those with high diversity or non-dominated status)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform item swapping between included and excluded items\n    # 2. Apply adaptive perturbation to escape local optima\n\n    # Item swapping\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select items to swap\n        swap_in = random.choice(included_items)\n        swap_out = random.choice(excluded_items)\n\n        # Check feasibility after swap\n        new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n        if new_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n\n    # Adaptive perturbation\n    if random.random() < 0.3:  # 30% chance of perturbation\n        # Randomly flip a few items to escape local optima\n        num_flips = min(3, len(new_solution))\n        flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.44522766360611177,
            1.5193010866641998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those with high diversity or non-dominated status)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform item swapping between included and excluded items\n    # 2. Apply adaptive perturbation to escape local optima\n\n    # Item swapping\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select items to swap\n        swap_in = random.choice(included_items)\n        swap_out = random.choice(excluded_items)\n\n        # Check feasibility after swap\n        new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n        if new_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n\n    # Adaptive perturbation\n    if random.random() < 0.3:  # 30% chance of perturbation\n        # Randomly flip a few items to escape local optima\n        num_flips = min(3, len(new_solution))\n        flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search that combines item swaps, flips, and adaptive perturbation to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random flip with feasibility check\n    flip_idx = np.random.randint(0, n_items)\n    if new_solution[flip_idx] == 1:\n        if (np.sum(weight_lst * new_solution) - weight_lst[flip_idx]) <= capacity:\n            new_solution[flip_idx] = 0\n    else:\n        if (np.sum(weight_lst * new_solution) + weight_lst[flip_idx]) <= capacity:\n            new_solution[flip_idx] = 1\n\n    # Step 2: Adaptive swap (if feasible)\n    swap_indices = np.where(new_solution == 1)[0]\n    if len(swap_indices) >= 2:\n        i, j = np.random.choice(swap_indices, 2, replace=False)\n        if (np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Perturbation (if no improvement)\n    if np.random.random() < 0.3:  # 30% chance of perturbation\n        perturb_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                if (np.sum(weight_lst * new_solution) - weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if (np.sum(weight_lst * new_solution) + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3240570864695718,
            2.4334824979305267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random flip with feasibility check\n    flip_idx = np.random.randint(0, n_items)\n    if new_solution[flip_idx] == 1:\n        if (np.sum(weight_lst * new_solution) - weight_lst[flip_idx]) <= capacity:\n            new_solution[flip_idx] = 0\n    else:\n        if (np.sum(weight_lst * new_solution) + weight_lst[flip_idx]) <= capacity:\n            new_solution[flip_idx] = 1\n\n    # Step 2: Adaptive swap (if feasible)\n    swap_indices = np.where(new_solution == 1)[0]\n    if len(swap_indices) >= 2:\n        i, j = np.random.choice(swap_indices, 2, replace=False)\n        if (np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Perturbation (if no improvement)\n    if np.random.random() < 0.3:  # 30% chance of perturbation\n        perturb_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                if (np.sum(weight_lst * new_solution) - weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if (np.sum(weight_lst * new_solution) + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search that combines item swaps and probabilistic flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score of objective values and weight efficiency\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst * x[0]) + 1e-6), reverse=True)\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one from the top solutions\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swaps and probabilistic flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Probabilistic flip: flip each item with a probability based on its value-to-weight ratio\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Probability to remove: inversely proportional to value1 and value2\n                prob_remove = 0.1 / (1 + value1_lst[i] + value2_lst[i])\n                if random.random() < prob_remove:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Probability to add: proportional to value1 and value2\n                if current_weight + weight_lst[i] <= capacity:\n                    prob_add = 0.5 * (value1_lst[i] + value2_lst[i]) / (np.max(value1_lst) + np.max(value2_lst) + 1e-6)\n                    if random.random() < prob_add:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Item swap: swap two items if it improves at least one objective\n    for _ in range(5):  # Limit number of swaps to avoid excessive computation\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Calculate new weight and objective values\n            new_weight = current_weight\n            if new_solution[i] == 1:\n                new_weight -= weight_lst[i]\n            else:\n                new_weight += weight_lst[i]\n            if new_solution[j] == 1:\n                new_weight -= weight_lst[j]\n            else:\n                new_weight += weight_lst[j]\n\n            if new_weight <= capacity:\n                # Calculate new objective values\n                new_value1 = np.sum(value1_lst * new_solution) - (value1_lst[i] if new_solution[i] == 1 else -value1_lst[i]) + (value1_lst[j] if new_solution[j] == 1 else -value1_lst[j])\n                new_value2 = np.sum(value2_lst * new_solution) - (value2_lst[i] if new_solution[i] == 1 else -value2_lst[i]) + (value2_lst[j] if new_solution[j] == 1 else -value2_lst[j])\n\n                # Accept swap if at least one objective improves\n                if (new_value1 > np.sum(value1_lst * new_solution)) or (new_value2 > np.sum(value2_lst * new_solution)):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3147818758586439,
            9.924155592918396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score of objective values and weight efficiency\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst * x[0]) + 1e-6), reverse=True)\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one from the top solutions\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swaps and probabilistic flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Probabilistic flip: flip each item with a probability based on its value-to-weight ratio\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Probability to remove: inversely proportional to value1 and value2\n                prob_remove = 0.1 / (1 + value1_lst[i] + value2_lst[i])\n                if random.random() < prob_remove:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Probability to add: proportional to value1 and value2\n                if current_weight + weight_lst[i] <= capacity:\n                    prob_add = 0.5 * (value1_lst[i] + value2_lst[i]) / (np.max(value1_lst) + np.max(value2_lst) + 1e-6)\n                    if random.random() < prob_add:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Item swap: swap two items if it improves at least one objective\n    for _ in range(5):  # Limit number of swaps to avoid excessive computation\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Calculate new weight and objective values\n            new_weight = current_weight\n            if new_solution[i] == 1:\n                new_weight -= weight_lst[i]\n            else:\n                new_weight += weight_lst[i]\n            if new_solution[j] == 1:\n                new_weight -= weight_lst[j]\n            else:\n                new_weight += weight_lst[j]\n\n            if new_weight <= capacity:\n                # Calculate new objective values\n                new_value1 = np.sum(value1_lst * new_solution) - (value1_lst[i] if new_solution[i] == 1 else -value1_lst[i]) + (value1_lst[j] if new_solution[j] == 1 else -value1_lst[j])\n                new_value2 = np.sum(value2_lst * new_solution) - (value2_lst[i] if new_solution[i] == 1 else -value2_lst[i]) + (value2_lst[j] if new_solution[j] == 1 else -value2_lst[j])\n\n                # Accept swap if at least one objective improves\n                if (new_value1 > np.sum(value1_lst * new_solution)) or (new_value2 > np.sum(value2_lst * new_solution)):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{A novel local search heuristic that intelligently selects a solution from the archive, identifies critical items with high marginal gains in both objectives, and applies a hybrid flip-and-swap operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify critical items (highest marginal gains in both objectives)\n    marginal_gains = (value1_lst + value2_lst) / weight_lst\n    critical_items = np.argsort(marginal_gains)[-len(marginal_gains)//2:]\n\n    # Hybrid flip-and-swap operator\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        # Randomly choose an operation: flip or swap\n        operation = random.choice(['flip', 'swap'])\n\n        if operation == 'flip':\n            # Flip a critical item if possible\n            for item in critical_items:\n                if new_solution[item] == 1:\n                    if current_weight - weight_lst[item] >= 0:\n                        new_solution[item] = 0\n                        current_weight -= weight_lst[item]\n                        break\n                else:\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        break\n\n        else:  # swap\n            # Swap two items: one in the solution and one out\n            in_items = np.where(new_solution == 1)[0]\n            out_items = np.where(new_solution == 0)[0]\n            if len(in_items) > 0 and len(out_items) > 0:\n                item_in = random.choice(in_items)\n                item_out = random.choice(out_items)\n                if current_weight - weight_lst[item_in] + weight_lst[item_out] <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n                    current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n    return new_solution\n\n",
        "score": [
            -0.46801374646173044,
            1.2712321877479553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify critical items (highest marginal gains in both objectives)\n    marginal_gains = (value1_lst + value2_lst) / weight_lst\n    critical_items = np.argsort(marginal_gains)[-len(marginal_gains)//2:]\n\n    # Hybrid flip-and-swap operator\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        # Randomly choose an operation: flip or swap\n        operation = random.choice(['flip', 'swap'])\n\n        if operation == 'flip':\n            # Flip a critical item if possible\n            for item in critical_items:\n                if new_solution[item] == 1:\n                    if current_weight - weight_lst[item] >= 0:\n                        new_solution[item] = 0\n                        current_weight -= weight_lst[item]\n                        break\n                else:\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        break\n\n        else:  # swap\n            # Swap two items: one in the solution and one out\n            in_items = np.where(new_solution == 1)[0]\n            out_items = np.where(new_solution == 0)[0]\n            if len(in_items) > 0 and len(out_items) > 0:\n                item_in = random.choice(in_items)\n                item_out = random.choice(out_items)\n                if current_weight - weight_lst[item_in] + weight_lst[item_out] <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n                    current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{A novel hybrid local search strategy combines adaptive neighborhood exploration with multi-objective path relinking, intelligently selecting solutions with high potential for improvement by balancing marginal gains in both objectives while ensuring feasibility through dynamic constraint handling.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objective = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst[x[0] == 1]) + 1e-6))\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify candidate items to flip (0 to 1 or 1 to 0)\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    # Hybrid local search: combination of greedy and random exploration\n    for _ in range(5):  # Number of local search steps\n        # Greedy selection of items to flip\n        flip_candidates = []\n        for idx in candidate_indices:\n            if new_solution[idx] == 1:\n                # Consider removing this item\n                new_weight = current_weight - weight_lst[idx]\n                if new_weight <= capacity:\n                    flip_candidates.append((idx, -1, weight_lst[idx], value1_lst[idx], value2_lst[idx]))\n            else:\n                # Consider adding this item\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    flip_candidates.append((idx, 1, weight_lst[idx], value1_lst[idx], value2_lst[idx]))\n\n        if not flip_candidates:\n            break\n\n        # Select the best candidate based on marginal gain\n        best_candidate = max(flip_candidates, key=lambda x: (x[3] + x[4]) / (x[2] + 1e-6))\n\n        # Apply the flip\n        idx, flip, w, v1, v2 = best_candidate\n        new_solution[idx] = flip\n        current_weight += flip * w\n        current_value1 += flip * v1\n        current_value2 += flip * v2\n\n        # Update candidate indices for next iteration\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            candidate_indices = np.arange(len(weight_lst))\n\n    return new_solution\n\n",
        "score": [
            -0.8523296642900995,
            6.370992451906204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objective = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst[x[0] == 1]) + 1e-6))\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify candidate items to flip (0 to 1 or 1 to 0)\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    # Hybrid local search: combination of greedy and random exploration\n    for _ in range(5):  # Number of local search steps\n        # Greedy selection of items to flip\n        flip_candidates = []\n        for idx in candidate_indices:\n            if new_solution[idx] == 1:\n                # Consider removing this item\n                new_weight = current_weight - weight_lst[idx]\n                if new_weight <= capacity:\n                    flip_candidates.append((idx, -1, weight_lst[idx], value1_lst[idx], value2_lst[idx]))\n            else:\n                # Consider adding this item\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    flip_candidates.append((idx, 1, weight_lst[idx], value1_lst[idx], value2_lst[idx]))\n\n        if not flip_candidates:\n            break\n\n        # Select the best candidate based on marginal gain\n        best_candidate = max(flip_candidates, key=lambda x: (x[3] + x[4]) / (x[2] + 1e-6))\n\n        # Apply the flip\n        idx, flip, w, v1, v2 = best_candidate\n        new_solution[idx] = flip\n        current_weight += flip * w\n        current_value1 += flip * v1\n        current_value2 += flip * v2\n\n        # Update candidate indices for next iteration\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            candidate_indices = np.arange(len(weight_lst))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive, then applies a hybrid local search combining item swaps and value-based perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Step 2.1: Randomly select a subset of items to perturb\n    n_items = len(weight_lst)\n    perturb_size = max(1, int(np.sqrt(n_items)))\n    perturb_indices = random.sample(range(n_items), perturb_size)\n\n    # Step 2.2: Apply value-based perturbations\n    for idx in perturb_indices:\n        # Flip the item if it improves at least one objective\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Calculate potential improvement\n                delta_v1 = -value1_lst[idx]\n                delta_v2 = -value2_lst[idx]\n                # Accept if at least one objective improves\n                if delta_v1 > 0 or delta_v2 > 0:\n                    new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Calculate potential improvement\n                delta_v1 = value1_lst[idx]\n                delta_v2 = value2_lst[idx]\n                # Accept if at least one objective improves\n                if delta_v1 > 0 or delta_v2 > 0:\n                    new_solution = temp_solution\n\n    # Step 2.3: Apply a swap operation between items of different objectives\n    if np.sum(new_solution) >= 2:\n        # Find items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_idx = random.choice(in_items)\n            out_idx = random.choice(out_items)\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[out_idx] + weight_lst[in_idx]\n\n            if new_weight <= capacity:\n                # Calculate potential improvement\n                delta_v1 = value1_lst[in_idx] - value1_lst[out_idx]\n                delta_v2 = value2_lst[in_idx] - value2_lst[out_idx]\n\n                # Accept if at least one objective improves\n                if delta_v1 > 0 or delta_v2 > 0:\n                    new_solution[out_idx] = 0\n                    new_solution[in_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.307374174242439,
            10.47585654258728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Step 2.1: Randomly select a subset of items to perturb\n    n_items = len(weight_lst)\n    perturb_size = max(1, int(np.sqrt(n_items)))\n    perturb_indices = random.sample(range(n_items), perturb_size)\n\n    # Step 2.2: Apply value-based perturbations\n    for idx in perturb_indices:\n        # Flip the item if it improves at least one objective\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Calculate potential improvement\n                delta_v1 = -value1_lst[idx]\n                delta_v2 = -value2_lst[idx]\n                # Accept if at least one objective improves\n                if delta_v1 > 0 or delta_v2 > 0:\n                    new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Calculate potential improvement\n                delta_v1 = value1_lst[idx]\n                delta_v2 = value2_lst[idx]\n                # Accept if at least one objective improves\n                if delta_v1 > 0 or delta_v2 > 0:\n                    new_solution = temp_solution\n\n    # Step 2.3: Apply a swap operation between items of different objectives\n    if np.sum(new_solution) >= 2:\n        # Find items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_idx = random.choice(in_items)\n            out_idx = random.choice(out_items)\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[out_idx] + weight_lst[in_idx]\n\n            if new_weight <= capacity:\n                # Calculate potential improvement\n                delta_v1 = value1_lst[in_idx] - value1_lst[out_idx]\n                delta_v2 = value2_lst[in_idx] - value2_lst[out_idx]\n\n                # Accept if at least one objective improves\n                if delta_v1 > 0 or delta_v2 > 0:\n                    new_solution[out_idx] = 0\n                    new_solution[in_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with diversity-preserving perturbations to intelligently explore the solution space while ensuring feasibility, focusing on balancing improvements in both objectives through weighted random selection and guided local moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = objectives.sum(axis=1)\n    weights = weights / weights.sum() if weights.sum() > 0 else np.ones(len(archive)) / len(archive)\n    base_idx = np.random.choice(len(archive), p=weights)\n    base_solution, base_obj = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Determine the objective to prioritize for improvement\n    obj1, obj2 = base_obj\n    priority = 1 if obj1 < obj2 else 2 if obj2 < obj1 else random.choice([1, 2])\n\n    # Hybrid local search: adaptive item swapping and diversity perturbation\n    current_weight = np.sum(weight_lst * new_solution)\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Step 1: Adaptive item swapping\n    if len(included_items) > 0 and len(available_items) > 0:\n        # Select an item to remove based on its contribution to the prioritized objective\n        if priority == 1:\n            remove_candidates = sorted(included_items, key=lambda x: value1_lst[x] / weight_lst[x], reverse=True)\n        else:\n            remove_candidates = sorted(included_items, key=lambda x: value2_lst[x] / weight_lst[x], reverse=True)\n\n        for item in remove_candidates:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n\n        # Select an item to add based on its potential improvement\n        if priority == 1:\n            add_candidates = sorted(available_items, key=lambda x: value1_lst[x] / weight_lst[x], reverse=True)\n        else:\n            add_candidates = sorted(available_items, key=lambda x: value2_lst[x] / weight_lst[x], reverse=True)\n\n        for item in add_candidates:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n\n    # Step 2: Diversity perturbation (small random moves)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        if len(included_items) > 0 and len(available_items) > 0:\n            # Randomly select items to swap\n            swap_out = random.choice(included_items)\n            swap_in = random.choice(available_items)\n\n            if current_weight - weight_lst[swap_out] + weight_lst[swap_in] <= capacity:\n                new_solution[swap_out] = 0\n                new_solution[swap_in] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4265111434152401,
            2.4642589390277863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = objectives.sum(axis=1)\n    weights = weights / weights.sum() if weights.sum() > 0 else np.ones(len(archive)) / len(archive)\n    base_idx = np.random.choice(len(archive), p=weights)\n    base_solution, base_obj = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Determine the objective to prioritize for improvement\n    obj1, obj2 = base_obj\n    priority = 1 if obj1 < obj2 else 2 if obj2 < obj1 else random.choice([1, 2])\n\n    # Hybrid local search: adaptive item swapping and diversity perturbation\n    current_weight = np.sum(weight_lst * new_solution)\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Step 1: Adaptive item swapping\n    if len(included_items) > 0 and len(available_items) > 0:\n        # Select an item to remove based on its contribution to the prioritized objective\n        if priority == 1:\n            remove_candidates = sorted(included_items, key=lambda x: value1_lst[x] / weight_lst[x], reverse=True)\n        else:\n            remove_candidates = sorted(included_items, key=lambda x: value2_lst[x] / weight_lst[x], reverse=True)\n\n        for item in remove_candidates:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n\n        # Select an item to add based on its potential improvement\n        if priority == 1:\n            add_candidates = sorted(available_items, key=lambda x: value1_lst[x] / weight_lst[x], reverse=True)\n        else:\n            add_candidates = sorted(available_items, key=lambda x: value2_lst[x] / weight_lst[x], reverse=True)\n\n        for item in add_candidates:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n\n    # Step 2: Diversity perturbation (small random moves)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        if len(included_items) > 0 and len(available_items) > 0:\n            # Randomly select items to swap\n            swap_out = random.choice(included_items)\n            swap_in = random.choice(available_items)\n\n            if current_weight - weight_lst[swap_out] + weight_lst[swap_in] <= capacity:\n                new_solution[swap_out] = 0\n                new_solution[swap_in] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{The novel heuristic function employs a dynamic neighborhood exploration strategy that combines item swapping with adaptive perturbation, guided by a weighted combination of objective improvements and diversity, to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with intelligent randomness\n    weights = np.array([np.sum(archive[i][0] * weight_lst) for i in range(len(archive))])\n    values1 = np.array([archive[i][1][0] for i in range(len(archive))])\n    values2 = np.array([archive[i][1][1] for i in range(len(archive))])\n\n    # Normalize and combine objectives for selection\n    norm_weights = (weights - np.min(weights)) / (np.max(weights) - np.min(weights) + 1e-10)\n    norm_values1 = (values1 - np.min(values1)) / (np.max(values1) - np.min(values1) + 1e-10)\n    norm_values2 = (values2 - np.min(values2)) / (np.max(values2) - np.min(values2) + 1e-10)\n\n    # Combine objectives with weights for selection\n    combined = 0.4 * norm_weights + 0.3 * norm_values1 + 0.3 * norm_values2\n    probs = combined / np.sum(combined)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Adaptive perturbation: swap items based on objective potential\n    potential_items = np.where((new_solution == 0) & (weight_lst <= capacity - current_weight))[0]\n    if len(potential_items) > 0:\n        # Select item with highest combined value\n        combined_values = 0.5 * value1_lst[potential_items] + 0.5 * value2_lst[potential_items]\n        best_item = potential_items[np.argmax(combined_values)]\n        new_solution[best_item] = 1\n\n    # Local improvement: remove items with least contribution\n    if np.sum(new_solution) > 0:\n        included_items = np.where(new_solution == 1)[0]\n        # Calculate contribution to both objectives\n        contributions = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        worst_item = included_items[np.argmin(contributions)]\n        new_solution[worst_item] = 0\n\n    # Ensure feasibility\n    while np.sum(new_solution * weight_lst) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        # Remove the item with smallest weight\n        smallest_item = included_items[np.argmin(weight_lst[included_items])]\n        new_solution[smallest_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.783997948453441,
            3.074270725250244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with intelligent randomness\n    weights = np.array([np.sum(archive[i][0] * weight_lst) for i in range(len(archive))])\n    values1 = np.array([archive[i][1][0] for i in range(len(archive))])\n    values2 = np.array([archive[i][1][1] for i in range(len(archive))])\n\n    # Normalize and combine objectives for selection\n    norm_weights = (weights - np.min(weights)) / (np.max(weights) - np.min(weights) + 1e-10)\n    norm_values1 = (values1 - np.min(values1)) / (np.max(values1) - np.min(values1) + 1e-10)\n    norm_values2 = (values2 - np.min(values2)) / (np.max(values2) - np.min(values2) + 1e-10)\n\n    # Combine objectives with weights for selection\n    combined = 0.4 * norm_weights + 0.3 * norm_values1 + 0.3 * norm_values2\n    probs = combined / np.sum(combined)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Adaptive perturbation: swap items based on objective potential\n    potential_items = np.where((new_solution == 0) & (weight_lst <= capacity - current_weight))[0]\n    if len(potential_items) > 0:\n        # Select item with highest combined value\n        combined_values = 0.5 * value1_lst[potential_items] + 0.5 * value2_lst[potential_items]\n        best_item = potential_items[np.argmax(combined_values)]\n        new_solution[best_item] = 1\n\n    # Local improvement: remove items with least contribution\n    if np.sum(new_solution) > 0:\n        included_items = np.where(new_solution == 1)[0]\n        # Calculate contribution to both objectives\n        contributions = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        worst_item = included_items[np.argmin(contributions)]\n        new_solution[worst_item] = 0\n\n    # Ensure feasibility\n    while np.sum(new_solution * weight_lst) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        # Remove the item with smallest weight\n        smallest_item = included_items[np.argmin(weight_lst[included_items])]\n        new_solution[smallest_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{The algorithm selects a promising solution from the archive based on its objective values and applies a hybrid local search operator that combines item swaps and random perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and perturb randomly\n    n_items = len(base_solution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Randomly select items to swap or flip\n    indices = np.where(base_solution == 1)[0]\n    if len(indices) > 0:\n        # Swap two items\n        idx1, idx2 = np.random.choice(indices, size=2, replace=False)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n        # Check feasibility\n        new_weight = np.sum(weight_lst[new_solution == 1])\n        if new_weight > capacity:\n            # If infeasible, revert and try random perturbation\n            new_solution = base_solution.copy()\n            idx = np.random.choice(n_items)\n            new_solution[idx] = 1 - new_solution[idx]\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                new_solution[idx] = base_solution[idx]\n\n    # Randomly flip a few items to explore neighborhood\n    for _ in range(2):\n        idx = np.random.randint(n_items)\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst[temp_solution == 1])\n        if temp_weight <= capacity:\n            new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.32493427124635244,
            2.116249293088913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and perturb randomly\n    n_items = len(base_solution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Randomly select items to swap or flip\n    indices = np.where(base_solution == 1)[0]\n    if len(indices) > 0:\n        # Swap two items\n        idx1, idx2 = np.random.choice(indices, size=2, replace=False)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n        # Check feasibility\n        new_weight = np.sum(weight_lst[new_solution == 1])\n        if new_weight > capacity:\n            # If infeasible, revert and try random perturbation\n            new_solution = base_solution.copy()\n            idx = np.random.choice(n_items)\n            new_solution[idx] = 1 - new_solution[idx]\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                new_solution[idx] = base_solution[idx]\n\n    # Randomly flip a few items to explore neighborhood\n    for _ in range(2):\n        idx = np.random.randint(n_items)\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst[temp_solution == 1])\n        if temp_weight <= capacity:\n            new_solution = temp_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, then applies a weighted random swap and a guided bit-flip operator to balance exploration and exploitation, ensuring feasibility while maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_weights = np.array([np.sum(weight_lst * sol) for sol in archive_solutions])\n    archive_values = np.array([(np.sum(value1_lst * sol), np.sum(value2_lst * sol)) for sol in archive_solutions])\n\n    # Compute potential improvement scores (weighted sum of normalized improvements)\n    improvement_scores = []\n    for i in range(len(archive_solutions)):\n        sol = archive_solutions[i]\n        current_weight = archive_weights[i]\n        current_values = archive_values[i]\n\n        # Find items not in the solution that can be added without exceeding capacity\n        remaining_capacity = capacity - current_weight\n        candidate_items = np.where((sol == 0) & (weight_lst <= remaining_capacity))[0]\n\n        if len(candidate_items) > 0:\n            # Compute potential value improvements\n            potential_value1 = np.sum(value1_lst[candidate_items])\n            potential_value2 = np.sum(value2_lst[candidate_items])\n            improvement_score = (potential_value1 + potential_value2) / (current_values[0] + current_values[1] + 1e-6)\n        else:\n            improvement_score = 0\n\n        improvement_scores.append(improvement_score)\n\n    # Select the solution with the highest improvement potential\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Weighted random swap (higher probability for items with higher marginal value)\n    if np.sum(new_solution) > 1:\n        # Calculate marginal values\n        marginal_value1 = value1_lst * (1 - new_solution)\n        marginal_value2 = value2_lst * (1 - new_solution)\n        marginal_weights = weight_lst * (1 - new_solution)\n\n        # Normalize and combine marginal values\n        combined_marginal = (marginal_value1 + marginal_value2) / (np.sum(marginal_weights) + 1e-6)\n\n        # Select items to swap with probability proportional to marginal value\n        swap_probs = combined_marginal / np.sum(combined_marginal)\n        swap_items = np.random.choice(np.arange(len(weight_lst)), size=2, p=swap_probs, replace=False)\n\n        # Perform swap if feasible\n        if new_solution[swap_items[0]] != new_solution[swap_items[1]]:\n            new_solution[swap_items[0]], new_solution[1] = new_solution[1], new_solution[swap_items[0]]\n\n    # Step 2: Guided bit-flip (flip bits that improve both objectives)\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Find items that can be added without exceeding capacity\n    add_candidates = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    # Find items that can be removed without making the solution empty\n    remove_candidates = np.where((new_solution == 1) & (np.sum(new_solution) > 1))[0]\n\n    # Evaluate potential flips\n    best_flip = None\n    best_improvement = 0\n\n    for item in add_candidates:\n        new_weight = current_weight + weight_lst[item]\n        if new_weight <= capacity:\n            improvement = value1_lst[item] + value2_lst[item]\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_flip = item\n\n    for item in remove_candidates:\n        improvement = value1_lst[item] + value2_lst[item]\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_flip = item\n\n    # Apply the best flip if it exists\n    if best_flip is not None:\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    return new_solution\n\n",
        "score": [
            -0.6863634869774506,
            6.535834848880768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_weights = np.array([np.sum(weight_lst * sol) for sol in archive_solutions])\n    archive_values = np.array([(np.sum(value1_lst * sol), np.sum(value2_lst * sol)) for sol in archive_solutions])\n\n    # Compute potential improvement scores (weighted sum of normalized improvements)\n    improvement_scores = []\n    for i in range(len(archive_solutions)):\n        sol = archive_solutions[i]\n        current_weight = archive_weights[i]\n        current_values = archive_values[i]\n\n        # Find items not in the solution that can be added without exceeding capacity\n        remaining_capacity = capacity - current_weight\n        candidate_items = np.where((sol == 0) & (weight_lst <= remaining_capacity))[0]\n\n        if len(candidate_items) > 0:\n            # Compute potential value improvements\n            potential_value1 = np.sum(value1_lst[candidate_items])\n            potential_value2 = np.sum(value2_lst[candidate_items])\n            improvement_score = (potential_value1 + potential_value2) / (current_values[0] + current_values[1] + 1e-6)\n        else:\n            improvement_score = 0\n\n        improvement_scores.append(improvement_score)\n\n    # Select the solution with the highest improvement potential\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Weighted random swap (higher probability for items with higher marginal value)\n    if np.sum(new_solution) > 1:\n        # Calculate marginal values\n        marginal_value1 = value1_lst * (1 - new_solution)\n        marginal_value2 = value2_lst * (1 - new_solution)\n        marginal_weights = weight_lst * (1 - new_solution)\n\n        # Normalize and combine marginal values\n        combined_marginal = (marginal_value1 + marginal_value2) / (np.sum(marginal_weights) + 1e-6)\n\n        # Select items to swap with probability proportional to marginal value\n        swap_probs = combined_marginal / np.sum(combined_marginal)\n        swap_items = np.random.choice(np.arange(len(weight_lst)), size=2, p=swap_probs, replace=False)\n\n        # Perform swap if feasible\n        if new_solution[swap_items[0]] != new_solution[swap_items[1]]:\n            new_solution[swap_items[0]], new_solution[1] = new_solution[1], new_solution[swap_items[0]]\n\n    # Step 2: Guided bit-flip (flip bits that improve both objectives)\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Find items that can be added without exceeding capacity\n    add_candidates = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    # Find items that can be removed without making the solution empty\n    remove_candidates = np.where((new_solution == 1) & (np.sum(new_solution) > 1))[0]\n\n    # Evaluate potential flips\n    best_flip = None\n    best_improvement = 0\n\n    for item in add_candidates:\n        new_weight = current_weight + weight_lst[item]\n        if new_weight <= capacity:\n            improvement = value1_lst[item] + value2_lst[item]\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_flip = item\n\n    for item in remove_candidates:\n        improvement = value1_lst[item] + value2_lst[item]\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_flip = item\n\n    # Apply the best flip if it exists\n    if best_flip is not None:\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{The heuristic function selects a solution from the archive based on its \"crowding distance\" in the objective space to prioritize solutions in less explored regions, then applies a novel \"guided flip\" local search that probabilistically flips items with high marginal utility ratios, ensuring feasibility while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for all solutions in the archive\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n    crowding_distances = np.zeros(n_solutions)\n\n    # Normalize objectives for crowding distance calculation\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n\n    # Sort solutions by each objective and compute crowding distances\n    for m in range(2):\n        sorted_indices = np.argsort(normalized_obj[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, n_solutions - 1):\n            crowding_distances[sorted_indices[i]] += normalized_obj[sorted_indices[i + 1], m] - normalized_obj[sorted_indices[i - 1], m]\n\n    # Select solution with minimum crowding distance (less explored region)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and marginal utility ratios\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_utility1 = value1_lst / (weight_lst + 1e-10)\n    marginal_utility2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_utility1 + marginal_utility2\n\n    # Guided flip: probabilistically flip items based on combined marginal utility\n    for i in range(len(base_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if base_solution[i] == 1:\n                # Consider removing item\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item\n                if current_weight + weight_lst[i] <= capacity:\n                    # Probability proportional to combined marginal utility\n                    prob = combined_marginal[i] / (np.sum(combined_marginal) + 1e-10)\n                    if np.random.rand() < prob:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9405463029811076,
            4.321256577968597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for all solutions in the archive\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n    crowding_distances = np.zeros(n_solutions)\n\n    # Normalize objectives for crowding distance calculation\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n\n    # Sort solutions by each objective and compute crowding distances\n    for m in range(2):\n        sorted_indices = np.argsort(normalized_obj[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, n_solutions - 1):\n            crowding_distances[sorted_indices[i]] += normalized_obj[sorted_indices[i + 1], m] - normalized_obj[sorted_indices[i - 1], m]\n\n    # Select solution with minimum crowding distance (less explored region)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and marginal utility ratios\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_utility1 = value1_lst / (weight_lst + 1e-10)\n    marginal_utility2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_utility1 + marginal_utility2\n\n    # Guided flip: probabilistically flip items based on combined marginal utility\n    for i in range(len(base_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if base_solution[i] == 1:\n                # Consider removing item\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item\n                if current_weight + weight_lst[i] <= capacity:\n                    # Probability proportional to combined marginal utility\n                    prob = combined_marginal[i] / (np.sum(combined_marginal) + 1e-10)\n                    if np.random.rand() < prob:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random item swaps and value-guided flips to explore the neighborhood while ensuring feasibility, prioritizing high-value items in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            # Prioritize solutions that are not already optimal in both objectives\n            is_optimal = True\n            for other_sol, other_obj in archive:\n                if (other_obj[0] > obj[0] and other_obj[1] >= obj[1]) or (other_obj[0] >= obj[0] and other_obj[1] > obj[1]):\n                    is_optimal = False\n                    break\n            if not is_optimal:\n                candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive  # Fallback to all solutions if none are non-optimal\n\n    # Select a random candidate with probability proportional to its potential improvement\n    weights = [1.0 / (1 + np.sum(sol)) for sol, _ in candidates]  # Example: inverse of solution size as a proxy for improvement\n    selected_sol, _ = random.choices(candidates, weights=weights, k=1)[0]\n    base_solution = selected_sol.copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly swap two items (if feasible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            total_weight = np.sum(weight_lst * new_solution)\n            if total_weight > capacity:\n                # Undo swap if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Flip items with high value-to-weight ratio in one objective\n    if random.random() < 0.5:  # 50% chance to flip based on value1\n        value_to_weight = value1_lst / (weight_lst + 1e-6)\n    else:  # 50% chance to flip based on value2\n        value_to_weight = value2_lst / (weight_lst + 1e-6)\n\n    # Select top-k items to consider flipping\n    k = min(5, n_items)  # Consider top 5 items\n    top_items = np.argsort(-value_to_weight)[:k]\n\n    for i in top_items:\n        if new_solution[i] == 0:\n            # Try adding the item\n            temp_sol = new_solution.copy()\n            temp_sol[i] = 1\n            total_weight = np.sum(weight_lst * temp_sol)\n            if total_weight <= capacity:\n                new_solution = temp_sol\n        else:\n            # Try removing the item\n            temp_sol = new_solution.copy()\n            temp_sol[i] = 0\n            new_solution = temp_sol\n\n    return new_solution\n\n",
        "score": [
            -0.6413801634496386,
            2.7616988122463226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            # Prioritize solutions that are not already optimal in both objectives\n            is_optimal = True\n            for other_sol, other_obj in archive:\n                if (other_obj[0] > obj[0] and other_obj[1] >= obj[1]) or (other_obj[0] >= obj[0] and other_obj[1] > obj[1]):\n                    is_optimal = False\n                    break\n            if not is_optimal:\n                candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive  # Fallback to all solutions if none are non-optimal\n\n    # Select a random candidate with probability proportional to its potential improvement\n    weights = [1.0 / (1 + np.sum(sol)) for sol, _ in candidates]  # Example: inverse of solution size as a proxy for improvement\n    selected_sol, _ = random.choices(candidates, weights=weights, k=1)[0]\n    base_solution = selected_sol.copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly swap two items (if feasible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            total_weight = np.sum(weight_lst * new_solution)\n            if total_weight > capacity:\n                # Undo swap if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Flip items with high value-to-weight ratio in one objective\n    if random.random() < 0.5:  # 50% chance to flip based on value1\n        value_to_weight = value1_lst / (weight_lst + 1e-6)\n    else:  # 50% chance to flip based on value2\n        value_to_weight = value2_lst / (weight_lst + 1e-6)\n\n    # Select top-k items to consider flipping\n    k = min(5, n_items)  # Consider top 5 items\n    top_items = np.argsort(-value_to_weight)[:k]\n\n    for i in top_items:\n        if new_solution[i] == 0:\n            # Try adding the item\n            temp_sol = new_solution.copy()\n            temp_sol[i] = 1\n            total_weight = np.sum(weight_lst * temp_sol)\n            if total_weight <= capacity:\n                new_solution = temp_sol\n        else:\n            # Try removing the item\n            temp_sol = new_solution.copy()\n            temp_sol[i] = 0\n            new_solution = temp_sol\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by prioritizing those with low dominance counts and applies a hybrid local search combining random swaps, value-based flips, and capacity-aware adjustments to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Create a copy for modification\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select a subset of items to flip\n        flip_indices = random.sample(range(len(base_solution)), min(5, len(base_solution)))\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                # If item is included, try to remove it\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                # If item is excluded, try to include it if it fits\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n        # Additional heuristic: flip items with high value-to-weight ratio\n        value_ratio = (value1_lst + value2_lst) / weight_lst\n        high_ratio_items = np.argsort(-value_ratio)[:min(5, len(value_ratio))]\n        for idx in high_ratio_items:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4700570481385765,
            2.441576838493347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Create a copy for modification\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select a subset of items to flip\n        flip_indices = random.sample(range(len(base_solution)), min(5, len(base_solution)))\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                # If item is included, try to remove it\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                # If item is excluded, try to include it if it fits\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n        # Additional heuristic: flip items with high value-to-weight ratio\n        value_ratio = (value1_lst + value2_lst) / weight_lst\n        high_ratio_items = np.argsort(-value_ratio)[:min(5, len(value_ratio))]\n        for idx in high_ratio_items:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search operator that combines item swapping with probabilistic flipping to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    current_weights = [np.sum(weight_lst[sol == 1]) for sol in archive_solutions]\n\n    # Prioritize solutions with lower weight (more room for improvement)\n    candidates = [(sol, w) for sol, w in zip(archive_solutions, current_weights) if w < capacity]\n    if not candidates:\n        candidates = archive_solutions\n\n    # Randomly select among top 30% candidates by weight\n    top_candidates = sorted(candidates, key=lambda x: x[1])[:max(1, len(candidates) // 3)]\n    base_solution = random.choice(top_candidates)[0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Probabilistic flipping of items with high marginal gain\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                # Check if adding this item keeps solution feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Swap items between high-value and low-value groups\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Identify high-value items to potentially remove\n        high_value_items = np.argsort(value1_lst[included] + value2_lst[included])[-min(3, len(included)):]\n        # Identify low-value items to potentially add\n        low_value_items = np.argsort(value1_lst[excluded] + value2_lst[excluded])[:min(3, len(excluded))]\n\n        for i in high_value_items:\n            for j in low_value_items:\n                # Try swapping i (included) with j (excluded)\n                temp_solution = new_solution.copy()\n                temp_solution[included[i]] = 0\n                temp_solution[excluded[j]] = 1\n\n                # Check feasibility\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3986997562019214,
            3.5938501358032227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    current_weights = [np.sum(weight_lst[sol == 1]) for sol in archive_solutions]\n\n    # Prioritize solutions with lower weight (more room for improvement)\n    candidates = [(sol, w) for sol, w in zip(archive_solutions, current_weights) if w < capacity]\n    if not candidates:\n        candidates = archive_solutions\n\n    # Randomly select among top 30% candidates by weight\n    top_candidates = sorted(candidates, key=lambda x: x[1])[:max(1, len(candidates) // 3)]\n    base_solution = random.choice(top_candidates)[0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Probabilistic flipping of items with high marginal gain\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                # Check if adding this item keeps solution feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Swap items between high-value and low-value groups\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Identify high-value items to potentially remove\n        high_value_items = np.argsort(value1_lst[included] + value2_lst[included])[-min(3, len(included)):]\n        # Identify low-value items to potentially add\n        low_value_items = np.argsort(value1_lst[excluded] + value2_lst[excluded])[:min(3, len(excluded))]\n\n        for i in high_value_items:\n            for j in low_value_items:\n                # Try swapping i (included) with j (excluded)\n                temp_solution = new_solution.copy()\n                temp_solution[included[i]] = 0\n                temp_solution[excluded[j]] = 1\n\n                # Check feasibility\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search that combines item swaps with adaptive neighborhood exploration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort archive by objective values (prioritize high values) and then by weight (prioritize low weight)\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1], sum(weight_lst[x[0] == 1])))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for swapping\n    subset_size = max(1, int(np.sqrt(n_items)))\n    indices = random.sample(range(n_items), subset_size)\n\n    # Apply adaptive neighborhood exploration\n    for i in indices:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    # Further improve by swapping items between objectives\n    for i in indices:\n        if new_solution[i] == 1:\n            # Try swapping item i with another item not in the solution\n            for j in indices:\n                if new_solution[j] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                    temp_weight = sum(weight_lst[temp_solution == 1])\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.31282052079561395,
            3.4253219962120056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort archive by objective values (prioritize high values) and then by weight (prioritize low weight)\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1], sum(weight_lst[x[0] == 1])))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for swapping\n    subset_size = max(1, int(np.sqrt(n_items)))\n    indices = random.sample(range(n_items), subset_size)\n\n    # Apply adaptive neighborhood exploration\n    for i in indices:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    # Further improve by swapping items between objectives\n    for i in indices:\n        if new_solution[i] == 1:\n            # Try swapping item i with another item not in the solution\n            for j in indices:\n                if new_solution[j] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                    temp_weight = sum(weight_lst[temp_solution == 1])\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search operator that combines random item swaps and targeted flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: random swaps and targeted flips\n    for _ in range(min(5, len(new_solution))):  # Limit the number of attempts\n        # Random swap\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                new_solution[j] = new_solution[i]\n                new_solution[i] = temp\n            else:\n                break\n\n    # Targeted flip: add or remove items to improve objectives\n    for _ in range(min(3, len(new_solution))):\n        # Find items that can be added\n        zero_indices = np.where(new_solution == 0)[0]\n        if len(zero_indices) > 0:\n            i = random.choice(zero_indices)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n        # Find items that can be removed\n        one_indices = np.where(new_solution == 1)[0]\n        if len(one_indices) > 0:\n            i = random.choice(one_indices)\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5966441033347527,
            1.3960423171520233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: random swaps and targeted flips\n    for _ in range(min(5, len(new_solution))):  # Limit the number of attempts\n        # Random swap\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                new_solution[j] = new_solution[i]\n                new_solution[i] = temp\n            else:\n                break\n\n    # Targeted flip: add or remove items to improve objectives\n    for _ in range(min(3, len(new_solution))):\n        # Find items that can be added\n        zero_indices = np.where(new_solution == 0)[0]\n        if len(zero_indices) > 0:\n            i = random.choice(zero_indices)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n        # Find items that can be removed\n        one_indices = np.where(new_solution == 1)[0]\n        if len(one_indices) > 0:\n            i = random.choice(one_indices)\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a promising solution from the archive, then applies a novel \"value-aware swap and shift\" operator to generate a neighbor by strategically flipping items based on their marginal contributions to both objectives, while ensuring feasibility through a capacity-aware adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Create a candidate list of items to consider for flipping\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search operator: value-aware swap and shift\n    new_solution = base_solution.copy()\n\n    # Step 1: Select a random item to potentially remove\n    if len(candidate_items) > 0:\n        item_to_remove = random.choice(candidate_items)\n        new_solution[item_to_remove] = 0\n        new_weight = current_weight - weight_lst[item_to_remove]\n\n        # Step 2: Find items that can be added without exceeding capacity\n        possible_additions = np.where((base_solution == 0) & (weight_lst <= (capacity - new_weight)))[0]\n\n        if len(possible_additions) > 0:\n            # Step 3: Select the item with highest marginal contribution to both objectives\n            marginal_value1 = value1_lst[possible_additions] / weight_lst[possible_additions]\n            marginal_value2 = value2_lst[possible_additions] / weight_lst[possible_additions]\n\n            # Combine marginal contributions (simple sum for this example)\n            combined_marginal = marginal_value1 + marginal_value2\n            best_addition = possible_additions[np.argmax(combined_marginal)]\n\n            new_solution[best_addition] = 1\n\n    # Step 4: Capacity adjustment if needed (as a safeguard)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break\n            item_to_remove = random.choice(excess_items)\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.471735499976655,
            1.2537638545036316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Create a candidate list of items to consider for flipping\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search operator: value-aware swap and shift\n    new_solution = base_solution.copy()\n\n    # Step 1: Select a random item to potentially remove\n    if len(candidate_items) > 0:\n        item_to_remove = random.choice(candidate_items)\n        new_solution[item_to_remove] = 0\n        new_weight = current_weight - weight_lst[item_to_remove]\n\n        # Step 2: Find items that can be added without exceeding capacity\n        possible_additions = np.where((base_solution == 0) & (weight_lst <= (capacity - new_weight)))[0]\n\n        if len(possible_additions) > 0:\n            # Step 3: Select the item with highest marginal contribution to both objectives\n            marginal_value1 = value1_lst[possible_additions] / weight_lst[possible_additions]\n            marginal_value2 = value2_lst[possible_additions] / weight_lst[possible_additions]\n\n            # Combine marginal contributions (simple sum for this example)\n            combined_marginal = marginal_value1 + marginal_value2\n            best_addition = possible_additions[np.argmax(combined_marginal)]\n\n            new_solution[best_addition] = 1\n\n    # Step 4: Capacity adjustment if needed (as a safeguard)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break\n            item_to_remove = random.choice(excess_items)\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive based on its potential for improvement, then applies a combination of swap and shift operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap and shift operations\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Randomly select a subset of items to consider for swap\n    swap_candidates = np.where(base_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        i = random.choice(swap_candidates)\n        # Find a candidate to swap with (either another included item or an excluded one)\n        j_candidates = np.where(base_solution == 0)[0] if random.random() < 0.5 else swap_candidates\n        if len(j_candidates) > 0:\n            j = random.choice(j_candidates)\n            # Check feasibility of swap\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Shift operation: move a random item if possible\n    if random.random() < 0.3:  # 30% chance for shift\n        shift_candidates = np.where(base_solution == 0)[0]\n        if len(shift_candidates) > 0:\n            k = random.choice(shift_candidates)\n            if current_weight + weight_lst[k] <= capacity:\n                new_solution[k] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3529769494415612,
            2.8248938024044037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap and shift operations\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Randomly select a subset of items to consider for swap\n    swap_candidates = np.where(base_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        i = random.choice(swap_candidates)\n        # Find a candidate to swap with (either another included item or an excluded one)\n        j_candidates = np.where(base_solution == 0)[0] if random.random() < 0.5 else swap_candidates\n        if len(j_candidates) > 0:\n            j = random.choice(j_candidates)\n            # Check feasibility of swap\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Shift operation: move a random item if possible\n    if random.random() < 0.3:  # 30% chance for shift\n        shift_candidates = np.where(base_solution == 0)[0]\n        if len(shift_candidates) > 0:\n            k = random.choice(shift_candidates)\n            if current_weight + weight_lst[k] <= capacity:\n                new_solution[k] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[0]) / len(x[0]))  # Prefer solutions with more items (higher density)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Find items that can be flipped (added or removed)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                # Calculate potential value improvements\n                delta_value1 = -value1_lst[i]\n                delta_value2 = -value2_lst[i]\n                candidates.append((i, delta_value1, delta_value2, -weight_lst[i]))\n        else:\n            # Check if adding this item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                # Calculate potential value improvements\n                delta_value1 = value1_lst[i]\n                delta_value2 = value2_lst[i]\n                candidates.append((i, delta_value1, delta_value2, weight_lst[i]))\n\n    if not candidates:\n        return new_solution\n\n    # Select the flip with the highest combined value improvement\n    best_flip = max(candidates, key=lambda x: (x[1] + x[2]) / abs(x[3]) if x[3] != 0 else float('inf'))\n    new_solution[best_flip[0]] = 1 - new_solution[best_flip[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8064781482854491,
            4.157866179943085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[0]) / len(x[0]))  # Prefer solutions with more items (higher density)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Find items that can be flipped (added or removed)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                # Calculate potential value improvements\n                delta_value1 = -value1_lst[i]\n                delta_value2 = -value2_lst[i]\n                candidates.append((i, delta_value1, delta_value2, -weight_lst[i]))\n        else:\n            # Check if adding this item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                # Calculate potential value improvements\n                delta_value1 = value1_lst[i]\n                delta_value2 = value2_lst[i]\n                candidates.append((i, delta_value1, delta_value2, weight_lst[i]))\n\n    if not candidates:\n        return new_solution\n\n    # Select the flip with the highest combined value improvement\n    best_flip = max(candidates, key=lambda x: (x[1] + x[2]) / abs(x[3]) if x[3] != 0 else float('inf'))\n    new_solution[best_flip[0]] = 1 - new_solution[best_flip[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high total objective values, then applies a hybrid local search operator that combines adaptive item swapping and probabilistic bit flipping to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Adaptive item swapping\n    for _ in range(3):\n        if random.random() < 0.7:  # Higher probability for swapping\n            candidates = np.where(base_solution != new_solution)[0]\n            if len(candidates) > 0:\n                swap_idx = random.choice(candidates)\n                if new_solution[swap_idx] == 1:\n                    # Try to remove this item if it's in the solution\n                    if current_weight - weight_lst[swap_idx] <= capacity:\n                        new_solution[swap_idx] = 0\n                        current_weight -= weight_lst[swap_idx]\n                        current_value1 -= value1_lst[swap_idx]\n                        current_value2 -= value2_lst[swap_idx]\n                else:\n                    # Try to add this item if it's not in the solution\n                    if current_weight + weight_lst[swap_idx] <= capacity:\n                        new_solution[swap_idx] = 1\n                        current_weight += weight_lst[swap_idx]\n                        current_value1 += value1_lst[swap_idx]\n                        current_value2 += value2_lst[swap_idx]\n\n    # Probabilistic bit flipping with feasibility check\n    for _ in range(2):\n        flip_idx = random.randint(0, n_items - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n                current_value1 -= value1_lst[flip_idx]\n                current_value2 -= value2_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n                current_value1 += value1_lst[flip_idx]\n                current_value2 += value2_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4528026586942311,
            1.6668904423713684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Adaptive item swapping\n    for _ in range(3):\n        if random.random() < 0.7:  # Higher probability for swapping\n            candidates = np.where(base_solution != new_solution)[0]\n            if len(candidates) > 0:\n                swap_idx = random.choice(candidates)\n                if new_solution[swap_idx] == 1:\n                    # Try to remove this item if it's in the solution\n                    if current_weight - weight_lst[swap_idx] <= capacity:\n                        new_solution[swap_idx] = 0\n                        current_weight -= weight_lst[swap_idx]\n                        current_value1 -= value1_lst[swap_idx]\n                        current_value2 -= value2_lst[swap_idx]\n                else:\n                    # Try to add this item if it's not in the solution\n                    if current_weight + weight_lst[swap_idx] <= capacity:\n                        new_solution[swap_idx] = 1\n                        current_weight += weight_lst[swap_idx]\n                        current_value1 += value1_lst[swap_idx]\n                        current_value2 += value2_lst[swap_idx]\n\n    # Probabilistic bit flipping with feasibility check\n    for _ in range(2):\n        flip_idx = random.randint(0, n_items - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n                current_value1 -= value1_lst[flip_idx]\n                current_value2 -= value2_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n                current_value1 += value1_lst[flip_idx]\n                current_value2 += value2_lst[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, applies a weighted random perturbation to explore high-value regions, and uses adaptive flipping of items based on their marginal contribution to both objectives, ensuring feasibility while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Adaptive flipping probability based on marginal contributions\n    flip_probs = combined_marginal / np.sum(combined_marginal)\n    new_solution = base_solution.copy()\n\n    # Perform weighted random flips\n    for i in range(len(new_solution)):\n        if random.random() < flip_probs[i] * 0.3:  # Lower probability to avoid too many changes\n            if new_solution[i] == 1:\n                # Try to remove item if it's included\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add item if it's excluded\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Additional local improvement: flip the worst item in one objective if feasible\n    if np.random.random() < 0.5:\n        # Choose objective based on current solution's dominance\n        if current_value1 > current_value2:\n            # Focus on objective 1\n            worst_item = np.argmin(value1_lst[base_solution == 1] / weight_lst[base_solution == 1])\n            actual_idx = np.where(base_solution == 1)[0][worst_item]\n            if base_solution[actual_idx] == 1:\n                new_solution[actual_idx] = 0\n        else:\n            # Focus on objective 2\n            worst_item = np.argmin(value2_lst[base_solution == 1] / weight_lst[base_solution == 1])\n            actual_idx = np.where(base_solution == 1)[0][worst_item]\n            if base_solution[actual_idx] == 1:\n                new_solution[actual_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5390220057757137,
            7.928712695837021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Adaptive flipping probability based on marginal contributions\n    flip_probs = combined_marginal / np.sum(combined_marginal)\n    new_solution = base_solution.copy()\n\n    # Perform weighted random flips\n    for i in range(len(new_solution)):\n        if random.random() < flip_probs[i] * 0.3:  # Lower probability to avoid too many changes\n            if new_solution[i] == 1:\n                # Try to remove item if it's included\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add item if it's excluded\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Additional local improvement: flip the worst item in one objective if feasible\n    if np.random.random() < 0.5:\n        # Choose objective based on current solution's dominance\n        if current_value1 > current_value2:\n            # Focus on objective 1\n            worst_item = np.argmin(value1_lst[base_solution == 1] / weight_lst[base_solution == 1])\n            actual_idx = np.where(base_solution == 1)[0][worst_item]\n            if base_solution[actual_idx] == 1:\n                new_solution[actual_idx] = 0\n        else:\n            # Focus on objective 2\n            worst_item = np.argmin(value2_lst[base_solution == 1] / weight_lst[base_solution == 1])\n            actual_idx = np.where(base_solution == 1)[0][worst_item]\n            if base_solution[actual_idx] == 1:\n                new_solution[actual_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{A novel hybrid local search strategy combines random walk with adaptive mutation, selectively flipping items based on their marginal contribution to both objectives while ensuring feasibility, and intelligently choosing solutions from the archive with high potential for improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Adaptive mutation: flip items with high marginal contribution\n    for _ in range(min(5, len(new_solution))):  # Limit the number of flips\n        # Calculate marginal contributions for each item\n        marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n\n        # Combine marginal contributions (weighted sum)\n        combined_marginal = 0.5 * marginal1 + 0.5 * marginal2\n\n        # Select items to flip based on combined marginal contribution\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) == 0:\n            break\n\n        # Prioritize items with high marginal contribution\n        candidate_marginals = combined_marginal[candidate_indices]\n        selected_item = candidate_indices[np.argmax(candidate_marginals)]\n\n        # Check feasibility if we add the item\n        if current_weight + weight_lst[selected_item] <= capacity:\n            new_solution[selected_item] = 1\n            current_weight += weight_lst[selected_item]\n\n    # Random walk: flip a few items randomly to escape local optima\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3931430012667964,
            2.444968730211258
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Adaptive mutation: flip items with high marginal contribution\n    for _ in range(min(5, len(new_solution))):  # Limit the number of flips\n        # Calculate marginal contributions for each item\n        marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n\n        # Combine marginal contributions (weighted sum)\n        combined_marginal = 0.5 * marginal1 + 0.5 * marginal2\n\n        # Select items to flip based on combined marginal contribution\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) == 0:\n            break\n\n        # Prioritize items with high marginal contribution\n        candidate_marginals = combined_marginal[candidate_indices]\n        selected_item = candidate_indices[np.argmax(candidate_marginals)]\n\n        # Check feasibility if we add the item\n        if current_weight + weight_lst[selected_item] <= capacity:\n            new_solution[selected_item] = 1\n            current_weight += weight_lst[selected_item]\n\n    # Random walk: flip a few items randomly to escape local optima\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search operator that combines item swaps, insertions, and deletions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst[sol]) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    N = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to modify\n    k = min(3, N)  # Number of items to consider for modification\n    candidate_indices = np.random.choice(N, size=k, replace=False)\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no changes were made, perform a random swap\n    if np.array_equal(new_solution, base_solution):\n        if np.sum(base_solution) >= 2:\n            swap_indices = np.random.choice(np.where(base_solution == 1)[0], size=2, replace=False)\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.23565857725589895,
            5.859527766704559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst[sol]) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    N = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to modify\n    k = min(3, N)  # Number of items to consider for modification\n    candidate_indices = np.random.choice(N, size=k, replace=False)\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no changes were made, perform a random swap\n    if np.array_equal(new_solution, base_solution):\n        if np.sum(base_solution) >= 2:\n            swap_indices = np.random.choice(np.where(base_solution == 1)[0], size=2, replace=False)\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search operator that combines item swaps, flips, and adaptive perturbations to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to perturb\n    n_items = len(weight_lst)\n    perturb_size = min(5, n_items // 2)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n\n    # Adaptive flip or swap based on current state\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            # Try to remove if it's in the solution\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Try to add if it fits\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Additional swap operation for diversification\n    if len(perturb_indices) >= 2:\n        i, j = np.random.choice(perturb_indices, size=2, replace=False)\n        if (new_solution[i] == 1 and new_solution[j] == 0 and\n            total_weight - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.29583390652028213,
            2.0394529700279236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to perturb\n    n_items = len(weight_lst)\n    perturb_size = min(5, n_items // 2)\n    perturb_indices = np.random.choice(n_items, size=perturb_size, replace=False)\n\n    # Adaptive flip or swap based on current state\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            # Try to remove if it's in the solution\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Try to add if it fits\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Additional swap operation for diversification\n    if len(perturb_indices) >= 2:\n        i, j = np.random.choice(perturb_indices, size=2, replace=False)\n        if (new_solution[i] == 1 and new_solution[j] == 0 and\n            total_weight - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted random choice favoring solutions with high objective values and applies a hybrid local search that combines item swapping, perturbation, and a greedy improvement step to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = normalized_obj.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of perturbation and greedy improvement\n    num_items = len(weight_lst)\n\n    # Step 1: Random perturbation - flip a few bits\n    num_flips = min(3, num_items)  # Limit number of flips to avoid excessive changes\n    flip_indices = np.random.choice(num_items, size=num_flips, replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add item if feasible\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Greedy improvement - add items with highest marginal value\n    current_weight = np.sum(new_solution * weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal values for items not in the solution\n    marginal_value1 = value1_lst - new_solution * value1_lst\n    marginal_value2 = value2_lst - new_solution * value2_lst\n\n    # Sort items by combined marginal value (weighted sum)\n    combined_marginal = 0.5 * marginal_value1 + 0.5 * marginal_value2\n    candidate_indices = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n    sorted_candidates = sorted(candidate_indices, key=lambda x: -combined_marginal[x])\n\n    # Add items one by one if feasible\n    for idx in sorted_candidates:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Step 3: Optional - remove low-value items to free up capacity\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight < capacity:\n        # Calculate value density (value/weight) for items in the solution\n        value_density = (0.5 * value1_lst + 0.5 * value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_density)\n\n        # Remove items with lowest value density first\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8219387465403565,
            3.7226160764694214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = normalized_obj.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of perturbation and greedy improvement\n    num_items = len(weight_lst)\n\n    # Step 1: Random perturbation - flip a few bits\n    num_flips = min(3, num_items)  # Limit number of flips to avoid excessive changes\n    flip_indices = np.random.choice(num_items, size=num_flips, replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add item if feasible\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Greedy improvement - add items with highest marginal value\n    current_weight = np.sum(new_solution * weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal values for items not in the solution\n    marginal_value1 = value1_lst - new_solution * value1_lst\n    marginal_value2 = value2_lst - new_solution * value2_lst\n\n    # Sort items by combined marginal value (weighted sum)\n    combined_marginal = 0.5 * marginal_value1 + 0.5 * marginal_value2\n    candidate_indices = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n    sorted_candidates = sorted(candidate_indices, key=lambda x: -combined_marginal[x])\n\n    # Add items one by one if feasible\n    for idx in sorted_candidates:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Step 3: Optional - remove low-value items to free up capacity\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight < capacity:\n        # Calculate value density (value/weight) for items in the solution\n        value_density = (0.5 * value1_lst + 0.5 * value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_density)\n\n        # Remove items with lowest value density first\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{A novel hybrid local search approach that intelligently selects a solution from the archive based on its potential for improvement, then applies a dynamic item swapping strategy that considers both objectives and weight constraints to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items not in the solution\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Dynamic item swapping strategy\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Select a random item to remove\n        remove_idx = np.random.choice(one_indices)\n        # Select a random item to add (must fit within capacity)\n        add_candidates = [i for i in zero_indices if (current_weight - weight_lst[remove_idx] + weight_lst[i]) <= capacity]\n        if add_candidates:\n            add_idx = np.random.choice(add_candidates)\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # If no valid swap, try a different approach: flip a random bit if feasible\n    else:\n        flip_candidates = [i for i in range(len(new_solution))\n                          if (new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity)\n                          or (new_solution[i] == 1 and (current_weight - weight_lst[i]) + (np.min(weight_lst[new_solution == 0]) if len(zero_indices) > 0 else 0) <= capacity)]\n        if flip_candidates:\n            flip_idx = np.random.choice(flip_candidates)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5550272275319903,
            2.4833375215530396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items not in the solution\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Dynamic item swapping strategy\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Select a random item to remove\n        remove_idx = np.random.choice(one_indices)\n        # Select a random item to add (must fit within capacity)\n        add_candidates = [i for i in zero_indices if (current_weight - weight_lst[remove_idx] + weight_lst[i]) <= capacity]\n        if add_candidates:\n            add_idx = np.random.choice(add_candidates)\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # If no valid swap, try a different approach: flip a random bit if feasible\n    else:\n        flip_candidates = [i for i in range(len(new_solution))\n                          if (new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity)\n                          or (new_solution[i] == 1 and (current_weight - weight_lst[i]) + (np.min(weight_lst[new_solution == 0]) if len(zero_indices) > 0 else 0) <= capacity)]\n        if flip_candidates:\n            flip_idx = np.random.choice(flip_candidates)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = current_obj[0]\n    current_value2 = current_obj[1]\n\n    # Generate a neighbor by swapping a random subset of items\n    new_solution = base_solution.copy()\n    num_items = len(base_solution)\n    swap_size = min(3, num_items)  # Limit swap size to avoid excessive changes\n    swap_indices = random.sample(range(num_items), swap_size)\n\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Only add if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Perform a greedy improvement step for one objective\n    improved_solution = new_solution.copy()\n    for _ in range(2):  # Limit iterations for efficiency\n        if random.random() < 0.5:  # Alternate between objectives\n            # Greedy improvement for value1\n            for i in range(num_items):\n                if improved_solution[i] == 1:\n                    # Try removing item\n                    temp_solution = improved_solution.copy()\n                    temp_solution[i] = 0\n                    temp_weight = np.sum(weight_lst * temp_solution)\n                    if temp_weight <= capacity:\n                        improved_solution = temp_solution\n                else:\n                    # Try adding item\n                    if current_weight + weight_lst[i] <= capacity:\n                        temp_solution = improved_solution.copy()\n                        temp_solution[i] = 1\n                        improved_solution = temp_solution\n        else:\n            # Greedy improvement for value2\n            for i in range(num_items):\n                if improved_solution[i] == 1:\n                    # Try removing item\n                    temp_solution = improved_solution.copy()\n                    temp_solution[i] = 0\n                    temp_weight = np.sum(weight_lst * temp_solution)\n                    if temp_weight <= capacity:\n                        improved_solution = temp_solution\n                else:\n                    # Try adding item\n                    if current_weight + weight_lst[i] <= capacity:\n                        temp_solution = improved_solution.copy()\n                        temp_solution[i] = 1\n                        improved_solution = temp_solution\n\n    return improved_solution\n\n",
        "score": [
            -0.9577338481066451,
            6.692287415266037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = current_obj[0]\n    current_value2 = current_obj[1]\n\n    # Generate a neighbor by swapping a random subset of items\n    new_solution = base_solution.copy()\n    num_items = len(base_solution)\n    swap_size = min(3, num_items)  # Limit swap size to avoid excessive changes\n    swap_indices = random.sample(range(num_items), swap_size)\n\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Only add if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Perform a greedy improvement step for one objective\n    improved_solution = new_solution.copy()\n    for _ in range(2):  # Limit iterations for efficiency\n        if random.random() < 0.5:  # Alternate between objectives\n            # Greedy improvement for value1\n            for i in range(num_items):\n                if improved_solution[i] == 1:\n                    # Try removing item\n                    temp_solution = improved_solution.copy()\n                    temp_solution[i] = 0\n                    temp_weight = np.sum(weight_lst * temp_solution)\n                    if temp_weight <= capacity:\n                        improved_solution = temp_solution\n                else:\n                    # Try adding item\n                    if current_weight + weight_lst[i] <= capacity:\n                        temp_solution = improved_solution.copy()\n                        temp_solution[i] = 1\n                        improved_solution = temp_solution\n        else:\n            # Greedy improvement for value2\n            for i in range(num_items):\n                if improved_solution[i] == 1:\n                    # Try removing item\n                    temp_solution = improved_solution.copy()\n                    temp_solution[i] = 0\n                    temp_weight = np.sum(weight_lst * temp_solution)\n                    if temp_weight <= capacity:\n                        improved_solution = temp_solution\n                else:\n                    # Try adding item\n                    if current_weight + weight_lst[i] <= capacity:\n                        temp_solution = improved_solution.copy()\n                        temp_solution[i] = 1\n                        improved_solution = temp_solution\n\n    return improved_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping items with high marginal gains in either objective\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each item\n    marginal_gains1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_gains2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine gains (e.g., weighted sum)\n    combined_gains = 0.5 * marginal_gains1 + 0.5 * marginal_gains2\n\n    # Sort items by combined marginal gains (descending)\n    sorted_items = np.argsort(-combined_gains)\n\n    # Try flipping items in order of highest gains, ensuring feasibility\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.83506465415582,
            3.3262321650981903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping items with high marginal gains in either objective\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each item\n    marginal_gains1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_gains2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine gains (e.g., weighted sum)\n    combined_gains = 0.5 * marginal_gains1 + 0.5 * marginal_gains2\n\n    # Sort items by combined marginal gains (descending)\n    sorted_items = np.argsort(-combined_gains)\n\n    # Try flipping items in order of highest gains, ensuring feasibility\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive and applies a combination of random item swaps, value-based perturbations, and capacity-aware adjustments to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on value density (value1 + value2) / weight\n    densities = []\n    for sol, _ in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight == 0:\n            densities.append(0)\n        else:\n            total_value = np.sum(sol * (value1_lst + value2_lst))\n            densities.append(total_value / total_weight)\n\n    # Select top 3 solutions with highest density\n    top_indices = np.argsort(densities)[-3:]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor with hybrid perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random item swap (flip one random bit)\n    flip_idx = np.random.randint(n_items)\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Step 2: Value-based perturbation (flip items with low value density)\n    if np.random.random() < 0.3:\n        item_densities = (value1_lst + value2_lst) / weight_lst\n        low_density_items = np.where(new_solution & (item_densities < np.percentile(item_densities, 30)))[0]\n        if len(low_density_items) > 0:\n            flip_idx = np.random.choice(low_density_items)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Step 3: Capacity adjustment (if overweight, remove random item)\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        overweight_items = np.where(new_solution)[0]\n        if len(overweight_items) > 0:\n            remove_idx = np.random.choice(overweight_items)\n            new_solution[remove_idx] = 0\n\n    # Step 4: Random item addition (if underweight)\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight < capacity and np.random.random() < 0.5:\n        candidate_items = np.where(~new_solution)[0]\n        if len(candidate_items) > 0:\n            add_idx = np.random.choice(candidate_items)\n            if total_weight + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3138456739207994,
            7.723088353872299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on value density (value1 + value2) / weight\n    densities = []\n    for sol, _ in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight == 0:\n            densities.append(0)\n        else:\n            total_value = np.sum(sol * (value1_lst + value2_lst))\n            densities.append(total_value / total_weight)\n\n    # Select top 3 solutions with highest density\n    top_indices = np.argsort(densities)[-3:]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor with hybrid perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random item swap (flip one random bit)\n    flip_idx = np.random.randint(n_items)\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Step 2: Value-based perturbation (flip items with low value density)\n    if np.random.random() < 0.3:\n        item_densities = (value1_lst + value2_lst) / weight_lst\n        low_density_items = np.where(new_solution & (item_densities < np.percentile(item_densities, 30)))[0]\n        if len(low_density_items) > 0:\n            flip_idx = np.random.choice(low_density_items)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Step 3: Capacity adjustment (if overweight, remove random item)\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        overweight_items = np.where(new_solution)[0]\n        if len(overweight_items) > 0:\n            remove_idx = np.random.choice(overweight_items)\n            new_solution[remove_idx] = 0\n\n    # Step 4: Random item addition (if underweight)\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight < capacity and np.random.random() < 0.5:\n        candidate_items = np.where(~new_solution)[0]\n        if len(candidate_items) > 0:\n            add_idx = np.random.choice(candidate_items)\n            if total_weight + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swaps and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the range of objectives\n        obj1_values = [obj[0] for _, obj in archive]\n        obj2_values = [obj[1] for _, obj in archive]\n        obj1_range = max(obj1_values) - min(obj1_values)\n        obj2_range = max(obj2_values) - min(obj2_values)\n\n        # Select a solution that is not too extreme in either objective\n        candidates = []\n        for sol, obj in archive:\n            # Normalize the objectives to [0, 1] range\n            norm_obj1 = (obj[0] - min(obj1_values)) / (obj1_range + 1e-10)\n            norm_obj2 = (obj[1] - min(obj2_values)) / (obj2_range + 1e-10)\n            # Prefer solutions that are in the middle of the Pareto front\n            score = abs(norm_obj1 - norm_obj2)\n            candidates.append((score, sol))\n\n        # Sort by score and select the one with the highest score (most balanced)\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        base_solution = candidates[0][1].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: combine item swaps and adaptive neighborhood exploration\n    # First, perform a random swap of two items (if possible)\n    if n_items >= 2:\n        # Select two distinct random items\n        item1, item2 = random.sample(range(n_items), 2)\n\n        # Perform the swap\n        new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n        # Check feasibility and revert if necessary\n        total_weight = np.sum(new_solution * weight_lst)\n        if total_weight > capacity:\n            # Revert the swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            total_weight = np.sum(new_solution * weight_lst)\n\n        # If the swap didn't help, try adaptive neighborhood exploration\n        if new_solution[item1] == base_solution[item1] and new_solution[item2] == base_solution[item2]:\n            # Try adding or removing items based on their marginal contribution\n            # Calculate marginal contribution for each item\n            marginal_contribution1 = value1_lst / (weight_lst + 1e-10)\n            marginal_contribution2 = value2_lst / (weight_lst + 1e-10)\n            marginal_contribution = marginal_contribution1 + marginal_contribution2\n\n            # Sort items by marginal contribution (descending)\n            sorted_items = np.argsort(marginal_contribution)[::-1]\n\n            # Try adding the highest-contribution item if it fits\n            for item in sorted_items:\n                if new_solution[item] == 0:\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        break\n\n            # If no addition was possible, try removing the lowest-contribution item\n            if np.sum(new_solution) == np.sum(base_solution):\n                for item in sorted_items[::-1]:\n                    if new_solution[item] == 1:\n                        new_solution[item] = 0\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7849229026109765,
            2.2753198444843292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the range of objectives\n        obj1_values = [obj[0] for _, obj in archive]\n        obj2_values = [obj[1] for _, obj in archive]\n        obj1_range = max(obj1_values) - min(obj1_values)\n        obj2_range = max(obj2_values) - min(obj2_values)\n\n        # Select a solution that is not too extreme in either objective\n        candidates = []\n        for sol, obj in archive:\n            # Normalize the objectives to [0, 1] range\n            norm_obj1 = (obj[0] - min(obj1_values)) / (obj1_range + 1e-10)\n            norm_obj2 = (obj[1] - min(obj2_values)) / (obj2_range + 1e-10)\n            # Prefer solutions that are in the middle of the Pareto front\n            score = abs(norm_obj1 - norm_obj2)\n            candidates.append((score, sol))\n\n        # Sort by score and select the one with the highest score (most balanced)\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        base_solution = candidates[0][1].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: combine item swaps and adaptive neighborhood exploration\n    # First, perform a random swap of two items (if possible)\n    if n_items >= 2:\n        # Select two distinct random items\n        item1, item2 = random.sample(range(n_items), 2)\n\n        # Perform the swap\n        new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n        # Check feasibility and revert if necessary\n        total_weight = np.sum(new_solution * weight_lst)\n        if total_weight > capacity:\n            # Revert the swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            total_weight = np.sum(new_solution * weight_lst)\n\n        # If the swap didn't help, try adaptive neighborhood exploration\n        if new_solution[item1] == base_solution[item1] and new_solution[item2] == base_solution[item2]:\n            # Try adding or removing items based on their marginal contribution\n            # Calculate marginal contribution for each item\n            marginal_contribution1 = value1_lst / (weight_lst + 1e-10)\n            marginal_contribution2 = value2_lst / (weight_lst + 1e-10)\n            marginal_contribution = marginal_contribution1 + marginal_contribution2\n\n            # Sort items by marginal contribution (descending)\n            sorted_items = np.argsort(marginal_contribution)[::-1]\n\n            # Try adding the highest-contribution item if it fits\n            for item in sorted_items:\n                if new_solution[item] == 0:\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        break\n\n            # If no addition was possible, try removing the lowest-contribution item\n            if np.sum(new_solution) == np.sum(base_solution):\n                for item in sorted_items[::-1]:\n                    if new_solution[item] == 1:\n                        new_solution[item] = 0\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by prioritizing solutions with the highest combined normalized objective values, then applies a novel hybrid local search that combines item swapping, random flips, and a directed perturbation step to explore high-quality neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = base_solution.copy()\n\n    # Hybrid local search steps\n    # Step 1: Item swapping (swap two items if feasible)\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 1 and len(items_out) > 0:\n        i, j = random.sample(list(items_in), 2)\n        k = random.choice(items_out)\n\n        # Check feasibility of swap\n        delta_weight = weight_lst[k] - weight_lst[i] - weight_lst[j]\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j], new_solution[k] = 0, 0, 1\n\n    # Step 2: Random flip (flip a random item if feasible)\n    if random.random() < 0.3:  # 30% chance\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Directed perturbation (flip items with high marginal value)\n    if random.random() < 0.5:  # 50% chance\n        # Calculate marginal values\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Sort items by combined marginal value\n        sorted_items = np.argsort(-combined_marginal)\n\n        # Flip top k items (k determined by problem size)\n        k = max(1, len(sorted_items) // 10)\n        for idx in sorted_items[:k]:\n            if new_solution[idx] == 1:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4377054944280682,
            2.5236408412456512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = base_solution.copy()\n\n    # Hybrid local search steps\n    # Step 1: Item swapping (swap two items if feasible)\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 1 and len(items_out) > 0:\n        i, j = random.sample(list(items_in), 2)\n        k = random.choice(items_out)\n\n        # Check feasibility of swap\n        delta_weight = weight_lst[k] - weight_lst[i] - weight_lst[j]\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j], new_solution[k] = 0, 0, 1\n\n    # Step 2: Random flip (flip a random item if feasible)\n    if random.random() < 0.3:  # 30% chance\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Directed perturbation (flip items with high marginal value)\n    if random.random() < 0.5:  # 50% chance\n        # Calculate marginal values\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Sort items by combined marginal value\n        sorted_items = np.argsort(-combined_marginal)\n\n        # Flip top k items (k determined by problem size)\n        k = max(1, len(sorted_items) // 10)\n        for idx in sorted_items[:k]:\n            if new_solution[idx] == 1:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search strategy combining item swaps and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in objective space)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to flip (adaptive size based on solution size)\n    flip_size = max(1, int(np.random.normal(len(base_solution) * 0.1, len(base_solution) * 0.05)))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    # Step 2: Flip the selected items and ensure feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Apply a secondary local search (e.g., swap items with high marginal gains)\n    marginal_gains = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_gains)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Try to add the highest marginal gain item\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.2832750645556399,
            2.6013675332069397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in objective space)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to flip (adaptive size based on solution size)\n    flip_size = max(1, int(np.random.normal(len(base_solution) * 0.1, len(base_solution) * 0.05)))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    # Step 2: Flip the selected items and ensure feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Apply a secondary local search (e.g., swap items with high marginal gains)\n    marginal_gains = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_gains)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Try to add the highest marginal gain item\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search operator that combines item swapping and random perturbation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest sum of normalized objectives (promising potential)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high marginal contribution and random perturbation\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    zero_indices = np.where(base_solution == 0)[0]\n    one_indices = np.where(base_solution == 1)[0]\n\n    # Swap one item with high marginal contribution\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Calculate marginal contributions for zero items\n        marginal_contribs = []\n        for idx in zero_indices:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                marginal_contribs.append((value1_lst[idx] + value2_lst[idx]) / weight_lst[idx])\n            else:\n                marginal_contribs.append(-np.inf)\n\n        if any(m > -np.inf for m in marginal_contribs):\n            best_zero_idx = zero_indices[np.argmax(marginal_contribs)]\n            new_solution[best_zero_idx] = 1\n\n            # Remove one item with low marginal contribution\n            if len(one_indices) > 1:\n                marginal_contribs = []\n                for idx in one_indices:\n                    new_weight = current_weight - weight_lst[idx]\n                    if new_weight >= 0:\n                        marginal_contribs.append((value1_lst[idx] + value2_lst[idx]) / weight_lst[idx])\n                    else:\n                        marginal_contribs.append(np.inf)\n\n                if any(m < np.inf for m in marginal_contribs):\n                    worst_one_idx = one_indices[np.argmin(marginal_contribs)]\n                    new_solution[worst_one_idx] = 0\n\n    # Random perturbation: flip a small number of bits (1-3) to explore neighborhood\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        flip_count = random.randint(1, min(3, len(zero_indices), len(one_indices)))\n        for _ in range(flip_count):\n            # Select a random item to flip\n            if random.random() < 0.5 and len(zero_indices) > 0:\n                flip_idx = random.choice(zero_indices)\n                new_weight = current_weight + weight_lst[flip_idx]\n                if new_weight <= capacity:\n                    new_solution[flip_idx] = 1\n                    current_weight = new_weight\n            elif len(one_indices) > 0:\n                flip_idx = random.choice(one_indices)\n                new_weight = current_weight - weight_lst[flip_idx]\n                if new_weight >= 0:\n                    new_solution[flip_idx] = 0\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.29153746590854906,
            4.657456874847412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest sum of normalized objectives (promising potential)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high marginal contribution and random perturbation\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    zero_indices = np.where(base_solution == 0)[0]\n    one_indices = np.where(base_solution == 1)[0]\n\n    # Swap one item with high marginal contribution\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Calculate marginal contributions for zero items\n        marginal_contribs = []\n        for idx in zero_indices:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                marginal_contribs.append((value1_lst[idx] + value2_lst[idx]) / weight_lst[idx])\n            else:\n                marginal_contribs.append(-np.inf)\n\n        if any(m > -np.inf for m in marginal_contribs):\n            best_zero_idx = zero_indices[np.argmax(marginal_contribs)]\n            new_solution[best_zero_idx] = 1\n\n            # Remove one item with low marginal contribution\n            if len(one_indices) > 1:\n                marginal_contribs = []\n                for idx in one_indices:\n                    new_weight = current_weight - weight_lst[idx]\n                    if new_weight >= 0:\n                        marginal_contribs.append((value1_lst[idx] + value2_lst[idx]) / weight_lst[idx])\n                    else:\n                        marginal_contribs.append(np.inf)\n\n                if any(m < np.inf for m in marginal_contribs):\n                    worst_one_idx = one_indices[np.argmin(marginal_contribs)]\n                    new_solution[worst_one_idx] = 0\n\n    # Random perturbation: flip a small number of bits (1-3) to explore neighborhood\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        flip_count = random.randint(1, min(3, len(zero_indices), len(one_indices)))\n        for _ in range(flip_count):\n            # Select a random item to flip\n            if random.random() < 0.5 and len(zero_indices) > 0:\n                flip_idx = random.choice(zero_indices)\n                new_weight = current_weight + weight_lst[flip_idx]\n                if new_weight <= capacity:\n                    new_solution[flip_idx] = 1\n                    current_weight = new_weight\n            elif len(one_indices) > 0:\n                flip_idx = random.choice(one_indices)\n                new_weight = current_weight - weight_lst[flip_idx]\n                if new_weight >= 0:\n                    new_solution[flip_idx] = 0\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{A novel local search heuristic that combines adaptive item swapping with objective-aware perturbation to explore the solution space while maintaining feasibility, prioritizing solutions with high marginal gains in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Compute the total weight and objectives for each solution in the archive\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the marginal gains (per unit weight) for each objective\n    marginal_gains1 = np.array([v1 / w if w > 0 else 0 for v1, w in zip(value1_lst, weight_lst)])\n    marginal_gains2 = np.array([v2 / w if w > 0 else 0 for v2, w in zip(value2_lst, weight_lst)])\n\n    # Select the solution with the highest combined marginal gain potential\n    selected_idx = np.argmax([np.sum(sol * marginal_gains1) + np.sum(sol * marginal_gains2) for sol in archive_solutions])\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(base_solution * weight_lst)\n\n    # Generate a neighbor by flipping items with high marginal gains while maintaining feasibility\n    new_solution = base_solution.copy()\n    candidate_items = np.where(new_solution == 0)[0]  # Items not in the solution\n    if len(candidate_items) > 0:\n        # Select items with high marginal gains that can be added without exceeding capacity\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Apply a perturbation: flip a random item in the solution to escape local optima\n    items_in_solution = np.where(new_solution == 1)[0]\n    if len(items_in_solution) > 0:\n        random_item = np.random.choice(items_in_solution)\n        new_solution[random_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9447993700265374,
            5.278193950653076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Compute the total weight and objectives for each solution in the archive\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the marginal gains (per unit weight) for each objective\n    marginal_gains1 = np.array([v1 / w if w > 0 else 0 for v1, w in zip(value1_lst, weight_lst)])\n    marginal_gains2 = np.array([v2 / w if w > 0 else 0 for v2, w in zip(value2_lst, weight_lst)])\n\n    # Select the solution with the highest combined marginal gain potential\n    selected_idx = np.argmax([np.sum(sol * marginal_gains1) + np.sum(sol * marginal_gains2) for sol in archive_solutions])\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(base_solution * weight_lst)\n\n    # Generate a neighbor by flipping items with high marginal gains while maintaining feasibility\n    new_solution = base_solution.copy()\n    candidate_items = np.where(new_solution == 0)[0]  # Items not in the solution\n    if len(candidate_items) > 0:\n        # Select items with high marginal gains that can be added without exceeding capacity\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Apply a perturbation: flip a random item in the solution to escape local optima\n    items_in_solution = np.where(new_solution == 1)[0]\n    if len(items_in_solution) > 0:\n        random_item = np.random.choice(items_in_solution)\n        new_solution[random_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high marginal gains in either objective space, then applies a hybrid local search combining random item swaps and targeted flips to balance exploration and exploitation while ensuring feasibility through weight checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([sum(archive[i][0] * weight_lst) for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and targeted flips\n    for _ in range(5):  # Number of attempts\n        # Random swap\n        swap_indices = np.random.choice(np.where(base_solution == 1)[0], size=min(2, len(np.where(base_solution == 1)[0])), replace=False)\n        if len(swap_indices) == 2:\n            temp = new_solution[swap_indices[0]]\n            new_solution[swap_indices[0]] = new_solution[swap_indices[1]]\n            new_solution[swap_indices[1]] = temp\n\n        # Check feasibility\n        if sum(new_solution * weight_lst) > capacity:\n            new_solution = base_solution.copy()\n            continue\n\n        # Targeted flip: add an item if space allows\n        zero_indices = np.where(new_solution == 0)[0]\n        if len(zero_indices) > 0:\n            candidate = np.random.choice(zero_indices)\n            if sum(new_solution * weight_lst) + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8474443804715356,
            8.01596286892891
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([sum(archive[i][0] * weight_lst) for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and targeted flips\n    for _ in range(5):  # Number of attempts\n        # Random swap\n        swap_indices = np.random.choice(np.where(base_solution == 1)[0], size=min(2, len(np.where(base_solution == 1)[0])), replace=False)\n        if len(swap_indices) == 2:\n            temp = new_solution[swap_indices[0]]\n            new_solution[swap_indices[0]] = new_solution[swap_indices[1]]\n            new_solution[swap_indices[1]] = temp\n\n        # Check feasibility\n        if sum(new_solution * weight_lst) > capacity:\n            new_solution = base_solution.copy()\n            continue\n\n        # Targeted flip: add an item if space allows\n        zero_indices = np.where(new_solution == 0)[0]\n        if len(zero_indices) > 0:\n            candidate = np.random.choice(zero_indices)\n            if sum(new_solution * weight_lst) + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst))\n        normalized_objectives.append((sol, normalized_obj))\n    best_sol, _ = max(normalized_objectives, key=lambda x: sum(x[1]))\n    base_solution = best_sol.copy()\n\n    # Generate a neighbor by flipping items with high marginal utility\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal utility for each item\n    marginal_utilities = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # Utility of removing item i\n            utility = (value1_lst[i] / np.max(value1_lst)) + (value2_lst[i] / np.max(value2_lst))\n            marginal_utilities.append((i, -utility, weight_lst[i]))\n        else:\n            # Utility of adding item i if feasible\n            if total_weight + weight_lst[i] <= capacity:\n                utility = (value1_lst[i] / np.max(value1_lst)) + (value2_lst[i] / np.max(value2_lst))\n                marginal_utilities.append((i, utility, weight_lst[i]))\n            else:\n                marginal_utilities.append((i, 0, 0))\n\n    # Select top 3 items with highest marginal utility\n    marginal_utilities.sort(key=lambda x: abs(x[1]), reverse=True)\n    selected_items = [x[0] for x in marginal_utilities[:3]]\n\n    # Flip the selected items\n    for i in selected_items:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with lowest utility until feasible\n        while total_weight > capacity:\n            # Find item with lowest utility in the knapsack\n            in_knapsack = np.where(new_solution == 1)[0]\n            if len(in_knapsack) == 0:\n                break\n            utilities = [(i, (value1_lst[i] / np.max(value1_lst)) + (value2_lst[i] / np.max(value2_lst))) for i in in_knapsack]\n            i_to_remove = min(utilities, key=lambda x: x[1])[0]\n            new_solution[i_to_remove] = 0\n            total_weight -= weight_lst[i_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.8970160501668238,
            8.503541827201843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst))\n        normalized_objectives.append((sol, normalized_obj))\n    best_sol, _ = max(normalized_objectives, key=lambda x: sum(x[1]))\n    base_solution = best_sol.copy()\n\n    # Generate a neighbor by flipping items with high marginal utility\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal utility for each item\n    marginal_utilities = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # Utility of removing item i\n            utility = (value1_lst[i] / np.max(value1_lst)) + (value2_lst[i] / np.max(value2_lst))\n            marginal_utilities.append((i, -utility, weight_lst[i]))\n        else:\n            # Utility of adding item i if feasible\n            if total_weight + weight_lst[i] <= capacity:\n                utility = (value1_lst[i] / np.max(value1_lst)) + (value2_lst[i] / np.max(value2_lst))\n                marginal_utilities.append((i, utility, weight_lst[i]))\n            else:\n                marginal_utilities.append((i, 0, 0))\n\n    # Select top 3 items with highest marginal utility\n    marginal_utilities.sort(key=lambda x: abs(x[1]), reverse=True)\n    selected_items = [x[0] for x in marginal_utilities[:3]]\n\n    # Flip the selected items\n    for i in selected_items:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with lowest utility until feasible\n        while total_weight > capacity:\n            # Find item with lowest utility in the knapsack\n            in_knapsack = np.where(new_solution == 1)[0]\n            if len(in_knapsack) == 0:\n                break\n            utilities = [(i, (value1_lst[i] / np.max(value1_lst)) + (value2_lst[i] / np.max(value2_lst))) for i in in_knapsack]\n            i_to_remove = min(utilities, key=lambda x: x[1])[0]\n            new_solution[i_to_remove] = 0\n            total_weight -= weight_lst[i_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{The novel local search algorithm intelligently selects a promising solution from the archive, identifies critical items via a hybrid of diversity-aware and objective-space analysis, and performs a multi-directional flip operation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (prioritize solutions with high diversity or potential)\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Identify critical items (high value-to-weight ratio or diverse items)\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Calculate value-to-weight ratios for included items\n    if len(included_items) > 0:\n        val1_ratio = value1_lst[included_items] / weight_lst[included_items]\n        val2_ratio = value2_lst[included_items] / weight_lst[included_items]\n        critical_items = included_items[np.logical_or(val1_ratio > np.median(val1_ratio), val2_ratio > np.median(val2_ratio))]\n    else:\n        critical_items = []\n\n    # Step 3: Hybrid local search operation\n    # Flip a critical item (if any) or a random item to create diversity\n    if len(critical_items) > 0:\n        flip_item = random.choice(critical_items)\n    elif len(excluded_items) > 0:\n        flip_item = random.choice(excluded_items)\n    else:\n        flip_item = random.choice(included_items)\n\n    # Flip the selected item\n    new_solution[flip_item] = 1 - new_solution[flip_item]\n\n    # Ensure feasibility by checking weight constraint\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If infeasible, try to remove items until feasible\n        while current_weight > capacity and np.sum(new_solution) > 0:\n            # Remove the item with the lowest value-to-weight ratio\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            val1_ratio = value1_lst[included_items] / weight_lst[included_items]\n            val2_ratio = value2_lst[included_items] / weight_lst[included_items]\n            combined_ratio = val1_ratio + val2_ratio\n            remove_item = included_items[np.argmin(combined_ratio)]\n            new_solution[remove_item] = 0\n            current_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.8473774688267119,
            1.5544203519821167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (prioritize solutions with high diversity or potential)\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Identify critical items (high value-to-weight ratio or diverse items)\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Calculate value-to-weight ratios for included items\n    if len(included_items) > 0:\n        val1_ratio = value1_lst[included_items] / weight_lst[included_items]\n        val2_ratio = value2_lst[included_items] / weight_lst[included_items]\n        critical_items = included_items[np.logical_or(val1_ratio > np.median(val1_ratio), val2_ratio > np.median(val2_ratio))]\n    else:\n        critical_items = []\n\n    # Step 3: Hybrid local search operation\n    # Flip a critical item (if any) or a random item to create diversity\n    if len(critical_items) > 0:\n        flip_item = random.choice(critical_items)\n    elif len(excluded_items) > 0:\n        flip_item = random.choice(excluded_items)\n    else:\n        flip_item = random.choice(included_items)\n\n    # Flip the selected item\n    new_solution[flip_item] = 1 - new_solution[flip_item]\n\n    # Ensure feasibility by checking weight constraint\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If infeasible, try to remove items until feasible\n        while current_weight > capacity and np.sum(new_solution) > 0:\n            # Remove the item with the lowest value-to-weight ratio\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            val1_ratio = value1_lst[included_items] / weight_lst[included_items]\n            val2_ratio = value2_lst[included_items] / weight_lst[included_items]\n            combined_ratio = val1_ratio + val2_ratio\n            remove_item = included_items[np.argmin(combined_ratio)]\n            new_solution[remove_item] = 0\n            current_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on its potential for improvement, then applies a creative combination of item swaps, insertions, and deletions to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[0]) * (1 + random.random() * 0.1))  # Add randomness to avoid local optima\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combination of swap, insertion, and deletion\n    for _ in range(10):  # Number of attempts to improve\n        # Randomly select an operation\n        operation = random.choice(['swap', 'insert', 'delete'])\n\n        if operation == 'swap':\n            # Swap two items\n            indices = np.where(new_solution == 1)[0]\n            if len(indices) >= 2:\n                i, j = random.sample(list(indices), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'insert':\n            # Insert a new item if feasible\n            indices = np.where(new_solution == 0)[0]\n            if len(indices) > 0:\n                i = random.choice(indices)\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n        elif operation == 'delete':\n            # Delete an item\n            indices = np.where(new_solution == 1)[0]\n            if len(indices) > 0:\n                i = random.choice(indices)\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n        # Ensure feasibility\n        if np.sum(weight_lst[new_solution == 1]) > capacity:\n            # If not feasible, revert to base solution\n            new_solution = base_solution.copy()\n            current_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.30931875737560616,
            3.803946018218994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[0]) * (1 + random.random() * 0.1))  # Add randomness to avoid local optima\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combination of swap, insertion, and deletion\n    for _ in range(10):  # Number of attempts to improve\n        # Randomly select an operation\n        operation = random.choice(['swap', 'insert', 'delete'])\n\n        if operation == 'swap':\n            # Swap two items\n            indices = np.where(new_solution == 1)[0]\n            if len(indices) >= 2:\n                i, j = random.sample(list(indices), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'insert':\n            # Insert a new item if feasible\n            indices = np.where(new_solution == 0)[0]\n            if len(indices) > 0:\n                i = random.choice(indices)\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n        elif operation == 'delete':\n            # Delete an item\n            indices = np.where(new_solution == 1)[0]\n            if len(indices) > 0:\n                i = random.choice(indices)\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n        # Ensure feasibility\n        if np.sum(weight_lst[new_solution == 1]) > capacity:\n            # If not feasible, revert to base solution\n            new_solution = base_solution.copy()\n            current_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping items in a way that balances both objectives\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items to potentially flip (either add or remove)\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # Remove a random item to free up capacity\n        remove_idx = np.random.choice(candidate_indices)\n        new_solution[remove_idx] = 0\n        total_weight -= weight_lst[remove_idx]\n\n        # Add items that improve both objectives while respecting capacity\n        available_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(available_items)\n        for idx in available_items:\n            if total_weight + weight_lst[idx] <= capacity:\n                # Check if adding this item improves both objectives\n                if (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    # If no items were removed, try adding items\n    else:\n        available_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(available_items)\n        for idx in available_items:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3007174551166004,
            7.88363054394722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping items in a way that balances both objectives\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items to potentially flip (either add or remove)\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # Remove a random item to free up capacity\n        remove_idx = np.random.choice(candidate_indices)\n        new_solution[remove_idx] = 0\n        total_weight -= weight_lst[remove_idx]\n\n        # Add items that improve both objectives while respecting capacity\n        available_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(available_items)\n        for idx in available_items:\n            if total_weight + weight_lst[idx] <= capacity:\n                # Check if adding this item improves both objectives\n                if (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    # If no items were removed, try adding items\n    else:\n        available_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(available_items)\n        for idx in available_items:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{A novel hybrid local search operator combines adaptive item swapping and probabilistic item flipping, guided by objective-specific dominance probabilities, to intelligently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Adaptive item swapping\n    for _ in range(2):  # Perform 2 swaps\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Select items to swap based on objective dominance\n            item_in = random.choice(items_in)\n            item_out = random.choice(items_out)\n\n            # Calculate potential new values\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n            if new_weight <= capacity:\n                # Calculate potential objective improvements\n                val1_diff = value1_lst[item_out] - value1_lst[item_in]\n                val2_diff = value2_lst[item_out] - value2_lst[item_in]\n\n                # Accept swap if it improves at least one objective\n                if val1_diff > 0 or val2_diff > 0:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n    # Step 2: Probabilistic item flipping\n    for item in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip each item\n            if new_solution[item] == 1:\n                # Try removing the item\n                new_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n            else:\n                # Try adding the item\n                new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[item]\n                if new_weight <= capacity:\n                    # Accept with probability based on objective improvement\n                    val1_improve = value1_lst[item] / np.sum(value1_lst)\n                    val2_improve = value2_lst[item] / np.sum(value2_lst)\n                    if random.random() < (val1_improve + val2_improve) / 2:\n                        new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.863798464820855,
            9.260820627212524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Adaptive item swapping\n    for _ in range(2):  # Perform 2 swaps\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Select items to swap based on objective dominance\n            item_in = random.choice(items_in)\n            item_out = random.choice(items_out)\n\n            # Calculate potential new values\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n            if new_weight <= capacity:\n                # Calculate potential objective improvements\n                val1_diff = value1_lst[item_out] - value1_lst[item_in]\n                val2_diff = value2_lst[item_out] - value2_lst[item_in]\n\n                # Accept swap if it improves at least one objective\n                if val1_diff > 0 or val2_diff > 0:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n\n    # Step 2: Probabilistic item flipping\n    for item in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip each item\n            if new_solution[item] == 1:\n                # Try removing the item\n                new_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n            else:\n                # Try adding the item\n                new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[item]\n                if new_weight <= capacity:\n                    # Accept with probability based on objective improvement\n                    val1_improve = value1_lst[item] / np.sum(value1_lst)\n                    val2_improve = value2_lst[item] / np.sum(value2_lst)\n                    if random.random() < (val1_improve + val2_improve) / 2:\n                        new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{A novel local search heuristic that intelligently selects a solution from the archive, applies a hybrid of adaptive bit-flipping and item swapping to explore promising regions while ensuring feasibility, and prioritizes solutions with high potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a hybrid of objective diversity and potential improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst[sol.astype(bool)])\n        potential_v1 = v1 + np.sum(value1_lst[~sol.astype(bool)])\n        potential_v2 = v2 + np.sum(value2_lst[~sol.astype(bool)])\n        candidates.append((sol, v1, v2, potential_v1, potential_v2, total_weight))\n\n    # Sort by a combination of objective diversity and potential improvement\n    candidates.sort(key=lambda x: (x[3] - x[1]) + (x[4] - x[2]), reverse=True)\n    base_solution = candidates[0][0].copy()\n\n    # Generate neighbor using a hybrid of adaptive bit-flipping and item swapping\n    new_solution = base_solution.copy()\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Adaptive bit-flipping: flip items with high marginal utility\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Calculate marginal utility for items in knapsack\n        marginal_v1_in = value1_lst[items_in]\n        marginal_v2_in = value2_lst[items_in]\n        total_v1_in = np.sum(marginal_v1_in)\n        total_v2_in = np.sum(marginal_v2_in)\n\n        # Calculate marginal utility for items not in knapsack\n        marginal_v1_out = value1_lst[items_out]\n        marginal_v2_out = value2_lst[items_out]\n\n        # Select items to flip based on marginal utility and weight\n        flip_candidates = []\n        for i in items_in:\n            if total_v1_in - value1_lst[i] + np.sum(marginal_v1_out) > total_v1_in and \\\n               total_v2_in - value2_lst[i] + np.sum(marginal_v2_out) > total_v2_in:\n                flip_candidates.append(i)\n\n        if flip_candidates:\n            flip_item = random.choice(flip_candidates)\n            new_solution[flip_item] = 0\n\n        # Add an item if possible\n        add_candidates = []\n        current_weight = np.sum(weight_lst[new_solution.astype(bool)])\n        for i in items_out:\n            if current_weight + weight_lst[i] <= capacity:\n                add_candidates.append(i)\n\n        if add_candidates:\n            add_item = random.choice(add_candidates)\n            new_solution[add_item] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution.astype(bool)]) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) > 0:\n            remove_item = random.choice(items_in)\n            new_solution[remove_item] = 0\n        else:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8774925168126143,
            9.82728961110115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a hybrid of objective diversity and potential improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst[sol.astype(bool)])\n        potential_v1 = v1 + np.sum(value1_lst[~sol.astype(bool)])\n        potential_v2 = v2 + np.sum(value2_lst[~sol.astype(bool)])\n        candidates.append((sol, v1, v2, potential_v1, potential_v2, total_weight))\n\n    # Sort by a combination of objective diversity and potential improvement\n    candidates.sort(key=lambda x: (x[3] - x[1]) + (x[4] - x[2]), reverse=True)\n    base_solution = candidates[0][0].copy()\n\n    # Generate neighbor using a hybrid of adaptive bit-flipping and item swapping\n    new_solution = base_solution.copy()\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Adaptive bit-flipping: flip items with high marginal utility\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Calculate marginal utility for items in knapsack\n        marginal_v1_in = value1_lst[items_in]\n        marginal_v2_in = value2_lst[items_in]\n        total_v1_in = np.sum(marginal_v1_in)\n        total_v2_in = np.sum(marginal_v2_in)\n\n        # Calculate marginal utility for items not in knapsack\n        marginal_v1_out = value1_lst[items_out]\n        marginal_v2_out = value2_lst[items_out]\n\n        # Select items to flip based on marginal utility and weight\n        flip_candidates = []\n        for i in items_in:\n            if total_v1_in - value1_lst[i] + np.sum(marginal_v1_out) > total_v1_in and \\\n               total_v2_in - value2_lst[i] + np.sum(marginal_v2_out) > total_v2_in:\n                flip_candidates.append(i)\n\n        if flip_candidates:\n            flip_item = random.choice(flip_candidates)\n            new_solution[flip_item] = 0\n\n        # Add an item if possible\n        add_candidates = []\n        current_weight = np.sum(weight_lst[new_solution.astype(bool)])\n        for i in items_out:\n            if current_weight + weight_lst[i] <= capacity:\n                add_candidates.append(i)\n\n        if add_candidates:\n            add_item = random.choice(add_candidates)\n            new_solution[add_item] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution.astype(bool)]) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) > 0:\n            remove_item = random.choice(items_in)\n            new_solution[remove_item] = 0\n        else:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its dominance and diversity, then applies a hybrid local search combining item swapping, flipping, and guided random walks to explore high-potential regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias toward higher-value items\n    scores = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores) / sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap, flip, and guided random walk\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Item swapping (swap two items if feasible)\n    for _ in range(10):\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) * (base_solution[i] - base_solution[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n                break\n\n    # Step 2: Item flipping (flip a random item if feasible)\n    for _ in range(5):\n        i = random.randint(0, n_items - 1)\n        delta_weight = weight_lst[i] * (1 - 2 * base_solution[i])\n        if current_weight + delta_weight <= capacity:\n            new_solution[i] = 1 - new_solution[i]\n            current_weight += delta_weight\n            break\n\n    # Step 3: Guided random walk (add/remove high-value items)\n    for _ in range(3):\n        # Select high-value items not in solution\n        candidates = [i for i in range(n_items) if not base_solution[i] and weight_lst[i] <= capacity - current_weight]\n        if candidates:\n            i = random.choice(candidates)\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n        # Select low-weight items in solution to remove\n        candidates = [i for i in range(n_items) if base_solution[i] and weight_lst[i] <= capacity - current_weight]\n        if candidates:\n            i = random.choice(candidates)\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4052416439322184,
            3.493188977241516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias toward higher-value items\n    scores = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores) / sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap, flip, and guided random walk\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Item swapping (swap two items if feasible)\n    for _ in range(10):\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) * (base_solution[i] - base_solution[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n                break\n\n    # Step 2: Item flipping (flip a random item if feasible)\n    for _ in range(5):\n        i = random.randint(0, n_items - 1)\n        delta_weight = weight_lst[i] * (1 - 2 * base_solution[i])\n        if current_weight + delta_weight <= capacity:\n            new_solution[i] = 1 - new_solution[i]\n            current_weight += delta_weight\n            break\n\n    # Step 3: Guided random walk (add/remove high-value items)\n    for _ in range(3):\n        # Select high-value items not in solution\n        candidates = [i for i in range(n_items) if not base_solution[i] and weight_lst[i] <= capacity - current_weight]\n        if candidates:\n            i = random.choice(candidates)\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n        # Select low-weight items in solution to remove\n        candidates = [i for i in range(n_items) if base_solution[i] and weight_lst[i] <= capacity - current_weight]\n        if candidates:\n            i = random.choice(candidates)\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine item swaps and random flips with probability-based selection\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to swap (2 to 4 items)\n    swap_size = np.random.randint(2, 5)\n    swap_indices = np.random.choice(len(base_solution), size=swap_size, replace=False)\n\n    for idx in swap_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Randomly flip a small number of items (1 to 3) to escape local optima\n    flip_size = np.random.randint(1, 4)\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4019156221911876,
            1.8155916035175323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine item swaps and random flips with probability-based selection\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to swap (2 to 4 items)\n    swap_size = np.random.randint(2, 5)\n    swap_indices = np.random.choice(len(base_solution), size=swap_size, replace=False)\n\n    for idx in swap_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Randomly flip a small number of items (1 to 3) to escape local optima\n    flip_size = np.random.randint(1, 4)\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid local search strategy that combines randomness with adaptive neighborhood exploration, then applies a novel \"value-balanced flip\" operator to generate a neighbor solution by flipping items based on their marginal contributions to both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here, we select a random solution with a bias towards higher total value)\n    selected_idx = np.random.choice(len(archive), p=np.array([(sol[1][0] + sol[1][1]) / (sum(sol[1][0] + sol[1][1] for sol in archive) + 1e-6) for sol in archive]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify items that can be flipped (either included or excluded without violating capacity)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Candidate items for flipping: prioritize items with high marginal contribution to both objectives\n    candidate_items = []\n    for item in included_items:\n        if current_weight - weight_lst[item] >= 0:\n            candidate_items.append((item, -1))  # -1 means exclude\n    for item in excluded_items:\n        if current_weight + weight_lst[item] <= capacity:\n            candidate_items.append((item, 1))  # 1 means include\n\n    if not candidate_items:\n        return new_solution\n\n    # Select a candidate with high marginal contribution to both objectives\n    marginal_contributions = []\n    for item, flip in candidate_items:\n        if flip == 1:\n            marginal1 = value1_lst[item] / (weight_lst[item] + 1e-6)\n            marginal2 = value2_lst[item] / (weight_lst[item] + 1e-6)\n        else:\n            marginal1 = -value1_lst[item] / (weight_lst[item] + 1e-6)\n            marginal2 = -value2_lst[item] / (weight_lst[item] + 1e-6)\n        marginal_contributions.append((marginal1 + marginal2, item, flip))\n\n    if not marginal_contributions:\n        return new_solution\n\n    # Select the candidate with the highest combined marginal contribution\n    best_candidate = max(marginal_contributions, key=lambda x: x[0])\n    item, flip = best_candidate[1], best_candidate[2]\n\n    # Apply the flip\n    new_solution[item] = flip if flip == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8448388206161892,
            2.8369797468185425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here, we select a random solution with a bias towards higher total value)\n    selected_idx = np.random.choice(len(archive), p=np.array([(sol[1][0] + sol[1][1]) / (sum(sol[1][0] + sol[1][1] for sol in archive) + 1e-6) for sol in archive]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify items that can be flipped (either included or excluded without violating capacity)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Candidate items for flipping: prioritize items with high marginal contribution to both objectives\n    candidate_items = []\n    for item in included_items:\n        if current_weight - weight_lst[item] >= 0:\n            candidate_items.append((item, -1))  # -1 means exclude\n    for item in excluded_items:\n        if current_weight + weight_lst[item] <= capacity:\n            candidate_items.append((item, 1))  # 1 means include\n\n    if not candidate_items:\n        return new_solution\n\n    # Select a candidate with high marginal contribution to both objectives\n    marginal_contributions = []\n    for item, flip in candidate_items:\n        if flip == 1:\n            marginal1 = value1_lst[item] / (weight_lst[item] + 1e-6)\n            marginal2 = value2_lst[item] / (weight_lst[item] + 1e-6)\n        else:\n            marginal1 = -value1_lst[item] / (weight_lst[item] + 1e-6)\n            marginal2 = -value2_lst[item] / (weight_lst[item] + 1e-6)\n        marginal_contributions.append((marginal1 + marginal2, item, flip))\n\n    if not marginal_contributions:\n        return new_solution\n\n    # Select the candidate with the highest combined marginal contribution\n    best_candidate = max(marginal_contributions, key=lambda x: x[0])\n    item, flip = best_candidate[1], best_candidate[2]\n\n    # Apply the flip\n    new_solution[item] = flip if flip == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This heuristic selects a solution from the archive with the highest potential for improvement by evaluating the \"crowding distance\" of solutions in the objective space, then applies a novel \"guided mutation\" operator that intelligently flips bits based on marginal utility and feasibility constraints to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on crowding distance\n    def crowding_distance(solutions, objectives):\n        if len(solutions) <= 2:\n            return [float('inf')] * len(solutions)\n\n        distances = [0.0] * len(solutions)\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, len(solutions)-1):\n                if objectives[sorted_idx[i+1]][m] == objectives[sorted_idx[i-1]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max([obj[m] for obj in objectives]) - min([obj[m] for obj in objectives]))\n\n        return distances\n\n    solutions = [s for s, _ in archive]\n    objectives = [o for _, o in archive]\n    distances = crowding_distance(solutions, objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate neighbor using guided mutation\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal utility for each item\n    marginal_value1 = value1_lst - np.sum(value1_lst[new_solution == 1]) / np.sum(new_solution)\n    marginal_value2 = value2_lst - np.sum(value2_lst[new_solution == 1]) / np.sum(new_solution)\n    marginal_utility = marginal_value1 + marginal_value2\n\n    # Identify candidates for flip (items with high marginal utility and feasible to flip)\n    candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            if total_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -marginal_utility[i]))  # Negative for min-heap\n        else:\n            if total_weight + weight_lst[i] <= capacity:\n                candidates.append((i, marginal_utility[i]))\n\n    if not candidates:\n        return new_solution  # No feasible move\n\n    # Select top candidates based on utility\n    candidates.sort(key=lambda x: x[1])\n    top_candidates = candidates[:min(3, len(candidates))]  # Consider top 3 candidates\n\n    for i, _ in top_candidates:\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9104701964442197,
            2.719064474105835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on crowding distance\n    def crowding_distance(solutions, objectives):\n        if len(solutions) <= 2:\n            return [float('inf')] * len(solutions)\n\n        distances = [0.0] * len(solutions)\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, len(solutions)-1):\n                if objectives[sorted_idx[i+1]][m] == objectives[sorted_idx[i-1]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max([obj[m] for obj in objectives]) - min([obj[m] for obj in objectives]))\n\n        return distances\n\n    solutions = [s for s, _ in archive]\n    objectives = [o for _, o in archive]\n    distances = crowding_distance(solutions, objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate neighbor using guided mutation\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal utility for each item\n    marginal_value1 = value1_lst - np.sum(value1_lst[new_solution == 1]) / np.sum(new_solution)\n    marginal_value2 = value2_lst - np.sum(value2_lst[new_solution == 1]) / np.sum(new_solution)\n    marginal_utility = marginal_value1 + marginal_value2\n\n    # Identify candidates for flip (items with high marginal utility and feasible to flip)\n    candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            if total_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -marginal_utility[i]))  # Negative for min-heap\n        else:\n            if total_weight + weight_lst[i] <= capacity:\n                candidates.append((i, marginal_utility[i]))\n\n    if not candidates:\n        return new_solution  # No feasible move\n\n    # Select top candidates based on utility\n    candidates.sort(key=lambda x: x[1])\n    top_candidates = candidates[:min(3, len(candidates))]  # Consider top 3 candidates\n\n    for i, _ in top_candidates:\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{The algorithm selects a promising solution from the archive using a weighted random selection based on solution quality and diversity, then applies a hybrid local search combining item swapping and probabilistic flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = norm_obj.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high marginal value and flip low-value items probabilistically\n    candidate_items = np.where(new_solution == 1)[0]\n    non_candidate_items = np.where(new_solution == 0)[0]\n\n    # Calculate marginal values for each item\n    marginal_values1 = value1_lst - value1_lst.mean()\n    marginal_values2 = value2_lst - value2_lst.mean()\n\n    # Swap high-value items\n    if len(candidate_items) > 0:\n        high_value_items = candidate_items[np.argsort(-marginal_values1[candidate_items])[:min(3, len(candidate_items))]]\n        for item in high_value_items:\n            if np.random.rand() < 0.3:  # 30% chance to swap\n                swap_candidates = non_candidate_items[weight_lst[non_candidate_items] <= weight_lst[item]]\n                if len(swap_candidates) > 0:\n                    swap_item = np.random.choice(swap_candidates)\n                    new_solution[item], new_solution[swap_item] = 0, 1\n\n    # Flip low-value items with probability\n    if len(non_candidate_items) > 0:\n        low_value_items = non_candidate_items[np.argsort(marginal_values1[non_candidate_items])[:min(5, len(non_candidate_items))]]\n        for item in low_value_items:\n            if np.random.rand() < 0.2:  # 20% chance to flip\n                if (np.sum(weight_lst[new_solution == 1]) - weight_lst[item] + weight_lst[item]) <= capacity:\n                    new_solution[item] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    while current_weight > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        remove_item = np.random.choice(excess_items)\n        new_solution[remove_item] = 0\n        current_weight -= weight_lst[remove_item]\n\n    return new_solution\n\n",
        "score": [
            -0.5341521266523797,
            2.3746585845947266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = norm_obj.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high marginal value and flip low-value items probabilistically\n    candidate_items = np.where(new_solution == 1)[0]\n    non_candidate_items = np.where(new_solution == 0)[0]\n\n    # Calculate marginal values for each item\n    marginal_values1 = value1_lst - value1_lst.mean()\n    marginal_values2 = value2_lst - value2_lst.mean()\n\n    # Swap high-value items\n    if len(candidate_items) > 0:\n        high_value_items = candidate_items[np.argsort(-marginal_values1[candidate_items])[:min(3, len(candidate_items))]]\n        for item in high_value_items:\n            if np.random.rand() < 0.3:  # 30% chance to swap\n                swap_candidates = non_candidate_items[weight_lst[non_candidate_items] <= weight_lst[item]]\n                if len(swap_candidates) > 0:\n                    swap_item = np.random.choice(swap_candidates)\n                    new_solution[item], new_solution[swap_item] = 0, 1\n\n    # Flip low-value items with probability\n    if len(non_candidate_items) > 0:\n        low_value_items = non_candidate_items[np.argsort(marginal_values1[non_candidate_items])[:min(5, len(non_candidate_items))]]\n        for item in low_value_items:\n            if np.random.rand() < 0.2:  # 20% chance to flip\n                if (np.sum(weight_lst[new_solution == 1]) - weight_lst[item] + weight_lst[item]) <= capacity:\n                    new_solution[item] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    while current_weight > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        remove_item = np.random.choice(excess_items)\n        new_solution[remove_item] = 0\n        current_weight -= weight_lst[remove_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values and applies a hybrid local search that combines item swaps and flips, guided by a diversity-aware objective to escape local optima and improve multi-objective quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: swap + flip with diversity awareness\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Candidate items for swap/flip\n    in_knapsack = np.where(new_solution == 1)[0]\n    out_knapsack = np.where(new_solution == 0)[0]\n\n    # Try to swap one item in with one item out (if feasible)\n    if len(in_knapsack) > 0 and len(out_knapsack) > 0:\n        i = random.choice(in_knapsack)\n        j = random.choice(out_knapsack)\n        delta_weight = weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            return new_solution\n\n    # If swap not possible, try to flip one item (add or remove)\n    candidates = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # Remove item\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # Add item\n\n    if candidates:\n        i, flip = random.choice(candidates)\n        new_solution[i] = flip if flip == 1 else 0\n        return new_solution\n\n    # If no feasible move, return base solution\n    return base_solution\n\n",
        "score": [
            -0.2932328248615202,
            1.161659151315689
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: swap + flip with diversity awareness\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Candidate items for swap/flip\n    in_knapsack = np.where(new_solution == 1)[0]\n    out_knapsack = np.where(new_solution == 0)[0]\n\n    # Try to swap one item in with one item out (if feasible)\n    if len(in_knapsack) > 0 and len(out_knapsack) > 0:\n        i = random.choice(in_knapsack)\n        j = random.choice(out_knapsack)\n        delta_weight = weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            return new_solution\n\n    # If swap not possible, try to flip one item (add or remove)\n    candidates = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # Remove item\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # Add item\n\n    if candidates:\n        i, flip = random.choice(candidates)\n        new_solution[i] = flip if flip == 1 else 0\n        return new_solution\n\n    # If no feasible move, return base solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for local improvement, then applies a hybrid local search operator that combines item swapping and random flipping to explore the solution space while ensuring feasibility, thereby generating high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution with high potential for improvement\n    # Sort solutions by the sum of their objective values (prioritize high-value solutions)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to flip (1 -> 0 or 0 -> 1)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it if feasible\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, try to include it if feasible\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Perform item swapping if feasible\n    swap_indices = random.sample(range(n_items), min(2, n_items))\n    if len(swap_indices) == 2:\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            # Swap items if the weight difference is manageable\n            weight_diff = weight_lst[i] - weight_lst[j]\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if (current_weight + weight_diff) <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.311571018713443,
            1.1918036043643951
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution with high potential for improvement\n    # Sort solutions by the sum of their objective values (prioritize high-value solutions)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to flip (1 -> 0 or 0 -> 1)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it if feasible\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, try to include it if feasible\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Perform item swapping if feasible\n    swap_indices = random.sample(range(n_items), min(2, n_items))\n    if len(swap_indices) == 2:\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            # Swap items if the weight difference is manageable\n            weight_diff = weight_lst[i] - weight_lst[j]\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if (current_weight + weight_diff) <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{The heuristic selects a promising solution from the archive based on its potential for improvement, then applies a novel hybrid local search that combines item swaps, flips, and adaptive perturbations to explore non-dominated regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distance or other metrics to select a diverse solution\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            sol, obj = archive[i]\n            total_weight = np.sum(weight_lst * sol)\n            total_value1 = np.sum(value1_lst * sol)\n            total_value2 = np.sum(value2_lst * sol)\n            # Simple heuristic: prefer solutions with moderate values and good weight utilization\n            crowding[i] = (total_value1 + total_value2) / (total_weight + 1e-6)\n        # Select the solution with the highest crowding score (most promising for improvement)\n        selected_idx = np.argmax(crowding)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Phase 1: Randomized item swaps to explore neighboring regions\n    n_items = len(new_solution)\n    if n_items >= 2:\n        # Select two random items to swap\n        idx1, idx2 = np.random.choice(n_items, size=2, replace=False)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Phase 2: Adaptive flips based on item impact\n    # Calculate the impact of each item on both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    impact1 = value1_lst - (value1_lst * new_solution)\n    impact2 = value2_lst - (value2_lst * new_solution)\n\n    # Flip items with high impact on at least one objective, ensuring feasibility\n    for i in range(n_items):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            if impact1[i] > 0 or impact2[i] > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Phase 3: Random perturbations to escape local optima\n    # Flip a small number of random items to introduce diversity\n    n_perturb = min(2, n_items)  # Small perturbation\n    perturb_indices = np.random.choice(n_items, size=n_perturb, replace=False)\n    for i in perturb_indices:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n        else:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.33422946152721345,
            6.678289324045181
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distance or other metrics to select a diverse solution\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            sol, obj = archive[i]\n            total_weight = np.sum(weight_lst * sol)\n            total_value1 = np.sum(value1_lst * sol)\n            total_value2 = np.sum(value2_lst * sol)\n            # Simple heuristic: prefer solutions with moderate values and good weight utilization\n            crowding[i] = (total_value1 + total_value2) / (total_weight + 1e-6)\n        # Select the solution with the highest crowding score (most promising for improvement)\n        selected_idx = np.argmax(crowding)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Phase 1: Randomized item swaps to explore neighboring regions\n    n_items = len(new_solution)\n    if n_items >= 2:\n        # Select two random items to swap\n        idx1, idx2 = np.random.choice(n_items, size=2, replace=False)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Phase 2: Adaptive flips based on item impact\n    # Calculate the impact of each item on both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    impact1 = value1_lst - (value1_lst * new_solution)\n    impact2 = value2_lst - (value2_lst * new_solution)\n\n    # Flip items with high impact on at least one objective, ensuring feasibility\n    for i in range(n_items):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            if impact1[i] > 0 or impact2[i] > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Phase 3: Random perturbations to escape local optima\n    # Flip a small number of random items to introduce diversity\n    n_perturb = min(2, n_items)  # Small perturbation\n    perturb_indices = np.random.choice(n_items, size=n_perturb, replace=False)\n    for i in perturb_indices:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n        else:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines adaptive item swaps, strategic flips, and biased randomness to explore the solution space while ensuring feasibility and promoting multi-objective improvement by prioritizing solutions with high potential for further optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        slack = capacity - total_weight\n        if slack > 0 and np.sum(sol) < len(sol):  # Not fully packed\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive  # Fallback to all solutions\n\n    # Intelligently select a solution (e.g., with high objective values or large slack)\n    selected = max(candidates, key=lambda x: (x[1][0] + x[1][1]) * (capacity - np.sum(weight_lst * x[0])))\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive swaps and flips\n    total_weight = np.sum(weight_lst * base_solution)\n    slack = capacity - total_weight\n\n    # Strategy 1: Swap items to improve both objectives\n    for _ in range(2):\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items to swap based on value density\n            in_density = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_density = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            swap_in = in_items[np.argmin(in_density)]  # Remove low-density item\n            swap_out = out_items[np.argmax(out_density)]  # Add high-density item\n\n            if weight_lst[swap_out] <= slack + weight_lst[swap_in]:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                slack = slack + weight_lst[swap_in] - weight_lst[swap_out]\n\n    # Strategy 2: Flip items to improve objectives\n    for _ in range(2):\n        # Find items that can be flipped without violating capacity\n        flippable = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                if slack + weight_lst[i] >= 0:\n                    flippable.append((i, -1))  # Remove item\n            else:\n                if weight_lst[i] <= slack:\n                    flippable.append((i, 1))  # Add item\n\n        if flippable:\n            # Select flip based on value improvement\n            improvements = []\n            for i, direction in flippable:\n                if direction == 1:\n                    delta1 = value1_lst[i]\n                    delta2 = value2_lst[i]\n                else:\n                    delta1 = -value1_lst[i]\n                    delta2 = -value2_lst[i]\n                improvements.append((i, direction, delta1 + delta2))\n\n            if improvements:\n                best_flip = max(improvements, key=lambda x: x[2])\n                new_solution[best_flip[0]] = best_flip[1] == 1\n\n    return new_solution\n\n",
        "score": [
            -0.8532615627036608,
            3.949639707803726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        slack = capacity - total_weight\n        if slack > 0 and np.sum(sol) < len(sol):  # Not fully packed\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive  # Fallback to all solutions\n\n    # Intelligently select a solution (e.g., with high objective values or large slack)\n    selected = max(candidates, key=lambda x: (x[1][0] + x[1][1]) * (capacity - np.sum(weight_lst * x[0])))\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive swaps and flips\n    total_weight = np.sum(weight_lst * base_solution)\n    slack = capacity - total_weight\n\n    # Strategy 1: Swap items to improve both objectives\n    for _ in range(2):\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items to swap based on value density\n            in_density = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_density = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            swap_in = in_items[np.argmin(in_density)]  # Remove low-density item\n            swap_out = out_items[np.argmax(out_density)]  # Add high-density item\n\n            if weight_lst[swap_out] <= slack + weight_lst[swap_in]:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                slack = slack + weight_lst[swap_in] - weight_lst[swap_out]\n\n    # Strategy 2: Flip items to improve objectives\n    for _ in range(2):\n        # Find items that can be flipped without violating capacity\n        flippable = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                if slack + weight_lst[i] >= 0:\n                    flippable.append((i, -1))  # Remove item\n            else:\n                if weight_lst[i] <= slack:\n                    flippable.append((i, 1))  # Add item\n\n        if flippable:\n            # Select flip based on value improvement\n            improvements = []\n            for i, direction in flippable:\n                if direction == 1:\n                    delta1 = value1_lst[i]\n                    delta2 = value2_lst[i]\n                else:\n                    delta1 = -value1_lst[i]\n                    delta2 = -value2_lst[i]\n                improvements.append((i, direction, delta1 + delta2))\n\n            if improvements:\n                best_flip = max(improvements, key=lambda x: x[2])\n                new_solution[best_flip[0]] = best_flip[1] == 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (add/remove)\n    # 2. Apply a greedy improvement step to ensure feasibility and quality\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Randomly select a subset of items to flip\n    flip_mask = np.random.rand(n_items) < 0.2  # 20% chance per item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing items if the total weight exceeds capacity\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with the lowest (value1 + value2) / weight ratio until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            remove_idx = included_items[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Apply a greedy improvement step: add items with the highest (value1 + value2) / weight ratio\n    # that do not exceed the capacity\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n        sorted_indices = np.argsort(ratios)[::-1]  # descending order\n        for idx in sorted_indices:\n            if weight_lst[excluded_items[idx]] <= remaining_weight:\n                new_solution[excluded_items[idx]] = 1\n                remaining_weight -= weight_lst[excluded_items[idx]]\n\n    return new_solution\n\n",
        "score": [
            -0.3791316422588385,
            1.7666421234607697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (add/remove)\n    # 2. Apply a greedy improvement step to ensure feasibility and quality\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Randomly select a subset of items to flip\n    flip_mask = np.random.rand(n_items) < 0.2  # 20% chance per item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing items if the total weight exceeds capacity\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with the lowest (value1 + value2) / weight ratio until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            remove_idx = included_items[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Apply a greedy improvement step: add items with the highest (value1 + value2) / weight ratio\n    # that do not exceed the capacity\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n        sorted_indices = np.argsort(ratios)[::-1]  # descending order\n        for idx in sorted_indices:\n            if weight_lst[excluded_items[idx]] <= remaining_weight:\n                new_solution[excluded_items[idx]] = 1\n                remaining_weight -= weight_lst[excluded_items[idx]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{The algorithm selects a promising solution from the archive by leveraging a hybrid local search strategy that combines random perturbation with a value-based greedy selection, ensuring feasibility and maximizing potential improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending) to prioritize less explored regions\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a solution in the middle to balance exploration and exploitation\n        selected_idx = len(archive_sorted) // 2\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + greedy value-based selection\n    # Step 1: Randomly flip a subset of items (perturbation)\n    num_flips = min(3, len(new_solution))  # Flip up to 3 items\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedily add items with high value-to-weight ratio for both objectives\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-to-weight ratios for both objectives\n    value1_ratio = value1_lst / weight_lst\n    value2_ratio = value2_lst / weight_lst\n\n    # Combine ratios using a weighted sum to balance both objectives\n    combined_ratio = 0.5 * value1_ratio + 0.5 * value2_ratio\n\n    # Sort items by combined ratio in descending order\n    sorted_indices = np.argsort(-combined_ratio)\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Ensure feasibility (should not be necessary due to greedy addition, but included for safety)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If infeasible, remove items with lowest combined ratio until feasible\n        sorted_indices = np.argsort(combined_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3155780321870584,
            1.5975114405155182
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending) to prioritize less explored regions\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a solution in the middle to balance exploration and exploitation\n        selected_idx = len(archive_sorted) // 2\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + greedy value-based selection\n    # Step 1: Randomly flip a subset of items (perturbation)\n    num_flips = min(3, len(new_solution))  # Flip up to 3 items\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedily add items with high value-to-weight ratio for both objectives\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-to-weight ratios for both objectives\n    value1_ratio = value1_lst / weight_lst\n    value2_ratio = value2_lst / weight_lst\n\n    # Combine ratios using a weighted sum to balance both objectives\n    combined_ratio = 0.5 * value1_ratio + 0.5 * value2_ratio\n\n    # Sort items by combined ratio in descending order\n    sorted_indices = np.argsort(-combined_ratio)\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Ensure feasibility (should not be necessary due to greedy addition, but included for safety)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If infeasible, remove items with lowest combined ratio until feasible\n        sorted_indices = np.argsort(combined_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects solutions with high potential for improvement by combining adaptive neighborhood exploration with a dynamic perturbation mechanism to escape local optima, ensuring feasibility while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        # Calculate dominance count (simplified for this example)\n        dominance = sum(1 for s, _ in archive if (s != sol).any() and (obj[0] <= s_obj[0] for s_obj in archive if s_obj != obj) and (obj[1] <= s_obj[1] for s_obj in archive if s_obj != obj))\n        candidates.append((sol, obj, dominance))\n\n    # Sort by dominance and pick the least dominated solution\n    candidates.sort(key=lambda x: x[2])\n    selected_sol = candidates[0][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    new_solution = selected_sol.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Strategy 1: Randomly flip items with high marginal contribution\n    for _ in range(3):  # Number of flips\n        # Calculate marginal contribution (simplified)\n        marginal_contrib = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        # Prioritize items with high marginal contribution\n        candidate_indices = np.argsort(marginal_contrib)[::-1]\n        for idx in candidate_indices:\n            if new_solution[idx] == 0:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n                    break\n            else:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n                break\n\n    # Strategy 2: Dynamic perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance to perturb\n        # Randomly flip a subset of items\n        perturb_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for idx in perturb_indices:\n            if new_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7325269031328014,
            6.793885588645935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        # Calculate dominance count (simplified for this example)\n        dominance = sum(1 for s, _ in archive if (s != sol).any() and (obj[0] <= s_obj[0] for s_obj in archive if s_obj != obj) and (obj[1] <= s_obj[1] for s_obj in archive if s_obj != obj))\n        candidates.append((sol, obj, dominance))\n\n    # Sort by dominance and pick the least dominated solution\n    candidates.sort(key=lambda x: x[2])\n    selected_sol = candidates[0][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    new_solution = selected_sol.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Strategy 1: Randomly flip items with high marginal contribution\n    for _ in range(3):  # Number of flips\n        # Calculate marginal contribution (simplified)\n        marginal_contrib = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        # Prioritize items with high marginal contribution\n        candidate_indices = np.argsort(marginal_contrib)[::-1]\n        for idx in candidate_indices:\n            if new_solution[idx] == 0:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n                    break\n            else:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n                break\n\n    # Strategy 2: Dynamic perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance to perturb\n        # Randomly flip a subset of items\n        perturb_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for idx in perturb_indices:\n            if new_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Identify items to potentially flip (those with high marginal value or low weight)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_score = marginal_value1 + marginal_value2\n\n    # Prioritize items with high combined marginal value or low weight\n    candidate_items = np.argsort(combined_score)[::-1]\n\n    # Flip items in a way that balances both objectives and maintains feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for item in candidate_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9192198961209204,
            1.3992889523506165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Identify items to potentially flip (those with high marginal value or low weight)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_score = marginal_value1 + marginal_value2\n\n    # Prioritize items with high combined marginal value or low weight\n    candidate_items = np.argsort(combined_score)[::-1]\n\n    # Flip items in a way that balances both objectives and maintains feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for item in candidate_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swaps with strategic flips to generate a neighbor solution while ensuring feasibility and maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives to find promising ones\n        normalized_scores = []\n        for sol, obj in archive:\n            total_weight = np.sum(weight_lst * sol)\n            if total_weight > capacity:\n                continue  # Skip infeasible solutions\n            # Normalize objectives to [0,1] range\n            max_v1 = np.max(value1_lst)\n            max_v2 = np.max(value2_lst)\n            norm_v1 = obj[0] / max_v1 if max_v1 > 0 else 0\n            norm_v2 = obj[1] / max_v2 if max_v2 > 0 else 0\n            normalized_scores.append((sol, norm_v1 + norm_v2))\n\n        if normalized_scores:\n            # Select the solution with highest normalized score\n            base_solution = max(normalized_scores, key=lambda x: x[1])[0]\n        else:\n            base_solution = archive[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: combine item swaps with strategic flips\n    for _ in range(5):  # Perform multiple operations for better exploration\n        # Option 1: Random swap between included and excluded items\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[j] - weight_lst[i]\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Option 2: Strategic flip based on value-weight ratio\n        if random.random() < 0.3:  # 30% chance for strategic flip\n            # Calculate value-weight ratios\n            v1_ratios = value1_lst / weight_lst\n            v2_ratios = value2_lst / weight_lst\n\n            # Combine ratios for both objectives\n            combined_ratios = v1_ratios + v2_ratios\n\n            # Find items with highest combined ratio\n            sorted_items = np.argsort(combined_ratios)[::-1]\n\n            for item in sorted_items:\n                if new_solution[item] == 0:\n                    # Check feasibility\n                    current_weight = np.sum(weight_lst * new_solution)\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        break\n                elif new_solution[item] == 1:\n                    # Check if removing this item improves both objectives\n                    if (value1_lst[item] < np.median(value1_lst) and\n                        value2_lst[item] < np.median(value2_lst)):\n                        new_solution[item] = 0\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.36517676132238774,
            8.16014614701271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives to find promising ones\n        normalized_scores = []\n        for sol, obj in archive:\n            total_weight = np.sum(weight_lst * sol)\n            if total_weight > capacity:\n                continue  # Skip infeasible solutions\n            # Normalize objectives to [0,1] range\n            max_v1 = np.max(value1_lst)\n            max_v2 = np.max(value2_lst)\n            norm_v1 = obj[0] / max_v1 if max_v1 > 0 else 0\n            norm_v2 = obj[1] / max_v2 if max_v2 > 0 else 0\n            normalized_scores.append((sol, norm_v1 + norm_v2))\n\n        if normalized_scores:\n            # Select the solution with highest normalized score\n            base_solution = max(normalized_scores, key=lambda x: x[1])[0]\n        else:\n            base_solution = archive[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: combine item swaps with strategic flips\n    for _ in range(5):  # Perform multiple operations for better exploration\n        # Option 1: Random swap between included and excluded items\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst * new_solution)\n            delta_weight = weight_lst[j] - weight_lst[i]\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Option 2: Strategic flip based on value-weight ratio\n        if random.random() < 0.3:  # 30% chance for strategic flip\n            # Calculate value-weight ratios\n            v1_ratios = value1_lst / weight_lst\n            v2_ratios = value2_lst / weight_lst\n\n            # Combine ratios for both objectives\n            combined_ratios = v1_ratios + v2_ratios\n\n            # Find items with highest combined ratio\n            sorted_items = np.argsort(combined_ratios)[::-1]\n\n            for item in sorted_items:\n                if new_solution[item] == 0:\n                    # Check feasibility\n                    current_weight = np.sum(weight_lst * new_solution)\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        break\n                elif new_solution[item] == 1:\n                    # Check if removing this item improves both objectives\n                    if (value1_lst[item] < np.median(value1_lst) and\n                        value2_lst[item] < np.median(value2_lst)):\n                        new_solution[item] = 0\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / np.sum(weight_lst * x[0]))\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (added or removed)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing the item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding the item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))   # 1 indicates addition\n\n    if not candidates:\n        return new_solution  # No feasible moves\n\n    # Select a random candidate with preference for high-value items\n    item_idx, flip = random.choice(candidates)\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    # Apply a secondary move to further diversify the solution\n    secondary_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] != base_solution[i]:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    secondary_candidates.append((i, -1))\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    secondary_candidates.append((i, 1))\n\n    if secondary_candidates:\n        item_idx, flip = random.choice(secondary_candidates)\n        new_solution[item_idx] = 1 if flip == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.6690671542220902,
            3.636424273252487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / np.sum(weight_lst * x[0]))\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (added or removed)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing the item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding the item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))   # 1 indicates addition\n\n    if not candidates:\n        return new_solution  # No feasible moves\n\n    # Select a random candidate with preference for high-value items\n    item_idx, flip = random.choice(candidates)\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    # Apply a secondary move to further diversify the solution\n    secondary_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] != base_solution[i]:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    secondary_candidates.append((i, -1))\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    secondary_candidates.append((i, 1))\n\n    if secondary_candidates:\n        item_idx, flip = random.choice(secondary_candidates)\n        new_solution[item_idx] = 1 if flip == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This heuristic selects a promising solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that intelligently flips item selections while ensuring feasibility, prioritizing items with high marginal gains in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (e.g., with high combined objective values)\n    selected_idx = np.argmax([obj1 + obj2 for _, (obj1, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each item\n    marginal_gains = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-marginal_gains)  # Sort by descending marginal gain\n\n    # Apply a novel local search: flip items with high marginal gains while maintaining feasibility\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8243605925453164,
            1.313549280166626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (e.g., with high combined objective values)\n    selected_idx = np.argmax([obj1 + obj2 for _, (obj1, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each item\n    marginal_gains = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-marginal_gains)  # Sort by descending marginal gain\n\n    # Apply a novel local search: flip items with high marginal gains while maintaining feasibility\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive, performs a novel combination of item swaps and flips based on objective-specific value-to-weight ratios, and ensures feasibility by dynamically adjusting the neighbor generation to respect capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    v1_ratio = value1_lst / weight_lst\n    v2_ratio = value2_lst / weight_lst\n\n    # Hybrid local search: combine item swaps and flips\n    if random.random() < 0.5:  # 50% chance for swap-based neighbor\n        # Select two items to swap (one included, one excluded)\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            item_to_remove = random.choice(included_items)\n            item_to_add = random.choice(excluded_items)\n\n            # Check if swap keeps solution feasible\n            if (current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]) <= capacity:\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n    else:  # 50% chance for flip-based neighbor\n        # Select items with high value-to-weight ratios for both objectives\n        candidates = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                # Consider removing items with low combined ratio\n                if (v1_ratio[i] + v2_ratio[i]) < (current_val1 + current_val2) / (2 * current_weight):\n                    candidates.append(i)\n            else:\n                # Consider adding items with high combined ratio\n                if (v1_ratio[i] + v2_ratio[i]) > (current_val1 + current_val2) / (2 * capacity):\n                    candidates.append(i)\n\n        if candidates:\n            item_to_flip = random.choice(candidates)\n            if new_solution[item_to_flip] == 1:\n                # Check if removal keeps solution feasible\n                if (current_weight - weight_lst[item_to_flip]) <= capacity:\n                    new_solution[item_to_flip] = 0\n            else:\n                # Check if addition keeps solution feasible\n                if (current_weight + weight_lst[item_to_flip]) <= capacity:\n                    new_solution[item_to_flip] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.391516536509523,
            3.1393652856349945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    v1_ratio = value1_lst / weight_lst\n    v2_ratio = value2_lst / weight_lst\n\n    # Hybrid local search: combine item swaps and flips\n    if random.random() < 0.5:  # 50% chance for swap-based neighbor\n        # Select two items to swap (one included, one excluded)\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            item_to_remove = random.choice(included_items)\n            item_to_add = random.choice(excluded_items)\n\n            # Check if swap keeps solution feasible\n            if (current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]) <= capacity:\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n    else:  # 50% chance for flip-based neighbor\n        # Select items with high value-to-weight ratios for both objectives\n        candidates = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                # Consider removing items with low combined ratio\n                if (v1_ratio[i] + v2_ratio[i]) < (current_val1 + current_val2) / (2 * current_weight):\n                    candidates.append(i)\n            else:\n                # Consider adding items with high combined ratio\n                if (v1_ratio[i] + v2_ratio[i]) > (current_val1 + current_val2) / (2 * capacity):\n                    candidates.append(i)\n\n        if candidates:\n            item_to_flip = random.choice(candidates)\n            if new_solution[item_to_flip] == 1:\n                # Check if removal keeps solution feasible\n                if (current_weight - weight_lst[item_to_flip]) <= capacity:\n                    new_solution[item_to_flip] = 0\n            else:\n                # Check if addition keeps solution feasible\n                if (current_weight + weight_lst[item_to_flip]) <= capacity:\n                    new_solution[item_to_flip] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive, then applies a weighted random swap or flip operator followed by a greedy improvement step to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select randomly for diversity, but could be improved)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted random swap or flip\n    if random.random() < 0.7:  # Higher probability for swap\n        # Find two items to swap (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Weighted selection: prefer items with high marginal value-to-weight ratio\n            in_weights = weight_lst[in_items]\n            out_weights = weight_lst[out_items]\n            in_val1 = value1_lst[in_items]\n            out_val1 = value1_lst[out_items]\n            in_val2 = value2_lst[in_items]\n            out_val2 = value2_lst[out_items]\n\n            # Compute marginal ratios (avoid division by zero)\n            in_ratio1 = in_val1 / (in_weights + 1e-6)\n            out_ratio1 = out_val1 / (out_weights + 1e-6)\n            in_ratio2 = in_val2 / (in_weights + 1e-6)\n            out_ratio2 = out_val2 / (out_weights + 1e-6)\n\n            # Combine ratios for multi-objective selection\n            combined_in_ratio = in_ratio1 + in_ratio2\n            combined_out_ratio = out_ratio1 + out_ratio2\n\n            # Weighted selection\n            in_item = random.choices(in_items, weights=combined_in_ratio, k=1)[0]\n            out_item = random.choices(out_items, weights=combined_out_ratio, k=1)[0]\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n\n            if new_weight <= capacity:\n                new_solution[in_item] = 0\n                new_solution[out_item] = 1\n    else:\n        # Flip operation (randomly flip one item)\n        flip_item = random.randint(0, len(new_solution) - 1)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[flip_item] * new_solution[flip_item] + weight_lst[flip_item] * (1 - new_solution[flip_item])\n\n        if new_weight <= capacity:\n            new_solution[flip_item] = 1 - new_solution[flip_item]\n\n    # Greedy improvement step: try to add items with high marginal value\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    candidate_items = np.where(new_solution == 0)[0]\n\n    if len(candidate_items) > 0 and remaining_weight > 0:\n        # Filter items that can fit\n        feasible_items = candidate_items[weight_lst[candidate_items] <= remaining_weight]\n\n        if len(feasible_items) > 0:\n            # Select item with highest combined marginal value\n            marginal_val1 = value1_lst[feasible_items]\n            marginal_val2 = value2_lst[feasible_items]\n            combined_marginal = marginal_val1 + marginal_val2\n            best_item = feasible_items[np.argmax(combined_marginal)]\n\n            new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.31361376535496843,
            4.1785213351249695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select randomly for diversity, but could be improved)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted random swap or flip\n    if random.random() < 0.7:  # Higher probability for swap\n        # Find two items to swap (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Weighted selection: prefer items with high marginal value-to-weight ratio\n            in_weights = weight_lst[in_items]\n            out_weights = weight_lst[out_items]\n            in_val1 = value1_lst[in_items]\n            out_val1 = value1_lst[out_items]\n            in_val2 = value2_lst[in_items]\n            out_val2 = value2_lst[out_items]\n\n            # Compute marginal ratios (avoid division by zero)\n            in_ratio1 = in_val1 / (in_weights + 1e-6)\n            out_ratio1 = out_val1 / (out_weights + 1e-6)\n            in_ratio2 = in_val2 / (in_weights + 1e-6)\n            out_ratio2 = out_val2 / (out_weights + 1e-6)\n\n            # Combine ratios for multi-objective selection\n            combined_in_ratio = in_ratio1 + in_ratio2\n            combined_out_ratio = out_ratio1 + out_ratio2\n\n            # Weighted selection\n            in_item = random.choices(in_items, weights=combined_in_ratio, k=1)[0]\n            out_item = random.choices(out_items, weights=combined_out_ratio, k=1)[0]\n\n            # Check feasibility of swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n\n            if new_weight <= capacity:\n                new_solution[in_item] = 0\n                new_solution[out_item] = 1\n    else:\n        # Flip operation (randomly flip one item)\n        flip_item = random.randint(0, len(new_solution) - 1)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[flip_item] * new_solution[flip_item] + weight_lst[flip_item] * (1 - new_solution[flip_item])\n\n        if new_weight <= capacity:\n            new_solution[flip_item] = 1 - new_solution[flip_item]\n\n    # Greedy improvement step: try to add items with high marginal value\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    candidate_items = np.where(new_solution == 0)[0]\n\n    if len(candidate_items) > 0 and remaining_weight > 0:\n        # Filter items that can fit\n        feasible_items = candidate_items[weight_lst[candidate_items] <= remaining_weight]\n\n        if len(feasible_items) > 0:\n            # Select item with highest combined marginal value\n            marginal_val1 = value1_lst[feasible_items]\n            marginal_val2 = value2_lst[feasible_items]\n            combined_marginal = marginal_val1 + marginal_val2\n            best_item = feasible_items[np.argmax(combined_marginal)]\n\n            new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement by prioritizing solutions with low dominance counts and high objective values, then applies a hybrid local search combining random bit flips and a novel objective-aware swap strategy to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low dominance counts\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate dominance counts (simplified for selection)\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                obj1, obj2 = archive_objectives[i]\n                other_obj1, other_obj2 = archive_objectives[j]\n                if (obj1 <= other_obj1 and obj2 <= other_obj2) and (obj1 < other_obj1 or obj2 < other_obj2):\n                    dominance_counts[i] += 1\n\n    # Select solutions with low dominance counts and high objective values\n    candidates = sorted(zip(archive_solutions, archive_objectives, dominance_counts),\n                        key=lambda x: (x[2], -x[1][0], -x[1][1]))\n    selected_solution, selected_objective, _ = candidates[0]\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine random bit flips with objective-aware swaps\n    for _ in range(3):  # Perform 3 iterations of the hybrid search\n        # Random bit flip with feasibility check\n        flip_pos = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_pos] == 1:\n            if np.sum(weight_lst[new_solution == 1] - weight_lst[flip_pos]) <= capacity:\n                new_solution[flip_pos] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1] + weight_lst[flip_pos]) <= capacity:\n                new_solution[flip_pos] = 1\n\n        # Objective-aware swap: swap two items to potentially improve both objectives\n        if len(new_solution) >= 2:\n            swap_pos1, swap_pos2 = random.sample(range(len(new_solution)), 2)\n            if new_solution[swap_pos1] != new_solution[swap_pos2]:\n                # Calculate potential new weights and values\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight - weight_lst[swap_pos1] - weight_lst[swap_pos2] + weight_lst[swap_pos1] + weight_lst[swap_pos2]\n\n                if new_weight <= capacity:\n                    # Calculate potential new values\n                    current_val1 = np.sum(value1_lst[new_solution == 1])\n                    current_val2 = np.sum(value2_lst[new_solution == 1])\n                    new_val1 = current_val1 - value1_lst[swap_pos1] - value1_lst[swap_pos2] + value1_lst[swap_pos1] + value1_lst[swap_pos2]\n                    new_val2 = current_val2 - value2_lst[swap_pos1] - value2_lst[swap_pos2] + value2_lst[swap_pos1] + value2_lst[swap_pos2]\n\n                    # Only swap if both objectives are non-worsening\n                    if (new_val1 >= current_val1 and new_val2 >= current_val2):\n                        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.34541916630854114,
            2.9902617037296295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low dominance counts\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate dominance counts (simplified for selection)\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                obj1, obj2 = archive_objectives[i]\n                other_obj1, other_obj2 = archive_objectives[j]\n                if (obj1 <= other_obj1 and obj2 <= other_obj2) and (obj1 < other_obj1 or obj2 < other_obj2):\n                    dominance_counts[i] += 1\n\n    # Select solutions with low dominance counts and high objective values\n    candidates = sorted(zip(archive_solutions, archive_objectives, dominance_counts),\n                        key=lambda x: (x[2], -x[1][0], -x[1][1]))\n    selected_solution, selected_objective, _ = candidates[0]\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine random bit flips with objective-aware swaps\n    for _ in range(3):  # Perform 3 iterations of the hybrid search\n        # Random bit flip with feasibility check\n        flip_pos = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_pos] == 1:\n            if np.sum(weight_lst[new_solution == 1] - weight_lst[flip_pos]) <= capacity:\n                new_solution[flip_pos] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1] + weight_lst[flip_pos]) <= capacity:\n                new_solution[flip_pos] = 1\n\n        # Objective-aware swap: swap two items to potentially improve both objectives\n        if len(new_solution) >= 2:\n            swap_pos1, swap_pos2 = random.sample(range(len(new_solution)), 2)\n            if new_solution[swap_pos1] != new_solution[swap_pos2]:\n                # Calculate potential new weights and values\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight - weight_lst[swap_pos1] - weight_lst[swap_pos2] + weight_lst[swap_pos1] + weight_lst[swap_pos2]\n\n                if new_weight <= capacity:\n                    # Calculate potential new values\n                    current_val1 = np.sum(value1_lst[new_solution == 1])\n                    current_val2 = np.sum(value2_lst[new_solution == 1])\n                    new_val1 = current_val1 - value1_lst[swap_pos1] - value1_lst[swap_pos2] + value1_lst[swap_pos1] + value1_lst[swap_pos2]\n                    new_val2 = current_val2 - value2_lst[swap_pos1] - value2_lst[swap_pos2] + value2_lst[swap_pos1] + value2_lst[swap_pos2]\n\n                    # Only swap if both objectives are non-worsening\n                    if (new_val1 >= current_val1 and new_val2 >= current_val2):\n                        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))  # Prefer solutions with moderate density\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: item swapping and probabilistic flipping\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.5:  # 50% chance to flip the item\n            if new_solution[i] == 1:\n                # Try to remove the item if feasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    # Probabilistically swap with another item if feasible\n                    j = np.random.randint(0, len(new_solution))\n                    if new_solution[j] == 0 and current_weight + weight_lst[j] <= capacity:\n                        new_solution[j] = 1\n                        current_weight += weight_lst[j]\n            else:\n                # Try to add the item if feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    # Probabilistically swap with another item if feasible\n                    j = np.random.randint(0, len(new_solution))\n                    if new_solution[j] == 1 and current_weight - weight_lst[j] <= capacity:\n                        new_solution[j] = 0\n                        current_weight -= weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.3933833168439512,
            3.537270486354828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))  # Prefer solutions with moderate density\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: item swapping and probabilistic flipping\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.5:  # 50% chance to flip the item\n            if new_solution[i] == 1:\n                # Try to remove the item if feasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    # Probabilistically swap with another item if feasible\n                    j = np.random.randint(0, len(new_solution))\n                    if new_solution[j] == 0 and current_weight + weight_lst[j] <= capacity:\n                        new_solution[j] = 1\n                        current_weight += weight_lst[j]\n            else:\n                # Try to add the item if feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    # Probabilistically swap with another item if feasible\n                    j = np.random.randint(0, len(new_solution))\n                    if new_solution[j] == 1 and current_weight - weight_lst[j] <= capacity:\n                        new_solution[j] = 0\n                        current_weight -= weight_lst[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive, applies a combination of random perturbation and guided neighborhood exploration to generate a feasible neighbor solution, ensuring both objectives are improved or maintained while respecting the capacity constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Select solutions with the highest crowding distance (promising for further improvement)\n    crowding_distances = []\n    for i, (sol, _) in enumerate(archive):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = abs(archive[i+1][1][0] - archive[i-1][1][0])\n            dist2 = abs(archive[i+1][1][1] - archive[i-1][1][1])\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a segment to flip (perturbation)\n    segment_size = max(1, int(np.sqrt(n_items)))\n    start = random.randint(0, n_items - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = 1 - new_solution[start:end]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest value-to-weight ratio until feasible\n        while total_weight > capacity:\n            item_weights = weight_lst * new_solution\n            item_values = (value1_lst + value2_lst) * new_solution\n            ratios = np.divide(item_values, item_weights, out=np.zeros_like(item_values), where=item_weights!=0)\n            worst_item = np.argmax(ratios)\n            new_solution[worst_item] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 3: Apply guided neighborhood exploration (flip items with high marginal gain)\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        current_value1 = np.sum(value1_lst * new_solution)\n        current_value2 = np.sum(value2_lst * new_solution)\n        current_weight = np.sum(weight_lst * new_solution)\n\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                # Try removing item i\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_value1 = current_value1 - value1_lst[i]\n                    new_value2 = current_value2 - value2_lst[i]\n                    # Check if solution is non-dominated in the archive\n                    dominated = False\n                    for (_, (v1, v2)) in archive:\n                        if (v1 >= new_value1 and v2 >= new_value2) and (v1 > new_value1 or v2 > new_value2):\n                            dominated = True\n                            break\n                    if not dominated:\n                        new_solution[i] = 0\n                        current_weight = new_weight\n                        current_value1 = new_value1\n                        current_value2 = new_value2\n            else:\n                # Try adding item i\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_value1 = current_value1 + value1_lst[i]\n                    new_value2 = current_value2 + value2_lst[i]\n                    # Check if solution is non-dominated in the archive\n                    dominated = False\n                    for (_, (v1, v2)) in archive:\n                        if (v1 >= new_value1 and v2 >= new_value2) and (v1 > new_value1 or v2 > new_value2):\n                            dominated = True\n                            break\n                    if not dominated:\n                        new_solution[i] = 1\n                        current_weight = new_weight\n                        current_value1 = new_value1\n                        current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.7819568905799317,
            6.4613311886787415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Select solutions with the highest crowding distance (promising for further improvement)\n    crowding_distances = []\n    for i, (sol, _) in enumerate(archive):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = abs(archive[i+1][1][0] - archive[i-1][1][0])\n            dist2 = abs(archive[i+1][1][1] - archive[i-1][1][1])\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a segment to flip (perturbation)\n    segment_size = max(1, int(np.sqrt(n_items)))\n    start = random.randint(0, n_items - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = 1 - new_solution[start:end]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest value-to-weight ratio until feasible\n        while total_weight > capacity:\n            item_weights = weight_lst * new_solution\n            item_values = (value1_lst + value2_lst) * new_solution\n            ratios = np.divide(item_values, item_weights, out=np.zeros_like(item_values), where=item_weights!=0)\n            worst_item = np.argmax(ratios)\n            new_solution[worst_item] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 3: Apply guided neighborhood exploration (flip items with high marginal gain)\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        current_value1 = np.sum(value1_lst * new_solution)\n        current_value2 = np.sum(value2_lst * new_solution)\n        current_weight = np.sum(weight_lst * new_solution)\n\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                # Try removing item i\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_value1 = current_value1 - value1_lst[i]\n                    new_value2 = current_value2 - value2_lst[i]\n                    # Check if solution is non-dominated in the archive\n                    dominated = False\n                    for (_, (v1, v2)) in archive:\n                        if (v1 >= new_value1 and v2 >= new_value2) and (v1 > new_value1 or v2 > new_value2):\n                            dominated = True\n                            break\n                    if not dominated:\n                        new_solution[i] = 0\n                        current_weight = new_weight\n                        current_value1 = new_value1\n                        current_value2 = new_value2\n            else:\n                # Try adding item i\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_value1 = current_value1 + value1_lst[i]\n                    new_value2 = current_value2 + value2_lst[i]\n                    # Check if solution is non-dominated in the archive\n                    dominated = False\n                    for (_, (v1, v2)) in archive:\n                        if (v1 >= new_value1 and v2 >= new_value2) and (v1 > new_value1 or v2 > new_value2):\n                            dominated = True\n                            break\n                    if not dominated:\n                        new_solution[i] = 1\n                        current_weight = new_weight\n                        current_value1 = new_value1\n                        current_value2 = new_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps with a probability-based perturbation to explore the solution space, ensuring feasibility by dynamically adjusting the selection of items to swap or flip while respecting the capacity constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already dominated)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high value-to-weight ratio or flip items probabilistically\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - total_weight\n\n    # Calculate value-to-weight ratios for items not in the solution\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        value1_ratio = value1_lst[excluded_items] / weight_lst[excluded_items]\n        value2_ratio = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n        # Combine ratios and select top candidates\n        combined_ratio = value1_ratio + value2_ratio\n        top_candidates = excluded_items[np.argsort(combined_ratio)[-min(3, len(excluded_items)):]]\n\n        # Randomly select one of the top candidates to add\n        if len(top_candidates) > 0 and random.random() < 0.7:  # 70% chance to add a high-value item\n            candidate = random.choice(top_candidates)\n            if weight_lst[candidate] <= remaining_capacity:\n                new_solution[candidate] = 1\n                remaining_capacity -= weight_lst[candidate]\n\n    # Probabilistically flip items in the solution (remove low-value items)\n    included_items = np.where(new_solution == 1)[0]\n    for item in included_items:\n        if random.random() < 0.3:  # 30% chance to remove each included item\n            new_solution[item] = 0\n            remaining_capacity += weight_lst[item]\n\n    # Ensure feasibility by removing items until capacity is satisfied\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        # Remove the item with the smallest combined value-to-weight ratio\n        value1_ratio = value1_lst[included_items] / weight_lst[included_items]\n        value2_ratio = value2_lst[included_items] / weight_lst[included_items]\n        combined_ratio = value1_ratio + value2_ratio\n        worst_item = included_items[np.argmin(combined_ratio)]\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8528568396818965,
            0.807811051607132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already dominated)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high value-to-weight ratio or flip items probabilistically\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - total_weight\n\n    # Calculate value-to-weight ratios for items not in the solution\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        value1_ratio = value1_lst[excluded_items] / weight_lst[excluded_items]\n        value2_ratio = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n        # Combine ratios and select top candidates\n        combined_ratio = value1_ratio + value2_ratio\n        top_candidates = excluded_items[np.argsort(combined_ratio)[-min(3, len(excluded_items)):]]\n\n        # Randomly select one of the top candidates to add\n        if len(top_candidates) > 0 and random.random() < 0.7:  # 70% chance to add a high-value item\n            candidate = random.choice(top_candidates)\n            if weight_lst[candidate] <= remaining_capacity:\n                new_solution[candidate] = 1\n                remaining_capacity -= weight_lst[candidate]\n\n    # Probabilistically flip items in the solution (remove low-value items)\n    included_items = np.where(new_solution == 1)[0]\n    for item in included_items:\n        if random.random() < 0.3:  # 30% chance to remove each included item\n            new_solution[item] = 0\n            remaining_capacity += weight_lst[item]\n\n    # Ensure feasibility by removing items until capacity is satisfied\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        # Remove the item with the smallest combined value-to-weight ratio\n        value1_ratio = value1_lst[included_items] / weight_lst[included_items]\n        value2_ratio = value2_lst[included_items] / weight_lst[included_items]\n        combined_ratio = value1_ratio + value2_ratio\n        worst_item = included_items[np.argmin(combined_ratio)]\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps with a probability-based perturbation to explore the solution space, ensuring feasibility by dynamically adjusting the selection of items to swap or flip while respecting the capacity constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already dominated)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high value-to-weight ratio or flip items probabilistically\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - total_weight\n\n    # Calculate value-to-weight ratios for items not in the solution\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        value1_ratio = value1_lst[excluded_items] / weight_lst[excluded_items]\n        value2_ratio = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n        # Combine ratios and select top candidates\n        combined_ratio = value1_ratio + value2_ratio\n        top_candidates = excluded_items[np.argsort(combined_ratio)[-min(3, len(excluded_items)):]]\n\n        # Randomly select one of the top candidates to add\n        if len(top_candidates) > 0 and random.random() < 0.7:  # 70% chance to add a high-value item\n            candidate = random.choice(top_candidates)\n            if weight_lst[candidate] <= remaining_capacity:\n                new_solution[candidate] = 1\n                remaining_capacity -= weight_lst[candidate]\n\n    # Probabilistically flip items in the solution (remove low-value items)\n    included_items = np.where(new_solution == 1)[0]\n    for item in included_items:\n        if random.random() < 0.3:  # 30% chance to remove each included item\n            new_solution[item] = 0\n            remaining_capacity += weight_lst[item]\n\n    # Ensure feasibility by removing items until capacity is satisfied\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        # Remove the item with the smallest combined value-to-weight ratio\n        value1_ratio = value1_lst[included_items] / weight_lst[included_items]\n        value2_ratio = value2_lst[included_items] / weight_lst[included_items]\n        combined_ratio = value1_ratio + value2_ratio\n        worst_item = included_items[np.argmin(combined_ratio)]\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8528568396818965,
            0.807811051607132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already dominated)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high value-to-weight ratio or flip items probabilistically\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - total_weight\n\n    # Calculate value-to-weight ratios for items not in the solution\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        value1_ratio = value1_lst[excluded_items] / weight_lst[excluded_items]\n        value2_ratio = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n        # Combine ratios and select top candidates\n        combined_ratio = value1_ratio + value2_ratio\n        top_candidates = excluded_items[np.argsort(combined_ratio)[-min(3, len(excluded_items)):]]\n\n        # Randomly select one of the top candidates to add\n        if len(top_candidates) > 0 and random.random() < 0.7:  # 70% chance to add a high-value item\n            candidate = random.choice(top_candidates)\n            if weight_lst[candidate] <= remaining_capacity:\n                new_solution[candidate] = 1\n                remaining_capacity -= weight_lst[candidate]\n\n    # Probabilistically flip items in the solution (remove low-value items)\n    included_items = np.where(new_solution == 1)[0]\n    for item in included_items:\n        if random.random() < 0.3:  # 30% chance to remove each included item\n            new_solution[item] = 0\n            remaining_capacity += weight_lst[item]\n\n    # Ensure feasibility by removing items until capacity is satisfied\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        # Remove the item with the smallest combined value-to-weight ratio\n        value1_ratio = value1_lst[included_items] / weight_lst[included_items]\n        value2_ratio = value2_lst[included_items] / weight_lst[included_items]\n        combined_ratio = value1_ratio + value2_ratio\n        worst_item = included_items[np.argmin(combined_ratio)]\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive, identifies critical items based on marginal utility and diversity, and applies a hybrid local search operator that combines item swaps, probabilistic flips, and adaptive neighborhood exploration to generate high-quality non-dominated neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probabilistic bias towards higher diversity\n    base_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify critical items (those with high marginal utility)\n    marginal_utility = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    critical_items = np.argsort(marginal_utility)[-min(5, len(weight_lst)):]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Perform multiple perturbations\n        # Option 1: Swap critical items with non-critical items\n        if np.random.rand() < 0.6:\n            if len(critical_items) > 0:\n                critical_item = np.random.choice(critical_items)\n                non_critical_items = np.where(~new_solution)[0]\n                if len(non_critical_items) > 0:\n                    swap_candidate = np.random.choice(non_critical_items)\n                    if (current_weight - weight_lst[critical_item] + weight_lst[swap_candidate]) <= capacity:\n                        new_solution[critical_item], new_solution[swap_candidate] = 0, 1\n                        current_weight = current_weight - weight_lst[critical_item] + weight_lst[swap_candidate]\n\n        # Option 2: Probabilistic flip based on marginal utility\n        if np.random.rand() < 0.4:\n            flip_candidates = np.where(new_solution)[0]\n            if len(flip_candidates) > 0:\n                flip_item = np.random.choice(flip_candidates)\n                if current_weight - weight_lst[flip_item] <= capacity:\n                    new_solution[flip_item] = 0\n                    current_weight -= weight_lst[flip_item]\n\n        # Option 3: Add high-utility items if space allows\n        if np.random.rand() < 0.3:\n            add_candidates = np.where(~new_solution)[0]\n            if len(add_candidates) > 0:\n                add_item = np.random.choice(add_candidates)\n                if current_weight + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n                    current_weight += weight_lst[add_item]\n\n    return new_solution\n\n",
        "score": [
            -0.3432780293664911,
            1.910924106836319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probabilistic bias towards higher diversity\n    base_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify critical items (those with high marginal utility)\n    marginal_utility = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    critical_items = np.argsort(marginal_utility)[-min(5, len(weight_lst)):]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Perform multiple perturbations\n        # Option 1: Swap critical items with non-critical items\n        if np.random.rand() < 0.6:\n            if len(critical_items) > 0:\n                critical_item = np.random.choice(critical_items)\n                non_critical_items = np.where(~new_solution)[0]\n                if len(non_critical_items) > 0:\n                    swap_candidate = np.random.choice(non_critical_items)\n                    if (current_weight - weight_lst[critical_item] + weight_lst[swap_candidate]) <= capacity:\n                        new_solution[critical_item], new_solution[swap_candidate] = 0, 1\n                        current_weight = current_weight - weight_lst[critical_item] + weight_lst[swap_candidate]\n\n        # Option 2: Probabilistic flip based on marginal utility\n        if np.random.rand() < 0.4:\n            flip_candidates = np.where(new_solution)[0]\n            if len(flip_candidates) > 0:\n                flip_item = np.random.choice(flip_candidates)\n                if current_weight - weight_lst[flip_item] <= capacity:\n                    new_solution[flip_item] = 0\n                    current_weight -= weight_lst[flip_item]\n\n        # Option 3: Add high-utility items if space allows\n        if np.random.rand() < 0.3:\n            add_candidates = np.where(~new_solution)[0]\n            if len(add_candidates) > 0:\n                add_item = np.random.choice(add_candidates)\n                if current_weight + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n                    current_weight += weight_lst[add_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This heuristic first prioritizes solutions with high objective values and low weight utilization, then applies a dynamic local search that iteratively adjusts item selections based on marginal gains in both objectives, while always ensuring feasibility through weight constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on high objective values and low weight utilization\n    def score(sol_obj):\n        sol, obj = sol_obj\n        total_weight = np.sum(weight_lst * sol)\n        obj1, obj2 = obj\n        return (obj1 + obj2) / (1 + (total_weight / capacity))\n\n    scored_solutions = [(sol_obj, score(sol_obj)) for sol_obj in archive]\n    scored_solutions.sort(key=lambda x: -x[1])\n    selected_sol = scored_solutions[0][0][0].copy()\n\n    # Dynamic local search: iteratively adjust items based on marginal gains\n    new_solution = selected_sol.copy()\n    items = list(range(len(weight_lst)))\n    random.shuffle(items)\n\n    for item in items:\n        current_weight = np.sum(weight_lst * new_solution)\n        if new_solution[item] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                # Calculate marginal gains\n                marginal1 = value1_lst[item]\n                marginal2 = value2_lst[item]\n                # Accept if at least one objective improves\n                if marginal1 > 0 or marginal2 > 0:\n                    new_solution = temp_solution\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                # Calculate marginal gains\n                marginal1 = value1_lst[item]\n                marginal2 = value2_lst[item]\n                # Accept if at least one objective improves\n                if marginal1 > 0 or marginal2 > 0:\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.3969656992711691,
            9.846969723701477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on high objective values and low weight utilization\n    def score(sol_obj):\n        sol, obj = sol_obj\n        total_weight = np.sum(weight_lst * sol)\n        obj1, obj2 = obj\n        return (obj1 + obj2) / (1 + (total_weight / capacity))\n\n    scored_solutions = [(sol_obj, score(sol_obj)) for sol_obj in archive]\n    scored_solutions.sort(key=lambda x: -x[1])\n    selected_sol = scored_solutions[0][0][0].copy()\n\n    # Dynamic local search: iteratively adjust items based on marginal gains\n    new_solution = selected_sol.copy()\n    items = list(range(len(weight_lst)))\n    random.shuffle(items)\n\n    for item in items:\n        current_weight = np.sum(weight_lst * new_solution)\n        if new_solution[item] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                # Calculate marginal gains\n                marginal1 = value1_lst[item]\n                marginal2 = value2_lst[item]\n                # Accept if at least one objective improves\n                if marginal1 > 0 or marginal2 > 0:\n                    new_solution = temp_solution\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                # Calculate marginal gains\n                marginal1 = value1_lst[item]\n                marginal2 = value2_lst[item]\n                # Accept if at least one objective improves\n                if marginal1 > 0 or marginal2 > 0:\n                    new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive, employs a hybrid local search strategy combining item swapping and dynamic neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement\n        # Here, we select a solution with the highest sum of normalized objective values\n        normalized_objectives = []\n        max_value1 = max(obj[0] for _, obj in archive)\n        max_value2 = max(obj[1] for _, obj in archive)\n        for sol, obj in archive:\n            normalized_obj = (obj[0] / max_value1 if max_value1 != 0 else 0,\n                             obj[1] / max_value2 if max_value2 != 0 else 0)\n            normalized_objectives.append((sol, obj, sum(normalized_obj)))\n\n        # Select top 3 solutions and choose one randomly\n        top_solutions = sorted(normalized_objectives, key=lambda x: -x[2])[:min(3, len(normalized_objectives))]\n        selected = random.choice(top_solutions)\n        base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Randomly swap a subset of items\n    num_items = len(weight_lst)\n    swap_indices = random.sample(range(num_items), min(3, num_items))\n    for i in swap_indices:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n        else:\n            # Check if adding the item would keep the solution feasible\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Step 2: Dynamic neighborhood exploration\n    # Find items that are not in the solution but could potentially improve one objective\n    candidate_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    for i in candidate_items:\n        if current_weight + weight_lst[i] <= capacity:\n            # Calculate potential improvement for both objectives\n            delta_value1 = value1_lst[i]\n            delta_value2 = value2_lst[i]\n\n            # If adding this item improves at least one objective, consider it\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                current_value1 += delta_value1\n                current_value2 += delta_value2\n\n    # Step 3: Randomly flip one item to escape local optima\n    if random.random() < 0.3:  # 30% chance to perform this step\n        flip_index = random.choice(range(num_items))\n        if new_solution[flip_index] == 1:\n            new_solution[flip_index] = 0\n        else:\n            if current_weight + weight_lst[flip_index] <= capacity:\n                new_solution[flip_index] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.315169348224756,
            4.004733204841614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement\n        # Here, we select a solution with the highest sum of normalized objective values\n        normalized_objectives = []\n        max_value1 = max(obj[0] for _, obj in archive)\n        max_value2 = max(obj[1] for _, obj in archive)\n        for sol, obj in archive:\n            normalized_obj = (obj[0] / max_value1 if max_value1 != 0 else 0,\n                             obj[1] / max_value2 if max_value2 != 0 else 0)\n            normalized_objectives.append((sol, obj, sum(normalized_obj)))\n\n        # Select top 3 solutions and choose one randomly\n        top_solutions = sorted(normalized_objectives, key=lambda x: -x[2])[:min(3, len(normalized_objectives))]\n        selected = random.choice(top_solutions)\n        base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Randomly swap a subset of items\n    num_items = len(weight_lst)\n    swap_indices = random.sample(range(num_items), min(3, num_items))\n    for i in swap_indices:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n        else:\n            # Check if adding the item would keep the solution feasible\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Step 2: Dynamic neighborhood exploration\n    # Find items that are not in the solution but could potentially improve one objective\n    candidate_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    for i in candidate_items:\n        if current_weight + weight_lst[i] <= capacity:\n            # Calculate potential improvement for both objectives\n            delta_value1 = value1_lst[i]\n            delta_value2 = value2_lst[i]\n\n            # If adding this item improves at least one objective, consider it\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                current_value1 += delta_value1\n                current_value2 += delta_value2\n\n    # Step 3: Randomly flip one item to escape local optima\n    if random.random() < 0.3:  # 30% chance to perform this step\n        flip_index = random.choice(range(num_items))\n        if new_solution[flip_index] == 1:\n            new_solution[flip_index] = 0\n        else:\n            if current_weight + weight_lst[flip_index] <= capacity:\n                new_solution[flip_index] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects the most promising solution from the archive based on both objective values and weight distribution, then applies a dynamic item swap and perturbation operator to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select the most promising solution based on both objectives and weight distribution\n    def score_solution(solution, objective):\n        total_weight = np.sum(weight_lst[solution == 1])\n        # Score is a combination of normalized objectives and weight efficiency\n        score = (objective[0] + objective[1]) / (total_weight + 1e-6)\n        return score\n\n    scored_solutions = [(score_solution(sol, obj), sol, obj) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: -x[0])  # Sort by descending score\n\n    # Select top 20% of solutions for candidate pool\n    top_percentage = max(1, len(scored_solutions) // 5)\n    candidates = [sol for _, sol, _ in scored_solutions[:top_percentage]]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates)\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    def apply_operator(solution):\n        # Dynamic item swap and perturbation\n        non_zero_indices = np.where(solution == 1)[0]\n        zero_indices = np.where(solution == 0)[0]\n\n        # Try to swap a non-zero item with a zero item if feasible\n        if len(non_zero_indices) > 0 and len(zero_indices) > 0:\n            i = random.choice(non_zero_indices)\n            j = random.choice(zero_indices)\n\n            temp_solution = solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                return temp_solution\n\n        # If swap didn't work, try adding a random zero item if feasible\n        if len(zero_indices) > 0:\n            j = random.choice(zero_indices)\n            temp_solution = solution.copy()\n            temp_solution[j] = 1\n\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                return temp_solution\n\n        # If adding didn't work, try removing a random non-zero item\n        if len(non_zero_indices) > 0:\n            i = random.choice(non_zero_indices)\n            temp_solution = solution.copy()\n            temp_solution[i] = 0\n            return temp_solution\n\n        return solution\n\n    new_solution = apply_operator(new_solution)\n\n    # Step 3: Apply perturbation for diversity\n    if random.random() < 0.3:  # 30% chance of perturbation\n        non_zero_indices = np.where(new_solution == 1)[0]\n        zero_indices = np.where(new_solution == 0)[0]\n\n        if len(non_zero_indices) > 0 and len(zero_indices) > 0:\n            i = random.choice(non_zero_indices)\n            j = random.choice(zero_indices)\n\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6939978570074462,
            1.6040305495262146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select the most promising solution based on both objectives and weight distribution\n    def score_solution(solution, objective):\n        total_weight = np.sum(weight_lst[solution == 1])\n        # Score is a combination of normalized objectives and weight efficiency\n        score = (objective[0] + objective[1]) / (total_weight + 1e-6)\n        return score\n\n    scored_solutions = [(score_solution(sol, obj), sol, obj) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: -x[0])  # Sort by descending score\n\n    # Select top 20% of solutions for candidate pool\n    top_percentage = max(1, len(scored_solutions) // 5)\n    candidates = [sol for _, sol, _ in scored_solutions[:top_percentage]]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates)\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    def apply_operator(solution):\n        # Dynamic item swap and perturbation\n        non_zero_indices = np.where(solution == 1)[0]\n        zero_indices = np.where(solution == 0)[0]\n\n        # Try to swap a non-zero item with a zero item if feasible\n        if len(non_zero_indices) > 0 and len(zero_indices) > 0:\n            i = random.choice(non_zero_indices)\n            j = random.choice(zero_indices)\n\n            temp_solution = solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                return temp_solution\n\n        # If swap didn't work, try adding a random zero item if feasible\n        if len(zero_indices) > 0:\n            j = random.choice(zero_indices)\n            temp_solution = solution.copy()\n            temp_solution[j] = 1\n\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                return temp_solution\n\n        # If adding didn't work, try removing a random non-zero item\n        if len(non_zero_indices) > 0:\n            i = random.choice(non_zero_indices)\n            temp_solution = solution.copy()\n            temp_solution[i] = 0\n            return temp_solution\n\n        return solution\n\n    new_solution = apply_operator(new_solution)\n\n    # Step 3: Apply perturbation for diversity\n    if random.random() < 0.3:  # 30% chance of perturbation\n        non_zero_indices = np.where(new_solution == 1)[0]\n        zero_indices = np.where(new_solution == 0)[0]\n\n        if len(non_zero_indices) > 0 and len(zero_indices) > 0:\n            i = random.choice(non_zero_indices)\n            j = random.choice(zero_indices)\n\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    selected_obj = archive[selected_idx][1]\n\n    # Calculate current total weight and objectives\n    current_weight = np.sum(weight_lst * selected_solution)\n    current_value1 = selected_obj[0]\n    current_value2 = selected_obj[1]\n\n    # Generate candidate neighbors by flipping bits with a bias toward objective improvement\n    candidates = []\n    for _ in range(10):  # Generate 10 candidate neighbors\n        neighbor = selected_solution.copy()\n        # Randomly select a subset of items to flip\n        flip_indices = np.random.choice(len(neighbor), size=np.random.randint(1, min(5, len(neighbor))), replace=False)\n        neighbor[flip_indices] = 1 - neighbor[flip_indices]\n\n        # Check feasibility\n        new_weight = current_weight + np.sum((neighbor[flip_indices] - selected_solution[flip_indices]) * weight_lst[flip_indices])\n        if new_weight <= capacity:\n            candidates.append(neighbor)\n\n    if not candidates:\n        return selected_solution\n\n    # Evaluate candidates based on potential for objective improvement\n    best_neighbor = None\n    best_score = -np.inf\n    for neighbor in candidates:\n        # Calculate potential improvement in both objectives\n        delta_value1 = np.sum((neighbor - selected_solution) * value1_lst)\n        delta_value2 = np.sum((neighbor - selected_solution) * value2_lst)\n\n        # Score based on combined objective improvement (weighted sum)\n        score = 0.7 * delta_value1 + 0.3 * delta_value2  # Adjust weights based on problem characteristics\n\n        if score > best_score:\n            best_score = score\n            best_neighbor = neighbor\n\n    return best_neighbor if best_neighbor is not None else selected_solution\n\n",
        "score": [
            -0.4353433928407279,
            3.615845412015915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    selected_obj = archive[selected_idx][1]\n\n    # Calculate current total weight and objectives\n    current_weight = np.sum(weight_lst * selected_solution)\n    current_value1 = selected_obj[0]\n    current_value2 = selected_obj[1]\n\n    # Generate candidate neighbors by flipping bits with a bias toward objective improvement\n    candidates = []\n    for _ in range(10):  # Generate 10 candidate neighbors\n        neighbor = selected_solution.copy()\n        # Randomly select a subset of items to flip\n        flip_indices = np.random.choice(len(neighbor), size=np.random.randint(1, min(5, len(neighbor))), replace=False)\n        neighbor[flip_indices] = 1 - neighbor[flip_indices]\n\n        # Check feasibility\n        new_weight = current_weight + np.sum((neighbor[flip_indices] - selected_solution[flip_indices]) * weight_lst[flip_indices])\n        if new_weight <= capacity:\n            candidates.append(neighbor)\n\n    if not candidates:\n        return selected_solution\n\n    # Evaluate candidates based on potential for objective improvement\n    best_neighbor = None\n    best_score = -np.inf\n    for neighbor in candidates:\n        # Calculate potential improvement in both objectives\n        delta_value1 = np.sum((neighbor - selected_solution) * value1_lst)\n        delta_value2 = np.sum((neighbor - selected_solution) * value2_lst)\n\n        # Score based on combined objective improvement (weighted sum)\n        score = 0.7 * delta_value1 + 0.3 * delta_value2  # Adjust weights based on problem characteristics\n\n        if score > best_score:\n            best_score = score\n            best_neighbor = neighbor\n\n    return best_neighbor if best_neighbor is not None else selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))  # Select a solution with high item density\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomly flip a subset of items and apply a greedy repair\n    num_flips = min(3, len(new_solution))  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Greedy repair: Ensure feasibility and improve objectives\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess_weight = current_weight - capacity\n        items_in_solution = np.where(new_solution == 1)[0]\n        np.random.shuffle(items_in_solution)\n        for idx in items_in_solution:\n            if excess_weight <= 0:\n                break\n            new_solution[idx] = 0\n            excess_weight -= weight_lst[idx]\n\n    # Further improve by adding items with high marginal value\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    for idx in remaining_items:\n        if weight_lst[idx] <= remaining_capacity:\n            # Add item if it improves both objectives\n            if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.34164262041891547,
            1.4732341170310974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))  # Select a solution with high item density\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomly flip a subset of items and apply a greedy repair\n    num_flips = min(3, len(new_solution))  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Greedy repair: Ensure feasibility and improve objectives\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess_weight = current_weight - capacity\n        items_in_solution = np.where(new_solution == 1)[0]\n        np.random.shuffle(items_in_solution)\n        for idx in items_in_solution:\n            if excess_weight <= 0:\n                break\n            new_solution[idx] = 0\n            excess_weight -= weight_lst[idx]\n\n    # Further improve by adding items with high marginal value\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    for idx in remaining_items:\n        if weight_lst[idx] <= remaining_capacity:\n            # Add item if it improves both objectives\n            if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{A novel heuristic function that intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines item swaps with adaptive neighborhood exploration to generate high-quality, feasible neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential_score(solution, objective):\n        # Higher score for solutions with lower total weight (more room for improvement)\n        total_weight = np.sum(weight_lst[solution == 1])\n        return (capacity - total_weight) / capacity\n\n    scored_solutions = [(solution, objective, potential_score(solution, objective)) for solution, objective in archive]\n    scored_solutions.sort(key=lambda x: x[2], reverse=True)\n    selected_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Adaptive item swap\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        i = random.choice(swap_candidates)\n        new_solution[i] = 0\n\n        # Find best item to add (greedy with randomness)\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            remaining_capacity = capacity - current_weight\n\n            # Filter items that can be added without exceeding capacity\n            feasible_items = [j for j in available_items if weight_lst[j] <= remaining_capacity]\n\n            if feasible_items:\n                # Select item with highest combined marginal value\n                marginal_values = []\n                for j in feasible_items:\n                    marginal_value = (value1_lst[j] + value2_lst[j]) / weight_lst[j]\n                    marginal_values.append((j, marginal_value))\n\n                # Add some randomness to selection\n                marginal_values.sort(key=lambda x: x[1], reverse=True)\n                top_items = [x[0] for x in marginal_values[:max(1, len(marginal_values)//2)]]\n                j = random.choice(top_items)\n                new_solution[j] = 1\n\n    # Step 2: Local improvement with random walk\n    if random.random() < 0.3:  # 30% chance of additional local improvement\n        temp_solution = new_solution.copy()\n        for _ in range(3):  # Small number of random moves\n            # Randomly flip one item\n            k = random.randint(0, n_items - 1)\n            current_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_solution[k] == 1:\n                temp_solution[k] = 0\n            else:\n                if current_weight + weight_lst[k] <= capacity:\n                    temp_solution[k] = 1\n\n        # Accept if better in at least one objective\n        current_value1 = np.sum(value1_lst[new_solution == 1])\n        current_value2 = np.sum(value2_lst[new_solution == 1])\n        new_value1 = np.sum(value1_lst[temp_solution == 1])\n        new_value2 = np.sum(value2_lst[temp_solution == 1])\n\n        if (new_value1 > current_value1) or (new_value2 > current_value2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.3950660050492387,
            2.7456471621990204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential_score(solution, objective):\n        # Higher score for solutions with lower total weight (more room for improvement)\n        total_weight = np.sum(weight_lst[solution == 1])\n        return (capacity - total_weight) / capacity\n\n    scored_solutions = [(solution, objective, potential_score(solution, objective)) for solution, objective in archive]\n    scored_solutions.sort(key=lambda x: x[2], reverse=True)\n    selected_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Adaptive item swap\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        i = random.choice(swap_candidates)\n        new_solution[i] = 0\n\n        # Find best item to add (greedy with randomness)\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            remaining_capacity = capacity - current_weight\n\n            # Filter items that can be added without exceeding capacity\n            feasible_items = [j for j in available_items if weight_lst[j] <= remaining_capacity]\n\n            if feasible_items:\n                # Select item with highest combined marginal value\n                marginal_values = []\n                for j in feasible_items:\n                    marginal_value = (value1_lst[j] + value2_lst[j]) / weight_lst[j]\n                    marginal_values.append((j, marginal_value))\n\n                # Add some randomness to selection\n                marginal_values.sort(key=lambda x: x[1], reverse=True)\n                top_items = [x[0] for x in marginal_values[:max(1, len(marginal_values)//2)]]\n                j = random.choice(top_items)\n                new_solution[j] = 1\n\n    # Step 2: Local improvement with random walk\n    if random.random() < 0.3:  # 30% chance of additional local improvement\n        temp_solution = new_solution.copy()\n        for _ in range(3):  # Small number of random moves\n            # Randomly flip one item\n            k = random.randint(0, n_items - 1)\n            current_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_solution[k] == 1:\n                temp_solution[k] = 0\n            else:\n                if current_weight + weight_lst[k] <= capacity:\n                    temp_solution[k] = 1\n\n        # Accept if better in at least one objective\n        current_value1 = np.sum(value1_lst[new_solution == 1])\n        current_value2 = np.sum(value2_lst[new_solution == 1])\n        new_value1 = np.sum(value1_lst[temp_solution == 1])\n        new_value2 = np.sum(value2_lst[temp_solution == 1])\n\n        if (new_value1 > current_value1) or (new_value2 > current_value2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines random selection with a dynamic neighborhood exploration strategy, prioritizing solutions with high potential for multi-objective improvement by iteratively flipping subsets of items while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(i + 1) / len(archive) for i in range(len(archive))],\n        k=1\n    )[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Determine the number of items to flip (dynamic based on solution quality)\n    total_items = len(weight_lst)\n    flip_count = min(max(1, int(np.sqrt(total_items) * random.uniform(0.5, 1.5))), total_items)\n\n    # Step 3: Hybrid local search - flip subsets of items with adaptive weight adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    for _ in range(flip_count):\n        # Select a subset of items to flip\n        subset_size = min(max(1, int(np.sqrt(total_items) * random.uniform(0.3, 0.7))), total_items)\n        items_to_flip = random.sample(range(total_items), subset_size)\n\n        # Calculate potential weight change\n        weight_change = np.sum(weight_lst[items_to_flip] * (1 - 2 * new_solution[items_to_flip]))\n\n        # Only flip if feasible\n        if current_weight + weight_change <= capacity:\n            new_solution[items_to_flip] = 1 - new_solution[items_to_flip]\n            current_weight += weight_change\n\n    # Step 4: Ensure feasibility (fallback if needed)\n    if current_weight > capacity:\n        # If still infeasible, remove items randomly until feasible\n        while current_weight > capacity:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break\n            item_to_remove = random.choice(excess_items)\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.32744515530339935,
            3.3648858070373535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(i + 1) / len(archive) for i in range(len(archive))],\n        k=1\n    )[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Determine the number of items to flip (dynamic based on solution quality)\n    total_items = len(weight_lst)\n    flip_count = min(max(1, int(np.sqrt(total_items) * random.uniform(0.5, 1.5))), total_items)\n\n    # Step 3: Hybrid local search - flip subsets of items with adaptive weight adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    for _ in range(flip_count):\n        # Select a subset of items to flip\n        subset_size = min(max(1, int(np.sqrt(total_items) * random.uniform(0.3, 0.7))), total_items)\n        items_to_flip = random.sample(range(total_items), subset_size)\n\n        # Calculate potential weight change\n        weight_change = np.sum(weight_lst[items_to_flip] * (1 - 2 * new_solution[items_to_flip]))\n\n        # Only flip if feasible\n        if current_weight + weight_change <= capacity:\n            new_solution[items_to_flip] = 1 - new_solution[items_to_flip]\n            current_weight += weight_change\n\n    # Step 4: Ensure feasibility (fallback if needed)\n    if current_weight > capacity:\n        # If still infeasible, remove items randomly until feasible\n        while current_weight > capacity:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break\n            item_to_remove = random.choice(excess_items)\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a diversity-aware metric, then applies a hybrid local search that combines bit-flipping with a probabilistic item swap to explore the solution space while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: bit-flip with probabilistic swap\n    # Step 1: Random bit-flip (with probability)\n    if random.random() < 0.5:\n        flip_pos = random.randint(0, len(new_solution) - 1)\n        new_solution[flip_pos] = 1 - new_solution[flip_pos]\n\n    # Step 2: Probabilistic swap (with feasibility check)\n    if random.random() < 0.3:\n        # Select two distinct indices\n        idx1, idx2 = random.sample(range(len(new_solution)), 2)\n        # Swap items if feasible\n        if (new_solution[idx1] != new_solution[idx2]):\n            # Calculate new weights\n            current_weight = np.sum(new_solution * weight_lst)\n            if new_solution[idx1] == 1:\n                new_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            else:\n                new_weight = current_weight + weight_lst[idx1] - weight_lst[idx2]\n            if new_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility (in case of any errors)\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Randomly remove an item that's causing overweight\n        overweight_items = np.where((new_solution == 1) & (weight_lst > 0))[0]\n        if len(overweight_items) > 0:\n            remove_idx = np.random.choice(overweight_items)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.29262119180601753,
            1.4218690991401672
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: bit-flip with probabilistic swap\n    # Step 1: Random bit-flip (with probability)\n    if random.random() < 0.5:\n        flip_pos = random.randint(0, len(new_solution) - 1)\n        new_solution[flip_pos] = 1 - new_solution[flip_pos]\n\n    # Step 2: Probabilistic swap (with feasibility check)\n    if random.random() < 0.3:\n        # Select two distinct indices\n        idx1, idx2 = random.sample(range(len(new_solution)), 2)\n        # Swap items if feasible\n        if (new_solution[idx1] != new_solution[idx2]):\n            # Calculate new weights\n            current_weight = np.sum(new_solution * weight_lst)\n            if new_solution[idx1] == 1:\n                new_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            else:\n                new_weight = current_weight + weight_lst[idx1] - weight_lst[idx2]\n            if new_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility (in case of any errors)\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Randomly remove an item that's causing overweight\n        overweight_items = np.where((new_solution == 1) & (weight_lst > 0))[0]\n        if len(overweight_items) > 0:\n            remove_idx = np.random.choice(overweight_items)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on its potential for further improvement, then applies a hybrid local search operator that combines item swaps with probabilistic flips to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: swap items with high potential and flip items probabilistically\n    total_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Identify items to swap (highest value-to-weight ratio)\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n\n    # Select top 2 items to swap (one from each objective)\n    top_items1 = np.argsort(-value_ratio1)[:2]\n    top_items2 = np.argsort(-value_ratio2)[:2]\n\n    # Perform swaps if feasible\n    for i in top_items1:\n        if base_solution[i] == 0 and remaining_capacity >= weight_lst[i]:\n            new_solution[i] = 1\n            remaining_capacity -= weight_lst[i]\n        elif base_solution[i] == 1:\n            new_solution[i] = 0\n            remaining_capacity += weight_lst[i]\n\n    for i in top_items2:\n        if base_solution[i] == 0 and remaining_capacity >= weight_lst[i]:\n            new_solution[i] = 1\n            remaining_capacity -= weight_lst[i]\n        elif base_solution[i] == 1:\n            new_solution[i] = 0\n            remaining_capacity += weight_lst[i]\n\n    # Probabilistic flip for diversification\n    for i in range(len(base_solution)):\n        if random.random() < 0.2:  # 20% chance to flip\n            if base_solution[i] == 0 and remaining_capacity >= weight_lst[i]:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n            elif base_solution[i] == 1:\n                new_solution[i] = 0\n                remaining_capacity += weight_lst[i]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random items until feasible\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n        remove_idx = random.choice(candidates)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.42610772947458203,
            1.2029905021190643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: swap items with high potential and flip items probabilistically\n    total_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Identify items to swap (highest value-to-weight ratio)\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n\n    # Select top 2 items to swap (one from each objective)\n    top_items1 = np.argsort(-value_ratio1)[:2]\n    top_items2 = np.argsort(-value_ratio2)[:2]\n\n    # Perform swaps if feasible\n    for i in top_items1:\n        if base_solution[i] == 0 and remaining_capacity >= weight_lst[i]:\n            new_solution[i] = 1\n            remaining_capacity -= weight_lst[i]\n        elif base_solution[i] == 1:\n            new_solution[i] = 0\n            remaining_capacity += weight_lst[i]\n\n    for i in top_items2:\n        if base_solution[i] == 0 and remaining_capacity >= weight_lst[i]:\n            new_solution[i] = 1\n            remaining_capacity -= weight_lst[i]\n        elif base_solution[i] == 1:\n            new_solution[i] = 0\n            remaining_capacity += weight_lst[i]\n\n    # Probabilistic flip for diversification\n    for i in range(len(base_solution)):\n        if random.random() < 0.2:  # 20% chance to flip\n            if base_solution[i] == 0 and remaining_capacity >= weight_lst[i]:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n            elif base_solution[i] == 1:\n                new_solution[i] = 0\n                remaining_capacity += weight_lst[i]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random items until feasible\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n        remove_idx = random.choice(candidates)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{A novel heuristic function selects a solution from the archive with high potential for local improvement by evaluating the diversity and objective values of solutions, then applies a hybrid local search that combines item swaps, perturbations, and objective-specific moves to generate a feasible neighbor solution while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def evaluate_solution(sol, obj):\n        # Prefer solutions with high diversity and objective values\n        diversity = np.sum(sol != archive[0][0])\n        return (obj[0] + obj[1]) * diversity\n\n    candidates = [(sol, obj) for sol, obj in archive]\n    candidates.sort(key=lambda x: evaluate_solution(x[0], x[1]), reverse=True)\n    base_solution = candidates[0][0].copy()\n    base_obj = candidates[0][1]\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to perturb\n    perturb_size = min(5, n_items)\n    perturb_indices = random.sample(range(n_items), perturb_size)\n\n    # Step 2: Apply a perturbation (flip bits)\n    for idx in perturb_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 3: Ensure feasibility by removing excess weight\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items with the lowest marginal contribution to the primary objective\n        marginal_contributions = []\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                temp_sol = new_solution.copy()\n                temp_sol[i] = 0\n                temp_weight = np.sum(temp_sol * weight_lst)\n                if temp_weight <= capacity:\n                    marginal_contributions.append((i, base_obj[0] - np.sum(temp_sol * value1_lst)))\n\n        if marginal_contributions:\n            marginal_contributions.sort(key=lambda x: x[1])\n            for i, _ in marginal_contributions:\n                new_solution[i] = 0\n                if np.sum(new_solution * weight_lst) <= capacity:\n                    break\n\n    # Step 4: Apply objective-specific moves\n    if random.random() < 0.5 and len(perturb_indices) > 0:\n        # Add an item with high value1 if possible\n        candidate_items = [i for i in range(n_items) if new_solution[i] == 0]\n        if candidate_items:\n            candidate_items.sort(key=lambda i: value1_lst[i], reverse=True)\n            for i in candidate_items:\n                if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4216369609574524,
            7.716968595981598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def evaluate_solution(sol, obj):\n        # Prefer solutions with high diversity and objective values\n        diversity = np.sum(sol != archive[0][0])\n        return (obj[0] + obj[1]) * diversity\n\n    candidates = [(sol, obj) for sol, obj in archive]\n    candidates.sort(key=lambda x: evaluate_solution(x[0], x[1]), reverse=True)\n    base_solution = candidates[0][0].copy()\n    base_obj = candidates[0][1]\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to perturb\n    perturb_size = min(5, n_items)\n    perturb_indices = random.sample(range(n_items), perturb_size)\n\n    # Step 2: Apply a perturbation (flip bits)\n    for idx in perturb_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 3: Ensure feasibility by removing excess weight\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items with the lowest marginal contribution to the primary objective\n        marginal_contributions = []\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                temp_sol = new_solution.copy()\n                temp_sol[i] = 0\n                temp_weight = np.sum(temp_sol * weight_lst)\n                if temp_weight <= capacity:\n                    marginal_contributions.append((i, base_obj[0] - np.sum(temp_sol * value1_lst)))\n\n        if marginal_contributions:\n            marginal_contributions.sort(key=lambda x: x[1])\n            for i, _ in marginal_contributions:\n                new_solution[i] = 0\n                if np.sum(new_solution * weight_lst) <= capacity:\n                    break\n\n    # Step 4: Apply objective-specific moves\n    if random.random() < 0.5 and len(perturb_indices) > 0:\n        # Add an item with high value1 if possible\n        candidate_items = [i for i in range(n_items) if new_solution[i] == 0]\n        if candidate_items:\n            candidate_items.sort(key=lambda i: value1_lst[i], reverse=True)\n            for i in candidate_items:\n                if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{The heuristic selects a solution from the archive with high potential for local improvement by prioritizing solutions with high objective values and low dominance counts, then applies a novel hybrid local search operator that combines item swapping and adaptive perturbation to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Potential is a combination of objective values and dominance count (simplified)\n        potential = obj[0] + obj[1] - sum(archive[j][1][0] > obj[0] and archive[j][1][1] > obj[1] for j in range(len(archive)))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and adaptive perturbation\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Swap items to improve both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Select two items: one in the solution, one out\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        item_in = random.choice(in_items)\n        item_out = random.choice(out_items)\n\n        # Check if swap is feasible\n        delta_weight = weight_lst[item_out] - weight_lst[item_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n            current_weight += delta_weight\n\n    # Step 2: Adaptive perturbation to escape local optima\n    perturbation_strength = min(3, len(in_items))  # Adaptive strength\n    if perturbation_strength > 0:\n        items_to_flip = random.sample(list(in_items), min(perturbation_strength, len(in_items)))\n        for item in items_to_flip:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Ensure feasibility by removing random items if over capacity\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) == 0:\n            break\n        item_to_remove = random.choice(in_items)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5042288135123766,
            1.4177239537239075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Potential is a combination of objective values and dominance count (simplified)\n        potential = obj[0] + obj[1] - sum(archive[j][1][0] > obj[0] and archive[j][1][1] > obj[1] for j in range(len(archive)))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and adaptive perturbation\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Swap items to improve both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Select two items: one in the solution, one out\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        item_in = random.choice(in_items)\n        item_out = random.choice(out_items)\n\n        # Check if swap is feasible\n        delta_weight = weight_lst[item_out] - weight_lst[item_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n            current_weight += delta_weight\n\n    # Step 2: Adaptive perturbation to escape local optima\n    perturbation_strength = min(3, len(in_items))  # Adaptive strength\n    if perturbation_strength > 0:\n        items_to_flip = random.sample(list(in_items), min(perturbation_strength, len(in_items)))\n        for item in items_to_flip:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Ensure feasibility by removing random items if over capacity\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) == 0:\n            break\n        item_to_remove = random.choice(in_items)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement in both objectives, then applies a hybrid local search that combines random item swaps with a greedy selection of items based on marginal value-to-weight ratios, ensuring feasibility and maximizing multi-objective gains.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not on the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy selection\n    for _ in range(10):  # Number of iterations\n        # Randomly select a subset of items to consider for swapping\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            candidate_indices = np.where(new_solution == 0)[0]\n            if len(candidate_indices) == 0:\n                break  # No items to swap\n\n        # Randomly select an item to potentially remove\n        remove_idx = np.random.choice(candidate_indices)\n        temp_solution = new_solution.copy()\n        temp_solution[remove_idx] = 0\n\n        # Calculate remaining capacity\n        current_weight = np.sum(weight_lst[temp_solution == 1])\n        remaining_capacity = capacity - current_weight\n\n        # Find items that can be added without exceeding capacity\n        available_indices = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n        if len(available_indices) > 0:\n            # Greedily select the item with the highest combined value-to-weight ratio\n            ratios1 = value1_lst[available_indices] / weight_lst[available_indices]\n            ratios2 = value2_lst[available_indices] / weight_lst[available_indices]\n            combined_ratios = ratios1 + ratios2  # Simple combination for multi-objective\n\n            best_add_idx = available_indices[np.argmax(combined_ratios)]\n            temp_solution[best_add_idx] = 1\n\n            # Check feasibility\n            new_weight = np.sum(weight_lst[temp_solution == 1])\n            if new_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.545988676228837,
            3.594089776277542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not on the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy selection\n    for _ in range(10):  # Number of iterations\n        # Randomly select a subset of items to consider for swapping\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            candidate_indices = np.where(new_solution == 0)[0]\n            if len(candidate_indices) == 0:\n                break  # No items to swap\n\n        # Randomly select an item to potentially remove\n        remove_idx = np.random.choice(candidate_indices)\n        temp_solution = new_solution.copy()\n        temp_solution[remove_idx] = 0\n\n        # Calculate remaining capacity\n        current_weight = np.sum(weight_lst[temp_solution == 1])\n        remaining_capacity = capacity - current_weight\n\n        # Find items that can be added without exceeding capacity\n        available_indices = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n        if len(available_indices) > 0:\n            # Greedily select the item with the highest combined value-to-weight ratio\n            ratios1 = value1_lst[available_indices] / weight_lst[available_indices]\n            ratios2 = value2_lst[available_indices] / weight_lst[available_indices]\n            combined_ratios = ratios1 + ratios2  # Simple combination for multi-objective\n\n            best_add_idx = available_indices[np.argmax(combined_ratios)]\n            temp_solution[best_add_idx] = 1\n\n            # Check feasibility\n            new_weight = np.sum(weight_lst[temp_solution == 1])\n            if new_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping with probabilistic item flipping, guided by a dynamic trade-off between the two objectives, to intelligently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Calculate a score for each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        # Score is a combination of normalized objective values and diversity\n        norm_obj1 = obj[0] / (np.sum(value1_lst) + 1e-6)\n        norm_obj2 = obj[1] / (np.sum(value2_lst) + 1e-6)\n        diversity = np.sum(np.abs(sol - np.mean([s[0] for s in archive], axis=0)))\n        score = 0.5 * (norm_obj1 + norm_obj2) + 0.5 * diversity\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Adaptive item swapping (focus on improving the objective with lower value)\n    obj1, obj2 = archive[selected_idx][1]\n    if obj1 < obj2:\n        # More likely to improve objective 1\n        candidates = np.where((value1_lst > value2_lst) & (base_solution == 1))[0]\n    else:\n        # More likely to improve objective 2\n        candidates = np.where((value2_lst > value1_lst) & (base_solution == 1))[0]\n\n    if len(candidates) > 0:\n        # Swap one item with a likely better alternative\n        swap_idx = random.choice(candidates)\n        possible_replacements = np.where((base_solution == 0) &\n                                       (weight_lst <= capacity - np.sum(weight_lst * base_solution) + weight_lst[swap_idx]))[0]\n        if len(possible_replacements) > 0:\n            replace_idx = random.choice(possible_replacements)\n            new_solution[swap_idx] = 0\n            new_solution[replace_idx] = 1\n\n    # Step 2: Probabilistic item flipping (exploration)\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if base_solution[i] == 0:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n            else:\n                new_solution[i] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the heaviest item if over capacity\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) == 0:\n            break\n        remove_idx = heavy_items[np.argmax(weight_lst[heavy_items])]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.42204259487580253,
            5.498763412237167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Calculate a score for each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        # Score is a combination of normalized objective values and diversity\n        norm_obj1 = obj[0] / (np.sum(value1_lst) + 1e-6)\n        norm_obj2 = obj[1] / (np.sum(value2_lst) + 1e-6)\n        diversity = np.sum(np.abs(sol - np.mean([s[0] for s in archive], axis=0)))\n        score = 0.5 * (norm_obj1 + norm_obj2) + 0.5 * diversity\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Adaptive item swapping (focus on improving the objective with lower value)\n    obj1, obj2 = archive[selected_idx][1]\n    if obj1 < obj2:\n        # More likely to improve objective 1\n        candidates = np.where((value1_lst > value2_lst) & (base_solution == 1))[0]\n    else:\n        # More likely to improve objective 2\n        candidates = np.where((value2_lst > value1_lst) & (base_solution == 1))[0]\n\n    if len(candidates) > 0:\n        # Swap one item with a likely better alternative\n        swap_idx = random.choice(candidates)\n        possible_replacements = np.where((base_solution == 0) &\n                                       (weight_lst <= capacity - np.sum(weight_lst * base_solution) + weight_lst[swap_idx]))[0]\n        if len(possible_replacements) > 0:\n            replace_idx = random.choice(possible_replacements)\n            new_solution[swap_idx] = 0\n            new_solution[replace_idx] = 1\n\n    # Step 2: Probabilistic item flipping (exploration)\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if base_solution[i] == 0:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n            else:\n                new_solution[i] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the heaviest item if over capacity\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) == 0:\n            break\n        remove_idx = heavy_items[np.argmax(weight_lst[heavy_items])]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects solutions with high potential for improvement by combining adaptive neighborhood exploration with objective-specific perturbation to generate high-quality, feasible neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with high potential for improvement\n    # Sort solutions by their dominance score (higher is better)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)  # Select from top 30%\n    selected_solution, _ = archive_sorted[selected_idx]\n\n    new_solution = selected_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    # Randomly select a subset of items to flip (1 to 3 items)\n    n_items = len(new_solution)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Flip items while maintaining feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it improves at least one objective\n            if (value1_lst[idx] > 0 and value2_lst[idx] > 0) or random.random() < 0.7:\n                new_solution[idx] = 0\n        else:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional perturbation: swap two items if feasible\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] == 1 and new_solution[j] == 0:\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7558367704664659,
            0.8989989161491394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with high potential for improvement\n    # Sort solutions by their dominance score (higher is better)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)  # Select from top 30%\n    selected_solution, _ = archive_sorted[selected_idx]\n\n    new_solution = selected_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    # Randomly select a subset of items to flip (1 to 3 items)\n    n_items = len(new_solution)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Flip items while maintaining feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it improves at least one objective\n            if (value1_lst[idx] > 0 and value2_lst[idx] > 0) or random.random() < 0.7:\n                new_solution[idx] = 0\n        else:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional perturbation: swap two items if feasible\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] == 1 and new_solution[j] == 0:\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search combining item swaps and adaptive neighborhood exploration to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution based on objective values and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Calculate crowding distance\n    crowding_dist = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Combine objectives and crowding distance for selection\n    scores = normalized_obj[:, 0] + normalized_obj[:, 1] + crowding_dist / (np.max(crowding_dist) + 1e-10)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: item swaps with adaptive neighborhood\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # First, try to swap items in a way that improves both objectives\n    for _ in range(min(5, len(new_solution))):\n        # Find items that can be swapped\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select a random pair for swapping\n        i, j = np.random.choice(in_items, 1)[0], np.random.choice(out_items, 1)[0]\n\n        # Check feasibility\n        delta_weight = weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            # Calculate potential improvement\n            delta_value1 = value1_lst[j] - value1_lst[i]\n            delta_value2 = value2_lst[j] - value2_lst[i]\n\n            # Apply swap if it improves at least one objective\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    # Second, perform adaptive neighborhood exploration\n    for _ in range(min(3, len(new_solution))):\n        # Find items that can be flipped\n        flip_candidates = np.where((weight_lst <= (capacity - current_weight + np.sum(weight_lst * new_solution))) |\n                                 (new_solution == 1))[0]\n\n        if len(flip_candidates) == 0:\n            break\n\n        # Select a random item to flip\n        k = np.random.choice(flip_candidates, 1)[0]\n\n        # Flip the item if it improves at least one objective\n        if new_solution[k] == 0:\n            if current_weight + weight_lst[k] <= capacity:\n                new_solution[k] = 1\n                current_weight += weight_lst[k]\n        else:\n            new_solution[k] = 0\n            current_weight -= weight_lst[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7633220141918263,
            3.6082385182380676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution based on objective values and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Calculate crowding distance\n    crowding_dist = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Combine objectives and crowding distance for selection\n    scores = normalized_obj[:, 0] + normalized_obj[:, 1] + crowding_dist / (np.max(crowding_dist) + 1e-10)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: item swaps with adaptive neighborhood\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # First, try to swap items in a way that improves both objectives\n    for _ in range(min(5, len(new_solution))):\n        # Find items that can be swapped\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select a random pair for swapping\n        i, j = np.random.choice(in_items, 1)[0], np.random.choice(out_items, 1)[0]\n\n        # Check feasibility\n        delta_weight = weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            # Calculate potential improvement\n            delta_value1 = value1_lst[j] - value1_lst[i]\n            delta_value2 = value2_lst[j] - value2_lst[i]\n\n            # Apply swap if it improves at least one objective\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    # Second, perform adaptive neighborhood exploration\n    for _ in range(min(3, len(new_solution))):\n        # Find items that can be flipped\n        flip_candidates = np.where((weight_lst <= (capacity - current_weight + np.sum(weight_lst * new_solution))) |\n                                 (new_solution == 1))[0]\n\n        if len(flip_candidates) == 0:\n            break\n\n        # Select a random item to flip\n        k = np.random.choice(flip_candidates, 1)[0]\n\n        # Flip the item if it improves at least one objective\n        if new_solution[k] == 0:\n            if current_weight + weight_lst[k] <= capacity:\n                new_solution[k] = 1\n                current_weight += weight_lst[k]\n        else:\n            new_solution[k] = 0\n            current_weight -= weight_lst[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search combining random item swaps, objective-specific perturbations, and adaptive neighborhood exploration to generate a high-quality, feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low dominance counts\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate dominance counts (simplified for selection)\n    dominance_counts = []\n    for i, (obj_i) in enumerate(archive_objectives):\n        count = 0\n        for j, (obj_j) in enumerate(archive_objectives):\n            if i != j and obj_j[0] >= obj_i[0] and obj_j[1] >= obj_i[1] and (obj_j[0] > obj_i[0] or obj_j[1] > obj_i[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    # Select solutions with low dominance and high objective values\n    candidates = []\n    for i, (sol, obj) in enumerate(archive):\n        score = (obj[0] + obj[1]) / (1 + dominance_counts[i])\n        candidates.append((score, i))\n\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected_idx = candidates[0][1] if candidates else 0\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to perturb\n    # 2. Apply objective-specific perturbations\n    # 3. Ensure feasibility with adaptive neighborhood exploration\n\n    # Random subset selection\n    n_items = len(weight_lst)\n    subset_size = min(5, n_items)  # Adjust subset size based on problem size\n    subset_indices = random.sample(range(n_items), subset_size)\n\n    for idx in subset_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Objective-specific perturbations\n    # For value1: try to add items with high value1/weight ratio\n    if random.random() < 0.3:\n        value1_ratio = value1_lst / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(-value1_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n                break\n\n    # For value2: try to add items with high value2/weight ratio\n    if random.random() < 0.3:\n        value2_ratio = value2_lst / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(-value2_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n                break\n\n    # Adaptive neighborhood exploration\n    # If no improvement, try larger perturbations\n    if np.array_equal(new_solution, base_solution):\n        # Randomly flip a larger number of items\n        flip_count = min(3, n_items)\n        flip_indices = random.sample(range(n_items), flip_count)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    current_value1 -= value1_lst[idx]\n                    current_value2 -= value2_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    current_value1 += value1_lst[idx]\n                    current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3289510882109007,
            2.0119621455669403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low dominance counts\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate dominance counts (simplified for selection)\n    dominance_counts = []\n    for i, (obj_i) in enumerate(archive_objectives):\n        count = 0\n        for j, (obj_j) in enumerate(archive_objectives):\n            if i != j and obj_j[0] >= obj_i[0] and obj_j[1] >= obj_i[1] and (obj_j[0] > obj_i[0] or obj_j[1] > obj_i[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    # Select solutions with low dominance and high objective values\n    candidates = []\n    for i, (sol, obj) in enumerate(archive):\n        score = (obj[0] + obj[1]) / (1 + dominance_counts[i])\n        candidates.append((score, i))\n\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected_idx = candidates[0][1] if candidates else 0\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to perturb\n    # 2. Apply objective-specific perturbations\n    # 3. Ensure feasibility with adaptive neighborhood exploration\n\n    # Random subset selection\n    n_items = len(weight_lst)\n    subset_size = min(5, n_items)  # Adjust subset size based on problem size\n    subset_indices = random.sample(range(n_items), subset_size)\n\n    for idx in subset_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Objective-specific perturbations\n    # For value1: try to add items with high value1/weight ratio\n    if random.random() < 0.3:\n        value1_ratio = value1_lst / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(-value1_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n                break\n\n    # For value2: try to add items with high value2/weight ratio\n    if random.random() < 0.3:\n        value2_ratio = value2_lst / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(-value2_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n                break\n\n    # Adaptive neighborhood exploration\n    # If no improvement, try larger perturbations\n    if np.array_equal(new_solution, base_solution):\n        # Randomly flip a larger number of items\n        flip_count = min(3, n_items)\n        flip_indices = random.sample(range(n_items), flip_count)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    current_value1 -= value1_lst[idx]\n                    current_value2 -= value2_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    current_value1 += value1_lst[idx]\n                    current_value2 += value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (added or removed) while maintaining feasibility\n    flip_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        # If no feasible flips, return the original solution\n        return base_solution\n\n    # Randomly select a flip candidate\n    flip_idx = np.random.choice(flip_candidates)\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Apply a secondary flip to explore the neighborhood further\n    remaining_candidates = [i for i in flip_candidates if i != flip_idx]\n    if remaining_candidates:\n        secondary_flip_idx = np.random.choice(remaining_candidates)\n        new_solution[secondary_flip_idx] = 1 - new_solution[secondary_flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.748890924083582,
            1.4510406255722046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (added or removed) while maintaining feasibility\n    flip_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        # If no feasible flips, return the original solution\n        return base_solution\n\n    # Randomly select a flip candidate\n    flip_idx = np.random.choice(flip_candidates)\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Apply a secondary flip to explore the neighborhood further\n    remaining_candidates = [i for i in flip_candidates if i != flip_idx]\n    if remaining_candidates:\n        secondary_flip_idx = np.random.choice(remaining_candidates)\n        new_solution[secondary_flip_idx] = 1 - new_solution[secondary_flip_idx]\n\n    return new_solution\n\n"
    }
]