[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive with high potential for improvement, then applies a combination of item swaps, flips, and guided perturbations based on objective gradients to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Intelligent selection: choose a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply guided local search\n    # Calculate objective gradients\n    gradient1 = value1_lst / weight_lst\n    gradient2 = value2_lst / weight_lst\n\n    # Determine which objective to prioritize for improvement\n    if random.random() < 0.5:\n        # Prioritize objective 1\n        candidates = np.where((base_solution == 0) & (weight_lst <= capacity - np.sum(weight_lst * base_solution)))[0]\n        if len(candidates) > 0:\n            # Add items with highest gradient1\n            best_candidate = candidates[np.argmax(gradient1[candidates])]\n            new_solution[best_candidate] = 1\n    else:\n        # Prioritize objective 2\n        candidates = np.where((base_solution == 0) & (weight_lst <= capacity - np.sum(weight_lst * base_solution)))[0]\n        if len(candidates) > 0:\n            # Add items with highest gradient2\n            best_candidate = candidates[np.argmax(gradient2[candidates])]\n            new_solution[best_candidate] = 1\n\n    # Step 3: Apply random flips to escape local optima\n    for _ in range(2):\n        flip_candidates = np.where((base_solution == 1) | ((base_solution == 0) & (weight_lst <= capacity - np.sum(weight_lst * new_solution))))[0]\n        if len(flip_candidates) > 0:\n            flip_idx = random.choice(flip_candidates)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4200040173861279,
            0.8695991933345795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Intelligent selection: choose a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply guided local search\n    # Calculate objective gradients\n    gradient1 = value1_lst / weight_lst\n    gradient2 = value2_lst / weight_lst\n\n    # Determine which objective to prioritize for improvement\n    if random.random() < 0.5:\n        # Prioritize objective 1\n        candidates = np.where((base_solution == 0) & (weight_lst <= capacity - np.sum(weight_lst * base_solution)))[0]\n        if len(candidates) > 0:\n            # Add items with highest gradient1\n            best_candidate = candidates[np.argmax(gradient1[candidates])]\n            new_solution[best_candidate] = 1\n    else:\n        # Prioritize objective 2\n        candidates = np.where((base_solution == 0) & (weight_lst <= capacity - np.sum(weight_lst * base_solution)))[0]\n        if len(candidates) > 0:\n            # Add items with highest gradient2\n            best_candidate = candidates[np.argmax(gradient2[candidates])]\n            new_solution[best_candidate] = 1\n\n    # Step 3: Apply random flips to escape local optima\n    for _ in range(2):\n        flip_candidates = np.where((base_solution == 1) | ((base_solution == 0) & (weight_lst <= capacity - np.sum(weight_lst * new_solution))))[0]\n        if len(flip_candidates) > 0:\n            flip_idx = random.choice(flip_candidates)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by flipping a subset of items (adaptive flip based on current weight)\n    flip_indices = np.where(base_solution == 1)[0]\n    if len(flip_indices) == 0:\n        flip_indices = np.where(base_solution == 0)[0]\n\n    # Randomly select a subset of items to flip (adaptive size based on current weight)\n    flip_size = max(1, int(0.2 * len(flip_indices))) if current_weight < 0.8 * capacity else max(1, int(0.1 * len(flip_indices)))\n    flip_items = np.random.choice(flip_indices, size=flip_size, replace=False)\n\n    new_solution = base_solution.copy()\n    for idx in flip_items:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8223027996278307,
            0.922385573387146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by flipping a subset of items (adaptive flip based on current weight)\n    flip_indices = np.where(base_solution == 1)[0]\n    if len(flip_indices) == 0:\n        flip_indices = np.where(base_solution == 0)[0]\n\n    # Randomly select a subset of items to flip (adaptive size based on current weight)\n    flip_size = max(1, int(0.2 * len(flip_indices))) if current_weight < 0.8 * capacity else max(1, int(0.1 * len(flip_indices)))\n    flip_items = np.random.choice(flip_indices, size=flip_size, replace=False)\n\n    new_solution = base_solution.copy()\n    for idx in flip_items:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{The heuristic selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search operator that combines item swaps and adaptive perturbation to escape local optima while ensuring feasibility, balancing exploration and exploitation across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    def potential_score(solution, objective):\n        # Score based on objective values and diversity (e.g., distance to boundary)\n        obj1, obj2 = objective\n        total_weight = np.sum(weight_lst[solution == 1])\n        remaining_capacity = capacity - total_weight\n        # Penalize if near capacity\n        penalty = 1.0 if remaining_capacity < 0.1 * capacity else 0.0\n        return (obj1 + obj2) * (1 - penalty)\n\n    scored_solutions = [(potential_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    # Hybrid local search: swap + adaptive perturbation\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Swap-based local search (focus on high-value items)\n    for _ in range(5):\n        # Identify items to swap (prioritize high-value items)\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            break\n        swap_idx = random.choice(candidate_indices)\n        # Find item to swap out (consider weight and value impact)\n        out_indices = np.where(new_solution == 0)[0]\n        if len(out_indices) == 0:\n            break\n        # Choose item to add based on value-to-weight ratio\n        ratios = value1_lst[out_indices] / weight_lst[out_indices] + value2_lst[out_indices] / weight_lst[out_indices]\n        if len(ratios) == 0:\n            break\n        in_idx = out_indices[np.argmax(ratios)]\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[swap_idx] + weight_lst[in_idx]\n        if new_weight <= capacity:\n            new_solution[swap_idx], new_solution[in_idx] = new_solution[in_idx], new_solution[swap_idx]\n\n    # Step 2: Adaptive perturbation (escape local optima)\n    perturbation_strength = 0.2  # Adjust based on problem size\n    if random.random() < 0.3:  # 30% chance to perturb\n        n_flips = max(1, int(perturbation_strength * n_items))\n        flip_indices = random.sample(range(n_items), n_flips)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                # Check if removing this item keeps feasibility\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # Check if adding this item keeps feasibility\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.35125681496737127,
            4.133904159069061
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    def potential_score(solution, objective):\n        # Score based on objective values and diversity (e.g., distance to boundary)\n        obj1, obj2 = objective\n        total_weight = np.sum(weight_lst[solution == 1])\n        remaining_capacity = capacity - total_weight\n        # Penalize if near capacity\n        penalty = 1.0 if remaining_capacity < 0.1 * capacity else 0.0\n        return (obj1 + obj2) * (1 - penalty)\n\n    scored_solutions = [(potential_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    # Hybrid local search: swap + adaptive perturbation\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Swap-based local search (focus on high-value items)\n    for _ in range(5):\n        # Identify items to swap (prioritize high-value items)\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            break\n        swap_idx = random.choice(candidate_indices)\n        # Find item to swap out (consider weight and value impact)\n        out_indices = np.where(new_solution == 0)[0]\n        if len(out_indices) == 0:\n            break\n        # Choose item to add based on value-to-weight ratio\n        ratios = value1_lst[out_indices] / weight_lst[out_indices] + value2_lst[out_indices] / weight_lst[out_indices]\n        if len(ratios) == 0:\n            break\n        in_idx = out_indices[np.argmax(ratios)]\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[swap_idx] + weight_lst[in_idx]\n        if new_weight <= capacity:\n            new_solution[swap_idx], new_solution[in_idx] = new_solution[in_idx], new_solution[swap_idx]\n\n    # Step 2: Adaptive perturbation (escape local optima)\n    perturbation_strength = 0.2  # Adjust based on problem size\n    if random.random() < 0.3:  # 30% chance to perturb\n        n_flips = max(1, int(perturbation_strength * n_items))\n        flip_indices = random.sample(range(n_items), n_flips)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                # Check if removing this item keeps feasibility\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # Check if adding this item keeps feasibility\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining item swapping, reinsertion, and adaptive perturbation to explore the solution space while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the frontier)\n    candidate_indices = []\n    for idx, (sol, _) in enumerate(archive):\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < 0.9 * capacity:  # Avoid solutions already near capacity\n            candidate_indices.append(idx)\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap, reinsert, and perturb\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n    max_iter = min(5, n_items // 2)\n\n    for _ in range(max_iter):\n        # Randomly select two items to swap\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] == new_solution[j]:\n            continue  # No change if same status\n\n        # Calculate new weight after swap\n        delta_weight = weight_lst[i] - weight_lst[j] if new_solution[i] else weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n        # Reinsertion: try to add a new item if possible\n        available_items = np.where(~new_solution)[0]\n        if len(available_items) > 0 and current_weight < capacity:\n            k = random.choice(available_items)\n            if current_weight + weight_lst[k] <= capacity:\n                new_solution[k] = 1\n                current_weight += weight_lst[k]\n\n        # Adaptive perturbation: randomly flip a small number of bits\n        if random.random() < 0.3:\n            flip_indices = random.sample(range(n_items), min(2, n_items))\n            for idx in flip_indices:\n                if new_solution[idx]:\n                    if current_weight - weight_lst[idx] >= 0:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n                else:\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.36584535690799425,
            2.8695354759693146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the frontier)\n    candidate_indices = []\n    for idx, (sol, _) in enumerate(archive):\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < 0.9 * capacity:  # Avoid solutions already near capacity\n            candidate_indices.append(idx)\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap, reinsert, and perturb\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n    max_iter = min(5, n_items // 2)\n\n    for _ in range(max_iter):\n        # Randomly select two items to swap\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] == new_solution[j]:\n            continue  # No change if same status\n\n        # Calculate new weight after swap\n        delta_weight = weight_lst[i] - weight_lst[j] if new_solution[i] else weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n        # Reinsertion: try to add a new item if possible\n        available_items = np.where(~new_solution)[0]\n        if len(available_items) > 0 and current_weight < capacity:\n            k = random.choice(available_items)\n            if current_weight + weight_lst[k] <= capacity:\n                new_solution[k] = 1\n                current_weight += weight_lst[k]\n\n        # Adaptive perturbation: randomly flip a small number of bits\n        if random.random() < 0.3:\n            flip_indices = random.sample(range(n_items), min(2, n_items))\n            for idx in flip_indices:\n                if new_solution[idx]:\n                    if current_weight - weight_lst[idx] >= 0:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n                else:\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{The algorithm selects a promising solution from the archive based on diversity and objective value, then applies a hybrid local search combining item swapping and adaptive perturbation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and apply adaptive perturbation\n    num_items = len(weight_lst)\n    max_iterations = min(10, num_items // 2)\n\n    for _ in range(max_iterations):\n        # Swap two items\n        item1, item2 = random.sample(range(num_items), 2)\n        new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # If infeasible, undo the swap and try another operation\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            continue\n\n        # Adaptive perturbation: flip a random bit if the solution is not improving\n        if random.random() < 0.3:  # 30% chance of perturbation\n            item = random.randint(0, num_items - 1)\n            new_solution[item] = 1 - new_solution[item]\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                new_solution[item] = 1 - new_solution[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4406254421238748,
            1.6328343451023102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and apply adaptive perturbation\n    num_items = len(weight_lst)\n    max_iterations = min(10, num_items // 2)\n\n    for _ in range(max_iterations):\n        # Swap two items\n        item1, item2 = random.sample(range(num_items), 2)\n        new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # If infeasible, undo the swap and try another operation\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            continue\n\n        # Adaptive perturbation: flip a random bit if the solution is not improving\n        if random.random() < 0.3:  # 30% chance of perturbation\n            item = random.randint(0, num_items - 1)\n            new_solution[item] = 1 - new_solution[item]\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                new_solution[item] = 1 - new_solution[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomly flip items with high marginal value-to-weight ratio and low correlation\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - total_weight\n\n    # Calculate marginal value-to-weight ratios\n    marginal_ratios1 = value1_lst / weight_lst\n    marginal_ratios2 = value2_lst / weight_lst\n\n    # Identify items not in the solution with high marginal ratios\n    candidate_items = np.where(base_solution == 0)[0]\n    high_ratio_items = candidate_items[np.argsort(-np.maximum(marginal_ratios1, marginal_ratios2)[candidate_items])[:min(5, len(candidate_items))]]\n\n    # Randomly select items to flip with a preference toward high-ratio items\n    if len(high_ratio_items) > 0:\n        flip_indices = np.random.choice(high_ratio_items, size=min(2, len(high_ratio_items)), replace=False)\n        new_solution[flip_indices] = 1\n\n    # Calculate current weight and value\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # If over capacity, perform a repair by removing low-marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        included_items = np.where(new_solution == 1)[0]\n        sorted_included = included_items[np.argsort(np.maximum(marginal_ratios1, marginal_ratios2)[included_items])]\n\n        # Remove items until feasible\n        for item in sorted_included:\n            if excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Ensure solution is feasible\n    assert np.sum(weight_lst[new_solution == 1]) <= capacity\n    return new_solution\n\n",
        "score": [
            -0.28501058482047575,
            9.749792009592056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomly flip items with high marginal value-to-weight ratio and low correlation\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - total_weight\n\n    # Calculate marginal value-to-weight ratios\n    marginal_ratios1 = value1_lst / weight_lst\n    marginal_ratios2 = value2_lst / weight_lst\n\n    # Identify items not in the solution with high marginal ratios\n    candidate_items = np.where(base_solution == 0)[0]\n    high_ratio_items = candidate_items[np.argsort(-np.maximum(marginal_ratios1, marginal_ratios2)[candidate_items])[:min(5, len(candidate_items))]]\n\n    # Randomly select items to flip with a preference toward high-ratio items\n    if len(high_ratio_items) > 0:\n        flip_indices = np.random.choice(high_ratio_items, size=min(2, len(high_ratio_items)), replace=False)\n        new_solution[flip_indices] = 1\n\n    # Calculate current weight and value\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # If over capacity, perform a repair by removing low-marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        included_items = np.where(new_solution == 1)[0]\n        sorted_included = included_items[np.argsort(np.maximum(marginal_ratios1, marginal_ratios2)[included_items])]\n\n        # Remove items until feasible\n        for item in sorted_included:\n            if excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Ensure solution is feasible\n    assert np.sum(weight_lst[new_solution == 1]) <= capacity\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 307,
        "algorithm": "{The heuristic selects a promising solution from the archive based on a combination of objective diversity and local improvement potential, then applies a hybrid local search operator that combines item swapping and adaptive perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    # and high diversity in objectives\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (distance to hypervolume)\n    max_val1 = max(obj[0] for obj in archive_objectives)\n    max_val2 = max(obj[1] for obj in archive_objectives)\n    potentials = [(max_val1 - obj[0]) + (max_val2 - obj[1]) for obj in archive_objectives]\n\n    # Calculate diversity (distance to neighbors in objective space)\n    diversities = []\n    for i, obj in enumerate(archive_objectives):\n        distances = [np.linalg.norm(np.array(obj) - np.array(archive_objectives[j]))\n                    for j in range(len(archive_objectives)) if j != i]\n        diversities.append(min(distances) if distances else 0)\n\n    # Combine potential and diversity for selection\n    combined_scores = [potentials[i] * diversities[i] for i in range(len(archive))]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search operator: combine item swapping and adaptive perturbation\n    # 1. Item swapping: swap two items (one in, one out)\n    # Find items that can be swapped while maintaining feasibility\n    candidates_in = np.where(new_solution == 0)[0]\n    candidates_out = np.where(new_solution == 1)[0]\n\n    if len(candidates_in) > 0 and len(candidates_out) > 0:\n        # Select random items for swapping\n        in_item = random.choice(candidates_in)\n        out_item = random.choice(candidates_out)\n\n        # Check if swap is feasible\n        if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n            new_solution[out_item] = 0\n            new_solution[in_item] = 1\n\n    # 2. Adaptive perturbation: flip a random subset of items based on current solution quality\n    # Higher perturbation probability for solutions with lower diversity\n    diversity = diversities[selected_idx]\n    perturbation_prob = 0.1 + 0.4 * (1 - diversity / (max(diversities) + 1e-6))\n\n    for i in range(len(new_solution)):\n        if random.random() < perturbation_prob:\n            if new_solution[i] == 1:\n                if total_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n            else:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6188087974840999,
            5.6556152403354645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    # and high diversity in objectives\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (distance to hypervolume)\n    max_val1 = max(obj[0] for obj in archive_objectives)\n    max_val2 = max(obj[1] for obj in archive_objectives)\n    potentials = [(max_val1 - obj[0]) + (max_val2 - obj[1]) for obj in archive_objectives]\n\n    # Calculate diversity (distance to neighbors in objective space)\n    diversities = []\n    for i, obj in enumerate(archive_objectives):\n        distances = [np.linalg.norm(np.array(obj) - np.array(archive_objectives[j]))\n                    for j in range(len(archive_objectives)) if j != i]\n        diversities.append(min(distances) if distances else 0)\n\n    # Combine potential and diversity for selection\n    combined_scores = [potentials[i] * diversities[i] for i in range(len(archive))]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search operator: combine item swapping and adaptive perturbation\n    # 1. Item swapping: swap two items (one in, one out)\n    # Find items that can be swapped while maintaining feasibility\n    candidates_in = np.where(new_solution == 0)[0]\n    candidates_out = np.where(new_solution == 1)[0]\n\n    if len(candidates_in) > 0 and len(candidates_out) > 0:\n        # Select random items for swapping\n        in_item = random.choice(candidates_in)\n        out_item = random.choice(candidates_out)\n\n        # Check if swap is feasible\n        if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n            new_solution[out_item] = 0\n            new_solution[in_item] = 1\n\n    # 2. Adaptive perturbation: flip a random subset of items based on current solution quality\n    # Higher perturbation probability for solutions with lower diversity\n    diversity = diversities[selected_idx]\n    perturbation_prob = 0.1 + 0.4 * (1 - diversity / (max(diversities) + 1e-6))\n\n    for i in range(len(new_solution)):\n        if random.random() < perturbation_prob:\n            if new_solution[i] == 1:\n                if total_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n            else:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 308,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel local search operator that combines adaptive item swapping and greedy value augmentation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive) - 1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n    # Select solution with highest crowding distance (promising for exploration)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Adaptive item swapping (flip items with high value-to-weight ratio)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    value_ratio1 = value1_lst / (weight_lst + 1e-10)\n    value_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Select items to flip based on combined value ratios\n    combined_ratio = (value_ratio1 + value_ratio2) / 2\n    sorted_items = np.argsort(combined_ratio)[::-1]\n\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Try removing item\n            if total_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                total_weight -= weight_lst[item]\n        else:\n            # Try adding item\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Greedy value augmentation (add items with highest marginal value)\n    remaining_weight = capacity - total_weight\n    remaining_items = np.where(new_solution == 0)[0]\n\n    if len(remaining_items) > 0:\n        # Calculate marginal value for each remaining item\n        marginal_value1 = value1_lst[remaining_items]\n        marginal_value2 = value2_lst[remaining_items]\n        marginal_weight = weight_lst[remaining_items]\n\n        # Sort by combined marginal value\n        combined_marginal = (marginal_value1 + marginal_value2) / (marginal_weight + 1e-10)\n        sorted_marginal = np.argsort(combined_marginal)[::-1]\n\n        for idx in sorted_marginal:\n            item = remaining_items[idx]\n            if marginal_weight[idx] <= remaining_weight:\n                new_solution[item] = 1\n                remaining_weight -= marginal_weight[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7684927207121581,
            9.357536852359772
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive) - 1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n    # Select solution with highest crowding distance (promising for exploration)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Adaptive item swapping (flip items with high value-to-weight ratio)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    value_ratio1 = value1_lst / (weight_lst + 1e-10)\n    value_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Select items to flip based on combined value ratios\n    combined_ratio = (value_ratio1 + value_ratio2) / 2\n    sorted_items = np.argsort(combined_ratio)[::-1]\n\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Try removing item\n            if total_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                total_weight -= weight_lst[item]\n        else:\n            # Try adding item\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Greedy value augmentation (add items with highest marginal value)\n    remaining_weight = capacity - total_weight\n    remaining_items = np.where(new_solution == 0)[0]\n\n    if len(remaining_items) > 0:\n        # Calculate marginal value for each remaining item\n        marginal_value1 = value1_lst[remaining_items]\n        marginal_value2 = value2_lst[remaining_items]\n        marginal_weight = weight_lst[remaining_items]\n\n        # Sort by combined marginal value\n        combined_marginal = (marginal_value1 + marginal_value2) / (marginal_weight + 1e-10)\n        sorted_marginal = np.argsort(combined_marginal)[::-1]\n\n        for idx in sorted_marginal:\n            item = remaining_items[idx]\n            if marginal_weight[idx] <= remaining_weight:\n                new_solution[item] = 1\n                remaining_weight -= marginal_weight[idx]\n\n    return new_solution\n\n"
    }
]