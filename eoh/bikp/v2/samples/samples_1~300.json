[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with high objective values and generates a neighbor by intelligently flipping items with the highest marginal gain in either objective, ensuring feasibility through a weighted random selection that balances both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with higher objective values\n    archive.sort(key=lambda x: (-x[1][0], -x[1][1]))\n    base_solution = archive[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items to flip\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Calculate marginal gains for each candidate\n    marginal_gains = []\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # If item is included, calculate gain if removed\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[idx]\n                gain2 = -value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n        else:\n            # If item is not included, calculate gain if added\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n\n    if not marginal_gains:\n        # If no feasible flips, return the base solution\n        return base_solution\n\n    # Select the item with the highest combined marginal gain (weighted by objectives)\n    # We use a random weight to balance between the two objectives\n    alpha = random.uniform(0.3, 0.7)\n    best_idx = max(marginal_gains, key=lambda x: alpha * x[1] + (1 - alpha) * x[2])[0]\n\n    # Flip the selected item\n    new_solution = base_solution.copy()\n    new_solution[best_idx] = 1 - new_solution[best_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.774634286064095,
            2.6775991022586823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with higher objective values\n    archive.sort(key=lambda x: (-x[1][0], -x[1][1]))\n    base_solution = archive[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items to flip\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Calculate marginal gains for each candidate\n    marginal_gains = []\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # If item is included, calculate gain if removed\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[idx]\n                gain2 = -value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n        else:\n            # If item is not included, calculate gain if added\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n\n    if not marginal_gains:\n        # If no feasible flips, return the base solution\n        return base_solution\n\n    # Select the item with the highest combined marginal gain (weighted by objectives)\n    # We use a random weight to balance between the two objectives\n    alpha = random.uniform(0.3, 0.7)\n    best_idx = max(marginal_gains, key=lambda x: alpha * x[1] + (1 - alpha) * x[2])[0]\n\n    # Flip the selected item\n    new_solution = base_solution.copy()\n    new_solution[best_idx] = 1 - new_solution[best_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with high objective values and generates a neighbor by intelligently flipping items with the highest marginal gain in either objective, ensuring feasibility through a weighted random selection that balances both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with higher objective values\n    archive.sort(key=lambda x: (-x[1][0], -x[1][1]))\n    base_solution = archive[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items to flip\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Calculate marginal gains for each candidate\n    marginal_gains = []\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # If item is included, calculate gain if removed\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[idx]\n                gain2 = -value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n        else:\n            # If item is not included, calculate gain if added\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n\n    if not marginal_gains:\n        # If no feasible flips, return the base solution\n        return base_solution\n\n    # Select the item with the highest combined marginal gain (weighted by objectives)\n    # We use a random weight to balance between the two objectives\n    alpha = random.uniform(0.3, 0.7)\n    best_idx = max(marginal_gains, key=lambda x: alpha * x[1] + (1 - alpha) * x[2])[0]\n\n    # Flip the selected item\n    new_solution = base_solution.copy()\n    new_solution[best_idx] = 1 - new_solution[best_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.774634286064095,
            2.6775991022586823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with higher objective values\n    archive.sort(key=lambda x: (-x[1][0], -x[1][1]))\n    base_solution = archive[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items to flip\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Calculate marginal gains for each candidate\n    marginal_gains = []\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # If item is included, calculate gain if removed\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[idx]\n                gain2 = -value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n        else:\n            # If item is not included, calculate gain if added\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n\n    if not marginal_gains:\n        # If no feasible flips, return the base solution\n        return base_solution\n\n    # Select the item with the highest combined marginal gain (weighted by objectives)\n    # We use a random weight to balance between the two objectives\n    alpha = random.uniform(0.3, 0.7)\n    best_idx = max(marginal_gains, key=lambda x: alpha * x[1] + (1 - alpha) * x[2])[0]\n\n    # Flip the selected item\n    new_solution = base_solution.copy()\n    new_solution[best_idx] = 1 - new_solution[best_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with high objective values and generates a neighbor by intelligently flipping items with the highest marginal gain in either objective, ensuring feasibility through a weighted random selection that balances both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with higher objective values\n    archive.sort(key=lambda x: (-x[1][0], -x[1][1]))\n    base_solution = archive[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items to flip\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Calculate marginal gains for each candidate\n    marginal_gains = []\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # If item is included, calculate gain if removed\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[idx]\n                gain2 = -value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n        else:\n            # If item is not included, calculate gain if added\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n\n    if not marginal_gains:\n        # If no feasible flips, return the base solution\n        return base_solution\n\n    # Select the item with the highest combined marginal gain (weighted by objectives)\n    # We use a random weight to balance between the two objectives\n    alpha = random.uniform(0.3, 0.7)\n    best_idx = max(marginal_gains, key=lambda x: alpha * x[1] + (1 - alpha) * x[2])[0]\n\n    # Flip the selected item\n    new_solution = base_solution.copy()\n    new_solution[best_idx] = 1 - new_solution[best_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.774634286064095,
            2.6775991022586823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with higher objective values\n    archive.sort(key=lambda x: (-x[1][0], -x[1][1]))\n    base_solution = archive[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items to flip\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Calculate marginal gains for each candidate\n    marginal_gains = []\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # If item is included, calculate gain if removed\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[idx]\n                gain2 = -value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n        else:\n            # If item is not included, calculate gain if added\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains.append((idx, gain1, gain2))\n\n    if not marginal_gains:\n        # If no feasible flips, return the base solution\n        return base_solution\n\n    # Select the item with the highest combined marginal gain (weighted by objectives)\n    # We use a random weight to balance between the two objectives\n    alpha = random.uniform(0.3, 0.7)\n    best_idx = max(marginal_gains, key=lambda x: alpha * x[1] + (1 - alpha) * x[2])[0]\n\n    # Flip the selected item\n    new_solution = base_solution.copy()\n    new_solution[best_idx] = 1 - new_solution[best_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, applies a dynamic swap-and-replace strategy with probabilistic item selection, and ensures feasibility by validating weight constraints before returning the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Dynamic swap-and-replace strategy\n    n_items = len(weight_lst)\n    if n_items == 0:\n        return new_solution\n\n    # Randomly select a subset of items to consider for swapping\n    subset_size = max(1, min(5, n_items // 2))\n    candidates = random.sample(range(n_items), subset_size)\n\n    # Try to swap items in the subset with items not in the solution\n    for i in candidates:\n        if new_solution[i] == 1:\n            # Try to replace with a random item not in the solution\n            possible_replacements = [j for j in range(n_items) if new_solution[j] == 0 and (base_solution[i] == 0 or random.random() < 0.3)]\n            if possible_replacements:\n                j = random.choice(possible_replacements)\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_solution[j] = 1\n                total_weight = np.sum(weight_lst[temp_solution == 1])\n                if total_weight <= capacity:\n                    new_solution = temp_solution\n\n    # Probabilistic item addition/removal for diversity\n    for i in range(n_items):\n        if random.random() < 0.1:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                total_weight = np.sum(weight_lst[temp_solution == 1])\n                if total_weight <= capacity:\n                    new_solution = temp_solution\n            else:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                total_weight = np.sum(weight_lst[temp_solution == 1])\n                if total_weight <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.39425374588122997,
            7.592217057943344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Dynamic swap-and-replace strategy\n    n_items = len(weight_lst)\n    if n_items == 0:\n        return new_solution\n\n    # Randomly select a subset of items to consider for swapping\n    subset_size = max(1, min(5, n_items // 2))\n    candidates = random.sample(range(n_items), subset_size)\n\n    # Try to swap items in the subset with items not in the solution\n    for i in candidates:\n        if new_solution[i] == 1:\n            # Try to replace with a random item not in the solution\n            possible_replacements = [j for j in range(n_items) if new_solution[j] == 0 and (base_solution[i] == 0 or random.random() < 0.3)]\n            if possible_replacements:\n                j = random.choice(possible_replacements)\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_solution[j] = 1\n                total_weight = np.sum(weight_lst[temp_solution == 1])\n                if total_weight <= capacity:\n                    new_solution = temp_solution\n\n    # Probabilistic item addition/removal for diversity\n    for i in range(n_items):\n        if random.random() < 0.1:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                total_weight = np.sum(weight_lst[temp_solution == 1])\n                if total_weight <= capacity:\n                    new_solution = temp_solution\n            else:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                total_weight = np.sum(weight_lst[temp_solution == 1])\n                if total_weight <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive based on a combination of objective diversity and potential improvement, then applies a dynamic neighborhood exploration strategy that intelligently flips subsets of items while respecting capacity constraints, balancing exploration of both objectives through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for flip\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, -1))  # -1 means remove\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, 1))  # 1 means add\n\n    if not candidate_items:\n        return base_solution.copy()\n\n    # Select a random candidate item to flip\n    item_idx, flip = random.choice(candidate_items)\n\n    # Create new solution\n    new_solution = base_solution.copy()\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    # Apply additional flips based on objective diversity\n    if len(candidate_items) > 1 and random.random() < 0.3:  # 30% chance for additional flips\n        additional_flips = random.randint(1, min(3, len(candidate_items) - 1))\n        for _ in range(additional_flips):\n            # Select another candidate item that's different from the first flip\n            other_candidates = [c for c in candidate_items if c[0] != item_idx]\n            if other_candidates:\n                other_idx, other_flip = random.choice(other_candidates)\n                new_solution[other_idx] = 1 if other_flip == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8435106864384436,
            2.309448927640915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for flip\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, -1))  # -1 means remove\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, 1))  # 1 means add\n\n    if not candidate_items:\n        return base_solution.copy()\n\n    # Select a random candidate item to flip\n    item_idx, flip = random.choice(candidate_items)\n\n    # Create new solution\n    new_solution = base_solution.copy()\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    # Apply additional flips based on objective diversity\n    if len(candidate_items) > 1 and random.random() < 0.3:  # 30% chance for additional flips\n        additional_flips = random.randint(1, min(3, len(candidate_items) - 1))\n        for _ in range(additional_flips):\n            # Select another candidate item that's different from the first flip\n            other_candidates = [c for c in candidate_items if c[0] != item_idx]\n            if other_candidates:\n                other_idx, other_flip = random.choice(other_candidates)\n                new_solution[other_idx] = 1 if other_flip == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive based on a combination of objective diversity and potential improvement, then applies a dynamic neighborhood exploration strategy that intelligently flips subsets of items while respecting capacity constraints, balancing exploration of both objectives through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for flip\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, -1))  # -1 means remove\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, 1))  # 1 means add\n\n    if not candidate_items:\n        return base_solution.copy()\n\n    # Select a random candidate item to flip\n    item_idx, flip = random.choice(candidate_items)\n\n    # Create new solution\n    new_solution = base_solution.copy()\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    # Apply additional flips based on objective diversity\n    if len(candidate_items) > 1 and random.random() < 0.3:  # 30% chance for additional flips\n        additional_flips = random.randint(1, min(3, len(candidate_items) - 1))\n        for _ in range(additional_flips):\n            # Select another candidate item that's different from the first flip\n            other_candidates = [c for c in candidate_items if c[0] != item_idx]\n            if other_candidates:\n                other_idx, other_flip = random.choice(other_candidates)\n                new_solution[other_idx] = 1 if other_flip == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8435106864384436,
            2.309448927640915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for flip\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, -1))  # -1 means remove\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, 1))  # 1 means add\n\n    if not candidate_items:\n        return base_solution.copy()\n\n    # Select a random candidate item to flip\n    item_idx, flip = random.choice(candidate_items)\n\n    # Create new solution\n    new_solution = base_solution.copy()\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    # Apply additional flips based on objective diversity\n    if len(candidate_items) > 1 and random.random() < 0.3:  # 30% chance for additional flips\n        additional_flips = random.randint(1, min(3, len(candidate_items) - 1))\n        for _ in range(additional_flips):\n            # Select another candidate item that's different from the first flip\n            other_candidates = [c for c in candidate_items if c[0] != item_idx]\n            if other_candidates:\n                other_idx, other_flip = random.choice(other_candidates)\n                new_solution[other_idx] = 1 if other_flip == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive based on a combination of objective diversity and potential improvement, then applies a dynamic neighborhood exploration strategy that intelligently flips subsets of items while respecting capacity constraints, balancing exploration of both objectives through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for flip\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, -1))  # -1 means remove\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, 1))  # 1 means add\n\n    if not candidate_items:\n        return base_solution.copy()\n\n    # Select a random candidate item to flip\n    item_idx, flip = random.choice(candidate_items)\n\n    # Create new solution\n    new_solution = base_solution.copy()\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    # Apply additional flips based on objective diversity\n    if len(candidate_items) > 1 and random.random() < 0.3:  # 30% chance for additional flips\n        additional_flips = random.randint(1, min(3, len(candidate_items) - 1))\n        for _ in range(additional_flips):\n            # Select another candidate item that's different from the first flip\n            other_candidates = [c for c in candidate_items if c[0] != item_idx]\n            if other_candidates:\n                other_idx, other_flip = random.choice(other_candidates)\n                new_solution[other_idx] = 1 if other_flip == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8435106864384436,
            2.309448927640915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for flip\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, -1))  # -1 means remove\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, 1))  # 1 means add\n\n    if not candidate_items:\n        return base_solution.copy()\n\n    # Select a random candidate item to flip\n    item_idx, flip = random.choice(candidate_items)\n\n    # Create new solution\n    new_solution = base_solution.copy()\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    # Apply additional flips based on objective diversity\n    if len(candidate_items) > 1 and random.random() < 0.3:  # 30% chance for additional flips\n        additional_flips = random.randint(1, min(3, len(candidate_items) - 1))\n        for _ in range(additional_flips):\n            # Select another candidate item that's different from the first flip\n            other_candidates = [c for c in candidate_items if c[0] != item_idx]\n            if other_candidates:\n                other_idx, other_flip = random.choice(other_candidates)\n                new_solution[other_idx] = 1 if other_flip == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / (np.sum(value1_lst) + 1e-6), obj[1] / (np.sum(value2_lst) + 1e-6))\n        normalized_objectives.append(np.sum(normalized_obj))\n    base_idx = np.argmax(normalized_objectives)\n    base_solution = archive[base_idx][0].copy()\n\n    # Generate a neighbor by flipping a random item and ensuring feasibility\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Candidate items for flipping (those not in solution or in solution but can be removed)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0:\n            if total_weight + weight_lst[i] <= capacity:\n                candidates.append(i)\n        else:\n            if total_weight - weight_lst[i] <= capacity:\n                candidates.append(i)\n\n    if not candidates:\n        return base_solution  # No feasible move\n\n    # Select a random candidate to flip\n    flip_idx = np.random.choice(candidates)\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility by removing items if needed (for cases where adding an item causes overflow)\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items randomly until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            remove_idx = np.random.choice(included_items)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.842666930320797,
            7.657790273427963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / (np.sum(value1_lst) + 1e-6), obj[1] / (np.sum(value2_lst) + 1e-6))\n        normalized_objectives.append(np.sum(normalized_obj))\n    base_idx = np.argmax(normalized_objectives)\n    base_solution = archive[base_idx][0].copy()\n\n    # Generate a neighbor by flipping a random item and ensuring feasibility\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Candidate items for flipping (those not in solution or in solution but can be removed)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0:\n            if total_weight + weight_lst[i] <= capacity:\n                candidates.append(i)\n        else:\n            if total_weight - weight_lst[i] <= capacity:\n                candidates.append(i)\n\n    if not candidates:\n        return base_solution  # No feasible move\n\n    # Select a random candidate to flip\n    flip_idx = np.random.choice(candidates)\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility by removing items if needed (for cases where adding an item causes overflow)\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items randomly until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            remove_idx = np.random.choice(included_items)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The heuristic selects a solution from the archive based on its potential for improvement, then applies a hybrid local search that combines item swapping and adaptive perturbation to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in both objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    # Step 1: Swap items with high marginal gains\n    candidates = np.where(base_solution == 1)[0]\n    if len(candidates) > 0:\n        i = random.choice(candidates)\n        new_solution[i] = 0\n        # Find best item to add (not already in solution)\n        excluded = np.where(base_solution == 0)[0]\n        if len(excluded) > 0:\n            # Calculate marginal gains for each excluded item\n            marginal_gains1 = value1_lst[excluded]\n            marginal_gains2 = value2_lst[excluded]\n            # Combine gains (e.g., weighted sum)\n            combined_gains = marginal_gains1 + marginal_gains2\n            # Select top k candidates\n            k = min(3, len(excluded))\n            top_indices = np.argsort(combined_gains)[-k:]\n            j = excluded[top_indices[random.randint(0, k-1)]]\n            # Check feasibility\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    # Step 2: Adaptive perturbation (flip a random item if no improvement)\n    if np.array_equal(new_solution, base_solution):\n        # Flip a random item (add if excluded, remove if included)\n        candidates = np.arange(len(base_solution))\n        if len(candidates) > 0:\n            k = random.choice(candidates)\n            new_solution[k] = 1 - new_solution[k]\n            # Ensure feasibility\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                # Remove heaviest item if over capacity\n                included = np.where(new_solution == 1)[0]\n                if len(included) > 0:\n                    heaviest = included[np.argmax(weight_lst[included])]\n                    new_solution[heaviest] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.38334582632358083,
            1.3892132341861725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in both objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    # Step 1: Swap items with high marginal gains\n    candidates = np.where(base_solution == 1)[0]\n    if len(candidates) > 0:\n        i = random.choice(candidates)\n        new_solution[i] = 0\n        # Find best item to add (not already in solution)\n        excluded = np.where(base_solution == 0)[0]\n        if len(excluded) > 0:\n            # Calculate marginal gains for each excluded item\n            marginal_gains1 = value1_lst[excluded]\n            marginal_gains2 = value2_lst[excluded]\n            # Combine gains (e.g., weighted sum)\n            combined_gains = marginal_gains1 + marginal_gains2\n            # Select top k candidates\n            k = min(3, len(excluded))\n            top_indices = np.argsort(combined_gains)[-k:]\n            j = excluded[top_indices[random.randint(0, k-1)]]\n            # Check feasibility\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    # Step 2: Adaptive perturbation (flip a random item if no improvement)\n    if np.array_equal(new_solution, base_solution):\n        # Flip a random item (add if excluded, remove if included)\n        candidates = np.arange(len(base_solution))\n        if len(candidates) > 0:\n            k = random.choice(candidates)\n            new_solution[k] = 1 - new_solution[k]\n            # Ensure feasibility\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                # Remove heaviest item if over capacity\n                included = np.where(new_solution == 1)[0]\n                if len(included) > 0:\n                    heaviest = included[np.argmax(weight_lst[included])]\n                    new_solution[heaviest] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The heuristic selects a solution from the archive based on its potential for improvement, then applies a hybrid local search that combines item swapping and adaptive perturbation to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in both objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    # Step 1: Swap items with high marginal gains\n    candidates = np.where(base_solution == 1)[0]\n    if len(candidates) > 0:\n        i = random.choice(candidates)\n        new_solution[i] = 0\n        # Find best item to add (not already in solution)\n        excluded = np.where(base_solution == 0)[0]\n        if len(excluded) > 0:\n            # Calculate marginal gains for each excluded item\n            marginal_gains1 = value1_lst[excluded]\n            marginal_gains2 = value2_lst[excluded]\n            # Combine gains (e.g., weighted sum)\n            combined_gains = marginal_gains1 + marginal_gains2\n            # Select top k candidates\n            k = min(3, len(excluded))\n            top_indices = np.argsort(combined_gains)[-k:]\n            j = excluded[top_indices[random.randint(0, k-1)]]\n            # Check feasibility\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    # Step 2: Adaptive perturbation (flip a random item if no improvement)\n    if np.array_equal(new_solution, base_solution):\n        # Flip a random item (add if excluded, remove if included)\n        candidates = np.arange(len(base_solution))\n        if len(candidates) > 0:\n            k = random.choice(candidates)\n            new_solution[k] = 1 - new_solution[k]\n            # Ensure feasibility\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                # Remove heaviest item if over capacity\n                included = np.where(new_solution == 1)[0]\n                if len(included) > 0:\n                    heaviest = included[np.argmax(weight_lst[included])]\n                    new_solution[heaviest] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.38334582632358083,
            1.3892132341861725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in both objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    # Step 1: Swap items with high marginal gains\n    candidates = np.where(base_solution == 1)[0]\n    if len(candidates) > 0:\n        i = random.choice(candidates)\n        new_solution[i] = 0\n        # Find best item to add (not already in solution)\n        excluded = np.where(base_solution == 0)[0]\n        if len(excluded) > 0:\n            # Calculate marginal gains for each excluded item\n            marginal_gains1 = value1_lst[excluded]\n            marginal_gains2 = value2_lst[excluded]\n            # Combine gains (e.g., weighted sum)\n            combined_gains = marginal_gains1 + marginal_gains2\n            # Select top k candidates\n            k = min(3, len(excluded))\n            top_indices = np.argsort(combined_gains)[-k:]\n            j = excluded[top_indices[random.randint(0, k-1)]]\n            # Check feasibility\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    # Step 2: Adaptive perturbation (flip a random item if no improvement)\n    if np.array_equal(new_solution, base_solution):\n        # Flip a random item (add if excluded, remove if included)\n        candidates = np.arange(len(base_solution))\n        if len(candidates) > 0:\n            k = random.choice(candidates)\n            new_solution[k] = 1 - new_solution[k]\n            # Ensure feasibility\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                # Remove heaviest item if over capacity\n                included = np.where(new_solution == 1)[0]\n                if len(included) > 0:\n                    heaviest = included[np.argmax(weight_lst[included])]\n                    new_solution[heaviest] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A hybrid local search strategy that combines adaptive neighborhood exploration with probabilistic item swapping, guided by both objective values and weight constraints, to generate high-quality neighbors by intelligently selecting and flipping items based on their marginal contributions to the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we randomly select one with a bias towards higher objectives)\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify candidate items for flipping (0->1 or 1->0)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, 1))   # 1 indicates addition\n\n    if not candidates:\n        # No feasible moves, return the base solution\n        return base_solution\n\n    # Select a candidate with probability proportional to its marginal contribution\n    marginal_contributions = []\n    for i, delta in candidates:\n        if delta == 1:\n            marginal = value1_lst[i] + value2_lst[i]\n        else:\n            marginal = -(value1_lst[i] + value2_lst[i])\n        marginal_contributions.append(marginal)\n\n    # Normalize to form probabilities\n    marginal_contributions = np.array(marginal_contributions)\n    if np.sum(marginal_contributions) == 0:\n        # Avoid division by zero if all marginals are zero\n        probabilities = np.ones(len(candidates)) / len(candidates)\n    else:\n        probabilities = marginal_contributions / np.sum(marginal_contributions)\n\n    selected_candidate = np.random.choice(len(candidates), p=probabilities)\n    item_idx, delta = candidates[selected_candidate]\n\n    # Apply the flip\n    new_solution[item_idx] = 1 if delta == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.9351011768226375,
            3.7242986857891083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we randomly select one with a bias towards higher objectives)\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify candidate items for flipping (0->1 or 1->0)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, 1))   # 1 indicates addition\n\n    if not candidates:\n        # No feasible moves, return the base solution\n        return base_solution\n\n    # Select a candidate with probability proportional to its marginal contribution\n    marginal_contributions = []\n    for i, delta in candidates:\n        if delta == 1:\n            marginal = value1_lst[i] + value2_lst[i]\n        else:\n            marginal = -(value1_lst[i] + value2_lst[i])\n        marginal_contributions.append(marginal)\n\n    # Normalize to form probabilities\n    marginal_contributions = np.array(marginal_contributions)\n    if np.sum(marginal_contributions) == 0:\n        # Avoid division by zero if all marginals are zero\n        probabilities = np.ones(len(candidates)) / len(candidates)\n    else:\n        probabilities = marginal_contributions / np.sum(marginal_contributions)\n\n    selected_candidate = np.random.choice(len(candidates), p=probabilities)\n    item_idx, delta = candidates[selected_candidate]\n\n    # Apply the flip\n    new_solution[item_idx] = 1 if delta == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A hybrid local search strategy that combines adaptive neighborhood exploration with probabilistic item swapping, guided by both objective values and weight constraints, to generate high-quality neighbors by intelligently selecting and flipping items based on their marginal contributions to the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we randomly select one with a bias towards higher objectives)\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify candidate items for flipping (0->1 or 1->0)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, 1))   # 1 indicates addition\n\n    if not candidates:\n        # No feasible moves, return the base solution\n        return base_solution\n\n    # Select a candidate with probability proportional to its marginal contribution\n    marginal_contributions = []\n    for i, delta in candidates:\n        if delta == 1:\n            marginal = value1_lst[i] + value2_lst[i]\n        else:\n            marginal = -(value1_lst[i] + value2_lst[i])\n        marginal_contributions.append(marginal)\n\n    # Normalize to form probabilities\n    marginal_contributions = np.array(marginal_contributions)\n    if np.sum(marginal_contributions) == 0:\n        # Avoid division by zero if all marginals are zero\n        probabilities = np.ones(len(candidates)) / len(candidates)\n    else:\n        probabilities = marginal_contributions / np.sum(marginal_contributions)\n\n    selected_candidate = np.random.choice(len(candidates), p=probabilities)\n    item_idx, delta = candidates[selected_candidate]\n\n    # Apply the flip\n    new_solution[item_idx] = 1 if delta == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.9351011768226375,
            3.7242986857891083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we randomly select one with a bias towards higher objectives)\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify candidate items for flipping (0->1 or 1->0)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, 1))   # 1 indicates addition\n\n    if not candidates:\n        # No feasible moves, return the base solution\n        return base_solution\n\n    # Select a candidate with probability proportional to its marginal contribution\n    marginal_contributions = []\n    for i, delta in candidates:\n        if delta == 1:\n            marginal = value1_lst[i] + value2_lst[i]\n        else:\n            marginal = -(value1_lst[i] + value2_lst[i])\n        marginal_contributions.append(marginal)\n\n    # Normalize to form probabilities\n    marginal_contributions = np.array(marginal_contributions)\n    if np.sum(marginal_contributions) == 0:\n        # Avoid division by zero if all marginals are zero\n        probabilities = np.ones(len(candidates)) / len(candidates)\n    else:\n        probabilities = marginal_contributions / np.sum(marginal_contributions)\n\n    selected_candidate = np.random.choice(len(candidates), p=probabilities)\n    item_idx, delta = candidates[selected_candidate]\n\n    # Apply the flip\n    new_solution[item_idx] = 1 if delta == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel hybrid local search strategy combines random walk exploration with value-based flipping, prioritizing items with high marginal utility and ensuring feasibility through weight-constrained swaps and flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    current_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst[current_solution == 1])\n    new_solution = current_solution.copy()\n\n    # Calculate marginal utilities for flipping items\n    marginal_utilities = []\n    for i in range(len(current_solution)):\n        if current_solution[i] == 1:\n            # Flipping from 1 to 0\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                marginal_utilities.append((i, -weight_lst[i], -value1_lst[i], -value2_lst[i]))\n        else:\n            # Flipping from 0 to 1\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                marginal_utilities.append((i, weight_lst[i], value1_lst[i], value2_lst[i]))\n\n    if not marginal_utilities:\n        # If no feasible flips, perform a random feasible swap\n        candidates = [i for i in range(len(current_solution)) if current_solution[i] == 1]\n        if len(candidates) >= 2:\n            i, j = random.sample(candidates, 2)\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select the flip with the highest combined marginal utility\n        best_flip = max(marginal_utilities, key=lambda x: (x[2] + x[3]) / (abs(x[1]) + 1e-6))\n        i = best_flip[0]\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, remove items randomly until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            item_to_remove = random.choice(included_items)\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.8488244667879803,
            3.385749191045761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    current_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst[current_solution == 1])\n    new_solution = current_solution.copy()\n\n    # Calculate marginal utilities for flipping items\n    marginal_utilities = []\n    for i in range(len(current_solution)):\n        if current_solution[i] == 1:\n            # Flipping from 1 to 0\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                marginal_utilities.append((i, -weight_lst[i], -value1_lst[i], -value2_lst[i]))\n        else:\n            # Flipping from 0 to 1\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                marginal_utilities.append((i, weight_lst[i], value1_lst[i], value2_lst[i]))\n\n    if not marginal_utilities:\n        # If no feasible flips, perform a random feasible swap\n        candidates = [i for i in range(len(current_solution)) if current_solution[i] == 1]\n        if len(candidates) >= 2:\n            i, j = random.sample(candidates, 2)\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select the flip with the highest combined marginal utility\n        best_flip = max(marginal_utilities, key=lambda x: (x[2] + x[3]) / (abs(x[1]) + 1e-6))\n        i = best_flip[0]\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, remove items randomly until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            item_to_remove = random.choice(included_items)\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values and applies a hybrid local search that combines random bit flips with a greedy selection of items based on a weighted sum of both objectives, ensuring feasibility and exploring diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest normalized sum\n    max_norm_sum = -1\n    selected_solution = None\n    for sol, (v1, v2) in archive:\n        norm_sum = (v1 + v2) / (np.sum(value1_lst) + np.sum(value2_lst))\n        if norm_sum > max_norm_sum:\n            max_norm_sum = norm_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly flip bits (50% chance per bit)\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:\n            if new_solution[i] == 1:\n                # Remove item if possible\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            else:\n                # Add item if feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Greedy improvement step: add items with highest weighted sum\n    # Weighted sum combines both objectives with random weights\n    w1 = random.uniform(0.3, 0.7)\n    w2 = 1 - w1\n    weighted_values = w1 * value1_lst + w2 * value2_lst\n\n    # Sort items by weighted value in descending order\n    sorted_indices = np.argsort(-weighted_values)\n\n    for i in sorted_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.36431743683539486,
            3.9254411160945892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with highest normalized sum\n    max_norm_sum = -1\n    selected_solution = None\n    for sol, (v1, v2) in archive:\n        norm_sum = (v1 + v2) / (np.sum(value1_lst) + np.sum(value2_lst))\n        if norm_sum > max_norm_sum:\n            max_norm_sum = norm_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly flip bits (50% chance per bit)\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:\n            if new_solution[i] == 1:\n                # Remove item if possible\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            else:\n                # Add item if feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Greedy improvement step: add items with highest weighted sum\n    # Weighted sum combines both objectives with random weights\n    w1 = random.uniform(0.3, 0.7)\n    w2 = 1 - w1\n    weighted_values = w1 * value1_lst + w2 * value2_lst\n\n    # Sort items by weighted value in descending order\n    sorted_indices = np.argsort(-weighted_values)\n\n    for i in sorted_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive item swapping with probabilistic neighborhood exploration to intelligently perturb solutions while ensuring feasibility, balancing exploration and exploitation to improve multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objects = [obj for sol, obj in archive]\n\n    # Calculate potential improvement score (difference from archive average)\n    avg_obj1 = np.mean([obj[0] for obj in archive_objects])\n    avg_obj2 = np.mean([obj[1] for obj in archive_objects])\n    potential_scores = []\n    for idx, (sol, obj) in enumerate(archive):\n        score = (obj[0] - avg_obj1) + (obj[1] - avg_obj2)\n        potential_scores.append(score)\n\n    # Select top 30% solutions with highest potential\n    selected_indices = np.argsort(potential_scores)[-max(1, len(potential_scores) // 3):]\n    selected_solutions = [archive_solutions[i] for i in selected_indices]\n\n    # Randomly select one solution from the top candidates\n    base_solution = random.choice(selected_solutions).copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Adaptive item swapping\n    if random.random() < 0.7:  # 70% chance for swap-based move\n        if len(included_items) > 0 and len(available_items) > 0:\n            # Select a random item to remove and a random item to add\n            remove_idx = random.choice(included_items)\n            add_idx = random.choice(available_items)\n\n            # Check feasibility\n            if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n    else:  # 30% chance for probabilistic neighborhood exploration\n        # Flip a random subset of items while maintaining feasibility\n        flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2867764055451118,
            8.765227526426315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objects = [obj for sol, obj in archive]\n\n    # Calculate potential improvement score (difference from archive average)\n    avg_obj1 = np.mean([obj[0] for obj in archive_objects])\n    avg_obj2 = np.mean([obj[1] for obj in archive_objects])\n    potential_scores = []\n    for idx, (sol, obj) in enumerate(archive):\n        score = (obj[0] - avg_obj1) + (obj[1] - avg_obj2)\n        potential_scores.append(score)\n\n    # Select top 30% solutions with highest potential\n    selected_indices = np.argsort(potential_scores)[-max(1, len(potential_scores) // 3):]\n    selected_solutions = [archive_solutions[i] for i in selected_indices]\n\n    # Randomly select one solution from the top candidates\n    base_solution = random.choice(selected_solutions).copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Adaptive item swapping\n    if random.random() < 0.7:  # 70% chance for swap-based move\n        if len(included_items) > 0 and len(available_items) > 0:\n            # Select a random item to remove and a random item to add\n            remove_idx = random.choice(included_items)\n            add_idx = random.choice(available_items)\n\n            # Check feasibility\n            if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n    else:  # 30% chance for probabilistic neighborhood exploration\n        # Flip a random subset of items while maintaining feasibility\n        flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The heuristic function selects a promising solution from the archive using a weighted random selection based on the solution's objective values, then applies a hybrid local search operator that combines item swapping with a probabilistic flip of items to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = normalized_objectives.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights / weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping + probabilistic flip\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Randomly select two items to swap (if possible)\n    if np.sum(base_solution) >= 2:\n        indices = np.where(base_solution == 1)[0]\n        i, j = np.random.choice(indices, 2, replace=False)\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistically flip items to improve objectives\n    for idx in range(n_items):\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        indices = np.where(new_solution == 1)[0]\n        np.random.shuffle(indices)\n        for idx in indices:\n            if excess <= 0:\n                break\n            if weight_lst[idx] <= excess:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8505826632826008,
            6.538542032241821
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = normalized_objectives.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights / weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping + probabilistic flip\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Randomly select two items to swap (if possible)\n    if np.sum(base_solution) >= 2:\n        indices = np.where(base_solution == 1)[0]\n        i, j = np.random.choice(indices, 2, replace=False)\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistically flip items to improve objectives\n    for idx in range(n_items):\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        indices = np.where(new_solution == 1)[0]\n        np.random.shuffle(indices)\n        for idx in indices:\n            if excess <= 0:\n                break\n            if weight_lst[idx] <= excess:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and high diversity in their item selections, then applies a hybrid local search that combines item swaps, flips, and guided perturbations to explore the solution space while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high objective values and diversity\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = random.randint(0, min(4, len(archive)-1))  # Randomly select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: item swaps, flips, and guided perturbations\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Calculate potential new weight\n        if new_solution[item1] == new_solution[item2]:\n            continue  # No change if both are same\n\n        delta_weight = (weight_lst[item2] - weight_lst[item1]) if new_solution[item1] == 1 else (weight_lst[item1] - weight_lst[item2])\n\n        if current_weight + delta_weight <= capacity:\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight += delta_weight\n\n        # Random flip with feasibility check\n        item = random.randint(0, len(new_solution)-1)\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n        # Guided perturbation: add or remove high-value items\n        if random.random() < 0.3:  # 30% chance for perturbation\n            # Select high-value items based on both objectives\n            combined_values = value1_lst + value2_lst\n            high_value_items = np.argsort(combined_values)[-5:]  # Top 5 items by combined value\n\n            for item in high_value_items:\n                if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                elif new_solution[item] == 1:\n                    if current_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3798182964000204,
            3.4705795347690582
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high objective values and diversity\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = random.randint(0, min(4, len(archive)-1))  # Randomly select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: item swaps, flips, and guided perturbations\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Calculate potential new weight\n        if new_solution[item1] == new_solution[item2]:\n            continue  # No change if both are same\n\n        delta_weight = (weight_lst[item2] - weight_lst[item1]) if new_solution[item1] == 1 else (weight_lst[item1] - weight_lst[item2])\n\n        if current_weight + delta_weight <= capacity:\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight += delta_weight\n\n        # Random flip with feasibility check\n        item = random.randint(0, len(new_solution)-1)\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n        # Guided perturbation: add or remove high-value items\n        if random.random() < 0.3:  # 30% chance for perturbation\n            # Select high-value items based on both objectives\n            combined_values = value1_lst + value2_lst\n            high_value_items = np.argsort(combined_values)[-5:]  # Top 5 items by combined value\n\n            for item in high_value_items:\n                if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                elif new_solution[item] == 1:\n                    if current_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with higher marginal potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # Strategy: Randomly flip a subset of items, ensuring feasibility\n    new_solution = base_solution.copy()\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.30572574052377,
            1.66813263297081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with higher marginal potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # Strategy: Randomly flip a subset of items, ensuring feasibility\n    new_solution = base_solution.copy()\n    num_items = len(base_solution)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A hybrid local search algorithm that intelligently combines item swaps, flips, and guided perturbation to explore the solution space while ensuring feasibility and promoting multi-objective improvement by prioritizing high-potential solutions and dynamically adjusting the search based on objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (added/removed) without violating capacity\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # Mark for removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # Mark for addition\n\n    if not candidates:\n        # If no feasible candidates, perform a random flip\n        i = np.random.randint(len(base_solution))\n        new_solution[i] = 1 - new_solution[i]\n        return new_solution\n\n    # Hybrid local search: combine swaps and flips with guided perturbation\n    for _ in range(min(3, len(candidates))):  # Limit the number of operations\n        i, op = candidates[np.random.choice(len(candidates))]\n        if op == 1:\n            new_solution[i] = 1\n        else:\n            new_solution[i] = 0\n\n    # Guided perturbation: swap items with high value ratios\n    if np.random.random() < 0.3:  # 30% chance of guided perturbation\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_ratios)[::-1]  # Highest to lowest ratio\n        for i in sorted_indices:\n            if new_solution[i] == 0 and (current_weight + weight_lst[i] <= capacity):\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8931533923818868,
            3.275682717561722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (added/removed) without violating capacity\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # Mark for removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # Mark for addition\n\n    if not candidates:\n        # If no feasible candidates, perform a random flip\n        i = np.random.randint(len(base_solution))\n        new_solution[i] = 1 - new_solution[i]\n        return new_solution\n\n    # Hybrid local search: combine swaps and flips with guided perturbation\n    for _ in range(min(3, len(candidates))):  # Limit the number of operations\n        i, op = candidates[np.random.choice(len(candidates))]\n        if op == 1:\n            new_solution[i] = 1\n        else:\n            new_solution[i] = 0\n\n    # Guided perturbation: swap items with high value ratios\n    if np.random.random() < 0.3:  # 30% chance of guided perturbation\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_ratios)[::-1]  # Highest to lowest ratio\n        for i in sorted_indices:\n            if new_solution[i] == 0 and (current_weight + weight_lst[i] <= capacity):\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest potential for local improvement, then applies a hybrid local search operator that combines item swaps with a probabilistic exploration of high-value items to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Prioritize solutions with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: -sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap items with high value-to-weight ratio\n    value_ratio1 = value1_lst / (weight_lst + 1e-10)\n    value_ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value_ratio1 + value_ratio2\n\n    # Find items to swap or flip\n    candidates = np.where(new_solution == 1)[0]\n    if len(candidates) == 0:\n        # If no items selected, add high-value items\n        candidates = np.argsort(combined_ratio)[-5:]\n\n    # Perform probabilistic swaps\n    for i in candidates:\n        if random.random() < 0.7:  # 70% chance to consider swapping\n            # Try removing item i\n            if new_solution[i] == 1:\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n                    # Try adding a high-value item not in the solution\n                    excluded = np.where(new_solution == 0)[0]\n                    if len(excluded) > 0:\n                        best_add = excluded[np.argmax(combined_ratio[excluded])]\n                        if current_weight + weight_lst[best_add] <= capacity:\n                            new_solution[best_add] = 1\n                            current_weight += weight_lst[best_add]\n                    break\n\n    # Ensure solution is feasible\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = np.random.choice(items_in)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8704139282640853,
            3.1666645109653473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Prioritize solutions with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: -sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap items with high value-to-weight ratio\n    value_ratio1 = value1_lst / (weight_lst + 1e-10)\n    value_ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value_ratio1 + value_ratio2\n\n    # Find items to swap or flip\n    candidates = np.where(new_solution == 1)[0]\n    if len(candidates) == 0:\n        # If no items selected, add high-value items\n        candidates = np.argsort(combined_ratio)[-5:]\n\n    # Perform probabilistic swaps\n    for i in candidates:\n        if random.random() < 0.7:  # 70% chance to consider swapping\n            # Try removing item i\n            if new_solution[i] == 1:\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n                    # Try adding a high-value item not in the solution\n                    excluded = np.where(new_solution == 0)[0]\n                    if len(excluded) > 0:\n                        best_add = excluded[np.argmax(combined_ratio[excluded])]\n                        if current_weight + weight_lst[best_add] <= capacity:\n                            new_solution[best_add] = 1\n                            current_weight += weight_lst[best_add]\n                    break\n\n    # Ensure solution is feasible\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = np.random.choice(items_in)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive with high potential for improvement, then applies a hybrid local search operator that combines item swapping, random flips, and objective-aware perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives (higher is better)\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        selection_pool = sorted_archive[:max(1, len(archive) // 3)]  # Top 30%\n        # Randomly select from top candidates\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # 1. Randomly flip a few items (1-3) while ensuring feasibility\n    num_flips = random.randint(1, min(3, len(base_solution)))\n    flip_indices = random.sample(range(len(base_solution)), num_flips)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item (must keep at least one item)\n            if np.sum(new_solution) > 1:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item (must not exceed capacity)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # 2. Swap two items if it improves one objective without worsening the other\n    if len(base_solution) >= 2:\n        i, j = random.sample(range(len(base_solution)), 2)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[i] != new_solution[j]:\n            # Case 1: Swap 0 and 1\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Case 2: Swap 1 and 0 (same as above)\n            elif new_solution[i] == 1 and new_solution[j] == 0:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 3. Objective-aware perturbation: randomly select an item and flip it if it improves both objectives\n    if len(base_solution) >= 1:\n        idx = random.choice(range(len(base_solution)))\n        current_value1 = np.sum(value1_lst[new_solution == 1])\n        current_value2 = np.sum(value2_lst[new_solution == 1])\n        current_weight = np.sum(weight_lst[new_solution == 1])\n\n        if new_solution[idx] == 1:\n            # Try removing\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n            if new_value1 > current_value1 and new_value2 > current_value2:\n                new_solution[idx] = 0\n        else:\n            # Try adding\n            if current_weight + weight_lst[idx] <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                if new_value1 > current_value1 and new_value2 > current_value2:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.2925616628894365,
            4.632070809602737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives (higher is better)\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        selection_pool = sorted_archive[:max(1, len(archive) // 3)]  # Top 30%\n        # Randomly select from top candidates\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # 1. Randomly flip a few items (1-3) while ensuring feasibility\n    num_flips = random.randint(1, min(3, len(base_solution)))\n    flip_indices = random.sample(range(len(base_solution)), num_flips)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item (must keep at least one item)\n            if np.sum(new_solution) > 1:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item (must not exceed capacity)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # 2. Swap two items if it improves one objective without worsening the other\n    if len(base_solution) >= 2:\n        i, j = random.sample(range(len(base_solution)), 2)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[i] != new_solution[j]:\n            # Case 1: Swap 0 and 1\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Case 2: Swap 1 and 0 (same as above)\n            elif new_solution[i] == 1 and new_solution[j] == 0:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 3. Objective-aware perturbation: randomly select an item and flip it if it improves both objectives\n    if len(base_solution) >= 1:\n        idx = random.choice(range(len(base_solution)))\n        current_value1 = np.sum(value1_lst[new_solution == 1])\n        current_value2 = np.sum(value2_lst[new_solution == 1])\n        current_weight = np.sum(weight_lst[new_solution == 1])\n\n        if new_solution[idx] == 1:\n            # Try removing\n            new_value1 = current_value1 - value1_lst[idx]\n            new_value2 = current_value2 - value2_lst[idx]\n            if new_value1 > current_value1 and new_value2 > current_value2:\n                new_solution[idx] = 0\n        else:\n            # Try adding\n            if current_weight + weight_lst[idx] <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                if new_value1 > current_value1 and new_value2 > current_value2:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search combining item swaps and adaptive perturbation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = random.choices(range(len(archive)), weights=[sum(obj) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combination of item swaps and adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select items to swap (between included and excluded)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Swap a random included item with a random excluded item\n        swap_in = random.choice(included)\n        swap_out = random.choice(excluded)\n\n        # Check if swapping is feasible\n        delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n            current_weight += delta_weight\n\n    # Step 2: Adaptive perturbation - flip a small number of items to escape local optima\n    num_flips = min(2, len(included) + len(excluded))\n    for _ in range(num_flips):\n        flip_idx = random.choice(np.concatenate([included, excluded]))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3342765842692068,
            3.746922880411148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = random.choices(range(len(archive)), weights=[sum(obj) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combination of item swaps and adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select items to swap (between included and excluded)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Swap a random included item with a random excluded item\n        swap_in = random.choice(included)\n        swap_out = random.choice(excluded)\n\n        # Check if swapping is feasible\n        delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n            current_weight += delta_weight\n\n    # Step 2: Adaptive perturbation - flip a small number of items to escape local optima\n    num_flips = min(2, len(included) + len(excluded))\n    for _ in range(num_flips):\n        flip_idx = random.choice(np.concatenate([included, excluded]))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing solutions with the highest combined objective values, then applies a hybrid local search operator that combines item swaps and random flips to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = random.randint(0, min(4, len(archive) - 1))  # Select from top 5 or all if less than 5\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and random flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # First, try to swap two items (if possible)\n    if n_items >= 2:\n        item1, item2 = random.sample(range(n_items), 2)\n        if base_solution[item1] != base_solution[item2]:\n            if base_solution[item1] == 1:\n                if current_weight - weight_lst[item1] + weight_lst[item2] <= capacity:\n                    new_solution[item1], new_solution[item2] = 0, 1\n            else:\n                if current_weight - weight_lst[item2] + weight_lst[item1] <= capacity:\n                    new_solution[item1], new_solution[item2] = 1, 0\n\n    # If no swap was possible, try a random flip\n    if np.array_equal(new_solution, base_solution):\n        item = random.randint(0, n_items - 1)\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3359452570377678,
            5.9333599507808685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = random.randint(0, min(4, len(archive) - 1))  # Select from top 5 or all if less than 5\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and random flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # First, try to swap two items (if possible)\n    if n_items >= 2:\n        item1, item2 = random.sample(range(n_items), 2)\n        if base_solution[item1] != base_solution[item2]:\n            if base_solution[item1] == 1:\n                if current_weight - weight_lst[item1] + weight_lst[item2] <= capacity:\n                    new_solution[item1], new_solution[item2] = 0, 1\n            else:\n                if current_weight - weight_lst[item2] + weight_lst[item1] <= capacity:\n                    new_solution[item1], new_solution[item2] = 1, 0\n\n    # If no swap was possible, try a random flip\n    if np.array_equal(new_solution, base_solution):\n        item = random.randint(0, n_items - 1)\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of crowding distance and solution quality, then applies a novel local search operator that combines item swaps with adaptive perturbation to explore the solution space while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (hybrid of crowding distance and solution quality)\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [float('inf')] * len(solutions)\n        distances = [0.0] * len(solutions)\n        objectives = np.array([obj for _, obj in solutions])\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(solutions) - 1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        return distances\n\n    distances = crowding_distance(archive)\n    max_dist_idx = np.argmax(distances)\n    base_solution = archive[max_dist_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Adaptive perturbation: more aggressive if solution is crowded\n    perturbation_strength = 0.3 if distances[max_dist_idx] < np.mean(distances) else 0.1\n    num_changes = max(1, int(len(items) * perturbation_strength))\n\n    # Perform item swaps\n    for _ in range(num_changes):\n        if len(items) > 0 and len(non_items) > 0:\n            # Randomly select an item to remove and a non-item to add\n            remove_idx = np.random.choice(items)\n            add_idx = np.random.choice(non_items)\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[base_solution == 1])\n            new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n            if new_weight <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                base_solution = new_solution.copy()\n                items = np.where(base_solution == 1)[0]\n                non_items = np.where(base_solution == 0)[0]\n\n    # Ensure solution is feasible (in case of multiple changes)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        if len(items) == 0:\n            break\n        remove_idx = np.random.choice(items)\n        new_solution[remove_idx] = 0\n        items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.7363815045000559,
            9.286520421504974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (hybrid of crowding distance and solution quality)\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [float('inf')] * len(solutions)\n        distances = [0.0] * len(solutions)\n        objectives = np.array([obj for _, obj in solutions])\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(solutions) - 1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        return distances\n\n    distances = crowding_distance(archive)\n    max_dist_idx = np.argmax(distances)\n    base_solution = archive[max_dist_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Adaptive perturbation: more aggressive if solution is crowded\n    perturbation_strength = 0.3 if distances[max_dist_idx] < np.mean(distances) else 0.1\n    num_changes = max(1, int(len(items) * perturbation_strength))\n\n    # Perform item swaps\n    for _ in range(num_changes):\n        if len(items) > 0 and len(non_items) > 0:\n            # Randomly select an item to remove and a non-item to add\n            remove_idx = np.random.choice(items)\n            add_idx = np.random.choice(non_items)\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[base_solution == 1])\n            new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n            if new_weight <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                base_solution = new_solution.copy()\n                items = np.where(base_solution == 1)[0]\n                non_items = np.where(base_solution == 0)[0]\n\n    # Ensure solution is feasible (in case of multiple changes)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        if len(items) == 0:\n            break\n        remove_idx = np.random.choice(items)\n        new_solution[remove_idx] = 0\n        items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    # Select the middle solution (to balance exploration and exploitation)\n    selected_idx = len(archive_sorted) // 2\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    # Hybrid strategy: Randomly flip a subset of items and then apply a greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Randomly flip a subset of items (with probability 0.3)\n    flip_mask = np.random.rand(n_items) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items in order of lowest value contribution to the selected objective\n        # Here, we use the sum of normalized value1 and value2\n        normalized_values = (value1_lst + value2_lst) / (np.sum(value1_lst) + np.sum(value2_lst))\n        while total_weight > capacity:\n            # Find the item with the lowest value contribution that is included\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break  # No items left to remove\n            item_to_remove = candidate_indices[np.argmin(normalized_values[candidate_indices])]\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    # Step 3: Apply a greedy improvement step\n    # Try adding items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)  # Randomize order for diversity\n    for item in remaining_items:\n        if total_weight + weight_lst[item] <= capacity:\n            # Check if adding this item improves both objectives\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = current_value1 + value1_lst[item]\n            new_value2 = current_value2 + value2_lst[item]\n\n            # If both objectives are improved or at least one is improved without significant loss in the other\n            if (new_value1 > current_value1 and new_value2 > current_value2) or \\\n               (new_value1 > current_value1 and new_value2 >= current_value2 * 0.95) or \\\n               (new_value2 > current_value2 and new_value1 >= current_value1 * 0.95):\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.43607563002717725,
            6.59539395570755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    # Select the middle solution (to balance exploration and exploitation)\n    selected_idx = len(archive_sorted) // 2\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    # Hybrid strategy: Randomly flip a subset of items and then apply a greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Randomly flip a subset of items (with probability 0.3)\n    flip_mask = np.random.rand(n_items) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items in order of lowest value contribution to the selected objective\n        # Here, we use the sum of normalized value1 and value2\n        normalized_values = (value1_lst + value2_lst) / (np.sum(value1_lst) + np.sum(value2_lst))\n        while total_weight > capacity:\n            # Find the item with the lowest value contribution that is included\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break  # No items left to remove\n            item_to_remove = candidate_indices[np.argmin(normalized_values[candidate_indices])]\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    # Step 3: Apply a greedy improvement step\n    # Try adding items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)  # Randomize order for diversity\n    for item in remaining_items:\n        if total_weight + weight_lst[item] <= capacity:\n            # Check if adding this item improves both objectives\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = current_value1 + value1_lst[item]\n            new_value2 = current_value2 + value2_lst[item]\n\n            # If both objectives are improved or at least one is improved without significant loss in the other\n            if (new_value1 > current_value1 and new_value2 > current_value2) or \\\n               (new_value1 > current_value1 and new_value2 >= current_value2 * 0.95) or \\\n               (new_value2 > current_value2 and new_value1 >= current_value1 * 0.95):\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items\n    n_items = len(base_solution)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0  # Remove item\n        else:\n            # Add item only if it fits within capacity\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.326461603117784,
            2.781185567378998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items\n    n_items = len(base_solution)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0  # Remove item\n        else:\n            # Add item only if it fits within capacity\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid heuristic combining crowding distance and objective diversity, then applies a novel \"guided flip\" local search that intelligently flips items to improve both objectives while ensuring feasibility, balancing exploration and exploitation through a dynamic neighborhood exploration strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distances for each solution in the archive\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives for crowding distance calculation\n    obj1 = np.array([o[0] for o in objectives])\n    obj2 = np.array([o[1] for o in objectives])\n    min_obj1, max_obj1 = np.min(obj1), np.max(obj1)\n    min_obj2, max_obj2 = np.min(obj2), np.max(obj2)\n\n    if max_obj1 == min_obj1:\n        norm_obj1 = np.zeros_like(obj1)\n    else:\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1)\n\n    if max_obj2 == min_obj2:\n        norm_obj2 = np.zeros_like(obj2)\n    else:\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2)\n\n    # Sort solutions by objective values\n    sorted_indices = np.lexsort((norm_obj2, norm_obj1))\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For both objectives\n        obj = norm_obj1 if i == 0 else norm_obj2\n        sorted_obj = obj[sorted_indices]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[j]] += (sorted_obj[j+1] - sorted_obj[j-1])\n\n    # Select solutions with high crowding distance (promising for improvement)\n    selected_indices = np.argsort(crowding_distances)[-max(1, len(archive)//3):]\n    selected_solutions = [solutions[i] for i in selected_indices]\n    selected_objectives = [objectives[i] for i in selected_indices]\n\n    # Further select based on objective diversity\n    # Choose the solution with the most diverse objectives\n    if len(selected_solutions) > 1:\n        base_solution = selected_solutions[np.argmax([o[0] + o[1] for o in selected_objectives])]\n    else:\n        base_solution = selected_solutions[0]\n\n    # Step 2: Generate a neighbor solution using guided flip local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Find items that can be flipped (either added or removed)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, 'remove'))\n        else:\n            # Check if adding this item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 'add'))\n\n    if not candidates:\n        return new_solution  # No feasible flips possible\n\n    # Evaluate each candidate flip\n    best_candidate = None\n    best_score = -np.inf\n\n    for i, action in candidates:\n        if action == 'remove':\n            new_weight = current_weight - weight_lst[i]\n            new_value1 = current_value1 - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i]\n            delta1 = -value1_lst[i]\n            delta2 = -value2_lst[i]\n        else:  # 'add'\n            new_weight = current_weight + weight_lst[i]\n            new_value1 = current_value1 + value1_lst[i]\n            new_value2 = current_value2 + value2_lst[i]\n            delta1 = value1_lst[i]\n            delta2 = value2_lst[i]\n\n        # Calculate a hybrid score combining both objectives\n        score = (delta1 + delta2) + 0.5 * (delta1 * delta2)  # Combines additive and multiplicative effects\n\n        if score > best_score:\n            best_score = score\n            best_candidate = (i, action)\n\n    # Apply the best flip\n    if best_candidate:\n        i, action = best_candidate\n        if action == 'remove':\n            new_solution[i] = 0\n        else:\n            new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8798383355709234,
            7.258713066577911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distances for each solution in the archive\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives for crowding distance calculation\n    obj1 = np.array([o[0] for o in objectives])\n    obj2 = np.array([o[1] for o in objectives])\n    min_obj1, max_obj1 = np.min(obj1), np.max(obj1)\n    min_obj2, max_obj2 = np.min(obj2), np.max(obj2)\n\n    if max_obj1 == min_obj1:\n        norm_obj1 = np.zeros_like(obj1)\n    else:\n        norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1)\n\n    if max_obj2 == min_obj2:\n        norm_obj2 = np.zeros_like(obj2)\n    else:\n        norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2)\n\n    # Sort solutions by objective values\n    sorted_indices = np.lexsort((norm_obj2, norm_obj1))\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For both objectives\n        obj = norm_obj1 if i == 0 else norm_obj2\n        sorted_obj = obj[sorted_indices]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[j]] += (sorted_obj[j+1] - sorted_obj[j-1])\n\n    # Select solutions with high crowding distance (promising for improvement)\n    selected_indices = np.argsort(crowding_distances)[-max(1, len(archive)//3):]\n    selected_solutions = [solutions[i] for i in selected_indices]\n    selected_objectives = [objectives[i] for i in selected_indices]\n\n    # Further select based on objective diversity\n    # Choose the solution with the most diverse objectives\n    if len(selected_solutions) > 1:\n        base_solution = selected_solutions[np.argmax([o[0] + o[1] for o in selected_objectives])]\n    else:\n        base_solution = selected_solutions[0]\n\n    # Step 2: Generate a neighbor solution using guided flip local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Find items that can be flipped (either added or removed)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, 'remove'))\n        else:\n            # Check if adding this item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 'add'))\n\n    if not candidates:\n        return new_solution  # No feasible flips possible\n\n    # Evaluate each candidate flip\n    best_candidate = None\n    best_score = -np.inf\n\n    for i, action in candidates:\n        if action == 'remove':\n            new_weight = current_weight - weight_lst[i]\n            new_value1 = current_value1 - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i]\n            delta1 = -value1_lst[i]\n            delta2 = -value2_lst[i]\n        else:  # 'add'\n            new_weight = current_weight + weight_lst[i]\n            new_value1 = current_value1 + value1_lst[i]\n            new_value2 = current_value2 + value2_lst[i]\n            delta1 = value1_lst[i]\n            delta2 = value2_lst[i]\n\n        # Calculate a hybrid score combining both objectives\n        score = (delta1 + delta2) + 0.5 * (delta1 * delta2)  # Combines additive and multiplicative effects\n\n        if score > best_score:\n            best_score = score\n            best_candidate = (i, action)\n\n    # Apply the best flip\n    if best_candidate:\n        i, action = best_candidate\n        if action == 'remove':\n            new_solution[i] = 0\n        else:\n            new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a random item and then apply a value-driven swap\n    # Step 1: Random flip\n    flip_idx = np.random.choice(np.where(base_solution == 1)[0]) if np.sum(base_solution) > 0 else np.random.randint(len(base_solution))\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility after flip\n    if np.sum(weight_lst * new_solution) > capacity:\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Step 2: Value-driven swap\n    if np.sum(new_solution) > 1:\n        # Calculate marginal gains for both objectives\n        marginal_value1 = value1_lst * (1 - new_solution)\n        marginal_value2 = value2_lst * (1 - new_solution)\n        # Normalize and combine\n        combined_gain = (marginal_value1 / np.max(marginal_value1 + 1e-10)) + (marginal_value2 / np.max(marginal_value2 + 1e-10))\n        # Select items with highest combined gain\n        top_items = np.argsort(combined_gain)[-2:]  # Select top 2 items\n        # Swap two items to potentially improve both objectives\n        if len(top_items) >= 2:\n            i, j = top_items[0], top_items[1]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Ensure feasibility after swap\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8320261004151004,
            5.316148519515991
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a random item and then apply a value-driven swap\n    # Step 1: Random flip\n    flip_idx = np.random.choice(np.where(base_solution == 1)[0]) if np.sum(base_solution) > 0 else np.random.randint(len(base_solution))\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility after flip\n    if np.sum(weight_lst * new_solution) > capacity:\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Step 2: Value-driven swap\n    if np.sum(new_solution) > 1:\n        # Calculate marginal gains for both objectives\n        marginal_value1 = value1_lst * (1 - new_solution)\n        marginal_value2 = value2_lst * (1 - new_solution)\n        # Normalize and combine\n        combined_gain = (marginal_value1 / np.max(marginal_value1 + 1e-10)) + (marginal_value2 / np.max(marginal_value2 + 1e-10))\n        # Select items with highest combined gain\n        top_items = np.argsort(combined_gain)[-2:]  # Select top 2 items\n        # Swap two items to potentially improve both objectives\n        if len(top_items) >= 2:\n            i, j = top_items[0], top_items[1]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Ensure feasibility after swap\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator combining swap-based and insertion-based moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a promising solution\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    if len(items) > 0 and len(non_items) > 0:\n        # Hybrid move: swap one item with one non-item if feasible\n        swap_item = random.choice(items)\n        swap_non_item = random.choice(non_items)\n        if current_weight - weight_lst[swap_item] + weight_lst[swap_non_item] <= capacity:\n            new_solution[swap_item] = 0\n            new_solution[swap_non_item] = 1\n            return new_solution\n\n    # If swap not possible, try insertion of a single item\n    for item in non_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            return new_solution\n\n    # If no insertion possible, try removing one item\n    if len(items) > 0:\n        remove_item = random.choice(items)\n        new_solution[remove_item] = 0\n        return new_solution\n\n    # If all else fails, return the original solution\n    return base_solution\n\n",
        "score": [
            -0.3779175009456594,
            4.620337814092636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a promising solution\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    if len(items) > 0 and len(non_items) > 0:\n        # Hybrid move: swap one item with one non-item if feasible\n        swap_item = random.choice(items)\n        swap_non_item = random.choice(non_items)\n        if current_weight - weight_lst[swap_item] + weight_lst[swap_non_item] <= capacity:\n            new_solution[swap_item] = 0\n            new_solution[swap_non_item] = 1\n            return new_solution\n\n    # If swap not possible, try insertion of a single item\n    for item in non_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            return new_solution\n\n    # If no insertion possible, try removing one item\n    if len(items) > 0:\n        remove_item = random.choice(items)\n        new_solution[remove_item] = 0\n        return new_solution\n\n    # If all else fails, return the original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([archive[i][1][0] + archive[i][1][1] for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine bit-flip and swap-based moves with adaptive probability\n    if np.random.rand() < 0.7:  # Higher probability for bit-flip to explore more\n        # Bit-flip: randomly flip one bit if feasible\n        flip_idx = np.random.choice(len(base_solution))\n        if base_solution[flip_idx] == 1:\n            if np.sum(weight_lst * new_solution) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if np.sum(weight_lst * new_solution) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n    else:\n        # Swap-based move: swap two items if feasible\n        idx1, idx2 = np.random.choice(len(base_solution), 2, replace=False)\n        if base_solution[idx1] != base_solution[idx2]:\n            if base_solution[idx1] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[idx1] + weight_lst[idx2] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[idx1] - weight_lst[idx2] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.2743414071663794,
            9.183531522750854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([archive[i][1][0] + archive[i][1][1] for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine bit-flip and swap-based moves with adaptive probability\n    if np.random.rand() < 0.7:  # Higher probability for bit-flip to explore more\n        # Bit-flip: randomly flip one bit if feasible\n        flip_idx = np.random.choice(len(base_solution))\n        if base_solution[flip_idx] == 1:\n            if np.sum(weight_lst * new_solution) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if np.sum(weight_lst * new_solution) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n    else:\n        # Swap-based move: swap two items if feasible\n        idx1, idx2 = np.random.choice(len(base_solution), 2, replace=False)\n        if base_solution[idx1] != base_solution[idx2]:\n            if base_solution[idx1] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[idx1] + weight_lst[idx2] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[idx1] - weight_lst[idx2] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search that combines item swapping with adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high potential for improvement\n    sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = random.randint(0, min(2, len(sorted_archive) - 1))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swapping and neighborhood exploration\n    for _ in range(5):  # Perform multiple swaps\n        # Identify items to consider for swap\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) == 0 or len(excluded) == 0:\n            break\n\n        # Select a candidate to remove (from included items)\n        remove_candidate = random.choice(included)\n        remove_weight = weight_lst[remove_candidate]\n        remove_value1 = value1_lst[remove_candidate]\n        remove_value2 = value2_lst[remove_candidate]\n\n        # Find potential items to add (from excluded items) that can fit\n        potential_adds = []\n        for item in excluded:\n            if current_weight - remove_weight + weight_lst[item] <= capacity:\n                potential_adds.append(item)\n\n        if not potential_adds:\n            continue\n\n        # Select the best item to add based on potential improvement\n        best_add = None\n        best_score = -float('inf')\n        for item in potential_adds:\n            # Score based on both objectives and weight efficiency\n            score = (value1_lst[item] / weight_lst[item] + value2_lst[item] / weight_lst[item]) * random.uniform(0.8, 1.2)\n            if score > best_score:\n                best_score = score\n                best_add = item\n\n        if best_add is not None:\n            new_solution[remove_candidate] = 0\n            new_solution[best_add] = 1\n            current_weight = current_weight - remove_weight + weight_lst[best_add]\n\n    # Additional local search: flip items with high marginal value\n    for item in range(len(weight_lst)):\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Calculate marginal value\n            marginal_value1 = value1_lst[item] / weight_lst[item]\n            marginal_value2 = value2_lst[item] / weight_lst[item]\n            if (marginal_value1 + marginal_value2) > random.uniform(0.5, 1.5):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.32310070969592125,
            9.873608112335205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high potential for improvement\n    sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = random.randint(0, min(2, len(sorted_archive) - 1))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swapping and neighborhood exploration\n    for _ in range(5):  # Perform multiple swaps\n        # Identify items to consider for swap\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) == 0 or len(excluded) == 0:\n            break\n\n        # Select a candidate to remove (from included items)\n        remove_candidate = random.choice(included)\n        remove_weight = weight_lst[remove_candidate]\n        remove_value1 = value1_lst[remove_candidate]\n        remove_value2 = value2_lst[remove_candidate]\n\n        # Find potential items to add (from excluded items) that can fit\n        potential_adds = []\n        for item in excluded:\n            if current_weight - remove_weight + weight_lst[item] <= capacity:\n                potential_adds.append(item)\n\n        if not potential_adds:\n            continue\n\n        # Select the best item to add based on potential improvement\n        best_add = None\n        best_score = -float('inf')\n        for item in potential_adds:\n            # Score based on both objectives and weight efficiency\n            score = (value1_lst[item] / weight_lst[item] + value2_lst[item] / weight_lst[item]) * random.uniform(0.8, 1.2)\n            if score > best_score:\n                best_score = score\n                best_add = item\n\n        if best_add is not None:\n            new_solution[remove_candidate] = 0\n            new_solution[best_add] = 1\n            current_weight = current_weight - remove_weight + weight_lst[best_add]\n\n    # Additional local search: flip items with high marginal value\n    for item in range(len(weight_lst)):\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Calculate marginal value\n            marginal_value1 = value1_lst[item] / weight_lst[item]\n            marginal_value2 = value2_lst[item] / weight_lst[item]\n            if (marginal_value1 + marginal_value2) > random.uniform(0.5, 1.5):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Randomly select items to flip (swap 0 and 1)\n    flip_indices = np.random.choice(len(base_solution), size=min(5, len(base_solution)), replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional improvement: flip items with highest value-to-weight ratio\n    if np.random.rand() < 0.3:  # 30% chance to apply this strategy\n        value_ratio1 = value1_lst / weight_lst\n        value_ratio2 = value2_lst / weight_lst\n        combined_ratio = value_ratio1 + value_ratio2\n\n        # Sort items by combined ratio (descending)\n        sorted_indices = np.argsort(-combined_ratio)\n\n        for idx in sorted_indices:\n            if base_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            elif base_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.29738522975105863,
            7.6753151416778564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Randomly select items to flip (swap 0 and 1)\n    flip_indices = np.random.choice(len(base_solution), size=min(5, len(base_solution)), replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional improvement: flip items with highest value-to-weight ratio\n    if np.random.rand() < 0.3:  # 30% chance to apply this strategy\n        value_ratio1 = value1_lst / weight_lst\n        value_ratio2 = value2_lst / weight_lst\n        combined_ratio = value_ratio1 + value_ratio2\n\n        # Sort items by combined ratio (descending)\n        sorted_indices = np.argsort(-combined_ratio)\n\n        for idx in sorted_indices:\n            if base_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            elif base_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{The algorithm selects a solution from the archive with high diversity and objective improvement potential, then applies a hybrid local search combining random item swaps and adaptive neighborhood exploration to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity and objective improvement potential\n        objectives = np.array([obj for (sol, obj) in archive])\n        diversity = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n        np.fill_diagonal(diversity, np.inf)\n        avg_diversity = np.mean(diversity, axis=1)\n        selected_idx = np.argmax(avg_diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps with adaptive neighborhood\n    for _ in range(5):  # Number of attempts\n        # Randomly select items to swap\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) == 0:\n            candidate_items = np.arange(len(weight_lst))\n        np.random.shuffle(candidate_items)\n        swap_items = candidate_items[:min(3, len(candidate_items))]  # Swap up to 3 items\n\n        # Try adding/removing items\n        for item in swap_items:\n            if new_solution[item] == 1:\n                # Try removing\n                temp_weight = current_weight - weight_lst[item]\n                if temp_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = temp_weight\n            else:\n                # Try adding\n                temp_weight = current_weight + weight_lst[item]\n                if temp_weight <= capacity:\n                    new_solution[item] = 1\n                    current_weight = temp_weight\n\n        # Check for improvement in both objectives\n        new_obj1 = np.sum(value1_lst[new_solution == 1])\n        new_obj2 = np.sum(value2_lst[new_solution == 1])\n        old_obj1, old_obj2 = archive[selected_idx][1]\n\n        if (new_obj1 > old_obj1 and new_obj2 >= old_obj2) or (new_obj2 > old_obj2 and new_obj1 >= old_obj1):\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8412852985628577,
            4.571038901805878
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity and objective improvement potential\n        objectives = np.array([obj for (sol, obj) in archive])\n        diversity = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n        np.fill_diagonal(diversity, np.inf)\n        avg_diversity = np.mean(diversity, axis=1)\n        selected_idx = np.argmax(avg_diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps with adaptive neighborhood\n    for _ in range(5):  # Number of attempts\n        # Randomly select items to swap\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) == 0:\n            candidate_items = np.arange(len(weight_lst))\n        np.random.shuffle(candidate_items)\n        swap_items = candidate_items[:min(3, len(candidate_items))]  # Swap up to 3 items\n\n        # Try adding/removing items\n        for item in swap_items:\n            if new_solution[item] == 1:\n                # Try removing\n                temp_weight = current_weight - weight_lst[item]\n                if temp_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = temp_weight\n            else:\n                # Try adding\n                temp_weight = current_weight + weight_lst[item]\n                if temp_weight <= capacity:\n                    new_solution[item] = 1\n                    current_weight = temp_weight\n\n        # Check for improvement in both objectives\n        new_obj1 = np.sum(value1_lst[new_solution == 1])\n        new_obj2 = np.sum(value2_lst[new_solution == 1])\n        old_obj1, old_obj2 = archive[selected_idx][1]\n\n        if (new_obj1 > old_obj1 and new_obj2 >= old_obj2) or (new_obj2 > old_obj2 and new_obj1 >= old_obj1):\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of random and quality-driven selection, then applies a novel local search operator that intelligently reallocates items by considering both objective values and weights, ensuring feasibility through a capacity-aware adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias toward higher-quality solutions\n    scores = [obj[0] + obj[1] for (_, obj) in archive]\n    total_score = sum(scores)\n    probabilities = [score / total_score for score in scores]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Intelligent Reallocation\n    # Step 1: Identify items to consider for reallocation (those not in the solution or with potential)\n    candidate_indices = np.where(new_solution == 0)[0]\n    if len(candidate_indices) == 0:\n        return new_solution\n\n    # Step 2: Randomly select an item to potentially add\n    add_idx = np.random.choice(candidate_indices)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 3: If adding the item exceeds capacity, find a replacement or remove\n    if current_weight + weight_lst[add_idx] > capacity:\n        # Find items that can be removed to make space (considering both objectives)\n        in_solution_indices = np.where(new_solution == 1)[0]\n        if len(in_solution_indices) == 0:\n            return new_solution  # No items to remove\n\n        # Calculate the \"utility\" of each item (combining both objectives and weight)\n        utilities = []\n        for idx in in_solution_indices:\n            # Normalized utility: (value1 + value2) / weight\n            utility = (value1_lst[idx] + value2_lst[idx]) / weight_lst[idx]\n            utilities.append((idx, utility))\n\n        # Sort by utility (ascending) to prioritize removing less valuable items\n        utilities.sort(key=lambda x: x[1])\n        for idx, _ in utilities:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight + weight_lst[add_idx] <= capacity:\n                new_solution = temp_solution\n                break\n\n    # Step 4: Add the selected item if feasible\n    if current_weight + weight_lst[add_idx] <= capacity:\n        new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5001188640015519,
            3.8270327150821686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias toward higher-quality solutions\n    scores = [obj[0] + obj[1] for (_, obj) in archive]\n    total_score = sum(scores)\n    probabilities = [score / total_score for score in scores]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Intelligent Reallocation\n    # Step 1: Identify items to consider for reallocation (those not in the solution or with potential)\n    candidate_indices = np.where(new_solution == 0)[0]\n    if len(candidate_indices) == 0:\n        return new_solution\n\n    # Step 2: Randomly select an item to potentially add\n    add_idx = np.random.choice(candidate_indices)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 3: If adding the item exceeds capacity, find a replacement or remove\n    if current_weight + weight_lst[add_idx] > capacity:\n        # Find items that can be removed to make space (considering both objectives)\n        in_solution_indices = np.where(new_solution == 1)[0]\n        if len(in_solution_indices) == 0:\n            return new_solution  # No items to remove\n\n        # Calculate the \"utility\" of each item (combining both objectives and weight)\n        utilities = []\n        for idx in in_solution_indices:\n            # Normalized utility: (value1 + value2) / weight\n            utility = (value1_lst[idx] + value2_lst[idx]) / weight_lst[idx]\n            utilities.append((idx, utility))\n\n        # Sort by utility (ascending) to prioritize removing less valuable items\n        utilities.sort(key=lambda x: x[1])\n        for idx, _ in utilities:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight + weight_lst[add_idx] <= capacity:\n                new_solution = temp_solution\n                break\n\n    # Step 4: Add the selected item if feasible\n    if current_weight + weight_lst[add_idx] <= capacity:\n        new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the objective space coverage and select a solution with the largest coverage\n        objectives = np.array([obj for (_, obj) in archive])\n        max_obj = np.max(objectives, axis=0)\n        min_obj = np.min(objectives, axis=0)\n        coverage_scores = np.prod(max_obj - min_obj)  # Product of the objective space coverage\n        selected_idx = np.argmax(coverage_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # The strategy combines random item swaps with a greedy selection of high-value items\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 2.1: Randomly select a subset of items to consider for swapping\n    swap_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    # Step 2.2: For each selected item, decide whether to swap it based on a greedy criterion\n    for idx in swap_indices:\n        if base_solution[idx] == 1:\n            # If the item is included, consider removing it if it has low marginal value\n            total_value1 = np.sum(value1_lst[new_solution == 1])\n            total_value2 = np.sum(value2_lst[new_solution == 1])\n            marginal_value1 = total_value1 - value1_lst[idx]\n            marginal_value2 = total_value2 - value2_lst[idx]\n            if (marginal_value1 >= total_value1 or marginal_value2 >= total_value2) and np.random.rand() < 0.3:\n                new_solution[idx] = 0\n        else:\n            # If the item is excluded, consider adding it if it fits and improves both objectives\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Ensure the solution is feasible\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, perform a greedy removal of low-value items until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Remove the item with the lowest sum of normalized values\n            normalized_values = (value1_lst[included_items] + value2_lst[included_items]) / (value1_lst[included_items] + value2_lst[included_items] + 1e-6)\n            remove_idx = included_items[np.argmin(normalized_values)]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.9429162694571591,
            3.215505987405777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the objective space coverage and select a solution with the largest coverage\n        objectives = np.array([obj for (_, obj) in archive])\n        max_obj = np.max(objectives, axis=0)\n        min_obj = np.min(objectives, axis=0)\n        coverage_scores = np.prod(max_obj - min_obj)  # Product of the objective space coverage\n        selected_idx = np.argmax(coverage_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # The strategy combines random item swaps with a greedy selection of high-value items\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 2.1: Randomly select a subset of items to consider for swapping\n    swap_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    # Step 2.2: For each selected item, decide whether to swap it based on a greedy criterion\n    for idx in swap_indices:\n        if base_solution[idx] == 1:\n            # If the item is included, consider removing it if it has low marginal value\n            total_value1 = np.sum(value1_lst[new_solution == 1])\n            total_value2 = np.sum(value2_lst[new_solution == 1])\n            marginal_value1 = total_value1 - value1_lst[idx]\n            marginal_value2 = total_value2 - value2_lst[idx]\n            if (marginal_value1 >= total_value1 or marginal_value2 >= total_value2) and np.random.rand() < 0.3:\n                new_solution[idx] = 0\n        else:\n            # If the item is excluded, consider adding it if it fits and improves both objectives\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Ensure the solution is feasible\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, perform a greedy removal of low-value items until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Remove the item with the lowest sum of normalized values\n            normalized_values = (value1_lst[included_items] + value2_lst[included_items]) / (value1_lst[included_items] + value2_lst[included_items] + 1e-6)\n            remove_idx = included_items[np.argmin(normalized_values)]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the objective space coverage and select a solution with the largest coverage\n        objectives = np.array([obj for (_, obj) in archive])\n        max_obj = np.max(objectives, axis=0)\n        min_obj = np.min(objectives, axis=0)\n        coverage_scores = np.prod(max_obj - min_obj)  # Product of the objective space coverage\n        selected_idx = np.argmax(coverage_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # The strategy combines random item swaps with a greedy selection of high-value items\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 2.1: Randomly select a subset of items to consider for swapping\n    swap_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    # Step 2.2: For each selected item, decide whether to swap it based on a greedy criterion\n    for idx in swap_indices:\n        if base_solution[idx] == 1:\n            # If the item is included, consider removing it if it has low marginal value\n            total_value1 = np.sum(value1_lst[new_solution == 1])\n            total_value2 = np.sum(value2_lst[new_solution == 1])\n            marginal_value1 = total_value1 - value1_lst[idx]\n            marginal_value2 = total_value2 - value2_lst[idx]\n            if (marginal_value1 >= total_value1 or marginal_value2 >= total_value2) and np.random.rand() < 0.3:\n                new_solution[idx] = 0\n        else:\n            # If the item is excluded, consider adding it if it fits and improves both objectives\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Ensure the solution is feasible\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, perform a greedy removal of low-value items until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Remove the item with the lowest sum of normalized values\n            normalized_values = (value1_lst[included_items] + value2_lst[included_items]) / (value1_lst[included_items] + value2_lst[included_items] + 1e-6)\n            remove_idx = included_items[np.argmin(normalized_values)]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.9429162694571591,
            3.215505987405777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the objective space coverage and select a solution with the largest coverage\n        objectives = np.array([obj for (_, obj) in archive])\n        max_obj = np.max(objectives, axis=0)\n        min_obj = np.min(objectives, axis=0)\n        coverage_scores = np.prod(max_obj - min_obj)  # Product of the objective space coverage\n        selected_idx = np.argmax(coverage_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # The strategy combines random item swaps with a greedy selection of high-value items\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 2.1: Randomly select a subset of items to consider for swapping\n    swap_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    # Step 2.2: For each selected item, decide whether to swap it based on a greedy criterion\n    for idx in swap_indices:\n        if base_solution[idx] == 1:\n            # If the item is included, consider removing it if it has low marginal value\n            total_value1 = np.sum(value1_lst[new_solution == 1])\n            total_value2 = np.sum(value2_lst[new_solution == 1])\n            marginal_value1 = total_value1 - value1_lst[idx]\n            marginal_value2 = total_value2 - value2_lst[idx]\n            if (marginal_value1 >= total_value1 or marginal_value2 >= total_value2) and np.random.rand() < 0.3:\n                new_solution[idx] = 0\n        else:\n            # If the item is excluded, consider adding it if it fits and improves both objectives\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Ensure the solution is feasible\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, perform a greedy removal of low-value items until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Remove the item with the lowest sum of normalized values\n            normalized_values = (value1_lst[included_items] + value2_lst[included_items]) / (value1_lst[included_items] + value2_lst[included_items] + 1e-6)\n            remove_idx = included_items[np.argmin(normalized_values)]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps and probabilistic flips to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    # Here, we select the solution with the highest sum of objectives\n    selected_idx = np.argmax([sum(obj) for (sol, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider\n    num_items = len(weight_lst)\n    subset_size = min(5, num_items)  # Small subset to explore\n    subset_indices = np.random.choice(num_items, size=subset_size, replace=False)\n\n    for idx in subset_indices:\n        # Step 2: Flip the item if it improves at least one objective\n        if base_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = temp_weight\n\n        # Step 3: Probabilistically flip items based on value ratios\n        if np.random.rand() < 0.3:  # 30% chance to consider swaps\n            # Find an item to swap with\n            swap_candidate = np.random.choice(num_items)\n            if swap_candidate != idx and base_solution[swap_candidate] != base_solution[idx]:\n                # Check feasibility after swap\n                if base_solution[idx] == 1 and base_solution[swap_candidate] == 0:\n                    temp_weight = current_weight - weight_lst[idx] + weight_lst[swap_candidate]\n                    if temp_weight <= capacity:\n                        new_solution[idx], new_solution[swap_candidate] = 0, 1\n                        current_weight = temp_weight\n                elif base_solution[idx] == 0 and base_solution[swap_candidate] == 1:\n                    temp_weight = current_weight + weight_lst[idx] - weight_lst[swap_candidate]\n                    if temp_weight <= capacity:\n                        new_solution[idx], new_solution[swap_candidate] = 1, 0\n                        current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.31631426203365653,
            6.183212637901306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    # Here, we select the solution with the highest sum of objectives\n    selected_idx = np.argmax([sum(obj) for (sol, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider\n    num_items = len(weight_lst)\n    subset_size = min(5, num_items)  # Small subset to explore\n    subset_indices = np.random.choice(num_items, size=subset_size, replace=False)\n\n    for idx in subset_indices:\n        # Step 2: Flip the item if it improves at least one objective\n        if base_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = temp_weight\n\n        # Step 3: Probabilistically flip items based on value ratios\n        if np.random.rand() < 0.3:  # 30% chance to consider swaps\n            # Find an item to swap with\n            swap_candidate = np.random.choice(num_items)\n            if swap_candidate != idx and base_solution[swap_candidate] != base_solution[idx]:\n                # Check feasibility after swap\n                if base_solution[idx] == 1 and base_solution[swap_candidate] == 0:\n                    temp_weight = current_weight - weight_lst[idx] + weight_lst[swap_candidate]\n                    if temp_weight <= capacity:\n                        new_solution[idx], new_solution[swap_candidate] = 0, 1\n                        current_weight = temp_weight\n                elif base_solution[idx] == 0 and base_solution[swap_candidate] == 1:\n                    temp_weight = current_weight + weight_lst[idx] - weight_lst[swap_candidate]\n                    if temp_weight <= capacity:\n                        new_solution[idx], new_solution[swap_candidate] = 1, 0\n                        current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive based on its potential for improvement, then applies a novel combination of item swaps and flips to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those with low objective values)\n    # but also ensure diversity by considering their crowding distance or other metrics\n    solution_scores = []\n    for sol, _ in archive:\n        # Calculate potential improvement score (e.g., based on value density)\n        total_weight = np.sum(sol * weight_lst)\n        total_value1 = np.sum(sol * value1_lst)\n        total_value2 = np.sum(sol * value2_lst)\n        value_density1 = total_value1 / total_weight if total_weight > 0 else 0\n        value_density2 = total_value2 / total_weight if total_weight > 0 else 0\n        score = value_density1 * value_density2  # Combine densities for multi-objective\n        solution_scores.append(score)\n\n    # Select top 3 solutions with highest scores (higher score = more potential)\n    top_indices = np.argsort(solution_scores)[-min(3, len(solution_scores)):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid strategy: Randomly choose between two novel operators\n    if random.random() < 0.5:\n        # Operator 1: Randomly flip a subset of items (with size between 1 and 5)\n        flip_size = random.randint(1, min(5, n_items))\n        flip_indices = random.sample(range(n_items), flip_size)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n    else:\n        # Operator 2: Swap a pair of items (one in, one out) with high value density\n        # Select a random item to remove\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) > 0:\n            remove_idx = random.choice(in_items)\n            new_solution[remove_idx] = 0\n            # Select a random item to add (from those not in the solution)\n            out_items = np.where(new_solution == 0)[0]\n            if len(out_items) > 0:\n                add_idx = random.choice(out_items)\n                new_solution[add_idx] = 1\n\n    # Ensure feasibility by repairing if necessary\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        in_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(in_items) > 0:\n            remove_idx = random.choice(in_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n            in_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.3466233451713683,
            8.415793508291245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those with low objective values)\n    # but also ensure diversity by considering their crowding distance or other metrics\n    solution_scores = []\n    for sol, _ in archive:\n        # Calculate potential improvement score (e.g., based on value density)\n        total_weight = np.sum(sol * weight_lst)\n        total_value1 = np.sum(sol * value1_lst)\n        total_value2 = np.sum(sol * value2_lst)\n        value_density1 = total_value1 / total_weight if total_weight > 0 else 0\n        value_density2 = total_value2 / total_weight if total_weight > 0 else 0\n        score = value_density1 * value_density2  # Combine densities for multi-objective\n        solution_scores.append(score)\n\n    # Select top 3 solutions with highest scores (higher score = more potential)\n    top_indices = np.argsort(solution_scores)[-min(3, len(solution_scores)):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid strategy: Randomly choose between two novel operators\n    if random.random() < 0.5:\n        # Operator 1: Randomly flip a subset of items (with size between 1 and 5)\n        flip_size = random.randint(1, min(5, n_items))\n        flip_indices = random.sample(range(n_items), flip_size)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n    else:\n        # Operator 2: Swap a pair of items (one in, one out) with high value density\n        # Select a random item to remove\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) > 0:\n            remove_idx = random.choice(in_items)\n            new_solution[remove_idx] = 0\n            # Select a random item to add (from those not in the solution)\n            out_items = np.where(new_solution == 0)[0]\n            if len(out_items) > 0:\n                add_idx = random.choice(out_items)\n                new_solution[add_idx] = 1\n\n    # Ensure feasibility by repairing if necessary\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        in_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(in_items) > 0:\n            remove_idx = random.choice(in_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n            in_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search operator that combines item swaps and replacements to explore neighboring solutions while ensuring feasibility and potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_index = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_index]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swaps and replacements\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Randomly choose between swap or replacement\n    if random.random() < 0.5 and len(items_in) > 0 and len(items_out) > 0:\n        # Swap two items: one in and one out\n        item_in = random.choice(items_in)\n        item_out = random.choice(items_out)\n        new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n        if new_weight <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n    else:\n        # Randomly replace an item in with an item out\n        if len(items_in) > 0 and len(items_out) > 0:\n            item_in = random.choice(items_in)\n            item_out = random.choice(items_out)\n            new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n            if new_weight <= capacity:\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n        # If no swap/replacement possible, try adding a new item\n        elif len(items_out) > 0:\n            item_out = random.choice(items_out)\n            if current_weight + weight_lst[item_out] <= capacity:\n                new_solution[item_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4892054071718068,
            3.921500116586685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_index = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_index]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swaps and replacements\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Randomly choose between swap or replacement\n    if random.random() < 0.5 and len(items_in) > 0 and len(items_out) > 0:\n        # Swap two items: one in and one out\n        item_in = random.choice(items_in)\n        item_out = random.choice(items_out)\n        new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n        if new_weight <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n    else:\n        # Randomly replace an item in with an item out\n        if len(items_in) > 0 and len(items_out) > 0:\n            item_in = random.choice(items_in)\n            item_out = random.choice(items_out)\n            new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n            if new_weight <= capacity:\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n        # If no swap/replacement possible, try adding a new item\n        elif len(items_out) > 0:\n            item_out = random.choice(items_out)\n            if current_weight + weight_lst[item_out] <= capacity:\n                new_solution[item_out] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[np.random.randint(len(archive))][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items to consider for swap: those not in the solution or those in the solution\n    candidates = np.where((new_solution == 1) | (new_solution == 0))[0]\n\n    # Randomly select two items: one to remove and one to add\n    if len(candidates) >= 2:\n        i, j = np.random.choice(candidates, 2, replace=False)\n\n        # Calculate weight changes\n        weight_diff = weight_lst[j] - weight_lst[i] if new_solution[i] == 1 else weight_lst[j]\n\n        # Check feasibility\n        if current_weight + weight_diff <= capacity:\n            # Perform the swap\n            new_solution[i] = 0\n            new_solution[j] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.31806274845242266,
            6.2785510420799255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[np.random.randint(len(archive))][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items to consider for swap: those not in the solution or those in the solution\n    candidates = np.where((new_solution == 1) | (new_solution == 0))[0]\n\n    # Randomly select two items: one to remove and one to add\n    if len(candidates) >= 2:\n        i, j = np.random.choice(candidates, 2, replace=False)\n\n        # Calculate weight changes\n        weight_diff = weight_lst[j] - weight_lst[i] if new_solution[i] == 1 else weight_lst[j]\n\n        # Check feasibility\n        if current_weight + weight_diff <= capacity:\n            # Perform the swap\n            new_solution[i] = 0\n            new_solution[j] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a weighted random selection favoring solutions with higher potential for local improvement, then applies a hybrid local search operator combining item swapping and random perturbation to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores for each solution\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        potential_v1 = np.sum(value1_lst * (1 - sol))\n        potential_v2 = np.sum(value2_lst * (1 - sol))\n        score = (potential_v1 + potential_v2) / (1 + total_weight)  # Normalized by weight\n        scores.append(score)\n\n    # Select a solution with probability proportional to its score\n    selected_idx = random.choices(range(len(scores)), weights=scores)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly select a subset of items to consider for swap\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        # Randomly select one item to remove\n        remove_idx = random.choice(swap_candidates)\n        new_solution[remove_idx] = 0\n\n    # Step 2: Randomly select a subset of items to consider for addition\n    add_candidates = np.where(new_solution == 0)[0]\n    if len(add_candidates) > 0:\n        # Randomly select one item to add\n        add_idx = random.choice(add_candidates)\n        new_solution[add_idx] = 1\n\n    # Step 3: Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity:\n        # Randomly select an item to remove\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        remove_idx = random.choice(included_items)\n        new_solution[remove_idx] = 0\n        total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 4: Randomly flip some bits to introduce diversity\n    flip_prob = 0.1\n    for i in range(n_items):\n        if random.random() < flip_prob:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Ensure final solution is feasible\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        remove_idx = random.choice(included_items)\n        new_solution[remove_idx] = 0\n        total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.3833858862652971,
            5.876509010791779
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores for each solution\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        potential_v1 = np.sum(value1_lst * (1 - sol))\n        potential_v2 = np.sum(value2_lst * (1 - sol))\n        score = (potential_v1 + potential_v2) / (1 + total_weight)  # Normalized by weight\n        scores.append(score)\n\n    # Select a solution with probability proportional to its score\n    selected_idx = random.choices(range(len(scores)), weights=scores)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly select a subset of items to consider for swap\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 0:\n        # Randomly select one item to remove\n        remove_idx = random.choice(swap_candidates)\n        new_solution[remove_idx] = 0\n\n    # Step 2: Randomly select a subset of items to consider for addition\n    add_candidates = np.where(new_solution == 0)[0]\n    if len(add_candidates) > 0:\n        # Randomly select one item to add\n        add_idx = random.choice(add_candidates)\n        new_solution[add_idx] = 1\n\n    # Step 3: Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity:\n        # Randomly select an item to remove\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        remove_idx = random.choice(included_items)\n        new_solution[remove_idx] = 0\n        total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 4: Randomly flip some bits to introduce diversity\n    flip_prob = 0.1\n    for i in range(n_items):\n        if random.random() < flip_prob:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Ensure final solution is feasible\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        remove_idx = random.choice(included_items)\n        new_solution[remove_idx] = 0\n        total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    # Randomly select one of the top 30% solutions to introduce diversity\n    selected_idx = np.random.randint(0, max(1, len(sorted_archive) // 3))\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # Combine random bit flipping with a greedy addition of high-value items\n    new_solution = base_solution.copy()\n\n    # Randomly flip a small number of bits (1-3) to introduce diversity\n    flip_indices = np.random.choice(len(new_solution), size=np.random.randint(1, 4), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Check feasibility after flipping\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, randomly remove items until feasible\n        excess_weight = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        while excess_weight > 0 and len(excess_items) > 0:\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            excess_weight = np.sum(weight_lst[new_solution == 1]) - capacity\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Greedily add high-value items if capacity allows\n    remaining_capacity = capacity - np.sum(weight_lst[new_solution == 1])\n    if remaining_capacity > 0:\n        # Calculate the marginal value per weight for each item\n        marginal_value1 = value1_lst / weight_lst\n        marginal_value2 = value2_lst / weight_lst\n        # Combine both objectives into a single score (weighted sum)\n        combined_score = 0.5 * marginal_value1 + 0.5 * marginal_value2\n        # Sort items by combined score in descending order\n        sorted_items = np.argsort(-combined_score)\n        for item in sorted_items:\n            if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.327015524661152,
            8.306720942258835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    # Randomly select one of the top 30% solutions to introduce diversity\n    selected_idx = np.random.randint(0, max(1, len(sorted_archive) // 3))\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # Combine random bit flipping with a greedy addition of high-value items\n    new_solution = base_solution.copy()\n\n    # Randomly flip a small number of bits (1-3) to introduce diversity\n    flip_indices = np.random.choice(len(new_solution), size=np.random.randint(1, 4), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Check feasibility after flipping\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, randomly remove items until feasible\n        excess_weight = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        while excess_weight > 0 and len(excess_items) > 0:\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            excess_weight = np.sum(weight_lst[new_solution == 1]) - capacity\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Greedily add high-value items if capacity allows\n    remaining_capacity = capacity - np.sum(weight_lst[new_solution == 1])\n    if remaining_capacity > 0:\n        # Calculate the marginal value per weight for each item\n        marginal_value1 = value1_lst / weight_lst\n        marginal_value2 = value2_lst / weight_lst\n        # Combine both objectives into a single score (weighted sum)\n        combined_score = 0.5 * marginal_value1 + 0.5 * marginal_value2\n        # Sort items by combined score in descending order\n        sorted_items = np.argsort(-combined_score)\n        for item in sorted_items:\n            if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement in both objectives, then applies a hybrid local search operator that combines random item swaps with a value-weighted probability to flip items, ensuring feasibility and maximizing multi-objective gains.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    if len(total_values) > 0:\n        probabilities = total_values / np.sum(total_values)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy() if len(archive) > 0 else np.zeros_like(weight_lst, dtype=int)\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: flip items with probability based on value and weight\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing the item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding the item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    # Further flip items with high value-to-weight ratio\n                    if random.random() < 0.5 and np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                        value_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                        if value_ratio > np.mean((value1_lst + value2_lst) / weight_lst):\n                            new_solution[i] = 1\n                            current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        # Remove the item with the smallest value-to-weight ratio\n        ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        remove_idx = included_items[np.argmin(ratios)]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.40231034344923133,
            3.8505999147892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    if len(total_values) > 0:\n        probabilities = total_values / np.sum(total_values)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy() if len(archive) > 0 else np.zeros_like(weight_lst, dtype=int)\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: flip items with probability based on value and weight\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing the item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding the item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    # Further flip items with high value-to-weight ratio\n                    if random.random() < 0.5 and np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                        value_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                        if value_ratio > np.mean((value1_lst + value2_lst) / weight_lst):\n                            new_solution[i] = 1\n                            current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        # Remove the item with the smallest value-to-weight ratio\n        ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        remove_idx = included_items[np.argmin(ratios)]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{The heuristic function selects a solution from the archive using an adaptive weighted sum of objectives, then applies a hybrid local search combining item swapping and probabilistic flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with adaptive weighting\n    weights = np.array([(v1 + v2) / (1 + np.exp(-(v1 - v2))) for _, (v1, v2) in archive])\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and probabilistic flipping\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Randomly select a subset of items to consider for swapping\n    if len(items) > 0 and len(non_items) > 0:\n        swap_candidates = np.random.choice(items, size=min(3, len(items)), replace=False)\n        for i in swap_candidates:\n            if random.random() < 0.7:  # 70% chance to swap\n                j = np.random.choice(non_items)\n                # Check feasibility before swapping\n                if (np.sum(weight_lst[base_solution == 1]) - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_solution[i] = 0\n                    new_solution[j] = 1\n\n    # Probabilistic flipping of items with high marginal contribution\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:  # 30% chance to flip\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.1:  # 10% chance to flip\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5142143629806231,
            7.675794363021851
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with adaptive weighting\n    weights = np.array([(v1 + v2) / (1 + np.exp(-(v1 - v2))) for _, (v1, v2) in archive])\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and probabilistic flipping\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Randomly select a subset of items to consider for swapping\n    if len(items) > 0 and len(non_items) > 0:\n        swap_candidates = np.random.choice(items, size=min(3, len(items)), replace=False)\n        for i in swap_candidates:\n            if random.random() < 0.7:  # 70% chance to swap\n                j = np.random.choice(non_items)\n                # Check feasibility before swapping\n                if (np.sum(weight_lst[base_solution == 1]) - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_solution[i] = 0\n                    new_solution[j] = 1\n\n    # Probabilistic flipping of items with high marginal contribution\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.3:  # 30% chance to flip\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n        elif base_solution[i] == 0 and random.random() < 0.1:  # 10% chance to flip\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, applies a dynamic flip-and-rebalance operator to explore high-potential regions by flipping items with high marginal value-to-weight ratios and rebalancing the solution to ensure feasibility, and then performs a guided perturbation to escape local optima while preserving non-dominated status.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (here, we select the one with the highest sum of normalized objectives)\n    normalized_objectives = np.array([(val1 + val2) / (np.sum(weight_lst) + 1e-6) for _, (val1, val2) in archive])\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate a candidate neighbor by flipping items with high marginal value-to-weight ratios\n    new_solution = base_solution.copy()\n    marginal_value1 = (value1_lst - current_value1) / (weight_lst + 1e-6)\n    marginal_value2 = (value2_lst - current_value2) / (weight_lst + 1e-6)\n    marginal_score = marginal_value1 + marginal_value2\n\n    # Sort items by marginal score (descending)\n    sorted_indices = np.argsort(-marginal_score)\n\n    # Flip items in order of highest marginal score, ensuring feasibility\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Apply a guided perturbation to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        perturbation_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n        for idx in perturbation_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.719425790464534,
            4.72010812163353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (here, we select the one with the highest sum of normalized objectives)\n    normalized_objectives = np.array([(val1 + val2) / (np.sum(weight_lst) + 1e-6) for _, (val1, val2) in archive])\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate a candidate neighbor by flipping items with high marginal value-to-weight ratios\n    new_solution = base_solution.copy()\n    marginal_value1 = (value1_lst - current_value1) / (weight_lst + 1e-6)\n    marginal_value2 = (value2_lst - current_value2) / (weight_lst + 1e-6)\n    marginal_score = marginal_value1 + marginal_value2\n\n    # Sort items by marginal score (descending)\n    sorted_indices = np.argsort(-marginal_score)\n\n    # Flip items in order of highest marginal score, ensuring feasibility\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Apply a guided perturbation to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        perturbation_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n        for idx in perturbation_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{A novel local search heuristic that adaptively combines item swaps, random flips, and objective-biased selection to explore high-potential regions of the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    if not archive_solutions:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    selected_idx = np.argmax([obj[0] + obj[1] for obj in archive_objectives])\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly flip a subset of items (adaptive to objective values)\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        num_flips = min(3, len(flip_candidates))\n        flip_indices = np.random.choice(flip_candidates, num_flips, replace=False)\n        for i in flip_indices:\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 2: Add new items with high potential (biased by objective values)\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Calculate potential improvement for each remaining item\n        potential_value1 = value1_lst[remaining_items]\n        potential_value2 = value2_lst[remaining_items]\n        potential_weights = weight_lst[remaining_items]\n        # Normalize and combine objectives\n        combined_scores = (potential_value1 / np.max(potential_value1)) + (potential_value2 / np.max(potential_value2))\n        # Select top candidates\n        candidate_indices = np.argsort(-combined_scores)[:min(3, len(remaining_items))]\n        for i in candidate_indices:\n            if current_weight + potential_weights[i] <= capacity:\n                new_solution[remaining_items[i]] = 1\n                current_weight += potential_weights[i]\n\n    # Step 3: Perform a biased swap if possible\n    if np.sum(new_solution) > 1:\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], 2, replace=False)\n        i, j = swap_indices\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = 0, 1\n\n    return new_solution\n\n",
        "score": [
            -0.6078501377907485,
            6.618691921234131
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    if not archive_solutions:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    selected_idx = np.argmax([obj[0] + obj[1] for obj in archive_objectives])\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly flip a subset of items (adaptive to objective values)\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        num_flips = min(3, len(flip_candidates))\n        flip_indices = np.random.choice(flip_candidates, num_flips, replace=False)\n        for i in flip_indices:\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 2: Add new items with high potential (biased by objective values)\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Calculate potential improvement for each remaining item\n        potential_value1 = value1_lst[remaining_items]\n        potential_value2 = value2_lst[remaining_items]\n        potential_weights = weight_lst[remaining_items]\n        # Normalize and combine objectives\n        combined_scores = (potential_value1 / np.max(potential_value1)) + (potential_value2 / np.max(potential_value2))\n        # Select top candidates\n        candidate_indices = np.argsort(-combined_scores)[:min(3, len(remaining_items))]\n        for i in candidate_indices:\n            if current_weight + potential_weights[i] <= capacity:\n                new_solution[remaining_items[i]] = 1\n                current_weight += potential_weights[i]\n\n    # Step 3: Perform a biased swap if possible\n    if np.sum(new_solution) > 1:\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], 2, replace=False)\n        i, j = swap_indices\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = 0, 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines random selection of high-potential solutions with a dynamic neighborhood exploration strategy, leveraging both objective-specific and weight-constrained flips to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for flipping\n    subset_size = min(5, n_items)\n    candidate_indices = np.random.choice(n_items, size=subset_size, replace=False)\n\n    for idx in candidate_indices:\n        # Calculate the impact of flipping this item\n        if base_solution[idx] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                # Accept the flip if it improves both objectives or at least one\n                new_value1 = archive[selected_idx][1][0] - value1_lst[idx]\n                new_value2 = archive[selected_idx][1][1] - value2_lst[idx]\n                # Check if the new solution dominates or is non-dominated\n                if (new_value1 >= archive[selected_idx][1][0] and new_value2 >= archive[selected_idx][1][1]) or \\\n                   (np.random.rand() < 0.3):  # Small chance to explore non-dominated moves\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Accept the flip if it improves both objectives or at least one\n                new_value1 = archive[selected_idx][1][0] + value1_lst[idx]\n                new_value2 = archive[selected_idx][1][1] + value2_lst[idx]\n                # Check if the new solution dominates or is non-dominated\n                if (new_value1 >= archive[selected_idx][1][0] and new_value2 >= archive[selected_idx][1][1]) or \\\n                   (np.random.rand() < 0.3):  # Small chance to explore non-dominated moves\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3591208408608768,
            7.106868177652359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for flipping\n    subset_size = min(5, n_items)\n    candidate_indices = np.random.choice(n_items, size=subset_size, replace=False)\n\n    for idx in candidate_indices:\n        # Calculate the impact of flipping this item\n        if base_solution[idx] == 1:\n            # If item is included, consider removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                # Accept the flip if it improves both objectives or at least one\n                new_value1 = archive[selected_idx][1][0] - value1_lst[idx]\n                new_value2 = archive[selected_idx][1][1] - value2_lst[idx]\n                # Check if the new solution dominates or is non-dominated\n                if (new_value1 >= archive[selected_idx][1][0] and new_value2 >= archive[selected_idx][1][1]) or \\\n                   (np.random.rand() < 0.3):  # Small chance to explore non-dominated moves\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n        else:\n            # If item is excluded, consider adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Accept the flip if it improves both objectives or at least one\n                new_value1 = archive[selected_idx][1][0] + value1_lst[idx]\n                new_value2 = archive[selected_idx][1][1] + value2_lst[idx]\n                # Check if the new solution dominates or is non-dominated\n                if (new_value1 >= archive[selected_idx][1][0] and new_value2 >= archive[selected_idx][1][1]) or \\\n                   (np.random.rand() < 0.3):  # Small chance to explore non-dominated moves\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{A novel hybrid local search operator combines adaptive item swapping with probabilistic diversification, prioritizing items with high marginal gains in both objectives while ensuring feasibility through dynamic weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already Pareto-optimal)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: adaptive swapping with probabilistic diversification\n    for _ in range(5):  # Perform multiple swaps\n        # Identify promising candidates for swap (high marginal gain in either objective)\n        marginal_gains1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        marginal_gains2 = value2_lst / (weight_lst + 1e-6)\n\n        # Combine gains with probability based on current solution\n        combined_gain = (marginal_gains1 * (1 - current_val1 / (current_val1 + current_val2 + 1e-6)) +\n                         marginal_gains2 * (1 - current_val2 / (current_val1 + current_val2 + 1e-6)))\n\n        # Select items to swap (consider both inclusion and exclusion)\n        candidates = np.argsort(-combined_gain)\n        for item in candidates:\n            if new_solution[item] == 1:\n                # Try removing this item\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    break\n            else:\n                # Try adding this item\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n\n    # Probabilistic diversification: flip a random bit with low probability\n    if random.random() < 0.1:\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7738648839885954,
            3.7903671264648438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already Pareto-optimal)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: adaptive swapping with probabilistic diversification\n    for _ in range(5):  # Perform multiple swaps\n        # Identify promising candidates for swap (high marginal gain in either objective)\n        marginal_gains1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        marginal_gains2 = value2_lst / (weight_lst + 1e-6)\n\n        # Combine gains with probability based on current solution\n        combined_gain = (marginal_gains1 * (1 - current_val1 / (current_val1 + current_val2 + 1e-6)) +\n                         marginal_gains2 * (1 - current_val2 / (current_val1 + current_val2 + 1e-6)))\n\n        # Select items to swap (consider both inclusion and exclusion)\n        candidates = np.argsort(-combined_gain)\n        for item in candidates:\n            if new_solution[item] == 1:\n                # Try removing this item\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    break\n            else:\n                # Try adding this item\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n\n    # Probabilistic diversification: flip a random bit with low probability\n    if random.random() < 0.1:\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate neighbor by flipping items with high marginal utility\n    marginal_values1 = value1_lst / (weight_lst + 1e-6)\n    marginal_values2 = value2_lst / (weight_lst + 1e-6)\n    marginal_scores = marginal_values1 + marginal_values2\n\n    # Sort items by marginal utility\n    sorted_items = np.argsort(marginal_scores)[::-1]\n\n    new_solution = base_solution.copy()\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 += value1_lst[item]\n                current_value2 += value2_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8532510775604805,
            5.428679883480072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate neighbor by flipping items with high marginal utility\n    marginal_values1 = value1_lst / (weight_lst + 1e-6)\n    marginal_values2 = value2_lst / (weight_lst + 1e-6)\n    marginal_scores = marginal_values1 + marginal_values2\n\n    # Sort items by marginal utility\n    sorted_items = np.argsort(marginal_scores)[::-1]\n\n    new_solution = base_solution.copy()\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 += value1_lst[item]\n                current_value2 += value2_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping with a probabilistic diversification mechanism, where promising items are intelligently selected based on their marginal contributions to both objectives, and a random perturbation is applied to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    base_solution = archive[np.argmax(scores)][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Find items to potentially swap (items currently in the knapsack)\n    in_items = np.where(base_solution == 1)[0]\n    out_items = np.where(base_solution == 0)[0]\n\n    # Calculate marginal contributions for in_items\n    marginal_value1 = value1_lst[in_items] / weight_lst[in_items]\n    marginal_value2 = value2_lst[in_items] / weight_lst[in_items]\n\n    # Select top 20% items with highest marginal contributions\n    top_in_items = in_items[np.argsort(-(marginal_value1 + marginal_value2))[:max(1, len(in_items) // 5)]]\n\n    # Select random item to remove (from top candidates)\n    if len(top_in_items) > 0:\n        remove_item = random.choice(top_in_items)\n    else:\n        remove_item = random.choice(in_items)\n\n    # Calculate remaining capacity after removal\n    remaining_capacity = capacity - (current_weight - weight_lst[remove_item])\n\n    # Find items that can be added without exceeding capacity\n    candidates = [i for i in out_items if weight_lst[i] <= remaining_capacity]\n\n    if len(candidates) > 0:\n        # Select item with highest marginal contribution to both objectives\n        candidate_values = np.array([(value1_lst[i] + value2_lst[i]) / weight_lst[i] for i in candidates])\n        add_item = candidates[np.argmax(candidate_values)]\n        new_solution = base_solution.copy()\n        new_solution[remove_item] = 0\n        new_solution[add_item] = 1\n    else:\n        # If no items can be added, just remove the selected item\n        new_solution = base_solution.copy()\n        new_solution[remove_item] = 0\n\n    # With 20% probability, apply random perturbation to escape local optima\n    if random.random() < 0.2:\n        perturb_items = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n        for item in perturb_items:\n            if base_solution[item] == 1:\n                # Try to remove item if it doesn't cause infeasibility\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n            else:\n                # Try to add item if it doesn't exceed capacity\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4984227674627656,
            10.37600839138031
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    base_solution = archive[np.argmax(scores)][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Find items to potentially swap (items currently in the knapsack)\n    in_items = np.where(base_solution == 1)[0]\n    out_items = np.where(base_solution == 0)[0]\n\n    # Calculate marginal contributions for in_items\n    marginal_value1 = value1_lst[in_items] / weight_lst[in_items]\n    marginal_value2 = value2_lst[in_items] / weight_lst[in_items]\n\n    # Select top 20% items with highest marginal contributions\n    top_in_items = in_items[np.argsort(-(marginal_value1 + marginal_value2))[:max(1, len(in_items) // 5)]]\n\n    # Select random item to remove (from top candidates)\n    if len(top_in_items) > 0:\n        remove_item = random.choice(top_in_items)\n    else:\n        remove_item = random.choice(in_items)\n\n    # Calculate remaining capacity after removal\n    remaining_capacity = capacity - (current_weight - weight_lst[remove_item])\n\n    # Find items that can be added without exceeding capacity\n    candidates = [i for i in out_items if weight_lst[i] <= remaining_capacity]\n\n    if len(candidates) > 0:\n        # Select item with highest marginal contribution to both objectives\n        candidate_values = np.array([(value1_lst[i] + value2_lst[i]) / weight_lst[i] for i in candidates])\n        add_item = candidates[np.argmax(candidate_values)]\n        new_solution = base_solution.copy()\n        new_solution[remove_item] = 0\n        new_solution[add_item] = 1\n    else:\n        # If no items can be added, just remove the selected item\n        new_solution = base_solution.copy()\n        new_solution[remove_item] = 0\n\n    # With 20% probability, apply random perturbation to escape local optima\n    if random.random() < 0.2:\n        perturb_items = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n        for item in perturb_items:\n            if base_solution[item] == 1:\n                # Try to remove item if it doesn't cause infeasibility\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n            else:\n                # Try to add item if it doesn't exceed capacity\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid selection criterion that combines objective values and solution diversity, then applies a novel local search operator that intelligently flips a subset of items based on their marginal contributions to both objectives, ensuring feasibility and maximizing improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a hybrid criterion (objective + diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    base_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_val1 = value1_lst / np.maximum(weight_lst, 1e-10)  # Avoid division by zero\n    marginal_val2 = value2_lst / np.maximum(weight_lst, 1e-10)\n    marginal_combined = marginal_val1 + marginal_val2  # Combined marginal contribution\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Generate neighbor by flipping items with highest marginal contributions\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8197347404489624,
            4.103249430656433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a hybrid criterion (objective + diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    base_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_val1 = value1_lst / np.maximum(weight_lst, 1e-10)  # Avoid division by zero\n    marginal_val2 = value2_lst / np.maximum(weight_lst, 1e-10)\n    marginal_combined = marginal_val1 + marginal_val2  # Combined marginal contribution\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Generate neighbor by flipping items with highest marginal contributions\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{Our heuristic selects a solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search that iteratively flips items based on a dynamic trade-off between the two objectives, ensuring feasibility and maximizing both objective values.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective values and low weight\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n    archive_weights = [np.sum(weight_lst * sol) for sol in archive_solutions]\n\n    # Normalize objectives and weights\n    max_obj1 = max(obj[0] for obj in archive_objectives)\n    max_obj2 = max(obj[1] for obj in archive_objectives)\n    max_weight = max(archive_weights)\n\n    normalized_scores = []\n    for i, (obj, weight) in enumerate(zip(archive_objectives, archive_weights)):\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 != 0 else 0\n        norm_weight = weight / max_weight if max_weight != 0 else 0\n        score = 0.5 * (norm_obj1 + norm_obj2) - 0.5 * norm_weight\n        normalized_scores.append((score, i))\n\n    # Select the solution with the highest score\n    selected_idx = max(normalized_scores, key=lambda x: x[0])[1]\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using a dynamic trade-off local search\n    new_solution = base_solution.copy()\n    items = np.arange(len(weight_lst))\n    np.random.shuffle(items)\n\n    for item in items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Decide based on dynamic trade-off\n                delta_obj1 = value1_lst[item]\n                delta_obj2 = value2_lst[item]\n                if random.random() < 0.5:\n                    if delta_obj1 > 0:\n                        new_solution[item] = 1\n                        current_weight = new_weight\n                else:\n                    if delta_obj2 > 0:\n                        new_solution[item] = 1\n                        current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.48942191444458827,
            6.416444480419159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective values and low weight\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n    archive_weights = [np.sum(weight_lst * sol) for sol in archive_solutions]\n\n    # Normalize objectives and weights\n    max_obj1 = max(obj[0] for obj in archive_objectives)\n    max_obj2 = max(obj[1] for obj in archive_objectives)\n    max_weight = max(archive_weights)\n\n    normalized_scores = []\n    for i, (obj, weight) in enumerate(zip(archive_objectives, archive_weights)):\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 != 0 else 0\n        norm_weight = weight / max_weight if max_weight != 0 else 0\n        score = 0.5 * (norm_obj1 + norm_obj2) - 0.5 * norm_weight\n        normalized_scores.append((score, i))\n\n    # Select the solution with the highest score\n    selected_idx = max(normalized_scores, key=lambda x: x[0])[1]\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using a dynamic trade-off local search\n    new_solution = base_solution.copy()\n    items = np.arange(len(weight_lst))\n    np.random.shuffle(items)\n\n    for item in items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Decide based on dynamic trade-off\n                delta_obj1 = value1_lst[item]\n                delta_obj2 = value2_lst[item]\n                if random.random() < 0.5:\n                    if delta_obj1 > 0:\n                        new_solution[item] = 1\n                        current_weight = new_weight\n                else:\n                    if delta_obj2 > 0:\n                        new_solution[item] = 1\n                        current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by evaluating the trade-off between the two objectives, then performs a hybrid local search combining item swaps and value-based perturbations to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on the trade-off between objectives\n    def tradeoff_score(obj1, obj2):\n        return obj1 + obj2  # Simple sum for selection; can be replaced with more sophisticated scoring\n\n    scores = [tradeoff_score(obj[0], obj[1]) for (_, obj) in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: combine item swaps and value-based perturbations\n    # Randomly select a subset of items to perturb\n    perturb_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    for idx in perturb_indices:\n        # Attempt to swap the item (if feasible)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n\n    # Additionally, perform value-based perturbations to balance objectives\n    # Select items with high value1 but low value2 or vice versa\n    value_ratio = value1_lst / (value2_lst + 1e-6)\n    sorted_indices = np.argsort(value_ratio)\n\n    for idx in sorted_indices[-min(2, len(sorted_indices)):]:\n        if new_solution[idx] == 0:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.3052957758188083,
            6.813628226518631
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on the trade-off between objectives\n    def tradeoff_score(obj1, obj2):\n        return obj1 + obj2  # Simple sum for selection; can be replaced with more sophisticated scoring\n\n    scores = [tradeoff_score(obj[0], obj[1]) for (_, obj) in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: combine item swaps and value-based perturbations\n    # Randomly select a subset of items to perturb\n    perturb_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    for idx in perturb_indices:\n        # Attempt to swap the item (if feasible)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n\n    # Additionally, perform value-based perturbations to balance objectives\n    # Select items with high value1 but low value2 or vice versa\n    value_ratio = value1_lst / (value2_lst + 1e-6)\n    sorted_indices = np.argsort(value_ratio)\n\n    for idx in sorted_indices[-min(2, len(sorted_indices)):]:\n        if new_solution[idx] == 0:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{A hybrid local search strategy that intelligently selects a solution with high diversity and marginal improvement potential, then applies a novel combination of item swaps, flips, and intensity-based perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity and marginal improvement potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Perform intensity-based item swaps\n    for _ in range(3):\n        item1 = random.randint(0, n_items - 1)\n        item2 = random.randint(0, n_items - 1)\n\n        # Swap if feasible\n        if new_solution[item1] != new_solution[item2]:\n            if new_solution[item1] == 1:\n                new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            else:\n                new_weight = current_weight + weight_lst[item1] - weight_lst[item2]\n\n            if new_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = new_weight\n\n    # Step 2: Perform targeted flips\n    for _ in range(2):\n        item = random.randint(0, n_items - 1)\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = new_weight\n\n    # Step 3: Intensity-based perturbations\n    intensity = min(5, n_items // 10)\n    for _ in range(intensity):\n        item = random.randint(0, n_items - 1)\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4114796733799467,
            3.0875588953495026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity and marginal improvement potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Perform intensity-based item swaps\n    for _ in range(3):\n        item1 = random.randint(0, n_items - 1)\n        item2 = random.randint(0, n_items - 1)\n\n        # Swap if feasible\n        if new_solution[item1] != new_solution[item2]:\n            if new_solution[item1] == 1:\n                new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            else:\n                new_weight = current_weight + weight_lst[item1] - weight_lst[item2]\n\n            if new_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = new_weight\n\n    # Step 2: Perform targeted flips\n    for _ in range(2):\n        item = random.randint(0, n_items - 1)\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = new_weight\n\n    # Step 3: Intensity-based perturbations\n    intensity = min(5, n_items // 10)\n    for _ in range(intensity):\n        item = random.randint(0, n_items - 1)\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement, then applies a hybrid local search strategy combining item flipping, item swapping, and adaptive neighborhood exploration to generate a feasible neighbor solution while balancing improvements in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to find a balanced one\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a middle solution for better exploration\n        base_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Determine current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Random item flipping with adaptive probability\n    flip_prob = 0.3 if current_weight < capacity * 0.7 else 0.1\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # Try removing the item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                # Try adding the item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    # Step 2: Item swapping (swap items between 0 and 1)\n    swap_candidates = np.where(new_solution == 1)[0]\n    for i in swap_candidates:\n        if random.random() < 0.2:  # 20% chance to swap\n            # Find a zero item to swap with\n            zero_items = np.where(new_solution == 0)[0]\n            if len(zero_items) > 0:\n                j = random.choice(zero_items)\n                # Check feasibility of swap\n                if (current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Adaptive neighborhood exploration\n    # If still under capacity, try adding more items\n    if current_weight < capacity * 0.9:\n        zero_items = np.where(new_solution == 0)[0]\n        for i in zero_items:\n            if random.random() < 0.1:  # 10% chance to add\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.41143304727834584,
            11.096651583909988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to find a balanced one\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a middle solution for better exploration\n        base_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Determine current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Random item flipping with adaptive probability\n    flip_prob = 0.3 if current_weight < capacity * 0.7 else 0.1\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # Try removing the item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                # Try adding the item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    # Step 2: Item swapping (swap items between 0 and 1)\n    swap_candidates = np.where(new_solution == 1)[0]\n    for i in swap_candidates:\n        if random.random() < 0.2:  # 20% chance to swap\n            # Find a zero item to swap with\n            zero_items = np.where(new_solution == 0)[0]\n            if len(zero_items) > 0:\n                j = random.choice(zero_items)\n                # Check feasibility of swap\n                if (current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Adaptive neighborhood exploration\n    # If still under capacity, try adding more items\n    if current_weight < capacity * 0.9:\n        zero_items = np.where(new_solution == 0)[0]\n        for i in zero_items:\n            if random.random() < 0.1:  # 10% chance to add\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score of value1 and value2\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select the top 30% of solutions\n        top_solutions = sorted_archive[:max(1, int(len(sorted_archive) * 0.3))]\n        # Randomly select one from the top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combination of item swaps and random flips\n    for _ in range(5):  # Number of iterations for local search\n        # Randomly select two items\n        i, j = random.sample(range(len(new_solution)), 2)\n\n        # Attempt to swap items\n        if new_solution[i] != new_solution[j]:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n        # Attempt to flip a random item\n        k = random.randint(0, len(new_solution) - 1)\n        if new_solution[k] == 1:\n            temp_weight = current_weight - weight_lst[k]\n            if temp_weight <= capacity:\n                new_solution[k] = 0\n                current_weight = temp_weight\n        else:\n            temp_weight = current_weight + weight_lst[k]\n            if temp_weight <= capacity:\n                new_solution[k] = 1\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.37123201110016213,
            7.864375650882721
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score of value1 and value2\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select the top 30% of solutions\n        top_solutions = sorted_archive[:max(1, int(len(sorted_archive) * 0.3))]\n        # Randomly select one from the top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combination of item swaps and random flips\n    for _ in range(5):  # Number of iterations for local search\n        # Randomly select two items\n        i, j = random.sample(range(len(new_solution)), 2)\n\n        # Attempt to swap items\n        if new_solution[i] != new_solution[j]:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n        # Attempt to flip a random item\n        k = random.randint(0, len(new_solution) - 1)\n        if new_solution[k] == 1:\n            temp_weight = current_weight - weight_lst[k]\n            if temp_weight <= capacity:\n                new_solution[k] = 0\n                current_weight = temp_weight\n        else:\n            temp_weight = current_weight + weight_lst[k]\n            if temp_weight <= capacity:\n                new_solution[k] = 1\n                current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, applies a combination of adaptive item swaps and value-driven flips to explore high-potential regions while ensuring feasibility, and dynamically balances exploration of both objective spaces through a weighted random selection mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = random.choices(range(len(archive)), weights=[1 - (sum(archive[i][0] * weight_lst) / capacity) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    current_weight = sum(new_solution * weight_lst)\n\n    # Hybrid local search: adaptive item swaps and value-driven flips\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Randomly select two items to swap (if feasible)\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[item1] != new_solution[item2]:\n            if new_solution[item1] == 1:\n                new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            else:\n                new_weight = current_weight + weight_lst[item1] - weight_lst[item2]\n            if new_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = new_weight\n\n        # Randomly flip an item based on value density (higher density = more likely to flip)\n        item = random.randint(0, len(weight_lst) - 1)\n        value_density1 = value1_lst[item] / weight_lst[item]\n        value_density2 = value2_lst[item] / weight_lst[item]\n        flip_prob = (value_density1 + value_density2) / 2\n\n        if random.random() < flip_prob:\n            if new_solution[item] == 1:\n                new_weight = current_weight - weight_lst[item]\n            else:\n                new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1 - new_solution[item]\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.45331679864588914,
            6.992158591747284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = random.choices(range(len(archive)), weights=[1 - (sum(archive[i][0] * weight_lst) / capacity) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    current_weight = sum(new_solution * weight_lst)\n\n    # Hybrid local search: adaptive item swaps and value-driven flips\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Randomly select two items to swap (if feasible)\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[item1] != new_solution[item2]:\n            if new_solution[item1] == 1:\n                new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            else:\n                new_weight = current_weight + weight_lst[item1] - weight_lst[item2]\n            if new_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = new_weight\n\n        # Randomly flip an item based on value density (higher density = more likely to flip)\n        item = random.randint(0, len(weight_lst) - 1)\n        value_density1 = value1_lst[item] / weight_lst[item]\n        value_density2 = value2_lst[item] / weight_lst[item]\n        flip_prob = (value_density1 + value_density2) / 2\n\n        if random.random() < flip_prob:\n            if new_solution[item] == 1:\n                new_weight = current_weight - weight_lst[item]\n            else:\n                new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1 - new_solution[item]\n                current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This algorithm intelligently selects a non-dominated solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines random swaps with a greedy selection of items that maximize a weighted sum of both objectives, ensuring feasibility while exploring the solution space more effectively than standard methods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine random swaps with greedy selection\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Randomly select items to consider for swapping\n    candidates = random.sample(range(num_items), min(10, num_items))\n\n    for i in candidates:\n        if base_solution[i] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[i] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[i]\n\n    # Greedy selection of items not in the solution\n    remaining_items = [i for i in range(num_items) if new_solution[i] == 0]\n    random.shuffle(remaining_items)\n\n    for i in remaining_items:\n        if current_weight + weight_lst[i] <= capacity:\n            # Use a weighted sum of both objectives to decide\n            weight1 = random.uniform(0.3, 0.7)\n            weight2 = 1 - weight1\n            score = weight1 * value1_lst[i] + weight2 * value2_lst[i]\n\n            # Add item if it improves the weighted score\n            if score > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4018496476656181,
            4.018408894538879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine random swaps with greedy selection\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Randomly select items to consider for swapping\n    candidates = random.sample(range(num_items), min(10, num_items))\n\n    for i in candidates:\n        if base_solution[i] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[i] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[i]\n\n    # Greedy selection of items not in the solution\n    remaining_items = [i for i in range(num_items) if new_solution[i] == 0]\n    random.shuffle(remaining_items)\n\n    for i in remaining_items:\n        if current_weight + weight_lst[i] <= capacity:\n            # Use a weighted sum of both objectives to decide\n            weight1 = random.uniform(0.3, 0.7)\n            weight2 = 1 - weight1\n            score = weight1 * value1_lst[i] + weight2 * value2_lst[i]\n\n            # Add item if it improves the weighted score\n            if score > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search strategy that combines item swapping and value-balanced perturbations to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    current_solution = selected_solution.copy()\n    new_solution = current_solution.copy()\n\n    # Hybrid local search strategy: swap items with high value diversity and balance\n    n_items = len(weight_lst)\n    for _ in range(10):  # Limit iterations to balance exploration and computation\n        # Randomly select two items to swap\n        i, j = random.sample(range(n_items), 2)\n\n        # Calculate potential changes\n        if current_solution[i] == current_solution[j]:\n            continue  # Skip if both are the same\n\n        # Check feasibility for swap\n        delta_weight = (weight_lst[j] - weight_lst[i]) if current_solution[i] else (weight_lst[i] - weight_lst[j])\n        current_weight = np.sum(weight_lst * current_solution)\n        if current_weight + delta_weight > capacity:\n            continue  # Skip if swap violates capacity\n\n        # Perform swap if it improves both objectives\n        delta_value1 = (value1_lst[j] - value1_lst[i]) if current_solution[i] else (value1_lst[i] - value1_lst[j])\n        delta_value2 = (value2_lst[j] - value2_lst[i]) if current_solution[i] else (value2_lst[i] - value2_lst[j])\n\n        if delta_value1 > 0 and delta_value2 > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional perturbation: flip items with high value diversity\n    for _ in range(5):\n        # Select an item to flip\n        k = random.randint(0, n_items - 1)\n\n        # Check feasibility for flip\n        if current_solution[k] == 1:\n            if np.sum(weight_lst * current_solution) - weight_lst[k] <= capacity:\n                new_solution[k] = 0\n        else:\n            if np.sum(weight_lst * current_solution) + weight_lst[k] <= capacity:\n                new_solution[k] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.33588723209237453,
            4.997980415821075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    current_solution = selected_solution.copy()\n    new_solution = current_solution.copy()\n\n    # Hybrid local search strategy: swap items with high value diversity and balance\n    n_items = len(weight_lst)\n    for _ in range(10):  # Limit iterations to balance exploration and computation\n        # Randomly select two items to swap\n        i, j = random.sample(range(n_items), 2)\n\n        # Calculate potential changes\n        if current_solution[i] == current_solution[j]:\n            continue  # Skip if both are the same\n\n        # Check feasibility for swap\n        delta_weight = (weight_lst[j] - weight_lst[i]) if current_solution[i] else (weight_lst[i] - weight_lst[j])\n        current_weight = np.sum(weight_lst * current_solution)\n        if current_weight + delta_weight > capacity:\n            continue  # Skip if swap violates capacity\n\n        # Perform swap if it improves both objectives\n        delta_value1 = (value1_lst[j] - value1_lst[i]) if current_solution[i] else (value1_lst[i] - value1_lst[j])\n        delta_value2 = (value2_lst[j] - value2_lst[i]) if current_solution[i] else (value2_lst[i] - value2_lst[j])\n\n        if delta_value1 > 0 and delta_value2 > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional perturbation: flip items with high value diversity\n    for _ in range(5):\n        # Select an item to flip\n        k = random.randint(0, n_items - 1)\n\n        # Check feasibility for flip\n        if current_solution[k] == 1:\n            if np.sum(weight_lst * current_solution) - weight_lst[k] <= capacity:\n                new_solution[k] = 0\n        else:\n            if np.sum(weight_lst * current_solution) + weight_lst[k] <= capacity:\n                new_solution[k] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects promising solutions from the archive, applies a weighted random flip-based perturbation, and uses a dynamic acceptance mechanism to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with higher probability for solutions with higher total values\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    if len(total_values) == 0:\n        selected_idx = 0\n    else:\n        probs = total_values / np.sum(total_values)\n        selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution with weighted random flips\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Determine flip candidates: items that can be flipped without violating capacity\n    flip_candidates = []\n    for i in range(n_items):\n        if base_solution[i] == 1:\n            # If item is included, check if removing it keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n        else:\n            # If item is excluded, check if adding it keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        # If no feasible flips, return the base solution\n        return base_solution\n\n    # Select a random subset of flip candidates to flip\n    flip_count = min(3, len(flip_candidates))  # Limit to 3 flips for diversity\n    flip_indices = random.sample(flip_candidates, flip_count)\n\n    # Apply flips\n    for i in flip_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility (sanity check)\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # If not feasible, revert to base solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8691744842741529,
            4.105171948671341
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with higher probability for solutions with higher total values\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    if len(total_values) == 0:\n        selected_idx = 0\n    else:\n        probs = total_values / np.sum(total_values)\n        selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution with weighted random flips\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Determine flip candidates: items that can be flipped without violating capacity\n    flip_candidates = []\n    for i in range(n_items):\n        if base_solution[i] == 1:\n            # If item is included, check if removing it keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n        else:\n            # If item is excluded, check if adding it keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        # If no feasible flips, return the base solution\n        return base_solution\n\n    # Select a random subset of flip candidates to flip\n    flip_count = min(3, len(flip_candidates))  # Limit to 3 flips for diversity\n    flip_indices = random.sample(flip_candidates, flip_count)\n\n    # Apply flips\n    for i in flip_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility (sanity check)\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # If not feasible, revert to base solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify candidate items to flip (0 to 1 or 1 to 0)\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Candidate for removal\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Candidate for addition\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))   # 1 indicates addition\n\n    if not candidate_items:\n        return base_solution  # No feasible move\n\n    # Randomly select a candidate item to flip\n    item_idx, flip = candidate_items[np.random.randint(0, len(candidate_items))]\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    # Ensure the new solution is feasible\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # If not feasible, revert to the original solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9094277933507102,
            3.852485477924347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify candidate items to flip (0 to 1 or 1 to 0)\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Candidate for removal\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Candidate for addition\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))   # 1 indicates addition\n\n    if not candidate_items:\n        return base_solution  # No feasible move\n\n    # Randomly select a candidate item to flip\n    item_idx, flip = candidate_items[np.random.randint(0, len(candidate_items))]\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    # Ensure the new solution is feasible\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # If not feasible, revert to the original solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_weight = np.sum(weight_lst[base_solution == 1])\n    base_value1, base_value2 = archive[selected_idx][1]\n\n    # Hybrid local search: combine swap and flip with value-based selection\n    new_solution = base_solution.copy()\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # Randomly select an item to swap or flip\n        item_to_modify = np.random.choice(candidate_indices)\n        if np.random.rand() < 0.5:\n            # Flip operation: remove the selected item\n            new_solution[item_to_modify] = 0\n        else:\n            # Swap operation: replace with a non-selected item with high value ratio\n            available_items = np.where(base_solution == 0)[0]\n            if len(available_items) > 0:\n                # Select the item with highest value ratio (value1 + value2)/weight\n                value_ratios = (value1_lst[available_items] + value2_lst[available_items]) / weight_lst[available_items]\n                best_item = available_items[np.argmax(value_ratios)]\n                if weight_lst[best_item] <= capacity - base_weight + weight_lst[item_to_modify]:\n                    new_solution[item_to_modify] = 0\n                    new_solution[best_item] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess_weight = current_weight - capacity\n        while excess_weight > 0:\n            items_in_solution = np.where(new_solution == 1)[0]\n            if len(items_in_solution) == 0:\n                break\n            # Remove the item with smallest value ratio\n            value_ratios = (value1_lst[items_in_solution] + value2_lst[items_in_solution]) / weight_lst[items_in_solution]\n            worst_item = items_in_solution[np.argmin(value_ratios)]\n            new_solution[worst_item] = 0\n            excess_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n",
        "score": [
            -0.3540972309980993,
            3.4176642894744873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_weight = np.sum(weight_lst[base_solution == 1])\n    base_value1, base_value2 = archive[selected_idx][1]\n\n    # Hybrid local search: combine swap and flip with value-based selection\n    new_solution = base_solution.copy()\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # Randomly select an item to swap or flip\n        item_to_modify = np.random.choice(candidate_indices)\n        if np.random.rand() < 0.5:\n            # Flip operation: remove the selected item\n            new_solution[item_to_modify] = 0\n        else:\n            # Swap operation: replace with a non-selected item with high value ratio\n            available_items = np.where(base_solution == 0)[0]\n            if len(available_items) > 0:\n                # Select the item with highest value ratio (value1 + value2)/weight\n                value_ratios = (value1_lst[available_items] + value2_lst[available_items]) / weight_lst[available_items]\n                best_item = available_items[np.argmax(value_ratios)]\n                if weight_lst[best_item] <= capacity - base_weight + weight_lst[item_to_modify]:\n                    new_solution[item_to_modify] = 0\n                    new_solution[best_item] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess_weight = current_weight - capacity\n        while excess_weight > 0:\n            items_in_solution = np.where(new_solution == 1)[0]\n            if len(items_in_solution) == 0:\n                break\n            # Remove the item with smallest value ratio\n            value_ratios = (value1_lst[items_in_solution] + value2_lst[items_in_solution]) / weight_lst[items_in_solution]\n            worst_item = items_in_solution[np.argmin(value_ratios)]\n            new_solution[worst_item] = 0\n            excess_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{The algorithm selects a promising solution from the archive based on its potential for improvement in both objectives, then applies a hybrid local search operator that combines item swaps, flips, and adaptive perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Random flip of items with high value-to-weight ratio\n    value_to_weight1 = value1_lst / (weight_lst + 1e-6)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = (value_to_weight1 + value_to_weight2) / 2\n\n    # Identify items with high ratio and flip some randomly\n    high_ratio_items = np.where(combined_ratio > np.percentile(combined_ratio, 75))[0]\n    if len(high_ratio_items) > 0:\n        flip_indices = np.random.choice(high_ratio_items, size=min(3, len(high_ratio_items)), replace=False)\n        new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Step 2: Check feasibility and adjust if needed\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items until feasible\n        excess_weight = new_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        excess_items = excess_items[np.argsort(weight_lst[excess_items])][::-1]  # Sort by weight descending\n\n        for item in excess_items:\n            if excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Step 3: Add items that improve both objectives\n    candidate_items = np.where(new_solution == 0)[0]\n    candidate_items = candidate_items[np.argsort(combined_ratio[candidate_items])][::-1]  # Sort by ratio descending\n\n    for item in candidate_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.283378827415893,
            7.416900783777237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Random flip of items with high value-to-weight ratio\n    value_to_weight1 = value1_lst / (weight_lst + 1e-6)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = (value_to_weight1 + value_to_weight2) / 2\n\n    # Identify items with high ratio and flip some randomly\n    high_ratio_items = np.where(combined_ratio > np.percentile(combined_ratio, 75))[0]\n    if len(high_ratio_items) > 0:\n        flip_indices = np.random.choice(high_ratio_items, size=min(3, len(high_ratio_items)), replace=False)\n        new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Step 2: Check feasibility and adjust if needed\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items until feasible\n        excess_weight = new_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        excess_items = excess_items[np.argsort(weight_lst[excess_items])][::-1]  # Sort by weight descending\n\n        for item in excess_items:\n            if excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Step 3: Add items that improve both objectives\n    candidate_items = np.where(new_solution == 0)[0]\n    candidate_items = candidate_items[np.argsort(combined_ratio[candidate_items])][::-1]  # Sort by ratio descending\n\n    for item in candidate_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a novel 'diversity-aware' local search strategy that combines random perturbation with gradient-based objective improvement, ensuring feasibility by dynamically adjusting item swaps while prioritizing solutions with high potential for multi-objective enhancement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (diversity-aware)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(1 - np.mean(sol[0])) * (sol[1][0] + sol[1][1]) for sol in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + gradient-based improvement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Randomly select a subset of items to perturb\n    perturb_size = min(5, n_items)\n    perturb_indices = random.sample(range(n_items), perturb_size)\n\n    for idx in perturb_indices:\n        if base_solution[idx] == 1:\n            # Try to remove item if it's in the solution\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if it's not in the solution\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Gradient-based improvement for both objectives\n    for _ in range(3):\n        # Calculate marginal gains for both objectives\n        marginal_gain1 = value1_lst * (1 - base_solution)\n        marginal_gain2 = value2_lst * (1 - base_solution)\n        combined_gain = marginal_gain1 + marginal_gain2\n\n        # Select items to add based on combined gain\n        candidate_items = np.argsort(combined_gain)[::-1]\n        for item in candidate_items:\n            if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n\n        # Select items to remove based on negative marginal gain\n        marginal_gain1 = value1_lst * base_solution\n        marginal_gain2 = value2_lst * base_solution\n        combined_gain = marginal_gain1 + marginal_gain2\n\n        candidate_items = np.argsort(combined_gain)\n        for item in candidate_items:\n            if new_solution[item] == 1 and current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.34646722846318967,
            4.813029259443283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (diversity-aware)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(1 - np.mean(sol[0])) * (sol[1][0] + sol[1][1]) for sol in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + gradient-based improvement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Randomly select a subset of items to perturb\n    perturb_size = min(5, n_items)\n    perturb_indices = random.sample(range(n_items), perturb_size)\n\n    for idx in perturb_indices:\n        if base_solution[idx] == 1:\n            # Try to remove item if it's in the solution\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if it's not in the solution\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Gradient-based improvement for both objectives\n    for _ in range(3):\n        # Calculate marginal gains for both objectives\n        marginal_gain1 = value1_lst * (1 - base_solution)\n        marginal_gain2 = value2_lst * (1 - base_solution)\n        combined_gain = marginal_gain1 + marginal_gain2\n\n        # Select items to add based on combined gain\n        candidate_items = np.argsort(combined_gain)[::-1]\n        for item in candidate_items:\n            if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n\n        # Select items to remove based on negative marginal gain\n        marginal_gain1 = value1_lst * base_solution\n        marginal_gain2 = value2_lst * base_solution\n        combined_gain = marginal_gain1 + marginal_gain2\n\n        candidate_items = np.argsort(combined_gain)\n        for item in candidate_items:\n            if new_solution[item] == 1 and current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_score = -1\n    best_solution = None\n    for solution, (obj1, obj2) in archive:\n        # Normalize objectives for comparison\n        norm_obj1 = obj1 / (np.sum(value1_lst) + 1e-6)\n        norm_obj2 = obj2 / (np.sum(value2_lst) + 1e-6)\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            best_solution = solution\n\n    # Create a neighbor by flipping items with the highest marginal gain in either objective\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Calculate marginal gains for each item\n    gains1 = value1_lst / (weight_lst + 1e-6)\n    gains2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine gains and sort by their sum\n    combined_gains = gains1 + gains2\n    sorted_indices = np.argsort(-combined_gains)\n\n    # Try flipping items in order of highest combined gain\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.875708854661813,
            4.011153161525726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_score = -1\n    best_solution = None\n    for solution, (obj1, obj2) in archive:\n        # Normalize objectives for comparison\n        norm_obj1 = obj1 / (np.sum(value1_lst) + 1e-6)\n        norm_obj2 = obj2 / (np.sum(value2_lst) + 1e-6)\n        score = norm_obj1 + norm_obj2\n        if score > max_score:\n            max_score = score\n            best_solution = solution\n\n    # Create a neighbor by flipping items with the highest marginal gain in either objective\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Calculate marginal gains for each item\n    gains1 = value1_lst / (weight_lst + 1e-6)\n    gains2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine gains and sort by their sum\n    combined_gains = gains1 + gains2\n    sorted_indices = np.argsort(-combined_gains)\n\n    # Try flipping items in order of highest combined gain\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{A novel heuristic algorithm that selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid local search strategy combining greedy and random perturbations to explore the solution space while ensuring feasibility, focusing on both objectives through adaptive neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal for both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (v1, v2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by flipping items with high marginal gains\n    new_solution = base_solution.copy()\n    items = np.arange(len(weight_lst))\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst / (weight_lst + 1e-8)  # Avoid division by zero\n    marginal_gain2 = value2_lst / (weight_lst + 1e-8)\n    marginal_gain = marginal_gain1 + marginal_gain2  # Combined gain\n\n    # Sort items by marginal gain\n    sorted_items = items[np.argsort(-marginal_gain)]\n\n    # Apply a hybrid local search: flip top-k items with highest gain, then randomly flip others\n    k = max(1, len(sorted_items) // 10)  # Top k items\n    top_items = sorted_items[:k]\n\n    for item in top_items:\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Randomly flip other items to explore further\n    other_items = np.setdiff1d(items, top_items)\n    np.random.shuffle(other_items)\n    for item in other_items[:len(other_items)//2]:  # Flip half of the remaining items\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.412732320509259,
            2.5552637577056885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal for both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (v1, v2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by flipping items with high marginal gains\n    new_solution = base_solution.copy()\n    items = np.arange(len(weight_lst))\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst / (weight_lst + 1e-8)  # Avoid division by zero\n    marginal_gain2 = value2_lst / (weight_lst + 1e-8)\n    marginal_gain = marginal_gain1 + marginal_gain2  # Combined gain\n\n    # Sort items by marginal gain\n    sorted_items = items[np.argsort(-marginal_gain)]\n\n    # Apply a hybrid local search: flip top-k items with highest gain, then randomly flip others\n    k = max(1, len(sorted_items) // 10)  # Top k items\n    top_items = sorted_items[:k]\n\n    for item in top_items:\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Randomly flip other items to explore further\n    other_items = np.setdiff1d(items, top_items)\n    np.random.shuffle(other_items)\n    for item in other_items[:len(other_items)//2]:  # Flip half of the remaining items\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping with probabilistic neighborhood exploration, where the selection of items to swap is guided by their marginal contribution to both objectives, while ensuring feasibility through dynamic capacity adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential (e.g., top 20% in either objective)\n    archive_sorted_by_value1 = sorted(archive, key=lambda x: -x[1][0])\n    top_20_percent = int(0.2 * len(archive_sorted_by_value1))\n    candidate_solutions = archive_sorted_by_value1[:top_20_percent]\n\n    archive_sorted_by_value2 = sorted(archive, key=lambda x: -x[1][1])\n    top_20_percent = int(0.2 * len(archive_sorted_by_value2))\n    candidate_solutions += archive_sorted_by_value2[:top_20_percent]\n\n    # Remove duplicates and randomly select a base solution\n    unique_candidates = list({tuple(sol[0]): sol for sol in candidate_solutions}.values())\n    if not unique_candidates:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(unique_candidates)[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items in and out of the knapsack\n    in_knapsack = np.where(new_solution == 1)[0]\n    out_knapsack = np.where(new_solution == 0)[0]\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid local search: probabilistic swap based on marginal contributions\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        if len(in_knapsack) == 0 or len(out_knapsack) == 0:\n            break\n\n        # Select an item to remove (prefer high marginal contribution in either objective)\n        remove_idx = random.choices(\n            in_knapsack,\n            weights=np.maximum(marginal_value1[in_knapsack], marginal_value2[in_knapsack]),\n            k=1\n        )[0]\n\n        # Select an item to add (prefer items that can fit and have high marginal contribution)\n        possible_add = [i for i in out_knapsack if weight_lst[i] <= remaining_capacity + weight_lst[remove_idx]]\n        if not possible_add:\n            continue\n\n        add_weights = np.maximum(marginal_value1[possible_add], marginal_value2[possible_add])\n        add_idx = random.choices(possible_add, weights=add_weights, k=1)[0]\n\n        # Perform the swap\n        new_solution[remove_idx] = 0\n        new_solution[add_idx] = 1\n\n        # Verify feasibility\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # Revert if infeasible\n            new_solution[remove_idx] = 1\n            new_solution[add_idx] = 0\n        else:\n            remaining_capacity = capacity - new_weight\n            in_knapsack = np.where(new_solution == 1)[0]\n            out_knapsack = np.where(new_solution == 0)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.5059529273811595,
            10.451809465885162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential (e.g., top 20% in either objective)\n    archive_sorted_by_value1 = sorted(archive, key=lambda x: -x[1][0])\n    top_20_percent = int(0.2 * len(archive_sorted_by_value1))\n    candidate_solutions = archive_sorted_by_value1[:top_20_percent]\n\n    archive_sorted_by_value2 = sorted(archive, key=lambda x: -x[1][1])\n    top_20_percent = int(0.2 * len(archive_sorted_by_value2))\n    candidate_solutions += archive_sorted_by_value2[:top_20_percent]\n\n    # Remove duplicates and randomly select a base solution\n    unique_candidates = list({tuple(sol[0]): sol for sol in candidate_solutions}.values())\n    if not unique_candidates:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(unique_candidates)[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items in and out of the knapsack\n    in_knapsack = np.where(new_solution == 1)[0]\n    out_knapsack = np.where(new_solution == 0)[0]\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid local search: probabilistic swap based on marginal contributions\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        if len(in_knapsack) == 0 or len(out_knapsack) == 0:\n            break\n\n        # Select an item to remove (prefer high marginal contribution in either objective)\n        remove_idx = random.choices(\n            in_knapsack,\n            weights=np.maximum(marginal_value1[in_knapsack], marginal_value2[in_knapsack]),\n            k=1\n        )[0]\n\n        # Select an item to add (prefer items that can fit and have high marginal contribution)\n        possible_add = [i for i in out_knapsack if weight_lst[i] <= remaining_capacity + weight_lst[remove_idx]]\n        if not possible_add:\n            continue\n\n        add_weights = np.maximum(marginal_value1[possible_add], marginal_value2[possible_add])\n        add_idx = random.choices(possible_add, weights=add_weights, k=1)[0]\n\n        # Perform the swap\n        new_solution[remove_idx] = 0\n        new_solution[add_idx] = 1\n\n        # Verify feasibility\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # Revert if infeasible\n            new_solution[remove_idx] = 1\n            new_solution[add_idx] = 0\n        else:\n            remaining_capacity = capacity - new_weight\n            in_knapsack = np.where(new_solution == 1)[0]\n            out_knapsack = np.where(new_solution == 0)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search operator that combines random swaps of items with a greedy improvement step to ensure feasibility and quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: random swap + greedy improvement\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Randomly swap some items\n    if len(items) > 0 and len(non_items) > 0:\n        swap_count = min(3, len(items), len(non_items))\n        swap_indices = np.random.choice(len(items), swap_count, replace=False)\n        for i in swap_indices:\n            item_idx = items[i]\n            non_item_idx = np.random.choice(non_items)\n            if current_weight - weight_lst[item_idx] + weight_lst[non_item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                new_solution[non_item_idx] = 1\n                current_weight = current_weight - weight_lst[item_idx] + weight_lst[non_item_idx]\n\n    # Greedy improvement step\n    for _ in range(5):\n        # Try adding items not in solution\n        for idx in non_items:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n\n        # Try removing items in solution\n        for idx in items:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.33344111613057636,
            5.3468064069747925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: random swap + greedy improvement\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Randomly swap some items\n    if len(items) > 0 and len(non_items) > 0:\n        swap_count = min(3, len(items), len(non_items))\n        swap_indices = np.random.choice(len(items), swap_count, replace=False)\n        for i in swap_indices:\n            item_idx = items[i]\n            non_item_idx = np.random.choice(non_items)\n            if current_weight - weight_lst[item_idx] + weight_lst[non_item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                new_solution[non_item_idx] = 1\n                current_weight = current_weight - weight_lst[item_idx] + weight_lst[non_item_idx]\n\n    # Greedy improvement step\n    for _ in range(5):\n        # Try adding items not in solution\n        for idx in non_items:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n\n        # Try removing items in solution\n        for idx in items:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high objective values and low weight usage, then applies a hybrid local search combining item swaps and random flips to explore high-potential neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst[x[0] == 1]) + 1e-6))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: swap + random flip\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    items = np.arange(len(base_solution))\n\n    # Try to swap items between included and excluded\n    included = items[base_solution == 1]\n    excluded = items[base_solution == 0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        i = random.choice(included)\n        j = random.choice(excluded)\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            return new_solution\n\n    # If swap not possible, try random flip\n    for _ in range(5):  # Try up to 5 random flips\n        i = random.choice(items)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                return new_solution\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6186513605858416,
            3.5817089676856995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst[x[0] == 1]) + 1e-6))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: swap + random flip\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    items = np.arange(len(base_solution))\n\n    # Try to swap items between included and excluded\n    included = items[base_solution == 1]\n    excluded = items[base_solution == 0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        i = random.choice(included)\n        j = random.choice(excluded)\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            return new_solution\n\n    # If swap not possible, try random flip\n    for _ in range(5):  # Try up to 5 random flips\n        i = random.choice(items)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                return new_solution\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive and applies a combination of item swaps, targeted flips, and adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by dominance and select a promising one\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n        selected_idx = min(len(archive) // 2, len(archive) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly flip a subset of items with high potential\n    for _ in range(3):\n        # Identify items with high value-to-weight ratios\n        v1_ratio = value1_lst / (weight_lst + 1e-6)\n        v2_ratio = value2_lst / (weight_lst + 1e-6)\n        combined_ratio = v1_ratio + v2_ratio\n        high_potential_items = np.argsort(combined_ratio)[-5:]  # Top 5 items\n\n        # Randomly select an item to flip\n        if len(high_potential_items) > 0:\n            item = random.choice(high_potential_items)\n            if new_solution[item] == 1:\n                # Remove the item if it's in the solution\n                new_solution[item] = 0\n            else:\n                # Add the item if it's not in the solution and feasible\n                if np.sum(weight_lst * new_solution) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n\n    # Step 2: Perform a targeted swap between two items\n    # Find two items where swapping could improve both objectives\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) >= 2:\n        item1, item2 = random.sample(list(candidate_items), 2)\n        # Check if swapping improves both objectives\n        original_v1 = np.sum(value1_lst * new_solution)\n        original_v2 = np.sum(value2_lst * new_solution)\n        new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n        new_v1 = np.sum(value1_lst * new_solution)\n        new_v2 = np.sum(value2_lst * new_solution)\n        # If swapping doesn't improve both, revert\n        if not (new_v1 > original_v1 and new_v2 > original_v2):\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random items until feasible\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        item_to_remove = random.choice(included_items)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9206379751042348,
            1.7702667117118835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by dominance and select a promising one\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n        selected_idx = min(len(archive) // 2, len(archive) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly flip a subset of items with high potential\n    for _ in range(3):\n        # Identify items with high value-to-weight ratios\n        v1_ratio = value1_lst / (weight_lst + 1e-6)\n        v2_ratio = value2_lst / (weight_lst + 1e-6)\n        combined_ratio = v1_ratio + v2_ratio\n        high_potential_items = np.argsort(combined_ratio)[-5:]  # Top 5 items\n\n        # Randomly select an item to flip\n        if len(high_potential_items) > 0:\n            item = random.choice(high_potential_items)\n            if new_solution[item] == 1:\n                # Remove the item if it's in the solution\n                new_solution[item] = 0\n            else:\n                # Add the item if it's not in the solution and feasible\n                if np.sum(weight_lst * new_solution) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n\n    # Step 2: Perform a targeted swap between two items\n    # Find two items where swapping could improve both objectives\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) >= 2:\n        item1, item2 = random.sample(list(candidate_items), 2)\n        # Check if swapping improves both objectives\n        original_v1 = np.sum(value1_lst * new_solution)\n        original_v2 = np.sum(value2_lst * new_solution)\n        new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n        new_v1 = np.sum(value1_lst * new_solution)\n        new_v2 = np.sum(value2_lst * new_solution)\n        # If swapping doesn't improve both, revert\n        if not (new_v1 > original_v1 and new_v2 > original_v2):\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random items until feasible\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        item_to_remove = random.choice(included_items)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search operator that combines random item swaps with a novel objective-weighted greedy selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high objective values and low dominance)\n    objectives = np.array([obj for (sol, obj) in archive])\n    scores = objectives[:, 0] + objectives[:, 1]  # Simple score based on sum of objectives\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    swap_candidates = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    # Step 2: For each candidate, decide to flip based on objective-weighted greedy selection\n    for i in swap_candidates:\n        if base_solution[i] == 1:\n            # Consider removing item i\n            new_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[i]\n            if new_weight <= capacity:\n                # Evaluate the impact on objectives\n                delta1 = -value1_lst[i]\n                delta2 = -value2_lst[i]\n                # Simple greedy selection: accept if at least one objective improves\n                if delta1 > 0 or delta2 > 0:\n                    new_solution[i] = 0\n        else:\n            # Consider adding item i\n            new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i]\n            if new_weight <= capacity:\n                # Evaluate the impact on objectives\n                delta1 = value1_lst[i]\n                delta2 = value2_lst[i]\n                # Simple greedy selection: accept if at least one objective improves\n                if delta1 > 0 or delta2 > 0:\n                    new_solution[i] = 1\n\n    # Step 3: Perform a random swap to ensure diversity\n    if np.random.rand() < 0.3:  # 30% chance of random swap\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Ensure feasibility after swap\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            # If infeasible, revert the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Try another pair\n            i, j = np.random.choice(n_items, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.35798687080054403,
            7.448263734579086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high objective values and low dominance)\n    objectives = np.array([obj for (sol, obj) in archive])\n    scores = objectives[:, 0] + objectives[:, 1]  # Simple score based on sum of objectives\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    swap_candidates = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    # Step 2: For each candidate, decide to flip based on objective-weighted greedy selection\n    for i in swap_candidates:\n        if base_solution[i] == 1:\n            # Consider removing item i\n            new_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[i]\n            if new_weight <= capacity:\n                # Evaluate the impact on objectives\n                delta1 = -value1_lst[i]\n                delta2 = -value2_lst[i]\n                # Simple greedy selection: accept if at least one objective improves\n                if delta1 > 0 or delta2 > 0:\n                    new_solution[i] = 0\n        else:\n            # Consider adding item i\n            new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i]\n            if new_weight <= capacity:\n                # Evaluate the impact on objectives\n                delta1 = value1_lst[i]\n                delta2 = value2_lst[i]\n                # Simple greedy selection: accept if at least one objective improves\n                if delta1 > 0 or delta2 > 0:\n                    new_solution[i] = 1\n\n    # Step 3: Perform a random swap to ensure diversity\n    if np.random.rand() < 0.3:  # 30% chance of random swap\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Ensure feasibility after swap\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            # If infeasible, revert the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Try another pair\n            i, j = np.random.choice(n_items, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, then applies a combination of item swaps and weighted random perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with high potential for improvement\n    max_potential = -1\n    selected_solution = None\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        potential = np.sum(value1_lst * sol) + np.sum(value2_lst * sol)  # Simple heuristic for potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted random swaps and perturbations\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to perturb\n    perturb_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional weighted random swaps to improve objectives\n    for _ in range(3):\n        i, j = np.random.choice(num_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1:\n                # Try swapping i (in) with j (out)\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n            else:\n                # Try swapping j (in) with i (out)\n                if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[j] + weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.31158458035216985,
            5.772375822067261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with high potential for improvement\n    max_potential = -1\n    selected_solution = None\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        potential = np.sum(value1_lst * sol) + np.sum(value2_lst * sol)  # Simple heuristic for potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: weighted random swaps and perturbations\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to perturb\n    perturb_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional weighted random swaps to improve objectives\n    for _ in range(3):\n        i, j = np.random.choice(num_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1:\n                # Try swapping i (in) with j (out)\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n            else:\n                # Try swapping j (in) with i (out)\n                if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[j] + weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive, applies a dynamic flip-and-shift operator to explore high-potential regions, and ensures feasibility by adaptive weight adjustment, while balancing exploration and exploitation through a combination of random and greedy selection criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Identify high-potential items to flip (candidate items)\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing items that are not critical\n            if current_weight - weight_lst[i] >= 0:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Consider adding items that fit and improve both objectives\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    # Step 3: Apply dynamic flip-and-shift operator\n    if candidate_items:\n        # Randomly select a candidate item to flip\n        item_idx, flip_type = random.choice(candidate_items)\n        new_solution = base_solution.copy()\n        new_solution[item_idx] = flip_type\n\n        # Shift operator: randomly select another item to flip (if feasible)\n        if random.random() < 0.5:  # 50% chance to apply shift\n            shift_candidates = []\n            for i in range(len(new_solution)):\n                if new_solution[i] == 1 and new_solution[i] != base_solution[i]:\n                    if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] >= 0:\n                        shift_candidates.append((i, -1))\n                elif new_solution[i] == 0 and new_solution[i] != base_solution[i]:\n                    if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                        shift_candidates.append((i, 1))\n\n            if shift_candidates:\n                shift_idx, shift_type = random.choice(shift_candidates)\n                new_solution[shift_idx] = shift_type\n\n        # Ensure feasibility (fallback)\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Remove random items until feasible\n            while total_weight > capacity:\n                items_in = np.where(new_solution == 1)[0]\n                if len(items_in) == 0:\n                    break\n                remove_idx = random.choice(items_in)\n                new_solution[remove_idx] = 0\n                total_weight -= weight_lst[remove_idx]\n    else:\n        # No candidates, perform a random flip\n        new_solution = base_solution.copy()\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and random.random() < 0.5:\n            # Remove a random item\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n        elif len(items_out) > 0:\n            # Add a random item if feasible\n            add_idx = random.choice(items_out)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8308430431039305,
            4.475847005844116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Identify high-potential items to flip (candidate items)\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Consider removing items that are not critical\n            if current_weight - weight_lst[i] >= 0:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Consider adding items that fit and improve both objectives\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    # Step 3: Apply dynamic flip-and-shift operator\n    if candidate_items:\n        # Randomly select a candidate item to flip\n        item_idx, flip_type = random.choice(candidate_items)\n        new_solution = base_solution.copy()\n        new_solution[item_idx] = flip_type\n\n        # Shift operator: randomly select another item to flip (if feasible)\n        if random.random() < 0.5:  # 50% chance to apply shift\n            shift_candidates = []\n            for i in range(len(new_solution)):\n                if new_solution[i] == 1 and new_solution[i] != base_solution[i]:\n                    if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] >= 0:\n                        shift_candidates.append((i, -1))\n                elif new_solution[i] == 0 and new_solution[i] != base_solution[i]:\n                    if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                        shift_candidates.append((i, 1))\n\n            if shift_candidates:\n                shift_idx, shift_type = random.choice(shift_candidates)\n                new_solution[shift_idx] = shift_type\n\n        # Ensure feasibility (fallback)\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Remove random items until feasible\n            while total_weight > capacity:\n                items_in = np.where(new_solution == 1)[0]\n                if len(items_in) == 0:\n                    break\n                remove_idx = random.choice(items_in)\n                new_solution[remove_idx] = 0\n                total_weight -= weight_lst[remove_idx]\n    else:\n        # No candidates, perform a random flip\n        new_solution = base_solution.copy()\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and random.random() < 0.5:\n            # Remove a random item\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n        elif len(items_out) > 0:\n            # Add a random item if feasible\n            add_idx = random.choice(items_out)\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive with high potential for improvement, then applies a hybrid local search operator that combines randomized bit flips with a greedy selection of items that maximize the marginal gain in both objectives, ensuring feasibility by dynamically adjusting the selection based on weight constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not all items are included)\n    selected_solution = None\n    max_potential = -1\n    for sol, _ in archive:\n        potential = np.sum(sol)  # Higher potential if fewer items are included\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomly flip bits and greedily select items\n    for _ in range(5):  # Number of iterations\n        # Randomly flip some bits\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove items until feasible\n            excess_weight = total_weight - capacity\n            while excess_weight > 0:\n                # Select items with highest ratio of weight to sum of values\n                ratios = (weight_lst * new_solution) / (value1_lst + value2_lst + 1e-6)\n                max_ratio_idx = np.argmax(ratios)\n                if new_solution[max_ratio_idx] == 1:\n                    new_solution[max_ratio_idx] = 0\n                    excess_weight -= weight_lst[max_ratio_idx]\n                else:\n                    break\n\n        # Greedily add items with highest marginal gain\n        remaining_weight = capacity - np.sum(weight_lst * new_solution)\n        if remaining_weight > 0:\n            # Calculate marginal gains for each item\n            marginal_gains = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_weight))[0]\n            if len(candidate_items) > 0:\n                best_item = candidate_items[np.argmax(marginal_gains[candidate_items])]\n                new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.32929215088032526,
            8.395169645547867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not all items are included)\n    selected_solution = None\n    max_potential = -1\n    for sol, _ in archive:\n        potential = np.sum(sol)  # Higher potential if fewer items are included\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomly flip bits and greedily select items\n    for _ in range(5):  # Number of iterations\n        # Randomly flip some bits\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove items until feasible\n            excess_weight = total_weight - capacity\n            while excess_weight > 0:\n                # Select items with highest ratio of weight to sum of values\n                ratios = (weight_lst * new_solution) / (value1_lst + value2_lst + 1e-6)\n                max_ratio_idx = np.argmax(ratios)\n                if new_solution[max_ratio_idx] == 1:\n                    new_solution[max_ratio_idx] = 0\n                    excess_weight -= weight_lst[max_ratio_idx]\n                else:\n                    break\n\n        # Greedily add items with highest marginal gain\n        remaining_weight = capacity - np.sum(weight_lst * new_solution)\n        if remaining_weight > 0:\n            # Calculate marginal gains for each item\n            marginal_gains = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_weight))[0]\n            if len(candidate_items) > 0:\n                best_item = candidate_items[np.argmax(marginal_gains[candidate_items])]\n                new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps, insertions, and deletions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Determine possible operations\n    operations = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            operations.append(('remove', i))\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                operations.append(('add', i))\n\n    # Apply hybrid local search\n    if operations:\n        op_type, idx = random.choice(operations)\n        if op_type == 'remove':\n            new_solution[idx] = 0\n            # Try to add another item if possible\n            remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n            possible_adds = [i for i in range(len(new_solution)) if new_solution[i] == 0 and weight_lst[i] <= remaining_weight]\n            if possible_adds:\n                add_idx = random.choice(possible_adds)\n                new_solution[add_idx] = 1\n        else:  # add\n            new_solution[idx] = 1\n            # Try to remove another item if possible to balance objectives\n            current_items = np.where(new_solution == 1)[0]\n            if len(current_items) > 1:\n                remove_idx = random.choice(current_items)\n                new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5964878119706134,
            2.416490852832794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Determine possible operations\n    operations = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            operations.append(('remove', i))\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                operations.append(('add', i))\n\n    # Apply hybrid local search\n    if operations:\n        op_type, idx = random.choice(operations)\n        if op_type == 'remove':\n            new_solution[idx] = 0\n            # Try to add another item if possible\n            remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n            possible_adds = [i for i in range(len(new_solution)) if new_solution[i] == 0 and weight_lst[i] <= remaining_weight]\n            if possible_adds:\n                add_idx = random.choice(possible_adds)\n                new_solution[add_idx] = 1\n        else:  # add\n            new_solution[idx] = 1\n            # Try to remove another item if possible to balance objectives\n            current_items = np.where(new_solution == 1)[0]\n            if len(current_items) > 1:\n                remove_idx = random.choice(current_items)\n                new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The algorithm selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search strategy combining random item swaps and a greedy selection of high-value items to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity * 0.9:  # Consider solutions with room for improvement\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # Fallback to all solutions if none have room\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy selection\n    num_items = len(weight_lst)\n    for _ in range(min(5, num_items)):  # Limit number of swaps\n        # Randomly swap items\n        idx1, idx2 = random.sample(range(num_items), 2)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Greedy selection to maximize one objective while keeping the other stable\n    current_weight = np.sum(weight_lst * new_solution)\n    available_weight = capacity - current_weight\n\n    if available_weight > 0:\n        # Calculate marginal gains for both objectives\n        marginal_gain1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n        marginal_gain2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine gains (e.g., weighted sum) and select top items\n        combined_gain = 0.5 * marginal_gain1 + 0.5 * marginal_gain2\n        sorted_indices = np.argsort(combined_gain)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= available_weight:\n                new_solution[idx] = 1\n                available_weight -= weight_lst[idx]\n                if available_weight <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.33631272373531457,
            4.484847217798233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity * 0.9:  # Consider solutions with room for improvement\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # Fallback to all solutions if none have room\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy selection\n    num_items = len(weight_lst)\n    for _ in range(min(5, num_items)):  # Limit number of swaps\n        # Randomly swap items\n        idx1, idx2 = random.sample(range(num_items), 2)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Greedy selection to maximize one objective while keeping the other stable\n    current_weight = np.sum(weight_lst * new_solution)\n    available_weight = capacity - current_weight\n\n    if available_weight > 0:\n        # Calculate marginal gains for both objectives\n        marginal_gain1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n        marginal_gain2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine gains (e.g., weighted sum) and select top items\n        combined_gain = 0.5 * marginal_gain1 + 0.5 * marginal_gain2\n        sorted_indices = np.argsort(combined_gain)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= available_weight:\n                new_solution[idx] = 1\n                available_weight -= weight_lst[idx]\n                if available_weight <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{A novel hybrid local search algorithm that combines random walk with objective-specific perturbations to intelligently explore the solution space by selectively flipping item selections based on their marginal contributions to both objectives, ensuring feasibility and promoting non-dominated solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Determine items to consider for flipping\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: randomly decide between two strategies\n    if random.random() < 0.5:\n        # Strategy 1: Randomly flip one included item\n        if len(included_items) > 0:\n            flip_idx = random.choice(included_items)\n            new_solution = base_solution.copy()\n            new_solution[flip_idx] = 0\n            # Check feasibility\n            new_weight = current_weight - weight_lst[flip_idx]\n            if new_weight <= capacity:\n                return new_solution\n    else:\n        # Strategy 2: Randomly flip one excluded item if it fits\n        if len(excluded_items) > 0:\n            flip_idx = random.choice(excluded_items)\n            if weight_lst[flip_idx] <= capacity - current_weight:\n                new_solution = base_solution.copy()\n                new_solution[flip_idx] = 1\n                return new_solution\n\n    # If no valid move found, perform a random walk by flipping two items\n    if len(included_items) >= 2:\n        flip_idx1, flip_idx2 = random.sample(list(included_items), 2)\n        new_solution = base_solution.copy()\n        new_solution[flip_idx1] = 0\n        new_solution[flip_idx2] = 0\n        new_weight = current_weight - weight_lst[flip_idx1] - weight_lst[flip_idx2]\n        if new_weight <= capacity:\n            return new_solution\n\n    # If still no valid move, return the original solution\n    return base_solution\n\n",
        "score": [
            -0.9354140664370858,
            1.5858805775642395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Determine items to consider for flipping\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: randomly decide between two strategies\n    if random.random() < 0.5:\n        # Strategy 1: Randomly flip one included item\n        if len(included_items) > 0:\n            flip_idx = random.choice(included_items)\n            new_solution = base_solution.copy()\n            new_solution[flip_idx] = 0\n            # Check feasibility\n            new_weight = current_weight - weight_lst[flip_idx]\n            if new_weight <= capacity:\n                return new_solution\n    else:\n        # Strategy 2: Randomly flip one excluded item if it fits\n        if len(excluded_items) > 0:\n            flip_idx = random.choice(excluded_items)\n            if weight_lst[flip_idx] <= capacity - current_weight:\n                new_solution = base_solution.copy()\n                new_solution[flip_idx] = 1\n                return new_solution\n\n    # If no valid move found, perform a random walk by flipping two items\n    if len(included_items) >= 2:\n        flip_idx1, flip_idx2 = random.sample(list(included_items), 2)\n        new_solution = base_solution.copy()\n        new_solution[flip_idx1] = 0\n        new_solution[flip_idx2] = 0\n        new_weight = current_weight - weight_lst[flip_idx1] - weight_lst[flip_idx2]\n        if new_weight <= capacity:\n            return new_solution\n\n    # If still no valid move, return the original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on its potential for improvement, then applies a combination of item swaps and adaptive perturbations to explore the solution space while ensuring feasibility and maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combine item swaps and adaptive perturbations\n    for _ in range(3):  # Number of perturbation steps\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Calculate potential new weight\n        if new_solution[item1] == new_solution[item2]:\n            continue  # Skip if both are same (no change)\n\n        delta_weight = (new_solution[item2] - new_solution[item1]) * (weight_lst[item2] - weight_lst[item1])\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Accept the swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight = new_weight\n\n    # Adaptive perturbation: flip items with high marginal gain\n    for _ in range(2):\n        # Calculate marginal gains for all items\n        marginal_gains = []\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1:\n                # If item is in, calculate gain if removed\n                gain1 = -value1_lst[i]\n                gain2 = -value2_lst[i]\n                delta_w = -weight_lst[i]\n            else:\n                # If item is out, calculate gain if added\n                if current_weight + weight_lst[i] > capacity:\n                    continue  # Skip if adding would exceed capacity\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                delta_w = weight_lst[i]\n\n            # Normalize gains (simple approach)\n            total_gain = abs(gain1) + abs(gain2)\n            marginal_gains.append((i, total_gain, delta_w))\n\n        if marginal_gains:\n            # Select item with highest marginal gain\n            marginal_gains.sort(key=lambda x: -x[1])\n            best_item, _, delta_w = marginal_gains[0]\n\n            # Apply the flip if feasible\n            if current_weight + delta_w <= capacity:\n                new_solution[best_item] = 1 - new_solution[best_item]\n                current_weight += delta_w\n\n    return new_solution\n\n",
        "score": [
            -0.5763905597086305,
            8.384964674711227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combine item swaps and adaptive perturbations\n    for _ in range(3):  # Number of perturbation steps\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Calculate potential new weight\n        if new_solution[item1] == new_solution[item2]:\n            continue  # Skip if both are same (no change)\n\n        delta_weight = (new_solution[item2] - new_solution[item1]) * (weight_lst[item2] - weight_lst[item1])\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Accept the swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight = new_weight\n\n    # Adaptive perturbation: flip items with high marginal gain\n    for _ in range(2):\n        # Calculate marginal gains for all items\n        marginal_gains = []\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1:\n                # If item is in, calculate gain if removed\n                gain1 = -value1_lst[i]\n                gain2 = -value2_lst[i]\n                delta_w = -weight_lst[i]\n            else:\n                # If item is out, calculate gain if added\n                if current_weight + weight_lst[i] > capacity:\n                    continue  # Skip if adding would exceed capacity\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                delta_w = weight_lst[i]\n\n            # Normalize gains (simple approach)\n            total_gain = abs(gain1) + abs(gain2)\n            marginal_gains.append((i, total_gain, delta_w))\n\n        if marginal_gains:\n            # Select item with highest marginal gain\n            marginal_gains.sort(key=lambda x: -x[1])\n            best_item, _, delta_w = marginal_gains[0]\n\n            # Apply the flip if feasible\n            if current_weight + delta_w <= capacity:\n                new_solution[best_item] = 1 - new_solution[best_item]\n                current_weight += delta_w\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search that combines item swaps with a probabilistic flip of items based on their marginal utility to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective values and low crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            dist2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding_distances.append(dist1 + dist2)\n\n    # Select solutions with high objective values and low crowding distance\n    selected_indices = np.argsort([-obj[0] - obj[1] - cd for obj, cd in zip(objectives, crowding_distances)])\n    selected_index = np.random.choice(selected_indices[:max(1, len(selected_indices)//2)])\n    base_solution = solutions[selected_index].copy()\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: item swaps and probabilistic flips\n    for _ in range(5):  # Number of swaps/flips to attempt\n        # Randomly select two items\n        i, j = np.random.choice(len(weight_lst), size=2, replace=False)\n\n        # Try swap\n        new_swap_solution = new_solution.copy()\n        new_swap_solution[i], new_swap_solution[j] = new_swap_solution[j], new_swap_solution[i]\n        swap_weight = np.sum(weight_lst * new_swap_solution)\n\n        if swap_weight <= capacity:\n            # Calculate marginal utility for swap\n            marginal1 = (value1_lst[i] + value1_lst[j]) - (value1_lst[i] * new_solution[i] + value1_lst[j] * new_solution[j])\n            marginal2 = (value2_lst[i] + value2_lst[j]) - (value2_lst[i] * new_solution[i] + value2_lst[j] * new_solution[j])\n\n            # Accept swap if it improves at least one objective\n            if marginal1 > 0 or marginal2 > 0:\n                new_solution = new_swap_solution\n                total_weight = swap_weight\n                continue\n\n        # Try flip\n        new_flip_solution = new_solution.copy()\n        new_flip_solution[i] = 1 - new_flip_solution[i]\n        flip_weight = np.sum(weight_lst * new_flip_solution)\n\n        if flip_weight <= capacity:\n            # Calculate marginal utility for flip\n            marginal1 = value1_lst[i] * (1 - 2 * new_solution[i])\n            marginal2 = value2_lst[i] * (1 - 2 * new_solution[i])\n\n            # Accept flip with probability based on marginal utility\n            if marginal1 > 0 or marginal2 > 0:\n                new_solution = new_flip_solution\n                total_weight = flip_weight\n\n    return new_solution\n\n",
        "score": [
            -0.5164142731426098,
            4.685553967952728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective values and low crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            dist2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding_distances.append(dist1 + dist2)\n\n    # Select solutions with high objective values and low crowding distance\n    selected_indices = np.argsort([-obj[0] - obj[1] - cd for obj, cd in zip(objectives, crowding_distances)])\n    selected_index = np.random.choice(selected_indices[:max(1, len(selected_indices)//2)])\n    base_solution = solutions[selected_index].copy()\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: item swaps and probabilistic flips\n    for _ in range(5):  # Number of swaps/flips to attempt\n        # Randomly select two items\n        i, j = np.random.choice(len(weight_lst), size=2, replace=False)\n\n        # Try swap\n        new_swap_solution = new_solution.copy()\n        new_swap_solution[i], new_swap_solution[j] = new_swap_solution[j], new_swap_solution[i]\n        swap_weight = np.sum(weight_lst * new_swap_solution)\n\n        if swap_weight <= capacity:\n            # Calculate marginal utility for swap\n            marginal1 = (value1_lst[i] + value1_lst[j]) - (value1_lst[i] * new_solution[i] + value1_lst[j] * new_solution[j])\n            marginal2 = (value2_lst[i] + value2_lst[j]) - (value2_lst[i] * new_solution[i] + value2_lst[j] * new_solution[j])\n\n            # Accept swap if it improves at least one objective\n            if marginal1 > 0 or marginal2 > 0:\n                new_solution = new_swap_solution\n                total_weight = swap_weight\n                continue\n\n        # Try flip\n        new_flip_solution = new_solution.copy()\n        new_flip_solution[i] = 1 - new_flip_solution[i]\n        flip_weight = np.sum(weight_lst * new_flip_solution)\n\n        if flip_weight <= capacity:\n            # Calculate marginal utility for flip\n            marginal1 = value1_lst[i] * (1 - 2 * new_solution[i])\n            marginal2 = value2_lst[i] * (1 - 2 * new_solution[i])\n\n            # Accept flip with probability based on marginal utility\n            if marginal1 > 0 or marginal2 > 0:\n                new_solution = new_flip_solution\n                total_weight = flip_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The algorithm selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps and a novel \"value-weighted\" perturbation to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we choose the one with the highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    total_values = np.array([sum(obj) for obj in archive_objectives])\n    selected_idx = np.argmax(total_values)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and apply value-weighted perturbation\n    n_items = len(base_solution)\n\n    # Step 1: Swap two randomly selected items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Value-weighted perturbation - flip items with high value-to-weight ratio\n    if n_items > 0:\n        # Calculate value-to-weight ratios for both objectives\n        v1_ratio = value1_lst / weight_lst\n        v2_ratio = value2_lst / weight_lst\n\n        # Combine ratios (weighted sum)\n        combined_ratio = 0.5 * v1_ratio + 0.5 * v2_ratio\n\n        # Identify items not in the current solution\n        zero_indices = np.where(new_solution == 0)[0]\n\n        if len(zero_indices) > 0:\n            # Select items with top combined ratio not in the solution\n            top_indices = np.argsort(-combined_ratio[zero_indices])\n            top_indices = zero_indices[top_indices[:min(3, len(top_indices))]]\n\n            for idx in top_indices:\n                # Check if adding this item keeps the solution feasible\n                current_weight = np.sum(new_solution * weight_lst)\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        while current_weight > capacity:\n            ones_indices = np.where(new_solution == 1)[0]\n            if len(ones_indices) == 0:\n                break\n            remove_idx = random.choice(ones_indices)\n            new_solution[remove_idx] = 0\n            current_weight = np.sum(new_solution * weight_lst)\n\n    return new_solution\n\n",
        "score": [
            -0.32313902879242695,
            4.968597382307053
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we choose the one with the highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    total_values = np.array([sum(obj) for obj in archive_objectives])\n    selected_idx = np.argmax(total_values)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and apply value-weighted perturbation\n    n_items = len(base_solution)\n\n    # Step 1: Swap two randomly selected items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Value-weighted perturbation - flip items with high value-to-weight ratio\n    if n_items > 0:\n        # Calculate value-to-weight ratios for both objectives\n        v1_ratio = value1_lst / weight_lst\n        v2_ratio = value2_lst / weight_lst\n\n        # Combine ratios (weighted sum)\n        combined_ratio = 0.5 * v1_ratio + 0.5 * v2_ratio\n\n        # Identify items not in the current solution\n        zero_indices = np.where(new_solution == 0)[0]\n\n        if len(zero_indices) > 0:\n            # Select items with top combined ratio not in the solution\n            top_indices = np.argsort(-combined_ratio[zero_indices])\n            top_indices = zero_indices[top_indices[:min(3, len(top_indices))]]\n\n            for idx in top_indices:\n                # Check if adding this item keeps the solution feasible\n                current_weight = np.sum(new_solution * weight_lst)\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        while current_weight > capacity:\n            ones_indices = np.where(new_solution == 1)[0]\n            if len(ones_indices) == 0:\n                break\n            remove_idx = random.choice(ones_indices)\n            new_solution[remove_idx] = 0\n            current_weight = np.sum(new_solution * weight_lst)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [\n        ((obj[0] / np.max(value1_lst)) + (obj[1] / np.max(value2_lst)), sol)\n        for sol, obj in archive\n    ]\n    selected_sol = max(normalized_objectives, key=lambda x: x[0])[1]\n\n    # Hybrid local search: flip items based on marginal contribution and randomness\n    new_solution = selected_sol.copy()\n    marginal_contribution = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-marginal_contribution)\n\n    # Flip top 20% items with highest marginal contribution, then randomly flip 10% of remaining items\n    flip_indices = sorted_indices[:max(1, int(0.2 * len(sorted_indices)))]\n    for i in flip_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Randomly flip 10% of remaining items to escape local optima\n    remaining_indices = np.setdiff1d(np.arange(len(new_solution)), flip_indices)\n    random_flip = np.random.choice(remaining_indices, size=max(1, int(0.1 * len(remaining_indices))), replace=False)\n    for i in random_flip:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing items if capacity is exceeded\n    while np.dot(new_solution, weight_lst) > capacity:\n        excess_indices = np.where(new_solution == 1)[0]\n        if len(excess_indices) == 0:\n            break\n        remove_index = np.random.choice(excess_indices)\n        new_solution[remove_index] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4948467934859289,
            5.337250381708145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [\n        ((obj[0] / np.max(value1_lst)) + (obj[1] / np.max(value2_lst)), sol)\n        for sol, obj in archive\n    ]\n    selected_sol = max(normalized_objectives, key=lambda x: x[0])[1]\n\n    # Hybrid local search: flip items based on marginal contribution and randomness\n    new_solution = selected_sol.copy()\n    marginal_contribution = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-marginal_contribution)\n\n    # Flip top 20% items with highest marginal contribution, then randomly flip 10% of remaining items\n    flip_indices = sorted_indices[:max(1, int(0.2 * len(sorted_indices)))]\n    for i in flip_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Randomly flip 10% of remaining items to escape local optima\n    remaining_indices = np.setdiff1d(np.arange(len(new_solution)), flip_indices)\n    random_flip = np.random.choice(remaining_indices, size=max(1, int(0.1 * len(remaining_indices))), replace=False)\n    for i in random_flip:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing items if capacity is exceeded\n    while np.dot(new_solution, weight_lst) > capacity:\n        excess_indices = np.where(new_solution == 1)[0]\n        if len(excess_indices) == 0:\n            break\n        remove_index = np.random.choice(excess_indices)\n        new_solution[remove_index] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search strategy combining item swapping and adaptive perturbation to generate a neighbor solution while ensuring feasibility and maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values but not at the frontier)\n    selected_idx = np.argmax([obj[0] + obj[1] for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution.astype(bool)])\n\n    # Generate a neighbor by swapping items or perturbing the solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or perturb based on objective dominance\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two items to swap\n        item1, item2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Calculate new weights if swapped\n        if new_solution[item1] != new_solution[item2]:\n            delta_weight = (weight_lst[item2] - weight_lst[item1]) if new_solution[item1] else (weight_lst[item1] - weight_lst[item2])\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += delta_weight\n\n    # Additional perturbation: flip a random item if feasible\n    if np.random.rand() < 0.3:  # 30% chance to perturb\n        item = np.random.randint(len(new_solution))\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3539008473720745,
            3.616632729768753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values but not at the frontier)\n    selected_idx = np.argmax([obj[0] + obj[1] for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution.astype(bool)])\n\n    # Generate a neighbor by swapping items or perturbing the solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or perturb based on objective dominance\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two items to swap\n        item1, item2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Calculate new weights if swapped\n        if new_solution[item1] != new_solution[item2]:\n            delta_weight = (weight_lst[item2] - weight_lst[item1]) if new_solution[item1] else (weight_lst[item1] - weight_lst[item2])\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += delta_weight\n\n    # Additional perturbation: flip a random item if feasible\n    if np.random.rand() < 0.3:  # 30% chance to perturb\n        item = np.random.randint(len(new_solution))\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(value1_lst @ sol[0] + value2_lst @ sol[0]) / (weight_lst @ sol[0] + 1e-8) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: flip a subset of items based on marginal utility and weight sensitivity\n    new_solution = base_solution.copy()\n    weight_sum = weight_lst @ new_solution\n    potential_flips = []\n\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Evaluate removing the item\n            new_weight = weight_sum - weight_lst[i]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[i]\n                marginal_value2 = value2_lst[i]\n                potential_flips.append((i, marginal_value1, marginal_value2, -1))  # -1 for removal\n        else:\n            # Evaluate adding the item\n            new_weight = weight_sum + weight_lst[i]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[i]\n                marginal_value2 = value2_lst[i]\n                potential_flips.append((i, marginal_value1, marginal_value2, 1))  # 1 for addition\n\n    # Sort flips by a combined objective score (e.g., sum of normalized marginal values)\n    if potential_flips:\n        potential_flips.sort(key=lambda x: (x[1] + x[2]) / (weight_lst[x[0]] + 1e-8), reverse=True)\n        # Apply top 3 flips (or fewer if not enough)\n        for i in range(min(3, len(potential_flips))):\n            item_idx, _, _, flip_type = potential_flips[i]\n            new_solution[item_idx] = flip_type if flip_type == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8432531893142377,
            3.469024509191513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(value1_lst @ sol[0] + value2_lst @ sol[0]) / (weight_lst @ sol[0] + 1e-8) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: flip a subset of items based on marginal utility and weight sensitivity\n    new_solution = base_solution.copy()\n    weight_sum = weight_lst @ new_solution\n    potential_flips = []\n\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Evaluate removing the item\n            new_weight = weight_sum - weight_lst[i]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[i]\n                marginal_value2 = value2_lst[i]\n                potential_flips.append((i, marginal_value1, marginal_value2, -1))  # -1 for removal\n        else:\n            # Evaluate adding the item\n            new_weight = weight_sum + weight_lst[i]\n            if new_weight <= capacity:\n                marginal_value1 = value1_lst[i]\n                marginal_value2 = value2_lst[i]\n                potential_flips.append((i, marginal_value1, marginal_value2, 1))  # 1 for addition\n\n    # Sort flips by a combined objective score (e.g., sum of normalized marginal values)\n    if potential_flips:\n        potential_flips.sort(key=lambda x: (x[1] + x[2]) / (weight_lst[x[0]] + 1e-8), reverse=True)\n        # Apply top 3 flips (or fewer if not enough)\n        for i in range(min(3, len(potential_flips))):\n            item_idx, _, _, flip_type = potential_flips[i]\n            new_solution[item_idx] = flip_type if flip_type == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: (np.sum(x[0]) - np.sum(x[0] * weight_lst) / capacity))\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Randomly select a subset of items to flip (1 to 3 items)\n    flip_indices = np.random.choice(n_items, size=np.random.randint(1, 4), replace=False)\n\n    # Flip each selected item and check feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # If no feasible flip was possible, randomly flip one item (ensuring feasibility)\n    if np.array_equal(new_solution, base_solution):\n        feasible_indices = [i for i in range(n_items) if (base_solution[i] == 1) or (np.sum(base_solution * weight_lst) + weight_lst[i] <= capacity)]\n        if feasible_indices:\n            flip_idx = np.random.choice(feasible_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.30844152641681105,
            4.514415144920349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: (np.sum(x[0]) - np.sum(x[0] * weight_lst) / capacity))\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Randomly select a subset of items to flip (1 to 3 items)\n    flip_indices = np.random.choice(n_items, size=np.random.randint(1, 4), replace=False)\n\n    # Flip each selected item and check feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # If no feasible flip was possible, randomly flip one item (ensuring feasibility)\n    if np.array_equal(new_solution, base_solution):\n        feasible_indices = [i for i in range(n_items) if (base_solution[i] == 1) or (np.sum(base_solution * weight_lst) + weight_lst[i] <= capacity)]\n        if feasible_indices:\n            flip_idx = np.random.choice(feasible_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps and adaptive perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        if total_weight <= capacity:\n            # Calculate potential improvement by considering items not in the solution\n            excluded_items = np.where(sol == 0)[0]\n            if len(excluded_items) > 0:\n                # Calculate potential value gains\n                potential_v1 = np.sum(value1_lst[excluded_items])\n                potential_v2 = np.sum(value2_lst[excluded_items])\n                # Calculate potential weight increase\n                potential_weight = np.sum(weight_lst[excluded_items])\n                # Score based on potential improvement and feasibility\n                score = (potential_v1 + potential_v2) / (1 + potential_weight - capacity)\n                candidates.append((sol, score))\n\n    if not candidates:\n        # If no candidates, randomly select a solution\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest score\n        candidates.sort(key=lambda x: -x[1])\n        base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Item swaps with adaptive selection\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Select items to swap based on value density\n        value_density_in = value1_lst[items_in] / weight_lst[items_in]\n        value_density_out = value2_lst[items_out] / weight_lst[items_out]\n\n        # Find items with high value density to potentially remove\n        threshold_in = np.percentile(value_density_in, 75)\n        candidates_in = items_in[value_density_in >= threshold_in]\n\n        # Find items with high value density to potentially add\n        threshold_out = np.percentile(value_density_out, 75)\n        candidates_out = items_out[value_density_out >= threshold_out]\n\n        if len(candidates_in) > 0 and len(candidates_out) > 0:\n            # Perform swap\n            item_to_remove = random.choice(candidates_in)\n            item_to_add = random.choice(candidates_out)\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if (current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]) <= capacity:\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n\n    # Step 2: Adaptive perturbation\n    if random.random() < 0.2:  # 20% chance of perturbation\n        # Randomly flip a subset of items while maintaining feasibility\n        num_flips = min(3, len(new_solution))\n        flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8052819194612968,
            8.059706836938858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        if total_weight <= capacity:\n            # Calculate potential improvement by considering items not in the solution\n            excluded_items = np.where(sol == 0)[0]\n            if len(excluded_items) > 0:\n                # Calculate potential value gains\n                potential_v1 = np.sum(value1_lst[excluded_items])\n                potential_v2 = np.sum(value2_lst[excluded_items])\n                # Calculate potential weight increase\n                potential_weight = np.sum(weight_lst[excluded_items])\n                # Score based on potential improvement and feasibility\n                score = (potential_v1 + potential_v2) / (1 + potential_weight - capacity)\n                candidates.append((sol, score))\n\n    if not candidates:\n        # If no candidates, randomly select a solution\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest score\n        candidates.sort(key=lambda x: -x[1])\n        base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Item swaps with adaptive selection\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Select items to swap based on value density\n        value_density_in = value1_lst[items_in] / weight_lst[items_in]\n        value_density_out = value2_lst[items_out] / weight_lst[items_out]\n\n        # Find items with high value density to potentially remove\n        threshold_in = np.percentile(value_density_in, 75)\n        candidates_in = items_in[value_density_in >= threshold_in]\n\n        # Find items with high value density to potentially add\n        threshold_out = np.percentile(value_density_out, 75)\n        candidates_out = items_out[value_density_out >= threshold_out]\n\n        if len(candidates_in) > 0 and len(candidates_out) > 0:\n            # Perform swap\n            item_to_remove = random.choice(candidates_in)\n            item_to_add = random.choice(candidates_out)\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if (current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]) <= capacity:\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n\n    # Step 2: Adaptive perturbation\n    if random.random() < 0.2:  # 20% chance of perturbation\n        # Randomly flip a subset of items while maintaining feasibility\n        num_flips = min(3, len(new_solution))\n        flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This algorithm selects a promising solution from the archive based on the highest sum of normalized objective values, then applies a hybrid local search that combines item swapping and random perturbation to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    best_idx = np.argmax(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap items and apply random perturbation\n    for _ in range(5):  # Number of iterations\n        # Randomly select two items to swap\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) < 2:\n            break\n        i, j = np.random.choice(candidates, 2, replace=False)\n\n        # Check if swapping is feasible\n        delta_weight = weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n        # Random perturbation: flip a random item if feasible\n        if np.random.rand() < 0.3:  # 30% chance\n            k = np.random.randint(len(new_solution))\n            if new_solution[k] == 1:\n                if current_weight - weight_lst[k] <= capacity:\n                    new_solution[k] = 0\n                    current_weight -= weight_lst[k]\n            else:\n                if current_weight + weight_lst[k] <= capacity:\n                    new_solution[k] = 1\n                    current_weight += weight_lst[k]\n\n    return new_solution\n\n",
        "score": [
            -0.25299189663138555,
            5.131265342235565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    best_idx = np.argmax(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap items and apply random perturbation\n    for _ in range(5):  # Number of iterations\n        # Randomly select two items to swap\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) < 2:\n            break\n        i, j = np.random.choice(candidates, 2, replace=False)\n\n        # Check if swapping is feasible\n        delta_weight = weight_lst[j] - weight_lst[i]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n        # Random perturbation: flip a random item if feasible\n        if np.random.rand() < 0.3:  # 30% chance\n            k = np.random.randint(len(new_solution))\n            if new_solution[k] == 1:\n                if current_weight - weight_lst[k] <= capacity:\n                    new_solution[k] = 0\n                    current_weight -= weight_lst[k]\n            else:\n                if current_weight + weight_lst[k] <= capacity:\n                    new_solution[k] = 1\n                    current_weight += weight_lst[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive based on the highest combined normalized objective values, then applies a hybrid local search strategy that combines random swaps with a greedy improvement phase to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        total_value1, total_value2 = obj\n        normalized_obj = (total_value1 / np.max(value1_lst), total_value2 / np.max(value2_lst))\n        normalized_objectives.append(np.sum(normalized_obj))\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: random swaps followed by greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Random swaps (exploration)\n    for _ in range(10):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n                current_value1 += (value1_lst[j] - value1_lst[i]) if new_solution[i] else (value1_lst[i] - value1_lst[j])\n                current_value2 += (value2_lst[j] - value2_lst[i]) if new_solution[i] else (value2_lst[i] - value2_lst[j])\n\n    # Greedy improvement (exploitation)\n    for i in range(n_items):\n        if new_solution[i]:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                current_value1 -= value1_lst[i]\n                current_value2 -= value2_lst[i]\n            else:\n                for j in range(n_items):\n                    if not new_solution[j] and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = 0, 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                        current_value1 = current_value1 - value1_lst[i] + value1_lst[j]\n                        current_value2 = current_value2 - value2_lst[i] + value2_lst[j]\n                        break\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                current_value1 += value1_lst[i]\n                current_value2 += value2_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4902226735242197,
            3.3059902489185333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        total_value1, total_value2 = obj\n        normalized_obj = (total_value1 / np.max(value1_lst), total_value2 / np.max(value2_lst))\n        normalized_objectives.append(np.sum(normalized_obj))\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: random swaps followed by greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Random swaps (exploration)\n    for _ in range(10):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n                current_value1 += (value1_lst[j] - value1_lst[i]) if new_solution[i] else (value1_lst[i] - value1_lst[j])\n                current_value2 += (value2_lst[j] - value2_lst[i]) if new_solution[i] else (value2_lst[i] - value2_lst[j])\n\n    # Greedy improvement (exploitation)\n    for i in range(n_items):\n        if new_solution[i]:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                current_value1 -= value1_lst[i]\n                current_value2 -= value2_lst[i]\n            else:\n                for j in range(n_items):\n                    if not new_solution[j] and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = 0, 1\n                        current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                        current_value1 = current_value1 - value1_lst[i] + value1_lst[j]\n                        current_value2 = current_value2 - value2_lst[i] + value2_lst[j]\n                        break\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                current_value1 += value1_lst[i]\n                current_value2 += value2_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{A hybrid local search strategy that intelligently selects solutions with high potential for improvement by combining randomness with objective-based selection, then applies a novel two-phase perturbation: first flipping items with marginal improvement, then performing a weighted random walk to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and diversity\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            scores.append(0)  # Discard infeasible solutions\n        else:\n            # Score based on normalized objectives and diversity\n            score = (obj[0] + obj[1]) / 2\n            scores.append(score)\n\n    if not any(scores):\n        raise ValueError(\"No feasible solutions in archive\")\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Flip items with marginal improvement\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_sol = new_solution.copy()\n            temp_sol[i] = 0\n            temp_weight = np.sum(weight_lst * temp_sol)\n            if temp_weight <= capacity:\n                # Calculate marginal improvement\n                delta1 = value1_lst[i] if base_solution[i] == 1 else -value1_lst[i]\n                delta2 = value2_lst[i] if base_solution[i] == 1 else -value2_lst[i]\n                if delta1 > 0 or delta2 > 0:\n                    new_solution = temp_sol\n                    break\n        else:\n            # Try adding item i\n            temp_sol = new_solution.copy()\n            temp_sol[i] = 1\n            temp_weight = np.sum(weight_lst * temp_sol)\n            if temp_weight <= capacity:\n                # Calculate marginal improvement\n                delta1 = value1_lst[i] if base_solution[i] == 0 else -value1_lst[i]\n                delta2 = value2_lst[i] if base_solution[i] == 0 else -value2_lst[i]\n                if delta1 > 0 or delta2 > 0:\n                    new_solution = temp_sol\n                    break\n\n    # Phase 2: Weighted random walk to escape local optima\n    if random.random() < 0.3:  # 30% chance for random walk\n        # Select items with high potential for improvement\n        potential_items = []\n        for i in range(n_items):\n            if new_solution[i] == 0:\n                # Calculate potential improvement if added\n                potential_items.append((i, value1_lst[i] + value2_lst[i]))\n\n        if potential_items:\n            potential_items.sort(key=lambda x: -x[1])\n            # Select top 20% items for consideration\n            n_consider = max(1, len(potential_items) // 5)\n            candidates = [i for i, _ in potential_items[:n_consider]]\n\n            # Perform random walk among candidates\n            for _ in range(2):  # Perform 2 random steps\n                if not candidates:\n                    break\n                i = random.choice(candidates)\n                temp_sol = new_solution.copy()\n                temp_sol[i] = 1 - temp_sol[i]\n                temp_weight = np.sum(weight_lst * temp_sol)\n                if temp_weight <= capacity:\n                    new_solution = temp_sol\n                    # Update candidates after change\n                    if new_solution[i] == 1:\n                        candidates = [j for j in candidates if j != i]\n                    else:\n                        # Add back removed items if they still have potential\n                        if i in potential_items:\n                            candidates.append(i)\n\n    return new_solution\n\n",
        "score": [
            -0.42443695043937196,
            2.5784418880939484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and diversity\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            scores.append(0)  # Discard infeasible solutions\n        else:\n            # Score based on normalized objectives and diversity\n            score = (obj[0] + obj[1]) / 2\n            scores.append(score)\n\n    if not any(scores):\n        raise ValueError(\"No feasible solutions in archive\")\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Flip items with marginal improvement\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_sol = new_solution.copy()\n            temp_sol[i] = 0\n            temp_weight = np.sum(weight_lst * temp_sol)\n            if temp_weight <= capacity:\n                # Calculate marginal improvement\n                delta1 = value1_lst[i] if base_solution[i] == 1 else -value1_lst[i]\n                delta2 = value2_lst[i] if base_solution[i] == 1 else -value2_lst[i]\n                if delta1 > 0 or delta2 > 0:\n                    new_solution = temp_sol\n                    break\n        else:\n            # Try adding item i\n            temp_sol = new_solution.copy()\n            temp_sol[i] = 1\n            temp_weight = np.sum(weight_lst * temp_sol)\n            if temp_weight <= capacity:\n                # Calculate marginal improvement\n                delta1 = value1_lst[i] if base_solution[i] == 0 else -value1_lst[i]\n                delta2 = value2_lst[i] if base_solution[i] == 0 else -value2_lst[i]\n                if delta1 > 0 or delta2 > 0:\n                    new_solution = temp_sol\n                    break\n\n    # Phase 2: Weighted random walk to escape local optima\n    if random.random() < 0.3:  # 30% chance for random walk\n        # Select items with high potential for improvement\n        potential_items = []\n        for i in range(n_items):\n            if new_solution[i] == 0:\n                # Calculate potential improvement if added\n                potential_items.append((i, value1_lst[i] + value2_lst[i]))\n\n        if potential_items:\n            potential_items.sort(key=lambda x: -x[1])\n            # Select top 20% items for consideration\n            n_consider = max(1, len(potential_items) // 5)\n            candidates = [i for i, _ in potential_items[:n_consider]]\n\n            # Perform random walk among candidates\n            for _ in range(2):  # Perform 2 random steps\n                if not candidates:\n                    break\n                i = random.choice(candidates)\n                temp_sol = new_solution.copy()\n                temp_sol[i] = 1 - temp_sol[i]\n                temp_weight = np.sum(weight_lst * temp_sol)\n                if temp_weight <= capacity:\n                    new_solution = temp_sol\n                    # Update candidates after change\n                    if new_solution[i] == 1:\n                        candidates = [j for j in candidates if j != i]\n                    else:\n                        # Add back removed items if they still have potential\n                        if i in potential_items:\n                            candidates.append(i)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    # Flip a subset of items based on their marginal contributions\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = archive[selected_idx][1][0]\n    current_value2 = archive[selected_idx][1][1]\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst - current_value1\n    marginal_value2 = value2_lst - current_value2\n    marginal_ratio = (marginal_value1 + marginal_value2) / (weight_lst + 1e-8)\n\n    # Identify items to flip: prioritize items with high marginal contributions\n    sorted_indices = np.argsort(marginal_ratio)[::-1]\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7555073457646375,
            2.0913152396678925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    # Flip a subset of items based on their marginal contributions\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = archive[selected_idx][1][0]\n    current_value2 = archive[selected_idx][1][1]\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst - current_value1\n    marginal_value2 = value2_lst - current_value2\n    marginal_ratio = (marginal_value1 + marginal_value2) / (weight_lst + 1e-8)\n\n    # Identify items to flip: prioritize items with high marginal contributions\n    sorted_indices = np.argsort(marginal_ratio)[::-1]\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by prioritizing those with the largest objective values and applies a hybrid local search strategy that combines random item swaps, weight-based perturbations, and objective-driven flips to explore the solution space efficiently while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (prioritize those with largest objectives)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = random.randint(0, min(4, len(archive_sorted) - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random swaps, weight-based flips, and objective-driven flips\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to flip\n    flip_indices = random.sample(range(num_items), min(3, num_items))\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if it's included\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            # Add item if it's excluded and feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional perturbation: flip items based on weight and objective values\n    if random.random() < 0.3:  # 30% chance for perturbation\n        # Flip items with high value-to-weight ratio for objective 1\n        vw_ratio1 = value1_lst / weight_lst\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) > 0:\n            worst_idx = candidate_indices[np.argmin(vw_ratio1[candidate_indices])]\n            new_solution[worst_idx] = 0\n            current_weight -= weight_lst[worst_idx]\n\n        # Add items with high value-to-weight ratio for objective 2 if feasible\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            best_idx = candidate_indices[np.argmax(vw_ratio1[candidate_indices])]\n            if current_weight + weight_lst[best_idx] <= capacity:\n                new_solution[best_idx] = 1\n                current_weight += weight_lst[best_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.35232395197341315,
            1.5406867563724518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (prioritize those with largest objectives)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = random.randint(0, min(4, len(archive_sorted) - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random swaps, weight-based flips, and objective-driven flips\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to flip\n    flip_indices = random.sample(range(num_items), min(3, num_items))\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if it's included\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            # Add item if it's excluded and feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional perturbation: flip items based on weight and objective values\n    if random.random() < 0.3:  # 30% chance for perturbation\n        # Flip items with high value-to-weight ratio for objective 1\n        vw_ratio1 = value1_lst / weight_lst\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) > 0:\n            worst_idx = candidate_indices[np.argmin(vw_ratio1[candidate_indices])]\n            new_solution[worst_idx] = 0\n            current_weight -= weight_lst[worst_idx]\n\n        # Add items with high value-to-weight ratio for objective 2 if feasible\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            best_idx = candidate_indices[np.argmax(vw_ratio1[candidate_indices])]\n            if current_weight + weight_lst[best_idx] <= capacity:\n                new_solution[best_idx] = 1\n                current_weight += weight_lst[best_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with probabilistic objective prioritization to explore the solution space, ensuring feasibility while balancing both objectives through dynamic weight adjustments and intelligent neighbor selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Determine objective to prioritize based on current solution's position in the archive\n    obj_priority = random.choice([1, 2])  # Randomly choose which objective to prioritize\n\n    # Hybrid local search: adaptive item swapping with probabilistic objective prioritization\n    for _ in range(10):  # Number of attempts to find a better neighbor\n        # Randomly select an item to potentially swap\n        item_idx = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 0\n            temp_weight = current_weight - weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 1\n            temp_weight = current_weight + weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n        # Probabilistic objective prioritization: sometimes flip a bit based on the other objective\n        if random.random() < 0.3:  # 30% chance to consider the other objective\n            if obj_priority == 1:\n                # Look for items that improve value2\n                candidates = np.where(new_solution == 0)[0]\n                if len(candidates) > 0:\n                    best_candidate = candidates[np.argmax(value2_lst[candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n                        current_weight += weight_lst[best_candidate]\n            else:\n                # Look for items that improve value1\n                candidates = np.where(new_solution == 0)[0]\n                if len(candidates) > 0:\n                    best_candidate = candidates[np.argmax(value1_lst[candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n                        current_weight += weight_lst[best_candidate]\n\n    return new_solution\n\n",
        "score": [
            -0.37143004475081537,
            1.365091621875763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Determine objective to prioritize based on current solution's position in the archive\n    obj_priority = random.choice([1, 2])  # Randomly choose which objective to prioritize\n\n    # Hybrid local search: adaptive item swapping with probabilistic objective prioritization\n    for _ in range(10):  # Number of attempts to find a better neighbor\n        # Randomly select an item to potentially swap\n        item_idx = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 0\n            temp_weight = current_weight - weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 1\n            temp_weight = current_weight + weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n        # Probabilistic objective prioritization: sometimes flip a bit based on the other objective\n        if random.random() < 0.3:  # 30% chance to consider the other objective\n            if obj_priority == 1:\n                # Look for items that improve value2\n                candidates = np.where(new_solution == 0)[0]\n                if len(candidates) > 0:\n                    best_candidate = candidates[np.argmax(value2_lst[candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n                        current_weight += weight_lst[best_candidate]\n            else:\n                # Look for items that improve value1\n                candidates = np.where(new_solution == 0)[0]\n                if len(candidates) > 0:\n                    best_candidate = candidates[np.argmax(value1_lst[candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n                        current_weight += weight_lst[best_candidate]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with probabilistic objective prioritization to explore the solution space, ensuring feasibility while balancing both objectives through dynamic weight adjustments and intelligent neighbor selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Determine objective to prioritize based on current solution's position in the archive\n    obj_priority = random.choice([1, 2])  # Randomly choose which objective to prioritize\n\n    # Hybrid local search: adaptive item swapping with probabilistic objective prioritization\n    for _ in range(10):  # Number of attempts to find a better neighbor\n        # Randomly select an item to potentially swap\n        item_idx = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 0\n            temp_weight = current_weight - weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 1\n            temp_weight = current_weight + weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n        # Probabilistic objective prioritization: sometimes flip a bit based on the other objective\n        if random.random() < 0.3:  # 30% chance to consider the other objective\n            if obj_priority == 1:\n                # Look for items that improve value2\n                candidates = np.where(new_solution == 0)[0]\n                if len(candidates) > 0:\n                    best_candidate = candidates[np.argmax(value2_lst[candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n                        current_weight += weight_lst[best_candidate]\n            else:\n                # Look for items that improve value1\n                candidates = np.where(new_solution == 0)[0]\n                if len(candidates) > 0:\n                    best_candidate = candidates[np.argmax(value1_lst[candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n                        current_weight += weight_lst[best_candidate]\n\n    return new_solution\n\n",
        "score": [
            -0.37143004475081537,
            1.365091621875763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Determine objective to prioritize based on current solution's position in the archive\n    obj_priority = random.choice([1, 2])  # Randomly choose which objective to prioritize\n\n    # Hybrid local search: adaptive item swapping with probabilistic objective prioritization\n    for _ in range(10):  # Number of attempts to find a better neighbor\n        # Randomly select an item to potentially swap\n        item_idx = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 0\n            temp_weight = current_weight - weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 1\n            temp_weight = current_weight + weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n        # Probabilistic objective prioritization: sometimes flip a bit based on the other objective\n        if random.random() < 0.3:  # 30% chance to consider the other objective\n            if obj_priority == 1:\n                # Look for items that improve value2\n                candidates = np.where(new_solution == 0)[0]\n                if len(candidates) > 0:\n                    best_candidate = candidates[np.argmax(value2_lst[candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n                        current_weight += weight_lst[best_candidate]\n            else:\n                # Look for items that improve value1\n                candidates = np.where(new_solution == 0)[0]\n                if len(candidates) > 0:\n                    best_candidate = candidates[np.argmax(value1_lst[candidates])]\n                    if current_weight + weight_lst[best_candidate] <= capacity:\n                        new_solution[best_candidate] = 1\n                        current_weight += weight_lst[best_candidate]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{A novel local search heuristic that prioritizes solutions with high potential for improvement by selecting items with the highest marginal gains in either objective, then applies a hybrid strategy combining item swaps and flips to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Calculate gain if removed\n            gain_v1 = -value1_lst[i]\n            gain_v2 = -value2_lst[i]\n            marginal_gains.append((gain_v1, gain_v2, i, False))\n        else:\n            # Calculate gain if added (only if feasible)\n            if np.dot(new_solution, weight_lst) + weight_lst[i] <= capacity:\n                gain_v1 = value1_lst[i]\n                gain_v2 = value2_lst[i]\n                marginal_gains.append((gain_v1, gain_v2, i, True))\n\n    # Sort by combined gain (prioritize items with high potential improvement)\n    marginal_gains.sort(key=lambda x: (max(x[0], x[1]), random.random()), reverse=True)\n\n    # Apply hybrid local search: swap or flip items with highest marginal gains\n    for gain_v1, gain_v2, item_idx, is_add in marginal_gains[:3]:  # Consider top 3 candidates\n        if is_add:\n            new_solution[item_idx] = 1\n        else:\n            new_solution[item_idx] = 0\n\n        # Ensure feasibility\n        if np.dot(new_solution, weight_lst) > capacity:\n            # If infeasible, try to remove another item\n            for j in range(len(new_solution)):\n                if new_solution[j] == 1 and j != item_idx:\n                    new_solution[j] = 0\n                    if np.dot(new_solution, weight_lst) <= capacity:\n                        break\n\n    # Additional diversification: randomly flip one item to escape local optima\n    if random.random() < 0.3:  # 30% chance\n        candidate_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if candidate_items:\n            item_to_flip = random.choice(candidate_items)\n            new_solution[item_to_flip] = 0\n            # Try to add another item if possible\n            for i in range(len(new_solution)):\n                if new_solution[i] == 0 and np.dot(new_solution, weight_lst) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3547493001444265,
            5.12091651558876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Calculate gain if removed\n            gain_v1 = -value1_lst[i]\n            gain_v2 = -value2_lst[i]\n            marginal_gains.append((gain_v1, gain_v2, i, False))\n        else:\n            # Calculate gain if added (only if feasible)\n            if np.dot(new_solution, weight_lst) + weight_lst[i] <= capacity:\n                gain_v1 = value1_lst[i]\n                gain_v2 = value2_lst[i]\n                marginal_gains.append((gain_v1, gain_v2, i, True))\n\n    # Sort by combined gain (prioritize items with high potential improvement)\n    marginal_gains.sort(key=lambda x: (max(x[0], x[1]), random.random()), reverse=True)\n\n    # Apply hybrid local search: swap or flip items with highest marginal gains\n    for gain_v1, gain_v2, item_idx, is_add in marginal_gains[:3]:  # Consider top 3 candidates\n        if is_add:\n            new_solution[item_idx] = 1\n        else:\n            new_solution[item_idx] = 0\n\n        # Ensure feasibility\n        if np.dot(new_solution, weight_lst) > capacity:\n            # If infeasible, try to remove another item\n            for j in range(len(new_solution)):\n                if new_solution[j] == 1 and j != item_idx:\n                    new_solution[j] = 0\n                    if np.dot(new_solution, weight_lst) <= capacity:\n                        break\n\n    # Additional diversification: randomly flip one item to escape local optima\n    if random.random() < 0.3:  # 30% chance\n        candidate_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if candidate_items:\n            item_to_flip = random.choice(candidate_items)\n            new_solution[item_to_flip] = 0\n            # Try to add another item if possible\n            for i in range(len(new_solution)):\n                if new_solution[i] == 0 and np.dot(new_solution, weight_lst) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This algorithm intelligently selects a non-dominated solution from the archive based on a combination of objective diversity and local improvement potential, then applies a hybrid local search combining random swaps and objective-specific perturbations to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and potential\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_v1 = np.sum(value1_lst * base_solution)\n    current_v2 = np.sum(value2_lst * base_solution)\n\n    # Create a neighbor solution by hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly swap a subset of items to explore neighborhood\n    num_items = len(new_solution)\n    swap_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Check feasibility and adjust if needed\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove heaviest items until feasible\n        while new_weight > capacity:\n            excess = new_weight - capacity\n            # Identify items that can be removed (either 1 or 0 based on current state)\n            removable_items = np.where(new_solution == 1)[0]\n            if len(removable_items) == 0:\n                break\n            # Remove item with highest weight or highest value contribution\n            weights = weight_lst[removable_items]\n            v1_contrib = value1_lst[removable_items]\n            v2_contrib = value2_lst[removable_items]\n            # Prioritize items that contribute more to both objectives\n            priority = (v1_contrib + v2_contrib) / (weights + 1e-6)\n            remove_idx = removable_items[np.argmax(priority)]\n            new_solution[remove_idx] = 0\n            new_weight -= weight_lst[remove_idx]\n\n    # Step 3: Add items if possible to improve objectives\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Identify items not in solution\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Sort by objective-specific value density\n            v1_density = value1_lst[candidate_items] / (weight_lst[candidate_items] + 1e-6)\n            v2_density = value2_lst[candidate_items] / (weight_lst[candidate_items] + 1e-6)\n            # Combine densities for both objectives\n            combined_density = v1_density + v2_density\n            sorted_indices = np.argsort(combined_density)[::-1]\n\n            for idx in sorted_indices:\n                if weight_lst[candidate_items[idx]] <= remaining_weight:\n                    new_solution[candidate_items[idx]] = 1\n                    remaining_weight -= weight_lst[candidate_items[idx]]\n                    if remaining_weight <= 0:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.3211253419274166,
            3.929458439350128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and potential\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_v1 = np.sum(value1_lst * base_solution)\n    current_v2 = np.sum(value2_lst * base_solution)\n\n    # Create a neighbor solution by hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly swap a subset of items to explore neighborhood\n    num_items = len(new_solution)\n    swap_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Check feasibility and adjust if needed\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove heaviest items until feasible\n        while new_weight > capacity:\n            excess = new_weight - capacity\n            # Identify items that can be removed (either 1 or 0 based on current state)\n            removable_items = np.where(new_solution == 1)[0]\n            if len(removable_items) == 0:\n                break\n            # Remove item with highest weight or highest value contribution\n            weights = weight_lst[removable_items]\n            v1_contrib = value1_lst[removable_items]\n            v2_contrib = value2_lst[removable_items]\n            # Prioritize items that contribute more to both objectives\n            priority = (v1_contrib + v2_contrib) / (weights + 1e-6)\n            remove_idx = removable_items[np.argmax(priority)]\n            new_solution[remove_idx] = 0\n            new_weight -= weight_lst[remove_idx]\n\n    # Step 3: Add items if possible to improve objectives\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Identify items not in solution\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Sort by objective-specific value density\n            v1_density = value1_lst[candidate_items] / (weight_lst[candidate_items] + 1e-6)\n            v2_density = value2_lst[candidate_items] / (weight_lst[candidate_items] + 1e-6)\n            # Combine densities for both objectives\n            combined_density = v1_density + v2_density\n            sorted_indices = np.argsort(combined_density)[::-1]\n\n            for idx in sorted_indices:\n                if weight_lst[candidate_items[idx]] <= remaining_weight:\n                    new_solution[candidate_items[idx]] = 1\n                    remaining_weight -= weight_lst[candidate_items[idx]]\n                    if remaining_weight <= 0:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high diversity and marginal improvement potential, then applies a hybrid local search combining item swapping and probabilistic flipping to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Hybrid local search - swap two items or flip one item probabilistically\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    if len(items) >= 2 and np.random.rand() < 0.7:  # Swap two items\n        i, j = np.random.choice(items, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif len(non_items) > 0:  # Flip one item (add or remove)\n        idx = np.random.choice(non_items) if np.random.rand() < 0.5 else np.random.choice(items)\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst[new_solution == 1])\n    if new_weight > capacity:\n        # Remove items randomly until feasible\n        while new_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            idx = np.random.choice(items_in)\n            new_solution[idx] = 0\n            new_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.5098032096367592,
            2.565573990345001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Hybrid local search - swap two items or flip one item probabilistically\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    if len(items) >= 2 and np.random.rand() < 0.7:  # Swap two items\n        i, j = np.random.choice(items, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif len(non_items) > 0:  # Flip one item (add or remove)\n        idx = np.random.choice(non_items) if np.random.rand() < 0.5 else np.random.choice(items)\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst[new_solution == 1])\n    if new_weight > capacity:\n        # Remove items randomly until feasible\n        while new_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            idx = np.random.choice(items_in)\n            new_solution[idx] = 0\n            new_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating the density of each objective (value1/weight and value2/weight), then applies a hybrid local search combining greedy addition of high-value items and random perturbation to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate density for each objective\n    density1 = value1_lst / weight_lst\n    density2 = value2_lst / weight_lst\n\n    # Combine densities for selection criteria\n    combined_density = density1 + density2\n\n    # Sort items by combined density (descending)\n    sorted_indices = np.argsort(-combined_density)\n\n    new_solution = base_solution.copy()\n\n    # Greedy addition of high-density items\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Random perturbation: flip a small number of items to escape local optima\n    num_flips = min(3, len(new_solution) // 10)\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if (current_weight + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove items randomly until feasible\n        excess_indices = np.where(new_solution == 1)[0]\n        if len(excess_indices) == 0:\n            break\n        remove_idx = random.choice(excess_indices)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.491684382141065,
            6.235619008541107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate density for each objective\n    density1 = value1_lst / weight_lst\n    density2 = value2_lst / weight_lst\n\n    # Combine densities for selection criteria\n    combined_density = density1 + density2\n\n    # Sort items by combined density (descending)\n    sorted_indices = np.argsort(-combined_density)\n\n    new_solution = base_solution.copy()\n\n    # Greedy addition of high-density items\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Random perturbation: flip a small number of items to escape local optima\n    num_flips = min(3, len(new_solution) // 10)\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if (current_weight + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove items randomly until feasible\n        excess_indices = np.where(new_solution == 1)[0]\n        if len(excess_indices) == 0:\n            break\n        remove_idx = random.choice(excess_indices)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid local search strategy that combines adaptive item swapping, probabilistic neighborhood exploration, and objective-aware perturbation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with higher potential for improvement\n    def score_solution(solution, weight_lst, value1_lst, value2_lst, capacity):\n        total_weight = np.dot(solution, weight_lst)\n        total_value1 = np.dot(solution, value1_lst)\n        total_value2 = np.dot(solution, value2_lst)\n        # Score based on how close to capacity and how much potential remains\n        remaining_weight = capacity - total_weight\n        potential_value1 = np.dot(1 - solution, value1_lst)\n        potential_value2 = np.dot(1 - solution, value2_lst)\n        return (total_value1 + total_value2) * (1 + 0.1 * (remaining_weight / capacity)) * (1 + 0.1 * (potential_value1 + potential_value2))\n\n    scored_solutions = [(score_solution(sol[0], weight_lst, value1_lst, value2_lst, capacity), sol) for sol in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    selected = scored_solutions[0][1][0].copy()\n\n    # Hybrid local search: adaptive item swapping + probabilistic perturbation\n    new_solution = selected.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Adaptive swapping of items based on their contribution to objectives\n    swap_candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Calculate marginal contribution\n            marginal_value1 = value1_lst[i] / weight_lst[i]\n            marginal_value2 = value2_lst[i] / weight_lst[i]\n            swap_candidates.append((marginal_value1 + marginal_value2, i))\n\n    if swap_candidates:\n        swap_candidates.sort(reverse=True)\n        for _, i in swap_candidates[:min(3, len(swap_candidates))]:\n            if random.random() < 0.7:  # 70% chance to consider swapping\n                new_solution[i] = 0\n                # Try to add a new item that complements the removed one\n                possible_adds = []\n                current_weight = np.dot(new_solution, weight_lst)\n                for j in range(n_items):\n                    if new_solution[j] == 0 and current_weight + weight_lst[j] <= capacity:\n                        # Prioritize items with high marginal contribution\n                        marginal_value = (value1_lst[j] + value2_lst[j]) / weight_lst[j]\n                        possible_adds.append((marginal_value, j))\n\n                if possible_adds:\n                    possible_adds.sort(reverse=True)\n                    for _, j in possible_adds[:min(2, len(possible_adds))]:\n                        if random.random() < 0.5:  # 50% chance to add\n                            new_solution[j] = 1\n                            break\n\n    # Step 2: Probabilistic perturbation to escape local optima\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                if np.dot(new_solution, weight_lst) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility\n    total_weight = np.dot(new_solution, weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3491817605736145,
            4.3719126880168915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with higher potential for improvement\n    def score_solution(solution, weight_lst, value1_lst, value2_lst, capacity):\n        total_weight = np.dot(solution, weight_lst)\n        total_value1 = np.dot(solution, value1_lst)\n        total_value2 = np.dot(solution, value2_lst)\n        # Score based on how close to capacity and how much potential remains\n        remaining_weight = capacity - total_weight\n        potential_value1 = np.dot(1 - solution, value1_lst)\n        potential_value2 = np.dot(1 - solution, value2_lst)\n        return (total_value1 + total_value2) * (1 + 0.1 * (remaining_weight / capacity)) * (1 + 0.1 * (potential_value1 + potential_value2))\n\n    scored_solutions = [(score_solution(sol[0], weight_lst, value1_lst, value2_lst, capacity), sol) for sol in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    selected = scored_solutions[0][1][0].copy()\n\n    # Hybrid local search: adaptive item swapping + probabilistic perturbation\n    new_solution = selected.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Adaptive swapping of items based on their contribution to objectives\n    swap_candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Calculate marginal contribution\n            marginal_value1 = value1_lst[i] / weight_lst[i]\n            marginal_value2 = value2_lst[i] / weight_lst[i]\n            swap_candidates.append((marginal_value1 + marginal_value2, i))\n\n    if swap_candidates:\n        swap_candidates.sort(reverse=True)\n        for _, i in swap_candidates[:min(3, len(swap_candidates))]:\n            if random.random() < 0.7:  # 70% chance to consider swapping\n                new_solution[i] = 0\n                # Try to add a new item that complements the removed one\n                possible_adds = []\n                current_weight = np.dot(new_solution, weight_lst)\n                for j in range(n_items):\n                    if new_solution[j] == 0 and current_weight + weight_lst[j] <= capacity:\n                        # Prioritize items with high marginal contribution\n                        marginal_value = (value1_lst[j] + value2_lst[j]) / weight_lst[j]\n                        possible_adds.append((marginal_value, j))\n\n                if possible_adds:\n                    possible_adds.sort(reverse=True)\n                    for _, j in possible_adds[:min(2, len(possible_adds))]:\n                        if random.random() < 0.5:  # 50% chance to add\n                            new_solution[j] = 1\n                            break\n\n    # Step 2: Probabilistic perturbation to escape local optima\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                if np.dot(new_solution, weight_lst) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility\n    total_weight = np.dot(new_solution, weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{The heuristic selects a promising solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search combining guided flipping of items based on their marginal contribution to both objectives and a probabilistic swap of high-value items to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    objectives = np.array([sol_obj[1] for sol_obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    fitness_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(fitness_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: guided flip + probabilistic swap\n    # Step 1: Guided flip based on marginal contribution\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Calculate marginal contribution\n                marginal1 = np.sum(value1_lst[new_solution == 1]) - np.sum(value1_lst[temp_solution == 1])\n                marginal2 = np.sum(value2_lst[new_solution == 1]) - np.sum(value2_lst[temp_solution == 1])\n                if marginal1 > 0 or marginal2 > 0:\n                    new_solution = temp_solution\n                    break\n\n    # Step 2: Probabilistic swap of high-value items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Select items with highest value in either objective\n        candidate_values = np.maximum(value1_lst[candidate_items], value2_lst[candidate_items])\n        top_items = candidate_items[np.argsort(candidate_values)[-min(5, len(candidate_items)):]]\n\n        for i in top_items:\n            if random.random() < 0.3:  # 30% chance to consider adding\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    # Ensure solution is feasible\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(excess_items) > 0:\n            item_to_remove = random.choice(excess_items)\n            new_solution[item_to_remove] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            excess_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.3911519506967239,
            5.676200836896896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    objectives = np.array([sol_obj[1] for sol_obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    fitness_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(fitness_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: guided flip + probabilistic swap\n    # Step 1: Guided flip based on marginal contribution\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Calculate marginal contribution\n                marginal1 = np.sum(value1_lst[new_solution == 1]) - np.sum(value1_lst[temp_solution == 1])\n                marginal2 = np.sum(value2_lst[new_solution == 1]) - np.sum(value2_lst[temp_solution == 1])\n                if marginal1 > 0 or marginal2 > 0:\n                    new_solution = temp_solution\n                    break\n\n    # Step 2: Probabilistic swap of high-value items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Select items with highest value in either objective\n        candidate_values = np.maximum(value1_lst[candidate_items], value2_lst[candidate_items])\n        top_items = candidate_items[np.argsort(candidate_values)[-min(5, len(candidate_items)):]]\n\n        for i in top_items:\n            if random.random() < 0.3:  # 30% chance to consider adding\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    # Ensure solution is feasible\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(excess_items) > 0:\n            item_to_remove = random.choice(excess_items)\n            new_solution[item_to_remove] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            excess_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This heuristic selects a solution from the archive with the highest combined objective values, then applies a novel hybrid local search that combines item swapping and probabilistic flipping to explore high-potential regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective values\n    selected_idx = np.argmax([obj[0] + obj[1] for (sol, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of items to flip (with probability based on value ratios)\n    flip_candidates = np.concatenate([items, non_items])\n    if len(flip_candidates) > 0:\n        # Calculate value ratios to guide selection\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        probs = value_ratios[flip_candidates]\n        probs = probs / np.sum(probs) if np.sum(probs) > 0 else np.ones_like(probs) / len(probs)\n\n        # Select 1-3 items to flip (with higher chance for more promising items)\n        num_flips = np.random.choice([1, 2, 3], p=[0.6, 0.3, 0.1])\n        selected_flips = np.random.choice(flip_candidates, size=min(num_flips, len(flip_candidates)), replace=False, p=probs)\n\n        # Flip selected items and ensure feasibility\n        for idx in selected_flips:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional swap-based local search (like Lin-Kernighan but simplified)\n    if len(items) > 1:\n        # Select two items to swap (one in, one out)\n        item_in = np.random.choice(non_items)\n        item_out = np.random.choice(items)\n        if (current_weight - weight_lst[item_out] + weight_lst[item_in]) <= capacity:\n            new_solution[item_out] = 0\n            new_solution[item_in] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.36384411839036906,
            2.7265687584877014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective values\n    selected_idx = np.argmax([obj[0] + obj[1] for (sol, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of items to flip (with probability based on value ratios)\n    flip_candidates = np.concatenate([items, non_items])\n    if len(flip_candidates) > 0:\n        # Calculate value ratios to guide selection\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        probs = value_ratios[flip_candidates]\n        probs = probs / np.sum(probs) if np.sum(probs) > 0 else np.ones_like(probs) / len(probs)\n\n        # Select 1-3 items to flip (with higher chance for more promising items)\n        num_flips = np.random.choice([1, 2, 3], p=[0.6, 0.3, 0.1])\n        selected_flips = np.random.choice(flip_candidates, size=min(num_flips, len(flip_candidates)), replace=False, p=probs)\n\n        # Flip selected items and ensure feasibility\n        for idx in selected_flips:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional swap-based local search (like Lin-Kernighan but simplified)\n    if len(items) > 1:\n        # Select two items to swap (one in, one out)\n        item_in = np.random.choice(non_items)\n        item_out = np.random.choice(items)\n        if (current_weight - weight_lst[item_out] + weight_lst[item_in]) <= capacity:\n            new_solution[item_out] = 0\n            new_solution[item_in] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel local search operator that combines adaptive bit-flipping with guided item replacement to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution based on crowding distance and objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each solution\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n    # Combine crowding distance with objective diversity\n    diversity_scores = crowding_distances + np.std(objectives, axis=0).mean()\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor using adaptive bit-flipping with guided item replacement\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    item_indices = np.arange(len(weight_lst))\n\n    # Identify items that could be flipped to improve both objectives\n    for _ in range(min(5, len(weight_lst))):  # Limit the number of attempts\n        # Select a random item to flip\n        item = random.choice(item_indices)\n        if new_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                # Check if adding this item improves both objectives\n                v1_gain = value1_lst[item]\n                v2_gain = value2_lst[item]\n                if (v1_gain > 0 and v2_gain > 0) or random.random() < 0.3:  # Higher chance if both objectives improve\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Step 3: Guided item replacement (if needed)\n    if random.random() < 0.5:  # 50% chance to perform guided replacement\n        # Find items that are in the solution but have negative marginal contribution\n        in_solution = np.where(new_solution == 1)[0]\n        out_solution = np.where(new_solution == 0)[0]\n\n        # Calculate marginal contributions\n        marginal_v1 = value1_lst - np.sum(value1_lst * new_solution) / len(new_solution)\n        marginal_v2 = value2_lst - np.sum(value2_lst * new_solution) / len(new_solution)\n\n        # Identify items to potentially remove (negative marginal contribution)\n        remove_candidates = in_solution[(marginal_v1[in_solution] < 0) | (marginal_v2[in_solution] < 0)]\n        if len(remove_candidates) > 0:\n            item_to_remove = random.choice(remove_candidates)\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n            # Find items to potentially add that would improve both objectives\n            add_candidates = out_solution[(marginal_v1[out_solution] > 0) & (marginal_v2[out_solution] > 0)]\n            if len(add_candidates) > 0:\n                item_to_add = random.choice(add_candidates)\n                if current_weight + weight_lst[item_to_add] <= capacity:\n                    new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5860854500555761,
            2.3594584465026855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution based on crowding distance and objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each solution\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n    # Combine crowding distance with objective diversity\n    diversity_scores = crowding_distances + np.std(objectives, axis=0).mean()\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor using adaptive bit-flipping with guided item replacement\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    item_indices = np.arange(len(weight_lst))\n\n    # Identify items that could be flipped to improve both objectives\n    for _ in range(min(5, len(weight_lst))):  # Limit the number of attempts\n        # Select a random item to flip\n        item = random.choice(item_indices)\n        if new_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                # Check if adding this item improves both objectives\n                v1_gain = value1_lst[item]\n                v2_gain = value2_lst[item]\n                if (v1_gain > 0 and v2_gain > 0) or random.random() < 0.3:  # Higher chance if both objectives improve\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Step 3: Guided item replacement (if needed)\n    if random.random() < 0.5:  # 50% chance to perform guided replacement\n        # Find items that are in the solution but have negative marginal contribution\n        in_solution = np.where(new_solution == 1)[0]\n        out_solution = np.where(new_solution == 0)[0]\n\n        # Calculate marginal contributions\n        marginal_v1 = value1_lst - np.sum(value1_lst * new_solution) / len(new_solution)\n        marginal_v2 = value2_lst - np.sum(value2_lst * new_solution) / len(new_solution)\n\n        # Identify items to potentially remove (negative marginal contribution)\n        remove_candidates = in_solution[(marginal_v1[in_solution] < 0) | (marginal_v2[in_solution] < 0)]\n        if len(remove_candidates) > 0:\n            item_to_remove = random.choice(remove_candidates)\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n            # Find items to potentially add that would improve both objectives\n            add_candidates = out_solution[(marginal_v1[out_solution] > 0) & (marginal_v2[out_solution] > 0)]\n            if len(add_candidates) > 0:\n                item_to_add = random.choice(add_candidates)\n                if current_weight + weight_lst[item_to_add] <= capacity:\n                    new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Generate neighbor by flipping items with high marginal utility (weighted by both objectives)\n    marginal_utility = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n    sorted_indices = np.argsort(marginal_utility)[::-1]  # Descending order\n\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.940689203271485,
            1.9564429223537445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Generate neighbor by flipping items with high marginal utility (weighted by both objectives)\n    marginal_utility = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n    sorted_indices = np.argsort(marginal_utility)[::-1]  # Descending order\n\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid local search strategy that combines random selection with a novel objective-aware perturbation, ensuring feasibility by dynamically adjusting item swaps while prioritizing high-potential regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (1 + i) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Compute current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that could be swapped (0->1 or 1->0)\n    zero_items = np.where(base_solution == 0)[0]\n    one_items = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: random perturbation with objective-aware selection\n    new_solution = base_solution.copy()\n    max_attempts = min(10, len(zero_items) + len(one_items))\n\n    for _ in range(max_attempts):\n        # Randomly decide to add or remove an item\n        if random.random() < 0.5 and len(zero_items) > 0:\n            # Try to add an item (0->1)\n            candidate_idx = random.choice(zero_items)\n            if current_weight + weight_lst[candidate_idx] <= capacity:\n                new_solution[candidate_idx] = 1\n                current_weight += weight_lst[candidate_idx]\n        else:\n            # Try to remove an item (1->0)\n            if len(one_items) > 0:\n                candidate_idx = random.choice(one_items)\n                new_solution[candidate_idx] = 0\n                current_weight -= weight_lst[candidate_idx]\n\n        # Recompute zero and one items for next iteration\n        zero_items = np.where(new_solution == 0)[0]\n        one_items = np.where(new_solution == 1)[0]\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If infeasible, try to remove items until feasible\n        one_items = np.where(new_solution == 1)[0]\n        while np.sum(weight_lst * new_solution) > capacity and len(one_items) > 0:\n            candidate_idx = random.choice(one_items)\n            new_solution[candidate_idx] = 0\n            one_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.3970328314471021,
            1.7103572189807892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (1 + i) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Compute current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that could be swapped (0->1 or 1->0)\n    zero_items = np.where(base_solution == 0)[0]\n    one_items = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: random perturbation with objective-aware selection\n    new_solution = base_solution.copy()\n    max_attempts = min(10, len(zero_items) + len(one_items))\n\n    for _ in range(max_attempts):\n        # Randomly decide to add or remove an item\n        if random.random() < 0.5 and len(zero_items) > 0:\n            # Try to add an item (0->1)\n            candidate_idx = random.choice(zero_items)\n            if current_weight + weight_lst[candidate_idx] <= capacity:\n                new_solution[candidate_idx] = 1\n                current_weight += weight_lst[candidate_idx]\n        else:\n            # Try to remove an item (1->0)\n            if len(one_items) > 0:\n                candidate_idx = random.choice(one_items)\n                new_solution[candidate_idx] = 0\n                current_weight -= weight_lst[candidate_idx]\n\n        # Recompute zero and one items for next iteration\n        zero_items = np.where(new_solution == 0)[0]\n        one_items = np.where(new_solution == 1)[0]\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If infeasible, try to remove items until feasible\n        one_items = np.where(new_solution == 1)[0]\n        while np.sum(weight_lst * new_solution) > capacity and len(one_items) > 0:\n            candidate_idx = random.choice(one_items)\n            new_solution[candidate_idx] = 0\n            one_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search operator that combines random swaps of items with a greedy selection of high-value items to ensure feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor via hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items (with probability 0.2)\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.2:\n            if new_solution[i] == 1:\n                if current_weight > weight_lst[i]:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Greedily add high-value items (for both objectives)\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate value-to-weight ratios for both objectives\n        value_ratio1 = value1_lst / weight_lst\n        value_ratio2 = value2_lst / weight_lst\n        combined_ratio = value_ratio1 + value_ratio2\n\n        # Sort items by combined ratio (descending)\n        sorted_indices = np.argsort(-combined_ratio)\n\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.34578518598680186,
            2.4681436121463776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor via hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items (with probability 0.2)\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.2:\n            if new_solution[i] == 1:\n                if current_weight > weight_lst[i]:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Greedily add high-value items (for both objectives)\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate value-to-weight ratios for both objectives\n        value_ratio1 = value1_lst / weight_lst\n        value_ratio2 = value2_lst / weight_lst\n        combined_ratio = value_ratio1 + value_ratio2\n\n        # Sort items by combined ratio (descending)\n        sorted_indices = np.argsort(-combined_ratio)\n\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing those with low dominance counts, then applies a hybrid local search combining item swaps and neighborhood perturbations to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (low dominance count)\n    dominance_counts = []\n    for sol, _ in archive:\n        count = 0\n        for other_sol, other_obj in archive:\n            if other_obj[0] > sol[0] and other_obj[1] > sol[1]:\n                count += 1\n        dominance_counts.append(count)\n\n    min_dominance = min(dominance_counts)\n    candidates = [i for i, cnt in enumerate(dominance_counts) if cnt == min_dominance]\n    selected_idx = random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Item swaps (focus on improving both objectives)\n    for _ in range(min(5, n_items // 2)):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Try swapping\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n\n    # Phase 2: Neighborhood perturbation (focus on objective balance)\n    for _ in range(min(3, n_items // 3)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 1:\n            # Try removing\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.32505706728017497,
            5.166260600090027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (low dominance count)\n    dominance_counts = []\n    for sol, _ in archive:\n        count = 0\n        for other_sol, other_obj in archive:\n            if other_obj[0] > sol[0] and other_obj[1] > sol[1]:\n                count += 1\n        dominance_counts.append(count)\n\n    min_dominance = min(dominance_counts)\n    candidates = [i for i, cnt in enumerate(dominance_counts) if cnt == min_dominance]\n    selected_idx = random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Item swaps (focus on improving both objectives)\n    for _ in range(min(5, n_items // 2)):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Try swapping\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n\n    # Phase 2: Neighborhood perturbation (focus on objective balance)\n    for _ in range(min(3, n_items // 3)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 1:\n            # Try removing\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive with the highest potential for local improvement by combining crowding distance and objective diversity, then applies a hybrid local search combining item swapping and adaptive perturbation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select the most promising solution based on crowding distance and objective diversity\n    def calculate_crowding_distance(solutions, objectives):\n        n = len(solutions)\n        if n == 0:\n            return [0.0] * len(solutions)\n\n        distances = [0.0] * n\n        obj1 = [obj[0] for obj in objectives]\n        obj2 = [obj[1] for obj in objectives]\n\n        for i in range(2):\n            sorted_indices = np.argsort(obj1 if i == 0 else obj2)\n            distances[sorted_indices[0]] = float('inf')\n            distances[sorted_indices[-1]] = float('inf')\n            min_val = obj1[sorted_indices[0]] if i == 0 else obj2[sorted_indices[0]]\n            max_val = obj1[sorted_indices[-1]] if i == 0 else obj2[sorted_indices[-1]]\n\n            if max_val == min_val:\n                continue\n\n            for j in range(1, n-1):\n                idx = sorted_indices[j]\n                prev_idx = sorted_indices[j-1]\n                next_idx = sorted_indices[j+1]\n                distances[idx] += (obj1[next_idx] - obj1[prev_idx]) / (max_val - min_val) if i == 0 else (obj2[next_idx] - obj2[prev_idx]) / (max_val - min_val)\n\n        return distances\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    crowding_distances = calculate_crowding_distance(solutions, objectives)\n\n    # Combine crowding distance with objective diversity to select the most promising solution\n    combined_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        diversity = np.sum(np.abs(sol - np.mean(solutions, axis=0)))\n        combined_scores.append(crowding_distances[i] * diversity)\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search (item swapping + adaptive perturbation)\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be swapped or perturbed\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Adaptive perturbation: randomly select a number of items to perturb\n    num_perturb = min(3, len(candidates) // 2) if len(candidates) > 0 else 0\n    if num_perturb > 0:\n        perturb_indices = np.random.choice(candidates, num_perturb, replace=False)\n        for idx in perturb_indices:\n            if np.random.rand() < 0.5:  # 50% chance to remove\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            else:  # 50% chance to swap with a non-candidate\n                if len(non_candidates) > 0:\n                    swap_idx = np.random.choice(non_candidates)\n                    if current_weight - weight_lst[idx] + weight_lst[swap_idx] <= capacity:\n                        new_solution[idx] = 0\n                        new_solution[swap_idx] = 1\n                        current_weight = current_weight - weight_lst[idx] + weight_lst[swap_idx]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8618043016921588,
            8.812503784894943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select the most promising solution based on crowding distance and objective diversity\n    def calculate_crowding_distance(solutions, objectives):\n        n = len(solutions)\n        if n == 0:\n            return [0.0] * len(solutions)\n\n        distances = [0.0] * n\n        obj1 = [obj[0] for obj in objectives]\n        obj2 = [obj[1] for obj in objectives]\n\n        for i in range(2):\n            sorted_indices = np.argsort(obj1 if i == 0 else obj2)\n            distances[sorted_indices[0]] = float('inf')\n            distances[sorted_indices[-1]] = float('inf')\n            min_val = obj1[sorted_indices[0]] if i == 0 else obj2[sorted_indices[0]]\n            max_val = obj1[sorted_indices[-1]] if i == 0 else obj2[sorted_indices[-1]]\n\n            if max_val == min_val:\n                continue\n\n            for j in range(1, n-1):\n                idx = sorted_indices[j]\n                prev_idx = sorted_indices[j-1]\n                next_idx = sorted_indices[j+1]\n                distances[idx] += (obj1[next_idx] - obj1[prev_idx]) / (max_val - min_val) if i == 0 else (obj2[next_idx] - obj2[prev_idx]) / (max_val - min_val)\n\n        return distances\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    crowding_distances = calculate_crowding_distance(solutions, objectives)\n\n    # Combine crowding distance with objective diversity to select the most promising solution\n    combined_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        diversity = np.sum(np.abs(sol - np.mean(solutions, axis=0)))\n        combined_scores.append(crowding_distances[i] * diversity)\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search (item swapping + adaptive perturbation)\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be swapped or perturbed\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Adaptive perturbation: randomly select a number of items to perturb\n    num_perturb = min(3, len(candidates) // 2) if len(candidates) > 0 else 0\n    if num_perturb > 0:\n        perturb_indices = np.random.choice(candidates, num_perturb, replace=False)\n        for idx in perturb_indices:\n            if np.random.rand() < 0.5:  # 50% chance to remove\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            else:  # 50% chance to swap with a non-candidate\n                if len(non_candidates) > 0:\n                    swap_idx = np.random.choice(non_candidates)\n                    if current_weight - weight_lst[idx] + weight_lst[swap_idx] <= capacity:\n                        new_solution[idx] = 0\n                        new_solution[swap_idx] = 1\n                        current_weight = current_weight - weight_lst[idx] + weight_lst[swap_idx]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search strategy combining item swaps, insertions, and deletions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Randomly choose one of three operations: swap, insert, or delete\n    operation = random.choice(['swap', 'insert', 'delete'])\n\n    if operation == 'swap':\n        # Swap two items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) > 0 and len(out_items) > 0:\n            i = random.choice(in_items)\n            j = random.choice(out_items)\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                new_solution[j] = 1\n\n    elif operation == 'insert':\n        # Insert a new item (if feasible)\n        out_items = np.where(new_solution == 0)[0]\n        if len(out_items) > 0:\n            j = random.choice(out_items)\n            if current_weight + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    elif operation == 'delete':\n        # Delete an existing item\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) > 0:\n            i = random.choice(in_items)\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.2931878300848151,
            3.3320391476154327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Randomly choose one of three operations: swap, insert, or delete\n    operation = random.choice(['swap', 'insert', 'delete'])\n\n    if operation == 'swap':\n        # Swap two items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) > 0 and len(out_items) > 0:\n            i = random.choice(in_items)\n            j = random.choice(out_items)\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                new_solution[j] = 1\n\n    elif operation == 'insert':\n        # Insert a new item (if feasible)\n        out_items = np.where(new_solution == 0)[0]\n        if len(out_items) > 0:\n            j = random.choice(out_items)\n            if current_weight + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    elif operation == 'delete':\n        # Delete an existing item\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) > 0:\n            i = random.choice(in_items)\n            new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This heuristic selects a solution from the archive with the highest crowding distance in the objective space, indicating a less explored region, and applies a hybrid local search that combines item swapping with a probabilistic shift operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding_distance = np.zeros(len(objectives))\n    crowding_distance[sorted_indices[0]] = np.inf\n    crowding_distance[sorted_indices[-1]] = np.inf\n\n    for i in range(1, len(objectives) - 1):\n        crowding_distance[sorted_indices[i]] += (objectives_sorted[i + 1, 0] - objectives_sorted[i - 1, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0] + 1e-10)\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    objectives_sorted = objectives[sorted_indices]\n\n    for i in range(1, len(objectives) - 1):\n        crowding_distance[sorted_indices[i]] += (objectives_sorted[i + 1, 1] - objectives_sorted[i - 1, 1]) / (objectives_sorted[-1, 1] - objectives_sorted[0, 1] + 1e-10)\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: swap items with non-items or shift based on probability\n    if len(items) > 0 and len(non_items) > 0:\n        # Randomly select an item to remove and a non-item to add\n        item_to_remove = np.random.choice(items)\n        non_item_to_add = np.random.choice(non_items)\n\n        # Calculate total weight after swap\n        current_weight = np.sum(weight_lst[base_solution == 1])\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[non_item_to_add]\n\n        if new_weight <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[non_item_to_add] = 1\n        else:\n            # If swap is infeasible, try probabilistic shift\n            if np.random.rand() < 0.5 and len(items) > 1:\n                # Remove a random item\n                item_to_remove = np.random.choice(items)\n                new_weight = current_weight - weight_lst[item_to_remove]\n                if new_weight <= capacity:\n                    new_solution[item_to_remove] = 0\n            else:\n                # Add a random non-item if feasible\n                feasible_non_items = [i for i in non_items if weight_lst[i] <= capacity - current_weight]\n                if feasible_non_items:\n                    non_item_to_add = np.random.choice(feasible_non_items)\n                    new_solution[non_item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.6070150324059083,
            3.266593039035797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding_distance = np.zeros(len(objectives))\n    crowding_distance[sorted_indices[0]] = np.inf\n    crowding_distance[sorted_indices[-1]] = np.inf\n\n    for i in range(1, len(objectives) - 1):\n        crowding_distance[sorted_indices[i]] += (objectives_sorted[i + 1, 0] - objectives_sorted[i - 1, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0] + 1e-10)\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    objectives_sorted = objectives[sorted_indices]\n\n    for i in range(1, len(objectives) - 1):\n        crowding_distance[sorted_indices[i]] += (objectives_sorted[i + 1, 1] - objectives_sorted[i - 1, 1]) / (objectives_sorted[-1, 1] - objectives_sorted[0, 1] + 1e-10)\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: swap items with non-items or shift based on probability\n    if len(items) > 0 and len(non_items) > 0:\n        # Randomly select an item to remove and a non-item to add\n        item_to_remove = np.random.choice(items)\n        non_item_to_add = np.random.choice(non_items)\n\n        # Calculate total weight after swap\n        current_weight = np.sum(weight_lst[base_solution == 1])\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[non_item_to_add]\n\n        if new_weight <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[non_item_to_add] = 1\n        else:\n            # If swap is infeasible, try probabilistic shift\n            if np.random.rand() < 0.5 and len(items) > 1:\n                # Remove a random item\n                item_to_remove = np.random.choice(items)\n                new_weight = current_weight - weight_lst[item_to_remove]\n                if new_weight <= capacity:\n                    new_solution[item_to_remove] = 0\n            else:\n                # Add a random non-item if feasible\n                feasible_non_items = [i for i in non_items if weight_lst[i] <= capacity - current_weight]\n                if feasible_non_items:\n                    non_item_to_add = np.random.choice(feasible_non_items)\n                    new_solution[non_item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with probabilistic item flipping to intelligently explore the solution space while ensuring feasibility, guided by a dynamic priority metric balancing both objectives and solution density in the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive swapping and probabilistic flipping\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swapping\n    for _ in range(3):  # Perform multiple swaps\n        # Identify items that could potentially improve both objectives\n        potential_items = np.where((weight_lst <= (capacity - current_weight)) &\n                                 ((value1_lst + value2_lst) > (np.sum(value1_lst * base_solution) + np.sum(value2_lst * base_solution))))[0]\n\n        if len(potential_items) > 0:\n            swap_item = np.random.choice(potential_items)\n            if base_solution[swap_item] == 0:\n                new_solution[swap_item] = 1\n                current_weight += weight_lst[swap_item]\n            else:\n                new_solution[swap_item] = 0\n                current_weight -= weight_lst[swap_item]\n\n    # Step 2: Probabilistic item flipping with objective-aware probabilities\n    for i in range(len(new_solution)):\n        if np.random.random() < 0.2:  # 20% chance to flip each item\n            if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.39492987113339667,
            2.9666855335235596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive swapping and probabilistic flipping\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swapping\n    for _ in range(3):  # Perform multiple swaps\n        # Identify items that could potentially improve both objectives\n        potential_items = np.where((weight_lst <= (capacity - current_weight)) &\n                                 ((value1_lst + value2_lst) > (np.sum(value1_lst * base_solution) + np.sum(value2_lst * base_solution))))[0]\n\n        if len(potential_items) > 0:\n            swap_item = np.random.choice(potential_items)\n            if base_solution[swap_item] == 0:\n                new_solution[swap_item] = 1\n                current_weight += weight_lst[swap_item]\n            else:\n                new_solution[swap_item] = 0\n                current_weight -= weight_lst[swap_item]\n\n    # Step 2: Probabilistic item flipping with objective-aware probabilities\n    for i in range(len(new_solution)):\n        if np.random.random() < 0.2:  # 20% chance to flip each item\n            if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate the current weight and values of the base solution\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be flipped (added or removed) without violating capacity\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                return new_solution\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                return new_solution\n\n    # If no single flip works, try a more aggressive local search\n    # Randomly select two items to flip (one in, one out)\n    items = np.where(base_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n        if temp_weight <= capacity:\n            new_solution[i] = 0\n            new_solution[j] = 1\n            return new_solution\n\n    # If no improvement found, return the base solution\n    return base_solution\n\n",
        "score": [
            -0.9095582970944912,
            0.9379750192165375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate the current weight and values of the base solution\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be flipped (added or removed) without violating capacity\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                return new_solution\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                return new_solution\n\n    # If no single flip works, try a more aggressive local search\n    # Randomly select two items to flip (one in, one out)\n    items = np.where(base_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n        if temp_weight <= capacity:\n            new_solution[i] = 0\n            new_solution[j] = 1\n            return new_solution\n\n    # If no improvement found, return the base solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate the current weight and values of the base solution\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be flipped (added or removed) without violating capacity\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                return new_solution\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                return new_solution\n\n    # If no single flip works, try a more aggressive local search\n    # Randomly select two items to flip (one in, one out)\n    items = np.where(base_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n        if temp_weight <= capacity:\n            new_solution[i] = 0\n            new_solution[j] = 1\n            return new_solution\n\n    # If no improvement found, return the base solution\n    return base_solution\n\n",
        "score": [
            -0.9095582970944912,
            0.9379750192165375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate the current weight and values of the base solution\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be flipped (added or removed) without violating capacity\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                return new_solution\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                return new_solution\n\n    # If no single flip works, try a more aggressive local search\n    # Randomly select two items to flip (one in, one out)\n    items = np.where(base_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n        if temp_weight <= capacity:\n            new_solution[i] = 0\n            new_solution[j] = 1\n            return new_solution\n\n    # If no improvement found, return the base solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search strategy combining item swaps and diversified flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    normalized_objectives = [(sol, (v1 / np.max(value1_lst), v2 / np.max(value2_lst))) for sol, (v1, v2) in archive]\n    selected = max(normalized_objectives, key=lambda x: sum(x[1]))[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and diversified flips\n    n_items = len(base_solution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Randomly swap two items (one in, one out)\n    candidates_in = np.where(base_solution == 0)[0]\n    candidates_out = np.where(base_solution == 1)[0]\n\n    if len(candidates_in) > 0 and len(candidates_out) > 0:\n        item_in = random.choice(candidates_in)\n        item_out = random.choice(candidates_out)\n\n        if (current_weight - weight_lst[item_out] + weight_lst[item_in]) <= capacity:\n            new_solution[item_out] = 0\n            new_solution[item_in] = 1\n            return new_solution\n\n    # Step 2: If swap fails, perform diversified flips\n    # Flip a random subset of items (up to 3) that maintain feasibility\n    max_flips = min(3, n_items)\n    flip_indices = random.sample(range(n_items), max_flips)\n    temp_solution = new_solution.copy()\n    temp_weight = current_weight\n\n    for idx in flip_indices:\n        if temp_solution[idx] == 1:\n            temp_weight -= weight_lst[idx]\n            temp_solution[idx] = 0\n        else:\n            if (temp_weight + weight_lst[idx]) <= capacity:\n                temp_weight += weight_lst[idx]\n                temp_solution[idx] = 1\n\n    return temp_solution\n\n",
        "score": [
            -0.3192334249499057,
            7.00013393163681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    normalized_objectives = [(sol, (v1 / np.max(value1_lst), v2 / np.max(value2_lst))) for sol, (v1, v2) in archive]\n    selected = max(normalized_objectives, key=lambda x: sum(x[1]))[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and diversified flips\n    n_items = len(base_solution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Randomly swap two items (one in, one out)\n    candidates_in = np.where(base_solution == 0)[0]\n    candidates_out = np.where(base_solution == 1)[0]\n\n    if len(candidates_in) > 0 and len(candidates_out) > 0:\n        item_in = random.choice(candidates_in)\n        item_out = random.choice(candidates_out)\n\n        if (current_weight - weight_lst[item_out] + weight_lst[item_in]) <= capacity:\n            new_solution[item_out] = 0\n            new_solution[item_in] = 1\n            return new_solution\n\n    # Step 2: If swap fails, perform diversified flips\n    # Flip a random subset of items (up to 3) that maintain feasibility\n    max_flips = min(3, n_items)\n    flip_indices = random.sample(range(n_items), max_flips)\n    temp_solution = new_solution.copy()\n    temp_weight = current_weight\n\n    for idx in flip_indices:\n        if temp_solution[idx] == 1:\n            temp_weight -= weight_lst[idx]\n            temp_solution[idx] = 0\n        else:\n            if (temp_weight + weight_lst[idx]) <= capacity:\n                temp_weight += weight_lst[idx]\n                temp_solution[idx] = 1\n\n    return temp_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{A novel hybrid local search strategy is designed to intelligently select a solution from the archive, then apply a combination of item swaps and probabilistic flips to explore high-potential regions while ensuring feasibility through dynamic weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity potential (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of swaps and probabilistic flips\n    for _ in range(3):  # Number of attempts\n        # Randomly select two items to swap\n        i, j = random.sample(range(len(base_solution)), 2)\n\n        # Check if swapping is feasible\n        delta_weight = (weight_lst[j] - weight_lst[i]) * (new_solution[i] - new_solution[j])\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    # Probabilistic flips to escape local optima\n    for i in range(len(base_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility (edge case)\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Randomly remove items until feasible\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        item_to_remove = random.choice(items_in)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4298487033810981,
            1.2735630869865417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity potential (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of swaps and probabilistic flips\n    for _ in range(3):  # Number of attempts\n        # Randomly select two items to swap\n        i, j = random.sample(range(len(base_solution)), 2)\n\n        # Check if swapping is feasible\n        delta_weight = (weight_lst[j] - weight_lst[i]) * (new_solution[i] - new_solution[j])\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    # Probabilistic flips to escape local optima\n    for i in range(len(base_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility (edge case)\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Randomly remove items until feasible\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        item_to_remove = random.choice(items_in)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its objective values, then applies a hybrid local search operator that combines random flipping of items with a biased selection of critical items (those with high marginal utility) to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution.astype(bool)])\n\n    # Generate a neighbor by flipping items with high marginal utility\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate marginal utility for each item (ratio of total value to weight)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal utilities for both objectives\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Identify items to flip (prioritize those with high marginal utility)\n    flip_prob = combined_marginal / np.sum(combined_marginal)\n    flip_candidates = np.random.choice(n_items, size=min(3, n_items), p=flip_prob, replace=False)\n\n    for item in flip_candidates:\n        if base_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Apply random flips to escape local optima\n    for _ in range(2):\n        item = random.randint(0, n_items - 1)\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.26485913896728036,
            1.9525228440761566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution.astype(bool)])\n\n    # Generate a neighbor by flipping items with high marginal utility\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate marginal utility for each item (ratio of total value to weight)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal utilities for both objectives\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Identify items to flip (prioritize those with high marginal utility)\n    flip_prob = combined_marginal / np.sum(combined_marginal)\n    flip_candidates = np.random.choice(n_items, size=min(3, n_items), p=flip_prob, replace=False)\n\n    for item in flip_candidates:\n        if base_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Apply random flips to escape local optima\n    for _ in range(2):\n        item = random.randint(0, n_items - 1)\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{A hybrid local search strategy that intelligently combines random selection of promising solutions with a novel item swapping mechanism that prioritizes high-value items while ensuring feasibility, balancing both objectives through a weighted random choice of items to swap.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential for improvement (e.g., sum of value1 + value2 for items not in the solution)\n        potential = np.sum((value1_lst + value2_lst) * (1 - sol))\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        return archive[0][0].copy()  # Fallback to first solution if archive is empty\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: weighted random swap of items\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify candidate items to swap (out: in solution, in: not in solution)\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) == 0 or len(out_items) == 0:\n        return new_solution  # No possible swaps\n\n    # Calculate weighted probabilities for swapping items (prioritize high-value items)\n    weights_in = value1_lst[in_items] + value2_lst[in_items]\n    weights_out = value1_lst[out_items] + value2_lst[out_items]\n\n    # Normalize weights to form probabilities\n    prob_in = weights_in / np.sum(weights_in)\n    prob_out = weights_out / np.sum(weights_out)\n\n    # Randomly select items to swap based on their weights\n    item_in = np.random.choice(in_items, p=prob_in)\n    item_out = np.random.choice(out_items, p=prob_out)\n\n    # Check feasibility of swap\n    delta_weight = weight_lst[item_out] - weight_lst[item_in]\n    if current_weight + delta_weight <= capacity:\n        new_solution[item_in] = 0\n        new_solution[item_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9802565020917481,
            3.6537342965602875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential for improvement (e.g., sum of value1 + value2 for items not in the solution)\n        potential = np.sum((value1_lst + value2_lst) * (1 - sol))\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        return archive[0][0].copy()  # Fallback to first solution if archive is empty\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: weighted random swap of items\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify candidate items to swap (out: in solution, in: not in solution)\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) == 0 or len(out_items) == 0:\n        return new_solution  # No possible swaps\n\n    # Calculate weighted probabilities for swapping items (prioritize high-value items)\n    weights_in = value1_lst[in_items] + value2_lst[in_items]\n    weights_out = value1_lst[out_items] + value2_lst[out_items]\n\n    # Normalize weights to form probabilities\n    prob_in = weights_in / np.sum(weights_in)\n    prob_out = weights_out / np.sum(weights_out)\n\n    # Randomly select items to swap based on their weights\n    item_in = np.random.choice(in_items, p=prob_in)\n    item_out = np.random.choice(out_items, p=prob_out)\n\n    # Check feasibility of swap\n    delta_weight = weight_lst[item_out] - weight_lst[item_in]\n    if current_weight + delta_weight <= capacity:\n        new_solution[item_in] = 0\n        new_solution[item_out] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{A hybrid local search strategy that intelligently combines random selection of promising solutions with a novel item swapping mechanism that prioritizes high-value items while ensuring feasibility, balancing both objectives through a weighted random choice of items to swap.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential for improvement (e.g., sum of value1 + value2 for items not in the solution)\n        potential = np.sum((value1_lst + value2_lst) * (1 - sol))\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        return archive[0][0].copy()  # Fallback to first solution if archive is empty\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: weighted random swap of items\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify candidate items to swap (out: in solution, in: not in solution)\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) == 0 or len(out_items) == 0:\n        return new_solution  # No possible swaps\n\n    # Calculate weighted probabilities for swapping items (prioritize high-value items)\n    weights_in = value1_lst[in_items] + value2_lst[in_items]\n    weights_out = value1_lst[out_items] + value2_lst[out_items]\n\n    # Normalize weights to form probabilities\n    prob_in = weights_in / np.sum(weights_in)\n    prob_out = weights_out / np.sum(weights_out)\n\n    # Randomly select items to swap based on their weights\n    item_in = np.random.choice(in_items, p=prob_in)\n    item_out = np.random.choice(out_items, p=prob_out)\n\n    # Check feasibility of swap\n    delta_weight = weight_lst[item_out] - weight_lst[item_in]\n    if current_weight + delta_weight <= capacity:\n        new_solution[item_in] = 0\n        new_solution[item_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9802565020917481,
            3.6537342965602875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential for improvement (e.g., sum of value1 + value2 for items not in the solution)\n        potential = np.sum((value1_lst + value2_lst) * (1 - sol))\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        return archive[0][0].copy()  # Fallback to first solution if archive is empty\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: weighted random swap of items\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify candidate items to swap (out: in solution, in: not in solution)\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) == 0 or len(out_items) == 0:\n        return new_solution  # No possible swaps\n\n    # Calculate weighted probabilities for swapping items (prioritize high-value items)\n    weights_in = value1_lst[in_items] + value2_lst[in_items]\n    weights_out = value1_lst[out_items] + value2_lst[out_items]\n\n    # Normalize weights to form probabilities\n    prob_in = weights_in / np.sum(weights_in)\n    prob_out = weights_out / np.sum(weights_out)\n\n    # Randomly select items to swap based on their weights\n    item_in = np.random.choice(in_items, p=prob_in)\n    item_out = np.random.choice(out_items, p=prob_out)\n\n    # Check feasibility of swap\n    delta_weight = weight_lst[item_out] - weight_lst[item_in]\n    if current_weight + delta_weight <= capacity:\n        new_solution[item_in] = 0\n        new_solution[item_out] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a heuristic that considers both objective values and their potential for improvement, then applies a hybrid local search operator combining random flips and adaptive neighborhood exploration to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Heuristic to select a promising solution: prioritize solutions with higher total value in either objective\n    # and those with more items (potential for improvement)\n    archive.sort(key=lambda x: (-max(x[1][0], x[1][1]), -np.sum(x[0])))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flips with adaptive neighborhood\n    for _ in range(min(5, len(weight_lst))):  # Limit number of flips\n        # Select a random item to flip\n        item = random.randint(0, len(weight_lst) - 1)\n\n        # Calculate potential change in weight\n        if new_solution[item] == 1:\n            delta_weight = -weight_lst[item]\n        else:\n            delta_weight = weight_lst[item]\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight + delta_weight <= capacity:\n            new_solution[item] = 1 - new_solution[item]\n\n    # Additional adaptive neighborhood exploration: flip items with high marginal value\n    if random.random() < 0.3:  # 30% chance for this exploration\n        marginal_value1 = value1_lst / weight_lst\n        marginal_value2 = value2_lst / weight_lst\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Sort items by combined marginal value\n        sorted_items = np.argsort(-combined_marginal)\n\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if new_solution[item] == 1:\n                delta_weight = -weight_lst[item]\n            else:\n                delta_weight = weight_lst[item]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity:\n                new_solution[item] = 1 - new_solution[item]\n                break  # Only one flip in this phase\n\n    return new_solution\n\n",
        "score": [
            -0.3389354271624758,
            2.136732965707779
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Heuristic to select a promising solution: prioritize solutions with higher total value in either objective\n    # and those with more items (potential for improvement)\n    archive.sort(key=lambda x: (-max(x[1][0], x[1][1]), -np.sum(x[0])))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flips with adaptive neighborhood\n    for _ in range(min(5, len(weight_lst))):  # Limit number of flips\n        # Select a random item to flip\n        item = random.randint(0, len(weight_lst) - 1)\n\n        # Calculate potential change in weight\n        if new_solution[item] == 1:\n            delta_weight = -weight_lst[item]\n        else:\n            delta_weight = weight_lst[item]\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight + delta_weight <= capacity:\n            new_solution[item] = 1 - new_solution[item]\n\n    # Additional adaptive neighborhood exploration: flip items with high marginal value\n    if random.random() < 0.3:  # 30% chance for this exploration\n        marginal_value1 = value1_lst / weight_lst\n        marginal_value2 = value2_lst / weight_lst\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Sort items by combined marginal value\n        sorted_items = np.argsort(-combined_marginal)\n\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if new_solution[item] == 1:\n                delta_weight = -weight_lst[item]\n            else:\n                delta_weight = weight_lst[item]\n\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity:\n                new_solution[item] = 1 - new_solution[item]\n                break  # Only one flip in this phase\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (np.max(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each item\n    marginal_gains1 = value1_lst / (weight_lst + 1e-10)\n    marginal_gains2 = value2_lst / (weight_lst + 1e-10)\n    combined_gains = marginal_gains1 + marginal_gains2\n\n    # Sort items by combined marginal gains\n    sorted_items = np.argsort(combined_gains)[::-1]\n\n    # Flip top-k items with highest gains, ensuring feasibility\n    k = min(3, len(sorted_items))\n    for item in sorted_items[:k]:\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9510732090495908,
            1.655897080898285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (np.max(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each item\n    marginal_gains1 = value1_lst / (weight_lst + 1e-10)\n    marginal_gains2 = value2_lst / (weight_lst + 1e-10)\n    combined_gains = marginal_gains1 + marginal_gains2\n\n    # Sort items by combined marginal gains\n    sorted_items = np.argsort(combined_gains)[::-1]\n\n    # Flip top-k items with highest gains, ensuring feasibility\n    k = min(3, len(sorted_items))\n    for item in sorted_items[:k]:\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining item swaps and weight-balanced flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Randomly select a subset of items to flip (with bias toward high-weight items)\n    flip_indices = np.where(base_solution == 1)[0]\n    if len(flip_indices) > 0:\n        flip_candidates = random.sample(list(flip_indices), min(3, len(flip_indices)))\n        for idx in flip_candidates:\n            if base_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Step 2: Add items not in solution with high potential (weight-balanced selection)\n    available_indices = np.where(base_solution == 0)[0]\n    if len(available_indices) > 0 and current_weight < capacity:\n        potential_items = []\n        for idx in available_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                potential_items.append(idx)\n\n        if potential_items:\n            # Select items with high combined value1 and value2\n            potential_items_sorted = sorted(potential_items, key=lambda x: (value1_lst[x] + value2_lst[x]), reverse=True)\n            for idx in potential_items_sorted[:min(3, len(potential_items_sorted))]:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Perform a random swap between included and excluded items\n    if np.sum(new_solution) > 0 and np.sum(new_solution) < n_items:\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            swap_in = random.choice(included)\n            swap_out = random.choice(excluded)\n\n            if (current_weight - weight_lst[swap_in] + weight_lst[swap_out]) <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5059538436310247,
            3.9725641310214996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Randomly select a subset of items to flip (with bias toward high-weight items)\n    flip_indices = np.where(base_solution == 1)[0]\n    if len(flip_indices) > 0:\n        flip_candidates = random.sample(list(flip_indices), min(3, len(flip_indices)))\n        for idx in flip_candidates:\n            if base_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Step 2: Add items not in solution with high potential (weight-balanced selection)\n    available_indices = np.where(base_solution == 0)[0]\n    if len(available_indices) > 0 and current_weight < capacity:\n        potential_items = []\n        for idx in available_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                potential_items.append(idx)\n\n        if potential_items:\n            # Select items with high combined value1 and value2\n            potential_items_sorted = sorted(potential_items, key=lambda x: (value1_lst[x] + value2_lst[x]), reverse=True)\n            for idx in potential_items_sorted[:min(3, len(potential_items_sorted))]:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Perform a random swap between included and excluded items\n    if np.sum(new_solution) > 0 and np.sum(new_solution) < n_items:\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            swap_in = random.choice(included)\n            swap_out = random.choice(excluded)\n\n            if (current_weight - weight_lst[swap_in] + weight_lst[swap_out]) <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with low objective values relative to their weight, then applies a hybrid local search combining random swaps and value-based flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([(obj[0] + obj[1]) / np.sum(weight_lst[sol]) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and value-based flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a candidate item to flip\n    candidate_idx = np.random.randint(n_items)\n    if new_solution[candidate_idx] == 1:\n        # If included, try to remove it\n        if current_weight - weight_lst[candidate_idx] <= capacity:\n            new_solution[candidate_idx] = 0\n    else:\n        # If excluded, try to include it if profitable in both objectives\n        if current_weight + weight_lst[candidate_idx] <= capacity and \\\n           (value1_lst[candidate_idx] > 0 or value2_lst[candidate_idx] > 0):\n            new_solution[candidate_idx] = 1\n\n    # Additional random swaps to explore neighborhood\n    swap_indices = np.random.choice(n_items, size=2, replace=False)\n    i, j = swap_indices[0], swap_indices[1]\n    if new_solution[i] != new_solution[j]:\n        # Ensure feasibility after swap\n        if new_solution[i] == 1 and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7645255277641283,
            2.4060859382152557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([(obj[0] + obj[1]) / np.sum(weight_lst[sol]) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and value-based flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a candidate item to flip\n    candidate_idx = np.random.randint(n_items)\n    if new_solution[candidate_idx] == 1:\n        # If included, try to remove it\n        if current_weight - weight_lst[candidate_idx] <= capacity:\n            new_solution[candidate_idx] = 0\n    else:\n        # If excluded, try to include it if profitable in both objectives\n        if current_weight + weight_lst[candidate_idx] <= capacity and \\\n           (value1_lst[candidate_idx] > 0 or value2_lst[candidate_idx] > 0):\n            new_solution[candidate_idx] = 1\n\n    # Additional random swaps to explore neighborhood\n    swap_indices = np.random.choice(n_items, size=2, replace=False)\n    i, j = swap_indices[0], swap_indices[1]\n    if new_solution[i] != new_solution[j]:\n        # Ensure feasibility after swap\n        if new_solution[i] == 1 and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[0]) * (x[1][0] + x[1][1]))[0]\n    new_solution = selected.copy()\n\n    # Identify items that could be swapped or flipped\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    # Perform a hybrid local search: flip a random item if feasible, otherwise swap two items\n    if len(candidate_indices) > 0:\n        idx = np.random.choice(candidate_indices)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                # If flipping causes infeasibility, try swapping with another item\n                other_idx = np.random.choice(np.where(new_solution == 0)[0])\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] + weight_lst[other_idx] <= capacity:\n                    new_solution[idx] = 1\n                    new_solution[other_idx] = 1\n                else:\n                    new_solution[idx] = 1  # Revert if swap is infeasible\n        else:\n            new_solution[idx] = 1\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                new_solution[idx] = 0  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.8611594651610969,
            3.442810744047165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[0]) * (x[1][0] + x[1][1]))[0]\n    new_solution = selected.copy()\n\n    # Identify items that could be swapped or flipped\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    # Perform a hybrid local search: flip a random item if feasible, otherwise swap two items\n    if len(candidate_indices) > 0:\n        idx = np.random.choice(candidate_indices)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                # If flipping causes infeasibility, try swapping with another item\n                other_idx = np.random.choice(np.where(new_solution == 0)[0])\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] + weight_lst[other_idx] <= capacity:\n                    new_solution[idx] = 1\n                    new_solution[other_idx] = 1\n                else:\n                    new_solution[idx] = 1  # Revert if swap is infeasible\n        else:\n            new_solution[idx] = 1\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                new_solution[idx] = 0  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping with probabilistic objective-biased flipping to explore the solution space, prioritizing high-potential solutions and ensuring feasibility through dynamic constraint handling.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol[0] for sol in archive]\n    archive_objectives = [sol[1] for sol in archive]\n\n    # Calculate potential for each solution (normalized improvement potential)\n    potentials = []\n    for i, sol in enumerate(archive_solutions):\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            potentials.append(0)\n            continue\n\n        # Calculate potential based on both objectives\n        potential1 = np.sum(value1_lst * (1 - sol)) / np.sum(value1_lst)\n        potential2 = np.sum(value2_lst * (1 - sol)) / np.sum(value2_lst)\n        potential = (potential1 + potential2) / 2\n        potentials.append(potential)\n\n    # Select the solution with highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Adaptive item swapping (swap items between included and excluded)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Select a random included item to swap out\n        swap_out = random.choice(included_items)\n        # Select a random excluded item to swap in\n        swap_in = random.choice(excluded_items)\n\n        # Check if swap is feasible\n        delta_weight = weight_lst[swap_in] - weight_lst[swap_out]\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n            current_weight += delta_weight\n\n    # Step 2: Probabilistic objective-biased flipping\n    # Determine which objective to prioritize (alternate between them)\n    prioritize_obj1 = random.random() > 0.5\n\n    # Calculate flip probabilities based on objective values\n    flip_probs = np.zeros_like(new_solution, dtype=float)\n    if prioritize_obj1:\n        flip_probs[new_solution == 1] = -value1_lst[new_solution == 1] / np.sum(value1_lst)\n        flip_probs[new_solution == 0] = value1_lst[new_solution == 0] / np.sum(value1_lst)\n    else:\n        flip_probs[new_solution == 1] = -value2_lst[new_solution == 1] / np.sum(value2_lst)\n        flip_probs[new_solution == 0] = value2_lst[new_solution == 0] / np.sum(value2_lst)\n\n    # Normalize probabilities and apply probabilistic flipping\n    flip_probs = np.abs(flip_probs)\n    flip_probs /= np.sum(flip_probs) if np.sum(flip_probs) > 0 else 1\n\n    for i in range(len(new_solution)):\n        if random.random() < flip_probs[i]:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7602995932341747,
            7.555091589689255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol[0] for sol in archive]\n    archive_objectives = [sol[1] for sol in archive]\n\n    # Calculate potential for each solution (normalized improvement potential)\n    potentials = []\n    for i, sol in enumerate(archive_solutions):\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            potentials.append(0)\n            continue\n\n        # Calculate potential based on both objectives\n        potential1 = np.sum(value1_lst * (1 - sol)) / np.sum(value1_lst)\n        potential2 = np.sum(value2_lst * (1 - sol)) / np.sum(value2_lst)\n        potential = (potential1 + potential2) / 2\n        potentials.append(potential)\n\n    # Select the solution with highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Adaptive item swapping (swap items between included and excluded)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Select a random included item to swap out\n        swap_out = random.choice(included_items)\n        # Select a random excluded item to swap in\n        swap_in = random.choice(excluded_items)\n\n        # Check if swap is feasible\n        delta_weight = weight_lst[swap_in] - weight_lst[swap_out]\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n            current_weight += delta_weight\n\n    # Step 2: Probabilistic objective-biased flipping\n    # Determine which objective to prioritize (alternate between them)\n    prioritize_obj1 = random.random() > 0.5\n\n    # Calculate flip probabilities based on objective values\n    flip_probs = np.zeros_like(new_solution, dtype=float)\n    if prioritize_obj1:\n        flip_probs[new_solution == 1] = -value1_lst[new_solution == 1] / np.sum(value1_lst)\n        flip_probs[new_solution == 0] = value1_lst[new_solution == 0] / np.sum(value1_lst)\n    else:\n        flip_probs[new_solution == 1] = -value2_lst[new_solution == 1] / np.sum(value2_lst)\n        flip_probs[new_solution == 0] = value2_lst[new_solution == 0] / np.sum(value2_lst)\n\n    # Normalize probabilities and apply probabilistic flipping\n    flip_probs = np.abs(flip_probs)\n    flip_probs /= np.sum(flip_probs) if np.sum(flip_probs) > 0 else 1\n\n    for i in range(len(new_solution)):\n        if random.random() < flip_probs[i]:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines random selection of promising solutions with a creative two-phase neighborhood exploration (first exploring item swaps and then considering weight-balanced flips) to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of normalized objectives to identify high-potential solutions\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst) + 1e-6), reverse=True)\n        candidates = sorted_solutions[:max(1, len(archive) // 3)]\n        base_solution, _ = random.choice(candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Phase 1: Random item swap (with feasibility check)\n    if np.random.rand() < 0.7:  # Higher probability for this phase\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n\n            # Check if swapping i (remove) and j (add) keeps solution feasible\n            current_weight = np.sum(weight_lst[base_solution == 1])\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i] = 0\n                new_solution[j] = 1\n    else:\n        # Phase 2: Weight-balanced flip (more aggressive move)\n        included = np.where(base_solution == 1)[0]\n        if len(included) > 0:\n            # Find item with highest value-to-weight ratio for removal\n            ratios = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n            i = included[np.argmax(ratios)]\n\n            # Find best item to add (maximizing combined value while keeping weight feasible)\n            current_weight = np.sum(weight_lst[base_solution == 1])\n            remaining_capacity = capacity - (current_weight - weight_lst[i])\n            feasible_excluded = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n            if len(feasible_excluded) > 0:\n                # Select item with highest combined value\n                values = value1_lst[feasible_excluded] + value2_lst[feasible_excluded]\n                j = feasible_excluded[np.argmax(values)]\n\n                new_solution[i] = 0\n                new_solution[j] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.43313123540877524,
            6.238453656435013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of normalized objectives to identify high-potential solutions\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst) + 1e-6), reverse=True)\n        candidates = sorted_solutions[:max(1, len(archive) // 3)]\n        base_solution, _ = random.choice(candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Phase 1: Random item swap (with feasibility check)\n    if np.random.rand() < 0.7:  # Higher probability for this phase\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n\n            # Check if swapping i (remove) and j (add) keeps solution feasible\n            current_weight = np.sum(weight_lst[base_solution == 1])\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i] = 0\n                new_solution[j] = 1\n    else:\n        # Phase 2: Weight-balanced flip (more aggressive move)\n        included = np.where(base_solution == 1)[0]\n        if len(included) > 0:\n            # Find item with highest value-to-weight ratio for removal\n            ratios = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n            i = included[np.argmax(ratios)]\n\n            # Find best item to add (maximizing combined value while keeping weight feasible)\n            current_weight = np.sum(weight_lst[base_solution == 1])\n            remaining_capacity = capacity - (current_weight - weight_lst[i])\n            feasible_excluded = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n            if len(feasible_excluded) > 0:\n                # Select item with highest combined value\n                values = value1_lst[feasible_excluded] + value2_lst[feasible_excluded]\n                j = feasible_excluded[np.argmax(values)]\n\n                new_solution[i] = 0\n                new_solution[j] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random swaps with a value-to-weight ratio-based heuristic to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity:\n            # Calculate potential improvement based on value-to-weight ratio\n            ratio1 = v1 / (current_weight + 1e-8)\n            ratio2 = v2 / (current_weight + 1e-8)\n            candidates.append((sol, ratio1, ratio2, v1, v2))\n\n    if not candidates:\n        # Fallback to random selection if no candidates found\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest combined ratio\n        candidates.sort(key=lambda x: -(x[1] + x[2]))\n        base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps with value-to-weight heuristic\n    current_weight = np.sum(weight_lst * new_solution)\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Try to add items with high value-to-weight ratio\n    if len(non_items) > 0:\n        # Calculate value-to-weight ratios for non-selected items\n        ratios1 = value1_lst[non_items] / (weight_lst[non_items] + 1e-8)\n        ratios2 = value2_lst[non_items] / (weight_lst[non_items] + 1e-8)\n        combined_ratios = ratios1 + ratios2\n\n        # Select top candidates\n        top_candidates = np.argsort(combined_ratios)[-min(3, len(non_items)):]\n        for idx in top_candidates:\n            item = non_items[idx]\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Try to remove items with low value-to-weight ratio\n    if len(items) > 0:\n        # Calculate value-to-weight ratios for selected items\n        ratios1 = value1_lst[items] / (weight_lst[items] + 1e-8)\n        ratios2 = value2_lst[items] / (weight_lst[items] + 1e-8)\n        combined_ratios = ratios1 + ratios2\n\n        # Select bottom candidates\n        bottom_candidates = np.argsort(combined_ratios)[:min(3, len(items))]\n        for idx in bottom_candidates:\n            item = items[idx]\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Random swaps to escape local optima\n    if len(items) > 0 and len(non_items) > 0:\n        for _ in range(2):\n            item_in = random.choice(items)\n            item_out = random.choice(non_items)\n            if current_weight - weight_lst[item_in] + weight_lst[item_out] <= capacity:\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n                current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n    return new_solution\n\n",
        "score": [
            -0.4345277074883969,
            1.764924019575119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity:\n            # Calculate potential improvement based on value-to-weight ratio\n            ratio1 = v1 / (current_weight + 1e-8)\n            ratio2 = v2 / (current_weight + 1e-8)\n            candidates.append((sol, ratio1, ratio2, v1, v2))\n\n    if not candidates:\n        # Fallback to random selection if no candidates found\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest combined ratio\n        candidates.sort(key=lambda x: -(x[1] + x[2]))\n        base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps with value-to-weight heuristic\n    current_weight = np.sum(weight_lst * new_solution)\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Try to add items with high value-to-weight ratio\n    if len(non_items) > 0:\n        # Calculate value-to-weight ratios for non-selected items\n        ratios1 = value1_lst[non_items] / (weight_lst[non_items] + 1e-8)\n        ratios2 = value2_lst[non_items] / (weight_lst[non_items] + 1e-8)\n        combined_ratios = ratios1 + ratios2\n\n        # Select top candidates\n        top_candidates = np.argsort(combined_ratios)[-min(3, len(non_items)):]\n        for idx in top_candidates:\n            item = non_items[idx]\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Try to remove items with low value-to-weight ratio\n    if len(items) > 0:\n        # Calculate value-to-weight ratios for selected items\n        ratios1 = value1_lst[items] / (weight_lst[items] + 1e-8)\n        ratios2 = value2_lst[items] / (weight_lst[items] + 1e-8)\n        combined_ratios = ratios1 + ratios2\n\n        # Select bottom candidates\n        bottom_candidates = np.argsort(combined_ratios)[:min(3, len(items))]\n        for idx in bottom_candidates:\n            item = items[idx]\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Random swaps to escape local optima\n    if len(items) > 0 and len(non_items) > 0:\n        for _ in range(2):\n            item_in = random.choice(items)\n            item_out = random.choice(non_items)\n            if current_weight - weight_lst[item_in] + weight_lst[item_out] <= capacity:\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n                current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining item swaps and value-based perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n\n    # Prioritize solutions that are not too close to the mean in either objective\n    distances = np.abs(objectives - mean_obj) / (std_obj + 1e-8)\n    scores = np.max(distances, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: swap items with high value ratios or random perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Value-based swaps (prioritize items with high value/weight ratios)\n    value_ratios1 = value1_lst / (weight_lst + 1e-8)\n    value_ratios2 = value2_lst / (weight_lst + 1e-8)\n\n    # Sort items by value ratios (descending)\n    sorted_items1 = np.argsort(value_ratios1)[::-1]\n    sorted_items2 = np.argsort(value_ratios2)[::-1]\n\n    # Try swapping items between included and excluded\n    for i in range(min(5, n_items)):\n        item1 = sorted_items1[i]\n        item2 = sorted_items2[i]\n\n        if new_solution[item1] == 0 and new_solution[item2] == 1:\n            # Swap item1 (included) and item2 (excluded)\n            new_weight = current_weight - weight_lst[item2] + weight_lst[item1]\n            if new_weight <= capacity:\n                new_solution[item1] = 1\n                new_solution[item2] = 0\n                current_weight = new_weight\n                break\n\n    # Step 2: Random perturbations to escape local optima\n    if random.random() < 0.3:\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            item_to_remove = random.choice(candidates)\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n            # Add a random item not in the solution\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                item_to_add = random.choice(candidates)\n                if current_weight + weight_lst[item_to_add] <= capacity:\n                    new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7478885974589876,
            3.246992975473404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n\n    # Prioritize solutions that are not too close to the mean in either objective\n    distances = np.abs(objectives - mean_obj) / (std_obj + 1e-8)\n    scores = np.max(distances, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: swap items with high value ratios or random perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Value-based swaps (prioritize items with high value/weight ratios)\n    value_ratios1 = value1_lst / (weight_lst + 1e-8)\n    value_ratios2 = value2_lst / (weight_lst + 1e-8)\n\n    # Sort items by value ratios (descending)\n    sorted_items1 = np.argsort(value_ratios1)[::-1]\n    sorted_items2 = np.argsort(value_ratios2)[::-1]\n\n    # Try swapping items between included and excluded\n    for i in range(min(5, n_items)):\n        item1 = sorted_items1[i]\n        item2 = sorted_items2[i]\n\n        if new_solution[item1] == 0 and new_solution[item2] == 1:\n            # Swap item1 (included) and item2 (excluded)\n            new_weight = current_weight - weight_lst[item2] + weight_lst[item1]\n            if new_weight <= capacity:\n                new_solution[item1] = 1\n                new_solution[item2] = 0\n                current_weight = new_weight\n                break\n\n    # Step 2: Random perturbations to escape local optima\n    if random.random() < 0.3:\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            item_to_remove = random.choice(candidates)\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n            # Add a random item not in the solution\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                item_to_add = random.choice(candidates)\n                if current_weight + weight_lst[item_to_add] <= capacity:\n                    new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search that combines randomized item swaps with a dynamic neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the solution with the highest sum of objectives)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    num_items = len(base_solution)\n\n    # Randomly select a subset of items to perturb\n    perturb_size = max(1, int(0.2 * num_items))  # Perturb 20% of items\n    perturb_indices = random.sample(range(num_items), perturb_size)\n\n    for idx in perturb_indices:\n        # Try flipping the item (add if not present, remove if present)\n        if new_solution[idx] == 1:\n            # Remove the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Add the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Apply a dynamic neighborhood exploration (swap two items)\n    if num_items >= 2:\n        swap_indices = random.sample(range(num_items), 2)\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            # Swap the items\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = current_weight + (weight_lst[j] - weight_lst[i]) * (2 * new_solution[i] - 1)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.3263558733171413,
            1.550494521856308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the solution with the highest sum of objectives)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    num_items = len(base_solution)\n\n    # Randomly select a subset of items to perturb\n    perturb_size = max(1, int(0.2 * num_items))  # Perturb 20% of items\n    perturb_indices = random.sample(range(num_items), perturb_size)\n\n    for idx in perturb_indices:\n        # Try flipping the item (add if not present, remove if present)\n        if new_solution[idx] == 1:\n            # Remove the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Add the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Apply a dynamic neighborhood exploration (swap two items)\n    if num_items >= 2:\n        swap_indices = random.sample(range(num_items), 2)\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            # Swap the items\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = current_weight + (weight_lst[j] - weight_lst[i]) * (2 * new_solution[i] - 1)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive item swapping with probabilistic neighborhood exploration to intelligently select and perturb promising solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Rank solutions by their potential for improvement\n    def potential_score(solution):\n        total_weight = np.sum(weight_lst[solution == 1])\n        total_value1 = np.sum(value1_lst[solution == 1])\n        total_value2 = np.sum(value2_lst[solution == 1])\n        # Potential is high if the solution is not full and has room for improvement\n        return (capacity - total_weight) * (total_value1 + total_value2)\n\n    scored_solutions = [(potential_score(sol[0]), sol[0]) for sol in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    selected_solution = scored_solutions[0][1].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swap\n    swap_candidates = random.sample(range(n_items), min(10, n_items))\n\n    # Step 2: For each candidate, decide to swap based on probabilistic criteria\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try to remove the item if it's not critical\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try to add the item if it improves the solution\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Accept with probability based on value improvement\n                current_value = np.sum(value1_lst[new_solution == 1]) + np.sum(value2_lst[new_solution == 1])\n                new_value = np.sum(value1_lst[temp_solution == 1]) + np.sum(value2_lst[temp_solution == 1])\n                if new_value > current_value and random.random() < 0.7:\n                    new_solution = temp_solution\n\n    # Step 3: Perform a local search in the neighborhood of the new solution\n    for _ in range(3):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.47262792544460624,
            5.370491325855255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Rank solutions by their potential for improvement\n    def potential_score(solution):\n        total_weight = np.sum(weight_lst[solution == 1])\n        total_value1 = np.sum(value1_lst[solution == 1])\n        total_value2 = np.sum(value2_lst[solution == 1])\n        # Potential is high if the solution is not full and has room for improvement\n        return (capacity - total_weight) * (total_value1 + total_value2)\n\n    scored_solutions = [(potential_score(sol[0]), sol[0]) for sol in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    selected_solution = scored_solutions[0][1].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swap\n    swap_candidates = random.sample(range(n_items), min(10, n_items))\n\n    # Step 2: For each candidate, decide to swap based on probabilistic criteria\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try to remove the item if it's not critical\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try to add the item if it improves the solution\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Accept with probability based on value improvement\n                current_value = np.sum(value1_lst[new_solution == 1]) + np.sum(value2_lst[new_solution == 1])\n                new_value = np.sum(value1_lst[temp_solution == 1]) + np.sum(value2_lst[temp_solution == 1])\n                if new_value > current_value and random.random() < 0.7:\n                    new_solution = temp_solution\n\n    # Step 3: Perform a local search in the neighborhood of the new solution\n    for _ in range(3):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A novel hybrid local search operator combines adaptive item swapping and probabilistic item flipping, guided by a dynamic objective-weighted utility function to intelligently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (1 + np.sum(sol[0])) for sol in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Dynamic objective weights based on current archive diversity\n    obj1_weights = np.array([sol[1][0] for sol in archive])\n    obj2_weights = np.array([sol[1][1] for sol in archive])\n    obj1_weight = np.std(obj1_weights) / (np.mean(obj1_weights) + 1e-6)\n    obj2_weight = np.std(obj2_weights) / (np.mean(obj2_weights) + 1e-6)\n\n    # Hybrid local search: adaptive swapping and probabilistic flipping\n    for _ in range(5):  # Limit the number of attempts\n        # Adaptive swapping\n        if np.random.rand() < 0.7:\n            items_in = np.where(base_solution == 1)[0]\n            items_out = np.where(base_solution == 0)[0]\n            if len(items_in) > 0 and len(items_out) > 0:\n                swap_in = random.choice(items_in)\n                swap_out = random.choice(items_out)\n                temp_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n                if temp_weight <= capacity:\n                    new_solution[swap_in], new_solution[swap_out] = 0, 1\n                    current_weight = temp_weight\n                    continue\n\n        # Probabilistic flipping with objective-weighted utility\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                utility = (obj1_weight * value1_lst[i] + obj2_weight * value2_lst[i]) / (weight_lst[i] + 1e-6)\n                if np.random.rand() < 0.3 / (1 + utility):\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                utility = (obj1_weight * value1_lst[i] + obj2_weight * value2_lst[i]) / (weight_lst[i] + 1e-6)\n                if np.random.rand() < 0.3 * utility and (current_weight + weight_lst[i] <= capacity):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.43562183037206437,
            7.126275390386581
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (1 + np.sum(sol[0])) for sol in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Dynamic objective weights based on current archive diversity\n    obj1_weights = np.array([sol[1][0] for sol in archive])\n    obj2_weights = np.array([sol[1][1] for sol in archive])\n    obj1_weight = np.std(obj1_weights) / (np.mean(obj1_weights) + 1e-6)\n    obj2_weight = np.std(obj2_weights) / (np.mean(obj2_weights) + 1e-6)\n\n    # Hybrid local search: adaptive swapping and probabilistic flipping\n    for _ in range(5):  # Limit the number of attempts\n        # Adaptive swapping\n        if np.random.rand() < 0.7:\n            items_in = np.where(base_solution == 1)[0]\n            items_out = np.where(base_solution == 0)[0]\n            if len(items_in) > 0 and len(items_out) > 0:\n                swap_in = random.choice(items_in)\n                swap_out = random.choice(items_out)\n                temp_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n                if temp_weight <= capacity:\n                    new_solution[swap_in], new_solution[swap_out] = 0, 1\n                    current_weight = temp_weight\n                    continue\n\n        # Probabilistic flipping with objective-weighted utility\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                utility = (obj1_weight * value1_lst[i] + obj2_weight * value2_lst[i]) / (weight_lst[i] + 1e-6)\n                if np.random.rand() < 0.3 / (1 + utility):\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                utility = (obj1_weight * value1_lst[i] + obj2_weight * value2_lst[i]) / (weight_lst[i] + 1e-6)\n                if np.random.rand() < 0.3 * utility and (current_weight + weight_lst[i] <= capacity):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted random selection favoring solutions with higher objective values, then applies a hybrid local search combining random flipping of items with high marginal utility and a guided perturbation to explore nearby feasible solutions while maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with weighted randomness favoring higher objective values\n    weights = [obj1 + obj2 for _, (obj1, obj2) in archive]\n    total = sum(weights)\n    probs = [w / total for w in weights]\n    base_solution, _ = random.choices(archive, weights=probs)[0]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal utility for each item\n    marginal1 = value1_lst - (value1_lst * new_solution)\n    marginal2 = value2_lst - (value2_lst * new_solution)\n    marginal_utility = marginal1 + marginal2\n\n    # Identify items that can be added without exceeding capacity\n    feasible_add = (weight_lst <= (capacity - current_weight)) & (new_solution == 0)\n    feasible_remove = (new_solution == 1)\n\n    # Hybrid local search: flip items with high marginal utility or random flip\n    for _ in range(min(5, len(weight_lst))):  # Limit number of flips\n        if np.random.rand() < 0.7:  # 70% chance to flip high marginal utility item\n            if np.any(feasible_add):\n                candidates = np.where(feasible_add)[0]\n                best_candidate = candidates[np.argmax(marginal_utility[candidates])]\n                new_solution[best_candidate] = 1\n                current_weight += weight_lst[best_candidate]\n                feasible_add = (weight_lst <= (capacity - current_weight)) & (new_solution == 0)\n            elif np.any(feasible_remove):\n                candidates = np.where(feasible_remove)[0]\n                worst_candidate = candidates[np.argmin(marginal_utility[candidates])]\n                new_solution[worst_candidate] = 0\n                current_weight -= weight_lst[worst_candidate]\n                feasible_add = (weight_lst <= (capacity - current_weight)) & (new_solution == 0)\n        else:  # 30% chance for guided perturbation\n            if np.random.rand() < 0.5 and np.any(feasible_add):\n                candidate = np.random.choice(np.where(feasible_add)[0])\n                new_solution[candidate] = 1\n                current_weight += weight_lst[candidate]\n                feasible_add = (weight_lst <= (capacity - current_weight)) & (new_solution == 0)\n            elif np.any(feasible_remove):\n                candidate = np.random.choice(np.where(feasible_remove)[0])\n                new_solution[candidate] = 0\n                current_weight -= weight_lst[candidate]\n                feasible_add = (weight_lst <= (capacity - current_weight)) & (new_solution == 0)\n\n    return new_solution\n\n",
        "score": [
            -0.3413027086109412,
            3.3500677049160004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with weighted randomness favoring higher objective values\n    weights = [obj1 + obj2 for _, (obj1, obj2) in archive]\n    total = sum(weights)\n    probs = [w / total for w in weights]\n    base_solution, _ = random.choices(archive, weights=probs)[0]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal utility for each item\n    marginal1 = value1_lst - (value1_lst * new_solution)\n    marginal2 = value2_lst - (value2_lst * new_solution)\n    marginal_utility = marginal1 + marginal2\n\n    # Identify items that can be added without exceeding capacity\n    feasible_add = (weight_lst <= (capacity - current_weight)) & (new_solution == 0)\n    feasible_remove = (new_solution == 1)\n\n    # Hybrid local search: flip items with high marginal utility or random flip\n    for _ in range(min(5, len(weight_lst))):  # Limit number of flips\n        if np.random.rand() < 0.7:  # 70% chance to flip high marginal utility item\n            if np.any(feasible_add):\n                candidates = np.where(feasible_add)[0]\n                best_candidate = candidates[np.argmax(marginal_utility[candidates])]\n                new_solution[best_candidate] = 1\n                current_weight += weight_lst[best_candidate]\n                feasible_add = (weight_lst <= (capacity - current_weight)) & (new_solution == 0)\n            elif np.any(feasible_remove):\n                candidates = np.where(feasible_remove)[0]\n                worst_candidate = candidates[np.argmin(marginal_utility[candidates])]\n                new_solution[worst_candidate] = 0\n                current_weight -= weight_lst[worst_candidate]\n                feasible_add = (weight_lst <= (capacity - current_weight)) & (new_solution == 0)\n        else:  # 30% chance for guided perturbation\n            if np.random.rand() < 0.5 and np.any(feasible_add):\n                candidate = np.random.choice(np.where(feasible_add)[0])\n                new_solution[candidate] = 1\n                current_weight += weight_lst[candidate]\n                feasible_add = (weight_lst <= (capacity - current_weight)) & (new_solution == 0)\n            elif np.any(feasible_remove):\n                candidate = np.random.choice(np.where(feasible_remove)[0])\n                new_solution[candidate] = 0\n                current_weight -= weight_lst[candidate]\n                feasible_add = (weight_lst <= (capacity - current_weight)) & (new_solution == 0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{The heuristic algorithm selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search strategy combining random item swaps and greedy value-based flips to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: random swaps + greedy flips\n    new_solution = base_solution.copy()\n\n    # Random swaps (exploration)\n    for _ in range(3):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Greedy flips (exploitation)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding item i\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Randomly remove items until feasible\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        item_to_remove = random.choice(items_in)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4775314696006052,
            2.4787729680538177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: random swaps + greedy flips\n    new_solution = base_solution.copy()\n\n    # Random swaps (exploration)\n    for _ in range(3):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Greedy flips (exploitation)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding item i\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Randomly remove items until feasible\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        item_to_remove = random.choice(items_in)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    # Strategy: Randomly select a subset of items and perform a swap-and-replace operation\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    subset_size = max(1, int(np.sqrt(n_items)))  # Subset size proportional to sqrt of items\n    subset_indices = np.random.choice(n_items, subset_size, replace=False)\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for removal\n    remove_indices = subset_indices[:len(subset_indices)//2]\n    # Randomly select a subset of items to consider for addition\n    add_indices = subset_indices[len(subset_indices)//2:]\n\n    # Remove selected items (if feasible)\n    for idx in remove_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Add items until capacity is reached or no more items left\n    np.random.shuffle(add_indices)\n    for idx in add_indices:\n        if new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3742669300404684,
            2.5609576404094696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    # Strategy: Randomly select a subset of items and perform a swap-and-replace operation\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    subset_size = max(1, int(np.sqrt(n_items)))  # Subset size proportional to sqrt of items\n    subset_indices = np.random.choice(n_items, subset_size, replace=False)\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for removal\n    remove_indices = subset_indices[:len(subset_indices)//2]\n    # Randomly select a subset of items to consider for addition\n    add_indices = subset_indices[len(subset_indices)//2:]\n\n    # Remove selected items (if feasible)\n    for idx in remove_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Add items until capacity is reached or no more items left\n    np.random.shuffle(add_indices)\n    for idx in add_indices:\n        if new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{A novel local search algorithm that intelligently selects a promising solution from the archive, performs a hybrid of item swaps and probabilistic flips to explore the solution space while ensuring feasibility, and balances exploration of both objectives through adaptive selection criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a hybrid of diversity and objective values\n    selected_idx = random.choices(range(len(archive)), weights=[\n        (1 - (sol[1][0] + sol[1][1]) / (sum(value1_lst) + sum(value2_lst))) * random.uniform(0.5, 1.5)\n        for sol in archive\n    ])[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search: probabilistic item flips and targeted swaps\n    for _ in range(max(1, len(base_solution) // 5)):\n        if random.random() < 0.7:  # Probabilistic flip\n            idx = random.randint(0, len(base_solution) - 1)\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    current_value1 -= value1_lst[idx]\n                    current_value2 -= value2_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    current_value1 += value1_lst[idx]\n                    current_value2 += value2_lst[idx]\n        else:  # Targeted swap\n            if len(base_solution) > 1:\n                i, j = random.sample(range(len(base_solution)), 2)\n                if base_solution[i] != base_solution[j]:\n                    if base_solution[i] == 1:\n                        delta_weight = -weight_lst[i] + weight_lst[j]\n                    else:\n                        delta_weight = weight_lst[i] - weight_lst[j]\n\n                    if current_weight + delta_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight += delta_weight\n                        current_value1 += (value1_lst[j] - value1_lst[i]) if base_solution[i] == 1 else (value1_lst[i] - value1_lst[j])\n                        current_value2 += (value2_lst[j] - value2_lst[i]) if base_solution[i] == 1 else (value2_lst[i] - value2_lst[j])\n\n    return new_solution\n\n",
        "score": [
            -0.4872693794338367,
            5.661261945962906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a hybrid of diversity and objective values\n    selected_idx = random.choices(range(len(archive)), weights=[\n        (1 - (sol[1][0] + sol[1][1]) / (sum(value1_lst) + sum(value2_lst))) * random.uniform(0.5, 1.5)\n        for sol in archive\n    ])[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search: probabilistic item flips and targeted swaps\n    for _ in range(max(1, len(base_solution) // 5)):\n        if random.random() < 0.7:  # Probabilistic flip\n            idx = random.randint(0, len(base_solution) - 1)\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    current_value1 -= value1_lst[idx]\n                    current_value2 -= value2_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    current_value1 += value1_lst[idx]\n                    current_value2 += value2_lst[idx]\n        else:  # Targeted swap\n            if len(base_solution) > 1:\n                i, j = random.sample(range(len(base_solution)), 2)\n                if base_solution[i] != base_solution[j]:\n                    if base_solution[i] == 1:\n                        delta_weight = -weight_lst[i] + weight_lst[j]\n                    else:\n                        delta_weight = weight_lst[i] - weight_lst[j]\n\n                    if current_weight + delta_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight += delta_weight\n                        current_value1 += (value1_lst[j] - value1_lst[i]) if base_solution[i] == 1 else (value1_lst[i] - value1_lst[j])\n                        current_value2 += (value2_lst[j] - value2_lst[i]) if base_solution[i] == 1 else (value2_lst[i] - value2_lst[j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines random swaps of high-margin items with objective-specific perturbations to explore the solution space while ensuring feasibility, prioritizing solutions with high potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a promising solution based on potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator\n    # Step 1: Randomly select items with high marginal contribution\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Calculate marginal values for included items\n    if len(included) > 0:\n        marginal_val1 = value1_lst[included] / weight_lst[included]\n        marginal_val2 = value2_lst[included] / weight_lst[included]\n        high_marginal_included = included[np.argsort(-(marginal_val1 + marginal_val2))[:max(1, len(included) // 3)]]\n\n        # Randomly swap some high-marginal items\n        for item in high_marginal_included:\n            if random.random() < 0.3:  # 30% chance to swap\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Step 2: Randomly add items with high potential\n    if len(excluded) > 0:\n        marginal_val1 = value1_lst[excluded] / weight_lst[excluded]\n        marginal_val2 = value2_lst[excluded] / weight_lst[excluded]\n        high_marginal_excluded = excluded[np.argsort(-(marginal_val1 + marginal_val2))[:max(1, len(excluded) // 3)]]\n\n        # Randomly add some high-marginal items\n        for item in high_marginal_excluded:\n            if random.random() < 0.3 and (current_weight + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 3: Objective-specific perturbation\n    if random.random() < 0.5:  # 50% chance to focus on value1\n        # Find items that can improve value1 without violating capacity\n        potential_items = np.where((base_solution == 0) &\n                                 (weight_lst <= (capacity - current_weight)))[0]\n        if len(potential_items) > 0:\n            best_item = potential_items[np.argmax(value1_lst[potential_items])]\n            new_solution[best_item] = 1\n    else:  # Focus on value2\n        # Find items that can improve value2 without violating capacity\n        potential_items = np.where((base_solution == 0) &\n                                 (weight_lst <= (capacity - current_weight)))[0]\n        if len(potential_items) > 0:\n            best_item = potential_items[np.argmax(value2_lst[potential_items])]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.41292260193388486,
            1.3519352674484253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a promising solution based on potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator\n    # Step 1: Randomly select items with high marginal contribution\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Calculate marginal values for included items\n    if len(included) > 0:\n        marginal_val1 = value1_lst[included] / weight_lst[included]\n        marginal_val2 = value2_lst[included] / weight_lst[included]\n        high_marginal_included = included[np.argsort(-(marginal_val1 + marginal_val2))[:max(1, len(included) // 3)]]\n\n        # Randomly swap some high-marginal items\n        for item in high_marginal_included:\n            if random.random() < 0.3:  # 30% chance to swap\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Step 2: Randomly add items with high potential\n    if len(excluded) > 0:\n        marginal_val1 = value1_lst[excluded] / weight_lst[excluded]\n        marginal_val2 = value2_lst[excluded] / weight_lst[excluded]\n        high_marginal_excluded = excluded[np.argsort(-(marginal_val1 + marginal_val2))[:max(1, len(excluded) // 3)]]\n\n        # Randomly add some high-marginal items\n        for item in high_marginal_excluded:\n            if random.random() < 0.3 and (current_weight + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 3: Objective-specific perturbation\n    if random.random() < 0.5:  # 50% chance to focus on value1\n        # Find items that can improve value1 without violating capacity\n        potential_items = np.where((base_solution == 0) &\n                                 (weight_lst <= (capacity - current_weight)))[0]\n        if len(potential_items) > 0:\n            best_item = potential_items[np.argmax(value1_lst[potential_items])]\n            new_solution[best_item] = 1\n    else:  # Focus on value2\n        # Find items that can improve value2 without violating capacity\n        potential_items = np.where((base_solution == 0) &\n                                 (weight_lst <= (capacity - current_weight)))[0]\n        if len(potential_items) > 0:\n            best_item = potential_items[np.argmax(value2_lst[potential_items])]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive based on both objective values and weight utilization, then applies a multi-step perturbation (flipping items with high marginal gains in both objectives) followed by a greedy repair to ensure feasibility, while balancing exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # We prioritize solutions that are not already at the Pareto front and have room for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that could be flipped (either included or excluded)\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 0)[0]\n\n    # Calculate marginal gains for each candidate item\n    marginal_gains = []\n    for item in candidate_items:\n        if base_solution[item] == 1:\n            # If item is included, calculate gain if removed\n            new_weight = current_weight - weight_lst[item]\n            gain1 = -value1_lst[item]\n            gain2 = -value2_lst[item]\n        else:\n            # If item is excluded, calculate gain if added (must ensure feasibility)\n            new_weight = current_weight + weight_lst[item]\n            if new_weight > capacity:\n                continue  # Skip if adding would make infeasible\n            gain1 = value1_lst[item]\n            gain2 = value2_lst[item]\n\n        # Normalize gains by weight to balance both objectives\n        normalized_gain = (gain1 / (value1_lst[item] + 1e-6)) + (gain2 / (value2_lst[item] + 1e-6))\n        marginal_gains.append((item, normalized_gain))\n\n    if not marginal_gains:\n        # If no valid candidates found, just flip a random item (with feasibility check)\n        item = np.random.choice(len(base_solution))\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                base_solution[item] = 0\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                base_solution[item] = 1\n        return base_solution\n\n    # Sort candidates by marginal gain (descending)\n    marginal_gains.sort(key=lambda x: -x[1])\n\n    # Apply multi-step perturbation: flip top 20% of candidates (with feasibility check)\n    num_to_flip = max(1, int(0.2 * len(marginal_gains)))\n    flipped_items = []\n    for i in range(num_to_flip):\n        item, _ = marginal_gains[i]\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                base_solution[item] = 0\n                current_weight -= weight_lst[item]\n                flipped_items.append(item)\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                base_solution[item] = 1\n                current_weight += weight_lst[item]\n                flipped_items.append(item)\n\n    # Greedy repair: if solution is still infeasible, remove items until feasible\n    while current_weight > capacity:\n        # Find the item with the smallest ratio of (gain1 + gain2) / weight\n        ratios = []\n        for item in np.where(base_solution == 1)[0]:\n            ratio = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-6)\n            ratios.append((item, ratio))\n\n        if not ratios:\n            break  # No items left to remove\n\n        # Remove the item with the smallest ratio\n        item_to_remove = min(ratios, key=lambda x: x[1])[0]\n        base_solution[item_to_remove] = 0\n        current_weight -= weight_lst[item_to_remove]\n\n    return base_solution\n\n",
        "score": [
            -0.8629419075219502,
            1.6429675817489624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # We prioritize solutions that are not already at the Pareto front and have room for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that could be flipped (either included or excluded)\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 0)[0]\n\n    # Calculate marginal gains for each candidate item\n    marginal_gains = []\n    for item in candidate_items:\n        if base_solution[item] == 1:\n            # If item is included, calculate gain if removed\n            new_weight = current_weight - weight_lst[item]\n            gain1 = -value1_lst[item]\n            gain2 = -value2_lst[item]\n        else:\n            # If item is excluded, calculate gain if added (must ensure feasibility)\n            new_weight = current_weight + weight_lst[item]\n            if new_weight > capacity:\n                continue  # Skip if adding would make infeasible\n            gain1 = value1_lst[item]\n            gain2 = value2_lst[item]\n\n        # Normalize gains by weight to balance both objectives\n        normalized_gain = (gain1 / (value1_lst[item] + 1e-6)) + (gain2 / (value2_lst[item] + 1e-6))\n        marginal_gains.append((item, normalized_gain))\n\n    if not marginal_gains:\n        # If no valid candidates found, just flip a random item (with feasibility check)\n        item = np.random.choice(len(base_solution))\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                base_solution[item] = 0\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                base_solution[item] = 1\n        return base_solution\n\n    # Sort candidates by marginal gain (descending)\n    marginal_gains.sort(key=lambda x: -x[1])\n\n    # Apply multi-step perturbation: flip top 20% of candidates (with feasibility check)\n    num_to_flip = max(1, int(0.2 * len(marginal_gains)))\n    flipped_items = []\n    for i in range(num_to_flip):\n        item, _ = marginal_gains[i]\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                base_solution[item] = 0\n                current_weight -= weight_lst[item]\n                flipped_items.append(item)\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                base_solution[item] = 1\n                current_weight += weight_lst[item]\n                flipped_items.append(item)\n\n    # Greedy repair: if solution is still infeasible, remove items until feasible\n    while current_weight > capacity:\n        # Find the item with the smallest ratio of (gain1 + gain2) / weight\n        ratios = []\n        for item in np.where(base_solution == 1)[0]:\n            ratio = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-6)\n            ratios.append((item, ratio))\n\n        if not ratios:\n            break  # No items left to remove\n\n        # Remove the item with the smallest ratio\n        item_to_remove = min(ratios, key=lambda x: x[1])[0]\n        base_solution[item_to_remove] = 0\n        current_weight -= weight_lst[item_to_remove]\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement by considering both objective values and then applies a hybrid local search strategy that combines item swapping with a probabilistic flip mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with higher combined objective values\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        selected_idx = random.choice([0, 1]) if len(archive_sorted) >= 2 else 0\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swapping and probabilistic flip\n    # Step 1: Randomly select two items and swap their inclusion status\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistically flip items to explore new regions\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                # Check if removing the item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility by removing random items if capacity exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        item_to_remove = random.choice(items_in)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3690858015547416,
            2.7932418286800385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with higher combined objective values\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        selected_idx = random.choice([0, 1]) if len(archive_sorted) >= 2 else 0\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swapping and probabilistic flip\n    # Step 1: Randomly select two items and swap their inclusion status\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistically flip items to explore new regions\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                # Check if removing the item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility by removing random items if capacity exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        item_to_remove = random.choice(items_in)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive and applies a combination of item removal, addition, and perturbation to generate a neighbor solution, ensuring feasibility and potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Step 1: Randomly remove some items (up to 30% of items in)\n    if len(items_in) > 0:\n        num_to_remove = min(len(items_in), max(1, int(0.3 * len(items_in))))\n        items_to_remove = random.sample(list(items_in), num_to_remove)\n        new_solution[items_to_remove] = 0\n        current_weight -= np.sum(weight_lst[items_to_remove])\n\n    # Step 2: Randomly add items (up to 30% of items out) that don't exceed capacity\n    if len(items_out) > 0 and current_weight < capacity:\n        max_add = max(1, int(0.3 * len(items_out)))\n        items_to_try = random.sample(list(items_out), min(len(items_out), max_add))\n        for item in items_to_try:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 3: Perturbation - flip a random item to explore different regions\n    if len(items_in) + len(items_out) > 0:\n        all_items = np.arange(len(weight_lst))\n        random_item = random.choice(all_items)\n        if new_solution[random_item] == 1:\n            if current_weight - weight_lst[random_item] >= 0:\n                new_solution[random_item] = 0\n        else:\n            if current_weight + weight_lst[random_item] <= capacity:\n                new_solution[random_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4462175526473361,
            1.7785567045211792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Step 1: Randomly remove some items (up to 30% of items in)\n    if len(items_in) > 0:\n        num_to_remove = min(len(items_in), max(1, int(0.3 * len(items_in))))\n        items_to_remove = random.sample(list(items_in), num_to_remove)\n        new_solution[items_to_remove] = 0\n        current_weight -= np.sum(weight_lst[items_to_remove])\n\n    # Step 2: Randomly add items (up to 30% of items out) that don't exceed capacity\n    if len(items_out) > 0 and current_weight < capacity:\n        max_add = max(1, int(0.3 * len(items_out)))\n        items_to_try = random.sample(list(items_out), min(len(items_out), max_add))\n        for item in items_to_try:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 3: Perturbation - flip a random item to explore different regions\n    if len(items_in) + len(items_out) > 0:\n        all_items = np.arange(len(weight_lst))\n        random_item = random.choice(all_items)\n        if new_solution[random_item] == 1:\n            if current_weight - weight_lst[random_item] >= 0:\n                new_solution[random_item] = 0\n        else:\n            if current_weight + weight_lst[random_item] <= capacity:\n                new_solution[random_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{A novel hybrid local search algorithm that combines probabilistic item exchange with a fitness-based neighborhood exploration to generate high-quality neighbors by intelligently selecting items to swap or flip, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic exchange with fitness-based selection\n    for _ in range(5):  # Number of attempts to find a better neighbor\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Calculate potential changes\n        if new_solution[item1] == 1 and new_solution[item2] == 0:\n            delta_weight = weight_lst[item2] - weight_lst[item1]\n            delta_value1 = value1_lst[item2] - value1_lst[item1]\n            delta_value2 = value2_lst[item2] - value2_lst[item1]\n        elif new_solution[item1] == 0 and new_solution[item2] == 1:\n            delta_weight = weight_lst[item1] - weight_lst[item2]\n            delta_value1 = value1_lst[item1] - value1_lst[item2]\n            delta_value2 = value2_lst[item1] - value2_lst[item2]\n        else:\n            continue  # No change in weight or values\n\n        # Check feasibility and fitness improvement\n        if (current_weight + delta_weight <= capacity) and (delta_value1 > 0 or delta_value2 > 0):\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight += delta_weight\n            current_value1 += delta_value1\n            current_value2 += delta_value2\n\n    # Additional probabilistic flip for diversification\n    if random.random() < 0.3:\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5157283110845137,
            2.1754476726055145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic exchange with fitness-based selection\n    for _ in range(5):  # Number of attempts to find a better neighbor\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Calculate potential changes\n        if new_solution[item1] == 1 and new_solution[item2] == 0:\n            delta_weight = weight_lst[item2] - weight_lst[item1]\n            delta_value1 = value1_lst[item2] - value1_lst[item1]\n            delta_value2 = value2_lst[item2] - value2_lst[item1]\n        elif new_solution[item1] == 0 and new_solution[item2] == 1:\n            delta_weight = weight_lst[item1] - weight_lst[item2]\n            delta_value1 = value1_lst[item1] - value1_lst[item2]\n            delta_value2 = value2_lst[item1] - value2_lst[item2]\n        else:\n            continue  # No change in weight or values\n\n        # Check feasibility and fitness improvement\n        if (current_weight + delta_weight <= capacity) and (delta_value1 > 0 or delta_value2 > 0):\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight += delta_weight\n            current_value1 += delta_value1\n            current_value2 += delta_value2\n\n    # Additional probabilistic flip for diversification\n    if random.random() < 0.3:\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining item swaps and random flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Sort solutions by normalized objective values and weight utilization\n    def score(solution_obj):\n        v1, v2 = solution_obj[1]\n        total_weight = np.sum(weight_lst * solution_obj[0])\n        norm_v1 = v1 / (np.sum(value1_lst) + 1e-10)\n        norm_v2 = v2 / (np.sum(value2_lst) + 1e-10)\n        utilization = total_weight / capacity\n        return (norm_v1 + norm_v2) * (1 - utilization)\n\n    scored_solutions = [(sol, obj, score((sol, obj))) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[2], reverse=True)\n\n    # Select top 20% of solutions and pick one randomly\n    top_k = max(1, len(scored_solutions) // 5)\n    selected = random.choice(scored_solutions[:top_k])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: swap items if beneficial, otherwise random flip\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Try swapping items between included and excluded\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select items to swap\n        i = random.choice(included)\n        j = random.choice(excluded)\n\n        # Check if swapping improves at least one objective\n        current_weight = np.sum(weight_lst * new_solution)\n        new_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n        if new_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # If swap is invalid, try random flip\n            k = random.randint(0, n_items - 1)\n            if new_solution[k] == 1 and (current_weight - weight_lst[k]) <= capacity:\n                new_solution[k] = 0\n            elif new_solution[k] == 0 and (current_weight + weight_lst[k]) <= capacity:\n                new_solution[k] = 1\n\n    # If no swap/flip was performed, randomly flip one item if possible\n    if np.array_equal(new_solution, base_solution):\n        k = random.randint(0, n_items - 1)\n        current_weight = np.sum(weight_lst * new_solution)\n        if new_solution[k] == 1 and (current_weight - weight_lst[k]) <= capacity:\n            new_solution[k] = 0\n        elif new_solution[k] == 0 and (current_weight + weight_lst[k]) <= capacity:\n            new_solution[k] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5091154039141137,
            4.9741537272930145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Sort solutions by normalized objective values and weight utilization\n    def score(solution_obj):\n        v1, v2 = solution_obj[1]\n        total_weight = np.sum(weight_lst * solution_obj[0])\n        norm_v1 = v1 / (np.sum(value1_lst) + 1e-10)\n        norm_v2 = v2 / (np.sum(value2_lst) + 1e-10)\n        utilization = total_weight / capacity\n        return (norm_v1 + norm_v2) * (1 - utilization)\n\n    scored_solutions = [(sol, obj, score((sol, obj))) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[2], reverse=True)\n\n    # Select top 20% of solutions and pick one randomly\n    top_k = max(1, len(scored_solutions) // 5)\n    selected = random.choice(scored_solutions[:top_k])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: swap items if beneficial, otherwise random flip\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Try swapping items between included and excluded\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select items to swap\n        i = random.choice(included)\n        j = random.choice(excluded)\n\n        # Check if swapping improves at least one objective\n        current_weight = np.sum(weight_lst * new_solution)\n        new_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n        if new_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # If swap is invalid, try random flip\n            k = random.randint(0, n_items - 1)\n            if new_solution[k] == 1 and (current_weight - weight_lst[k]) <= capacity:\n                new_solution[k] = 0\n            elif new_solution[k] == 0 and (current_weight + weight_lst[k]) <= capacity:\n                new_solution[k] = 1\n\n    # If no swap/flip was performed, randomly flip one item if possible\n    if np.array_equal(new_solution, base_solution):\n        k = random.randint(0, n_items - 1)\n        current_weight = np.sum(weight_lst * new_solution)\n        if new_solution[k] == 1 and (current_weight - weight_lst[k]) <= capacity:\n            new_solution[k] = 0\n        elif new_solution[k] == 0 and (current_weight + weight_lst[k]) <= capacity:\n            new_solution[k] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with probabilistic item flipping, guided by a diversity-aware objective space analysis to intelligently explore the solution landscape while ensuring feasibility and promoting high-quality multi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Adaptive item swapping (focus on high-value items)\n    high_value_items = np.argsort(value1_lst + value2_lst)[-len(base_solution)//2:]\n    for i in high_value_items:\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif base_solution[i] == 1 and current_weight - weight_lst[i] >= 0:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 2: Probabilistic item flipping (focus on items with high marginal gain)\n    marginal_gain1 = value1_lst / weight_lst\n    marginal_gain2 = value2_lst / weight_lst\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    for i in range(len(base_solution)):\n        if random.random() < 0.3:  # 30% chance to flip\n            if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif base_solution[i] == 1 and current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 3: Ensure feasibility (if not already, force it)\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random item until feasible\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        remove_idx = random.choice(included_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5234615322071802,
            2.657575339078903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Adaptive item swapping (focus on high-value items)\n    high_value_items = np.argsort(value1_lst + value2_lst)[-len(base_solution)//2:]\n    for i in high_value_items:\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif base_solution[i] == 1 and current_weight - weight_lst[i] >= 0:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 2: Probabilistic item flipping (focus on items with high marginal gain)\n    marginal_gain1 = value1_lst / weight_lst\n    marginal_gain2 = value2_lst / weight_lst\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    for i in range(len(base_solution)):\n        if random.random() < 0.3:  # 30% chance to flip\n            if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif base_solution[i] == 1 and current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 3: Ensure feasibility (if not already, force it)\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random item until feasible\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        remove_idx = random.choice(included_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Find items that can be added (not in solution and weight <= remaining capacity)\n        addable_items = np.where((sol == 0) & (weight_lst <= remaining_capacity))[0]\n        # Find items that can be removed (in solution)\n        removable_items = np.where(sol == 1)[0]\n        if len(addable_items) > 0 or len(removable_items) > 0:\n            candidates.append((sol, obj, addable_items, removable_items))\n\n    if not candidates:\n        # If no candidates, return a random solution\n        return archive[np.random.randint(len(archive))][0].copy()\n\n    # Step 2: Select a candidate with high potential for improvement\n    # Criteria: Prefer solutions with high marginal value potential\n    selected_sol, _, addable_items, removable_items = max(\n        candidates,\n        key=lambda x: (\n            np.sum(value1_lst[x[2]] + value2_lst[x[2]]) if len(x[2]) > 0 else 0,\n            np.sum(value1_lst[x[3]] + value2_lst[x[3]]) if len(x[3]) > 0 else 0\n        )\n    )\n\n    # Step 3: Apply a novel hybrid local search operator\n    new_solution = selected_sol.copy()\n\n    # Operator 1: Randomly add an item if possible\n    if len(addable_items) > 0:\n        item_to_add = np.random.choice(addable_items)\n        new_solution[item_to_add] = 1\n        current_weight = np.sum(weight_lst * new_solution)\n        # If adding causes overcapacity, remove the heaviest item\n        if current_weight > capacity:\n            items_in_solution = np.where(new_solution == 1)[0]\n            if len(items_in_solution) > 0:\n                heaviest_item = items_in_solution[np.argmax(weight_lst[items_in_solution])]\n                new_solution[heaviest_item] = 0\n\n    # Operator 2: Randomly remove an item if possible\n    elif len(removable_items) > 0:\n        item_to_remove = np.random.choice(removable_items)\n        new_solution[item_to_remove] = 0\n\n    # Operator 3: If no simple moves, perform a more aggressive move\n    else:\n        # Find items with highest marginal value-to-weight ratio\n        marginal_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_items = np.argsort(marginal_ratios)[::-1]\n        for item in sorted_items:\n            if new_solution[item] == 0 and weight_lst[item] <= (capacity - np.sum(weight_lst * new_solution)):\n                new_solution[item] = 1\n                break\n            elif new_solution[item] == 1:\n                # Try to replace with another item\n                for other_item in sorted_items:\n                    if new_solution[other_item] == 0 and weight_lst[other_item] <= (capacity - np.sum(weight_lst * new_solution) + weight_lst[item]):\n                        new_solution[item] = 0\n                        new_solution[other_item] = 1\n                        break\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8092302068507706,
            4.789282411336899
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Find items that can be added (not in solution and weight <= remaining capacity)\n        addable_items = np.where((sol == 0) & (weight_lst <= remaining_capacity))[0]\n        # Find items that can be removed (in solution)\n        removable_items = np.where(sol == 1)[0]\n        if len(addable_items) > 0 or len(removable_items) > 0:\n            candidates.append((sol, obj, addable_items, removable_items))\n\n    if not candidates:\n        # If no candidates, return a random solution\n        return archive[np.random.randint(len(archive))][0].copy()\n\n    # Step 2: Select a candidate with high potential for improvement\n    # Criteria: Prefer solutions with high marginal value potential\n    selected_sol, _, addable_items, removable_items = max(\n        candidates,\n        key=lambda x: (\n            np.sum(value1_lst[x[2]] + value2_lst[x[2]]) if len(x[2]) > 0 else 0,\n            np.sum(value1_lst[x[3]] + value2_lst[x[3]]) if len(x[3]) > 0 else 0\n        )\n    )\n\n    # Step 3: Apply a novel hybrid local search operator\n    new_solution = selected_sol.copy()\n\n    # Operator 1: Randomly add an item if possible\n    if len(addable_items) > 0:\n        item_to_add = np.random.choice(addable_items)\n        new_solution[item_to_add] = 1\n        current_weight = np.sum(weight_lst * new_solution)\n        # If adding causes overcapacity, remove the heaviest item\n        if current_weight > capacity:\n            items_in_solution = np.where(new_solution == 1)[0]\n            if len(items_in_solution) > 0:\n                heaviest_item = items_in_solution[np.argmax(weight_lst[items_in_solution])]\n                new_solution[heaviest_item] = 0\n\n    # Operator 2: Randomly remove an item if possible\n    elif len(removable_items) > 0:\n        item_to_remove = np.random.choice(removable_items)\n        new_solution[item_to_remove] = 0\n\n    # Operator 3: If no simple moves, perform a more aggressive move\n    else:\n        # Find items with highest marginal value-to-weight ratio\n        marginal_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_items = np.argsort(marginal_ratios)[::-1]\n        for item in sorted_items:\n            if new_solution[item] == 0 and weight_lst[item] <= (capacity - np.sum(weight_lst * new_solution)):\n                new_solution[item] = 1\n                break\n            elif new_solution[item] == 1:\n                # Try to replace with another item\n                for other_item in sorted_items:\n                    if new_solution[other_item] == 0 and weight_lst[other_item] <= (capacity - np.sum(weight_lst * new_solution) + weight_lst[item]):\n                        new_solution[item] = 0\n                        new_solution[other_item] = 1\n                        break\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., not too crowded in objective space)\n        # Here, we use a simple random selection with bias towards solutions with higher total value\n        total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n        probabilities = total_values / np.sum(total_values)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a novel local search operator: \"Objective-Driven Flip with Trade-off\"\n    # This operator flips items in a way that considers both objectives and trade-offs\n    # Step 1: Identify items that can be flipped (either 0 to 1 or 1 to 0) without violating capacity\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    possible_flips = []\n\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                possible_flips.append((i, 'remove'))\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                possible_flips.append((i, 'add'))\n\n    if not possible_flips:\n        return base_solution  # No feasible flips possible\n\n    # Step 2: Evaluate flips based on a trade-off metric between the two objectives\n    # For each possible flip, compute the marginal contribution to both objectives\n    best_flip = None\n    best_score = -np.inf\n\n    for i, action in possible_flips:\n        if action == 'remove':\n            delta_value1 = -value1_lst[i]\n            delta_value2 = -value2_lst[i]\n        else:  # 'add'\n            delta_value1 = value1_lst[i]\n            delta_value2 = value2_lst[i]\n\n        # Score the flip based on a trade-off between the two objectives\n        # Here, we use a simple weighted sum of normalized deltas\n        norm_delta1 = delta_value1 / (np.max(value1_lst) - np.min(value1_lst) + 1e-6)\n        norm_delta2 = delta_value2 / (np.max(value2_lst) - np.min(value2_lst) + 1e-6)\n        score = 0.5 * norm_delta1 + 0.5 * norm_delta2  # Equal weights for simplicity\n\n        if score > best_score:\n            best_score = score\n            best_flip = (i, action)\n\n    # Apply the best flip\n    if best_flip is not None:\n        i, action = best_flip\n        if action == 'remove':\n            new_solution[i] = 0\n        else:\n            new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7730057517767164,
            10.378845870494843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., not too crowded in objective space)\n        # Here, we use a simple random selection with bias towards solutions with higher total value\n        total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n        probabilities = total_values / np.sum(total_values)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a novel local search operator: \"Objective-Driven Flip with Trade-off\"\n    # This operator flips items in a way that considers both objectives and trade-offs\n    # Step 1: Identify items that can be flipped (either 0 to 1 or 1 to 0) without violating capacity\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    possible_flips = []\n\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                possible_flips.append((i, 'remove'))\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                possible_flips.append((i, 'add'))\n\n    if not possible_flips:\n        return base_solution  # No feasible flips possible\n\n    # Step 2: Evaluate flips based on a trade-off metric between the two objectives\n    # For each possible flip, compute the marginal contribution to both objectives\n    best_flip = None\n    best_score = -np.inf\n\n    for i, action in possible_flips:\n        if action == 'remove':\n            delta_value1 = -value1_lst[i]\n            delta_value2 = -value2_lst[i]\n        else:  # 'add'\n            delta_value1 = value1_lst[i]\n            delta_value2 = value2_lst[i]\n\n        # Score the flip based on a trade-off between the two objectives\n        # Here, we use a simple weighted sum of normalized deltas\n        norm_delta1 = delta_value1 / (np.max(value1_lst) - np.min(value1_lst) + 1e-6)\n        norm_delta2 = delta_value2 / (np.max(value2_lst) - np.min(value2_lst) + 1e-6)\n        score = 0.5 * norm_delta1 + 0.5 * norm_delta2  # Equal weights for simplicity\n\n        if score > best_score:\n            best_score = score\n            best_flip = (i, action)\n\n    # Apply the best flip\n    if best_flip is not None:\n        i, action = best_flip\n        if action == 'remove':\n            new_solution[i] = 0\n        else:\n            new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = np.array([(v1 / np.max(value1_lst), v2 / np.max(value2_lst)) for _, (v1, v2) in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: combination of random perturbation and greedy improvement\n    new_solution = base_solution.copy()\n\n    # Randomly flip a subset of items to introduce diversity\n    flip_mask = np.random.rand(len(new_solution)) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing excess items\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for item in excess_items:\n            if excess_weight <= 0:\n                break\n            new_solution[item] = 0\n            excess_weight -= weight_lst[item]\n\n    # Greedily add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n    for item in remaining_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Check if adding the item improves both objectives\n            if (value1_lst[item] > 0 and value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3798174446094703,
            2.0828887820243835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = np.array([(v1 / np.max(value1_lst), v2 / np.max(value2_lst)) for _, (v1, v2) in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: combination of random perturbation and greedy improvement\n    new_solution = base_solution.copy()\n\n    # Randomly flip a subset of items to introduce diversity\n    flip_mask = np.random.rand(len(new_solution)) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing excess items\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for item in excess_items:\n            if excess_weight <= 0:\n                break\n            new_solution[item] = 0\n            excess_weight -= weight_lst[item]\n\n    # Greedily add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n    for item in remaining_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Check if adding the item improves both objectives\n            if (value1_lst[item] > 0 and value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swaps, insertions, and probabilistic flips to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., near the Pareto front)\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Probabilistic item flips\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                # Check if removing the item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Item swaps (swap two items if it improves both objectives)\n    for _ in range(3):  # Try up to 3 swaps\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n            # Check feasibility\n            if np.sum(weight_lst[new_solution == 1]) > capacity:\n                # Undo swap if infeasible\n                new_solution[i] = temp\n                new_solution[j] = 1 - temp\n\n    # Step 3: Insertion of promising items (items not in solution but could improve objectives)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Check if adding item i improves at least one objective\n            if (value1_lst[i] > 0) or (value2_lst[i] > 0):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.352745667576417,
            3.3971292972564697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., near the Pareto front)\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Probabilistic item flips\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                # Check if removing the item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Item swaps (swap two items if it improves both objectives)\n    for _ in range(3):  # Try up to 3 swaps\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n            # Check feasibility\n            if np.sum(weight_lst[new_solution == 1]) > capacity:\n                # Undo swap if infeasible\n                new_solution[i] = temp\n                new_solution[j] = 1 - temp\n\n    # Step 3: Insertion of promising items (items not in solution but could improve objectives)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Check if adding item i improves at least one objective\n            if (value1_lst[i] > 0) or (value2_lst[i] > 0):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Flip a subset of items based on marginal utility and diversity\n    # Step 1: Calculate marginal utility for each item (value1 + value2 / weight)\n    marginal_utility = (value1_lst + value2_lst) / weight_lst\n\n    # Step 2: Identify items with high marginal utility but not in the current solution\n    candidate_indices = np.where((base_solution == 0) & (marginal_utility > np.median(marginal_utility)))[0]\n\n    if len(candidate_indices) > 0:\n        # Step 3: Randomly select a subset of high-marginal-utility items to add\n        num_to_add = min(3, len(candidate_indices))  # Limit to 3 items for diversity\n        add_indices = np.random.choice(candidate_indices, num_to_add, replace=False)\n\n        # Step 4: Check feasibility when adding items\n        current_weight = np.sum(weight_lst * base_solution)\n        potential_add_weight = np.sum(weight_lst[add_indices])\n\n        if current_weight + potential_add_weight <= capacity:\n            new_solution[add_indices] = 1\n\n    # Step 5: Optionally remove low-marginal-utility items to create space\n    if np.sum(weight_lst * new_solution) < capacity:\n        candidate_indices = np.where((new_solution == 1) & (marginal_utility < np.median(marginal_utility)))[0]\n        if len(candidate_indices) > 0:\n            remove_indices = np.random.choice(candidate_indices, min(2, len(candidate_indices)), replace=False)\n            new_solution[remove_indices] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8696317350388421,
            2.4040847420692444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Flip a subset of items based on marginal utility and diversity\n    # Step 1: Calculate marginal utility for each item (value1 + value2 / weight)\n    marginal_utility = (value1_lst + value2_lst) / weight_lst\n\n    # Step 2: Identify items with high marginal utility but not in the current solution\n    candidate_indices = np.where((base_solution == 0) & (marginal_utility > np.median(marginal_utility)))[0]\n\n    if len(candidate_indices) > 0:\n        # Step 3: Randomly select a subset of high-marginal-utility items to add\n        num_to_add = min(3, len(candidate_indices))  # Limit to 3 items for diversity\n        add_indices = np.random.choice(candidate_indices, num_to_add, replace=False)\n\n        # Step 4: Check feasibility when adding items\n        current_weight = np.sum(weight_lst * base_solution)\n        potential_add_weight = np.sum(weight_lst[add_indices])\n\n        if current_weight + potential_add_weight <= capacity:\n            new_solution[add_indices] = 1\n\n    # Step 5: Optionally remove low-marginal-utility items to create space\n    if np.sum(weight_lst * new_solution) < capacity:\n        candidate_indices = np.where((new_solution == 1) & (marginal_utility < np.median(marginal_utility)))[0]\n        if len(candidate_indices) > 0:\n            remove_indices = np.random.choice(candidate_indices, min(2, len(candidate_indices)), replace=False)\n            new_solution[remove_indices] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{A novel adaptive local search heuristic that intelligently selects a base solution from the archive, identifies critical items via a multi-objective sensitivity analysis, and applies a hybrid operator combining item swaps and value-driven perturbations to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution with high potential for improvement\n    # Sort solutions by their objective values (assuming higher is better)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]), reverse=True)\n    # Randomly select among top 30% of solutions\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    base_solution, _ = selection_pool[np.random.randint(0, len(selection_pool))]\n\n    # Step 2: Identify critical items (those that contribute most to objectives)\n    current_weight = np.sum(weight_lst * base_solution)\n    value_ratio1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    value_ratio2 = value2_lst / (weight_lst + 1e-6)\n    critical_items = np.argsort(-(value_ratio1 + value_ratio2))[:len(weight_lst)//4]\n\n    # Step 3: Generate neighbor using hybrid operator\n    new_solution = base_solution.copy()\n    for _ in range(3):  # Perform up to 3 operations\n        # Option 1: Flip critical items with probability based on their value ratios\n        for item in critical_items:\n            if np.random.rand() < 0.7:  # Higher probability for critical items\n                if base_solution[item] == 1 and current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n        # Option 2: Randomly swap items to maintain diversity\n        if np.random.rand() < 0.5:\n            swap_indices = np.random.choice(len(weight_lst), size=2, replace=False)\n            if base_solution[swap_indices[0]] != base_solution[swap_indices[1]]:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n        # Option 3: Add/remove items with high marginal gain\n        marginal_gain1 = value1_lst / (weight_lst + 1e-6)\n        marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n        combined_gain = marginal_gain1 + marginal_gain2\n        high_gain_items = np.argsort(-combined_gain)[:len(weight_lst)//5]\n\n        for item in high_gain_items:\n            if np.random.rand() < 0.6:  # Higher probability for high-gain items\n                if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        removable_items = np.where(new_solution == 1)[0]\n        if len(removable_items) == 0:\n            break\n        # Remove items with smallest marginal gain\n        marginal_gain = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        remove_item = removable_items[np.argmin(marginal_gain[removable_items])]\n        new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4261549384222615,
            4.5735825300216675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution with high potential for improvement\n    # Sort solutions by their objective values (assuming higher is better)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]), reverse=True)\n    # Randomly select among top 30% of solutions\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    base_solution, _ = selection_pool[np.random.randint(0, len(selection_pool))]\n\n    # Step 2: Identify critical items (those that contribute most to objectives)\n    current_weight = np.sum(weight_lst * base_solution)\n    value_ratio1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    value_ratio2 = value2_lst / (weight_lst + 1e-6)\n    critical_items = np.argsort(-(value_ratio1 + value_ratio2))[:len(weight_lst)//4]\n\n    # Step 3: Generate neighbor using hybrid operator\n    new_solution = base_solution.copy()\n    for _ in range(3):  # Perform up to 3 operations\n        # Option 1: Flip critical items with probability based on their value ratios\n        for item in critical_items:\n            if np.random.rand() < 0.7:  # Higher probability for critical items\n                if base_solution[item] == 1 and current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n        # Option 2: Randomly swap items to maintain diversity\n        if np.random.rand() < 0.5:\n            swap_indices = np.random.choice(len(weight_lst), size=2, replace=False)\n            if base_solution[swap_indices[0]] != base_solution[swap_indices[1]]:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n        # Option 3: Add/remove items with high marginal gain\n        marginal_gain1 = value1_lst / (weight_lst + 1e-6)\n        marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n        combined_gain = marginal_gain1 + marginal_gain2\n        high_gain_items = np.argsort(-combined_gain)[:len(weight_lst)//5]\n\n        for item in high_gain_items:\n            if np.random.rand() < 0.6:  # Higher probability for high-gain items\n                if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        removable_items = np.where(new_solution == 1)[0]\n        if len(removable_items) == 0:\n            break\n        # Remove items with smallest marginal gain\n        marginal_gain = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        remove_item = removable_items[np.argmin(marginal_gain[removable_items])]\n        new_solution[remove_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{A hybrid local search algorithm that combines randomized item swaps, objective-biased perturbations, and dynamic neighborhood exploration to intelligently select and improve solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (normalized)\n        objectives = np.array([obj for _, obj in archive])\n        max_obj = np.max(objectives, axis=0)\n        norm_obj = objectives / max_obj\n        combined_score = np.sum(norm_obj, axis=1)\n        prob = combined_score / np.sum(combined_score)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate neighbor using a hybrid approach\n    # Step 1: Randomly swap a subset of items\n    num_items = len(weight_lst)\n    swap_indices = random.sample(range(num_items), min(3, num_items))\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Check if adding the item is feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Objective-biased perturbation\n    objective = archive[selected_idx][1]\n    if random.random() < 0.5:  # 50% chance to focus on value1\n        # Add items with highest value1 per weight ratio\n        ratios = value1_lst / weight_lst\n        sorted_indices = np.argsort(ratios)[::-1]\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                break\n    else:  # Focus on value2\n        # Add items with highest value2 per weight ratio\n        ratios = value2_lst / weight_lst\n        sorted_indices = np.argsort(ratios)[::-1]\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                break\n\n    # Step 3: Dynamic neighborhood exploration\n    if random.random() < 0.3:  # 30% chance to explore further\n        # Randomly flip a small number of items\n        flip_indices = random.sample(range(num_items), min(2, num_items))\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.39951907102566425,
            4.999808311462402
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (normalized)\n        objectives = np.array([obj for _, obj in archive])\n        max_obj = np.max(objectives, axis=0)\n        norm_obj = objectives / max_obj\n        combined_score = np.sum(norm_obj, axis=1)\n        prob = combined_score / np.sum(combined_score)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate neighbor using a hybrid approach\n    # Step 1: Randomly swap a subset of items\n    num_items = len(weight_lst)\n    swap_indices = random.sample(range(num_items), min(3, num_items))\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Check if adding the item is feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Objective-biased perturbation\n    objective = archive[selected_idx][1]\n    if random.random() < 0.5:  # 50% chance to focus on value1\n        # Add items with highest value1 per weight ratio\n        ratios = value1_lst / weight_lst\n        sorted_indices = np.argsort(ratios)[::-1]\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                break\n    else:  # Focus on value2\n        # Add items with highest value2 per weight ratio\n        ratios = value2_lst / weight_lst\n        sorted_indices = np.argsort(ratios)[::-1]\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                break\n\n    # Step 3: Dynamic neighborhood exploration\n    if random.random() < 0.3:  # 30% chance to explore further\n        # Randomly flip a small number of items\n        flip_indices = random.sample(range(num_items), min(2, num_items))\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and applies a novel hybrid local search operator that combines item swaps, flips, and a probabilistic greedy insertion to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine swaps, flips, and greedy insertion\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random item swap (if feasible)\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, 2, replace=False)\n        if (new_solution[i] == 1 and new_solution[j] == 0 and\n            current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistic flip (higher chance for items with high marginal value)\n    if np.random.rand() < 0.3:  # 30% chance\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal_value1 + marginal_value2\n        combined_marginal[new_solution == 1] *= 0.5  # Lower chance to remove\n\n        item_to_flip = np.random.choice(n_items, p=combined_marginal / np.sum(combined_marginal))\n        if new_solution[item_to_flip] == 0 and current_weight + weight_lst[item_to_flip] <= capacity:\n            new_solution[item_to_flip] = 1\n        elif new_solution[item_to_flip] == 1:\n            new_solution[item_to_flip] = 0\n\n    # Step 3: Greedy insertion of excluded items (if feasible)\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        np.random.shuffle(excluded_items)\n        for item in excluded_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6600121189490525,
            2.583517163991928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine swaps, flips, and greedy insertion\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random item swap (if feasible)\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, 2, replace=False)\n        if (new_solution[i] == 1 and new_solution[j] == 0 and\n            current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistic flip (higher chance for items with high marginal value)\n    if np.random.rand() < 0.3:  # 30% chance\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal_value1 + marginal_value2\n        combined_marginal[new_solution == 1] *= 0.5  # Lower chance to remove\n\n        item_to_flip = np.random.choice(n_items, p=combined_marginal / np.sum(combined_marginal))\n        if new_solution[item_to_flip] == 0 and current_weight + weight_lst[item_to_flip] <= capacity:\n            new_solution[item_to_flip] = 1\n        elif new_solution[item_to_flip] == 1:\n            new_solution[item_to_flip] = 0\n\n    # Step 3: Greedy insertion of excluded items (if feasible)\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        np.random.shuffle(excluded_items)\n        for item in excluded_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines adaptive perturbation, objective-biased flipping, and feasibility-preserving swaps to generate high-quality neighbor solutions by dynamically prioritizing items with the highest marginal gains in both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (prioritize those with higher potential)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 20% of solutions\n        top_k = max(1, len(archive) // 5)\n        selected_solutions = archive_sorted[:top_k]\n        # Randomly select one from the top candidates\n        base_solution, _ = random.choice(selected_solutions)\n    else:\n        base_solution, _ = archive[0]\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Objective-biased flipping: flip items with highest marginal gain in either objective\n    for _ in range(3):  # Perform 3 flips per iteration\n        # Calculate marginal gains for each item\n        marginal_gain1 = value1_lst - (new_solution * value1_lst)\n        marginal_gain2 = value2_lst - (new_solution * value2_lst)\n        combined_gain = marginal_gain1 + marginal_gain2  # Combined gain\n\n        # Find items that can be added (not in solution and within capacity)\n        addable_items = np.where((new_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n        if len(addable_items) > 0:\n            # Select item with highest combined gain\n            best_add_item = addable_items[np.argmax(combined_gain[addable_items])]\n            new_solution[best_add_item] = 1\n            current_weight += weight_lst[best_add_item]\n\n        # Find items that can be removed (in solution)\n        removable_items = np.where(new_solution == 1)[0]\n        if len(removable_items) > 0:\n            # Select item with lowest combined gain\n            best_remove_item = removable_items[np.argmin(combined_gain[removable_items])]\n            new_solution[best_remove_item] = 0\n            current_weight -= weight_lst[best_remove_item]\n\n    # Adaptive perturbation: randomly flip some items to escape local optima\n    if random.random() < 0.3:  # 30% chance of perturbation\n        num_perturbations = min(3, len(new_solution) // 2)\n        perturb_indices = np.random.choice(len(new_solution), num_perturbations, replace=False)\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.326009732793969,
            1.6721954047679901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (prioritize those with higher potential)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 20% of solutions\n        top_k = max(1, len(archive) // 5)\n        selected_solutions = archive_sorted[:top_k]\n        # Randomly select one from the top candidates\n        base_solution, _ = random.choice(selected_solutions)\n    else:\n        base_solution, _ = archive[0]\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Objective-biased flipping: flip items with highest marginal gain in either objective\n    for _ in range(3):  # Perform 3 flips per iteration\n        # Calculate marginal gains for each item\n        marginal_gain1 = value1_lst - (new_solution * value1_lst)\n        marginal_gain2 = value2_lst - (new_solution * value2_lst)\n        combined_gain = marginal_gain1 + marginal_gain2  # Combined gain\n\n        # Find items that can be added (not in solution and within capacity)\n        addable_items = np.where((new_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n        if len(addable_items) > 0:\n            # Select item with highest combined gain\n            best_add_item = addable_items[np.argmax(combined_gain[addable_items])]\n            new_solution[best_add_item] = 1\n            current_weight += weight_lst[best_add_item]\n\n        # Find items that can be removed (in solution)\n        removable_items = np.where(new_solution == 1)[0]\n        if len(removable_items) > 0:\n            # Select item with lowest combined gain\n            best_remove_item = removable_items[np.argmin(combined_gain[removable_items])]\n            new_solution[best_remove_item] = 0\n            current_weight -= weight_lst[best_remove_item]\n\n    # Adaptive perturbation: randomly flip some items to escape local optima\n    if random.random() < 0.3:  # 30% chance of perturbation\n        num_perturbations = min(3, len(new_solution) // 2)\n        perturb_indices = np.random.choice(len(new_solution), num_perturbations, replace=False)\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on a hybrid of objective diversity and solution quality, then applies a novel local search operator that combines item swapping and probabilistic flipping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with intelligent randomness\n    candidates = []\n    for sol, obj in archive:\n        # Prefer solutions with high objective values but also some diversity\n        score = obj[0] + obj[1] + random.uniform(0, 0.1)  # Small randomness for diversity\n        candidates.append((score, sol))\n\n    # Select the solution with the highest score\n    base_solution = max(candidates, key=lambda x: x[0])[1].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Hybrid of swapping and probabilistic flipping\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # First, try to swap two items (one in, one out)\n    in_items = np.where(base_solution == 1)[0]\n    out_items = np.where(base_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Select a random item to remove\n        remove_idx = random.choice(in_items)\n        # Select a random item to add, ensuring capacity constraint\n        possible_adds = [i for i in out_items if total_weight - weight_lst[remove_idx] + weight_lst[i] <= capacity]\n        if possible_adds:\n            add_idx = random.choice(possible_adds)\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n            return new_solution\n\n    # If swap didn't work, try probabilistic flipping\n    for i in range(n_items):\n        if base_solution[i] == 1:\n            # With some probability, remove this item if it doesn't violate capacity\n            if random.random() < 0.3 and total_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            # With some probability, add this item if it doesn't violate capacity\n            if random.random() < 0.1 and total_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.459714314874908,
            1.586281955242157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with intelligent randomness\n    candidates = []\n    for sol, obj in archive:\n        # Prefer solutions with high objective values but also some diversity\n        score = obj[0] + obj[1] + random.uniform(0, 0.1)  # Small randomness for diversity\n        candidates.append((score, sol))\n\n    # Select the solution with the highest score\n    base_solution = max(candidates, key=lambda x: x[0])[1].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Hybrid of swapping and probabilistic flipping\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # First, try to swap two items (one in, one out)\n    in_items = np.where(base_solution == 1)[0]\n    out_items = np.where(base_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Select a random item to remove\n        remove_idx = random.choice(in_items)\n        # Select a random item to add, ensuring capacity constraint\n        possible_adds = [i for i in out_items if total_weight - weight_lst[remove_idx] + weight_lst[i] <= capacity]\n        if possible_adds:\n            add_idx = random.choice(possible_adds)\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n            return new_solution\n\n    # If swap didn't work, try probabilistic flipping\n    for i in range(n_items):\n        if base_solution[i] == 1:\n            # With some probability, remove this item if it doesn't violate capacity\n            if random.random() < 0.3 and total_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            # With some probability, add this item if it doesn't violate capacity\n            if random.random() < 0.1 and total_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining item swaps and greedy additions to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    candidates = []\n    for sol, obj in archive:\n        weight = np.sum(weight_lst * sol)\n        utilization = weight / capacity\n        # Prefer solutions with high objective values and low weight utilization\n        score = (obj[0] + obj[1]) * (1 - utilization)\n        candidates.append((score, sol))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected_sol = candidates[0][1].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly swap a few items\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for i in swap_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Step 2: Greedily add items with high marginal value\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate marginal values for each objective\n        marginal_value1 = value1_lst - np.sum(value1_lst * new_solution) / n_items\n        marginal_value2 = value2_lst - np.sum(value2_lst * new_solution) / n_items\n        # Combine marginal values (simple sum for simplicity)\n        marginal_scores = marginal_value1 + marginal_value2\n\n        # Sort items by marginal score in descending order\n        sorted_indices = np.argsort(marginal_scores)[::-1]\n\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n                if remaining_capacity <= 0:\n                    break\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random item if over capacity\n        included_indices = np.where(new_solution == 1)[0]\n        if len(included_indices) > 0:\n            remove_idx = random.choice(included_indices)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3368008981660841,
            2.827707976102829
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    candidates = []\n    for sol, obj in archive:\n        weight = np.sum(weight_lst * sol)\n        utilization = weight / capacity\n        # Prefer solutions with high objective values and low weight utilization\n        score = (obj[0] + obj[1]) * (1 - utilization)\n        candidates.append((score, sol))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected_sol = candidates[0][1].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly swap a few items\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for i in swap_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Step 2: Greedily add items with high marginal value\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate marginal values for each objective\n        marginal_value1 = value1_lst - np.sum(value1_lst * new_solution) / n_items\n        marginal_value2 = value2_lst - np.sum(value2_lst * new_solution) / n_items\n        # Combine marginal values (simple sum for simplicity)\n        marginal_scores = marginal_value1 + marginal_value2\n\n        # Sort items by marginal score in descending order\n        sorted_indices = np.argsort(marginal_scores)[::-1]\n\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n                if remaining_capacity <= 0:\n                    break\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random item if over capacity\n        included_indices = np.where(new_solution == 1)[0]\n        if len(included_indices) > 0:\n            remove_idx = random.choice(included_indices)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by evaluating the diversity and dominance relationships of solutions, then applies a hybrid local search combining item swapping and guided mutation to explore new neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: swap and guided mutation\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swapping (swap one item in with one item out)\n    zero_indices = np.where(base_solution == 0)[0]\n    one_indices = np.where(base_solution == 1)[0]\n\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        swap_in = np.random.choice(zero_indices)\n        swap_out = np.random.choice(one_indices)\n\n        temp_weight = current_weight - weight_lst[swap_out] + weight_lst[swap_in]\n        if temp_weight <= capacity:\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n\n    # Step 2: Guided mutation (flip items with high marginal contribution)\n    if np.random.rand() < 0.5:  # 50% chance to apply guided mutation\n        marginal_contribution = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n        sorted_indices = np.argsort(marginal_contribution)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0:\n                temp_weight = current_weight + weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 1\n                    current_weight = temp_weight\n                    break\n            elif new_solution[idx] == 1:\n                temp_weight = current_weight - weight_lst[idx]\n                if temp_weight >= 0:\n                    new_solution[idx] = 0\n                    current_weight = temp_weight\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5697210392322652,
            1.967258334159851
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: swap and guided mutation\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swapping (swap one item in with one item out)\n    zero_indices = np.where(base_solution == 0)[0]\n    one_indices = np.where(base_solution == 1)[0]\n\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        swap_in = np.random.choice(zero_indices)\n        swap_out = np.random.choice(one_indices)\n\n        temp_weight = current_weight - weight_lst[swap_out] + weight_lst[swap_in]\n        if temp_weight <= capacity:\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n\n    # Step 2: Guided mutation (flip items with high marginal contribution)\n    if np.random.rand() < 0.5:  # 50% chance to apply guided mutation\n        marginal_contribution = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n        sorted_indices = np.argsort(marginal_contribution)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0:\n                temp_weight = current_weight + weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 1\n                    current_weight = temp_weight\n                    break\n            elif new_solution[idx] == 1:\n                temp_weight = current_weight - weight_lst[idx]\n                if temp_weight >= 0:\n                    new_solution[idx] = 0\n                    current_weight = temp_weight\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{A hybrid local search algorithm that combines adaptive item swapping with objective-specific perturbation to intelligently explore the solution space, prioritizing high-potential solutions and ensuring feasibility through dynamic weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Intelligent selection: prioritize solutions with high potential improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[np.sum(sol[0]) / len(sol[0]) for sol in archive],  # Higher density solutions have higher chance\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Step 2: Identify critical items (those with highest value-to-weight ratio)\n    value_to_weight1 = value1_lst / weight_lst\n    value_to_weight2 = value2_lst / weight_lst\n    combined_ratio = (value_to_weight1 + value_to_weight2) / 2\n\n    # Step 3: Hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Objective-specific perturbation\n    objective = random.choice([1, 2])  # Randomly choose which objective to focus on\n    if objective == 1:\n        # Focus on value1: swap items with highest value1/weight ratio\n        sorted_indices = np.argsort(-value_to_weight1)\n    else:\n        # Focus on value2: swap items with highest value2/weight ratio\n        sorted_indices = np.argsort(-value_to_weight2)\n\n    # Adaptive swapping: try to add high-value items and remove low-value ones\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Try to add item\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Try to remove item if it's not critical\n            if random.random() < 0.3:  # 30% chance to remove\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove random items until feasible\n        ones_indices = np.where(new_solution == 1)[0]\n        if len(ones_indices) == 0:\n            break\n        remove_idx = random.choice(ones_indices)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3868824699117652,
            2.364222228527069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Intelligent selection: prioritize solutions with high potential improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[np.sum(sol[0]) / len(sol[0]) for sol in archive],  # Higher density solutions have higher chance\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Step 2: Identify critical items (those with highest value-to-weight ratio)\n    value_to_weight1 = value1_lst / weight_lst\n    value_to_weight2 = value2_lst / weight_lst\n    combined_ratio = (value_to_weight1 + value_to_weight2) / 2\n\n    # Step 3: Hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Objective-specific perturbation\n    objective = random.choice([1, 2])  # Randomly choose which objective to focus on\n    if objective == 1:\n        # Focus on value1: swap items with highest value1/weight ratio\n        sorted_indices = np.argsort(-value_to_weight1)\n    else:\n        # Focus on value2: swap items with highest value2/weight ratio\n        sorted_indices = np.argsort(-value_to_weight2)\n\n    # Adaptive swapping: try to add high-value items and remove low-value ones\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Try to add item\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Try to remove item if it's not critical\n            if random.random() < 0.3:  # 30% chance to remove\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove random items until feasible\n        ones_indices = np.where(new_solution == 1)[0]\n        if len(ones_indices) == 0:\n            break\n        remove_idx = random.choice(ones_indices)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{A novel hybrid local search operator is designed that intelligently combines item swaps, random flips with objective-aware selection, and adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a base solution from the archive\n    # Prefer solutions with high potential for improvement (e.g., not too close to capacity)\n    base_solution, _ = max(archive, key=lambda x: sum(weight_lst[x[0] == 1]) / capacity)\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search operator\n    # Step 1: Random flip with objective-aware selection\n    if random.random() < 0.5:\n        # Select items to flip based on their contribution to both objectives\n        objective_weights = np.random.uniform(0.3, 0.7)  # Randomly weight the objectives\n        item_scores = (objective_weights * value1_lst + (1 - objective_weights) * value2_lst) / weight_lst\n        item_scores[base_solution == 0] *= -1  # Prefer flipping out low-score items or in high-score items\n        flip_indices = np.argsort(item_scores)[-min(3, n_items):]  # Flip top 3 items\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                # Check feasibility before adding\n                if sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    # Step 2: Adaptive neighborhood exploration\n    else:\n        # Perform a series of swaps between included and excluded items\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select a swap candidate based on both objectives\n            swap_in = random.choice(excluded)\n            swap_out = random.choice(included)\n\n            # Check feasibility\n            if (sum(weight_lst[new_solution == 1]) - weight_lst[swap_out] + weight_lst[swap_in]) <= capacity:\n                new_solution[swap_out] = 0\n                new_solution[swap_in] = 1\n\n    # Ensure solution is feasible (fallback)\n    if sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items with lowest combined value until feasible\n        while sum(weight_lst[new_solution == 1]) > capacity:\n            included = np.where(new_solution == 1)[0]\n            if len(included) == 0:\n                break\n            remove_idx = min(included, key=lambda x: value1_lst[x] + value2_lst[x])\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8805910720213244,
            2.8514443039894104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a base solution from the archive\n    # Prefer solutions with high potential for improvement (e.g., not too close to capacity)\n    base_solution, _ = max(archive, key=lambda x: sum(weight_lst[x[0] == 1]) / capacity)\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search operator\n    # Step 1: Random flip with objective-aware selection\n    if random.random() < 0.5:\n        # Select items to flip based on their contribution to both objectives\n        objective_weights = np.random.uniform(0.3, 0.7)  # Randomly weight the objectives\n        item_scores = (objective_weights * value1_lst + (1 - objective_weights) * value2_lst) / weight_lst\n        item_scores[base_solution == 0] *= -1  # Prefer flipping out low-score items or in high-score items\n        flip_indices = np.argsort(item_scores)[-min(3, n_items):]  # Flip top 3 items\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                # Check feasibility before adding\n                if sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    # Step 2: Adaptive neighborhood exploration\n    else:\n        # Perform a series of swaps between included and excluded items\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select a swap candidate based on both objectives\n            swap_in = random.choice(excluded)\n            swap_out = random.choice(included)\n\n            # Check feasibility\n            if (sum(weight_lst[new_solution == 1]) - weight_lst[swap_out] + weight_lst[swap_in]) <= capacity:\n                new_solution[swap_out] = 0\n                new_solution[swap_in] = 1\n\n    # Ensure solution is feasible (fallback)\n    if sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items with lowest combined value until feasible\n        while sum(weight_lst[new_solution == 1]) > capacity:\n            included = np.where(new_solution == 1)[0]\n            if len(included) == 0:\n                break\n            remove_idx = min(included, key=lambda x: value1_lst[x] + value2_lst[x])\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{The heuristic function selects a solution from the archive based on the highest combined objective value, then applies a novel local search strategy that flips a subset of items with the highest marginal improvement in either objective, ensuring feasibility by dynamically adjusting the selection to respect the capacity constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [obj[0] + obj[1] for _, obj in archive]\n    best_idx = np.argmax(combined_values)\n    base_solution = archive[best_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal improvements for flipping each item\n    marginal_improvements = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # If item is included, calculate marginal if removed\n            marginal1 = -value1_lst[i]\n            marginal2 = -value2_lst[i]\n            new_weight = current_weight - weight_lst[i]\n        else:\n            # If item is not included, calculate marginal if added (if feasible)\n            if current_weight + weight_lst[i] <= capacity:\n                marginal1 = value1_lst[i]\n                marginal2 = value2_lst[i]\n                new_weight = current_weight + weight_lst[i]\n            else:\n                marginal1 = -np.inf\n                marginal2 = -np.inf\n\n        marginal_improvements.append((marginal1 + marginal2, i))\n\n    # Sort by marginal improvement and select top k items to flip\n    marginal_improvements.sort(reverse=True, key=lambda x: x[0])\n    k = min(3, len(marginal_improvements))  # Flip up to 3 items for diversity\n    selected_indices = [idx for _, idx in marginal_improvements[:k]]\n\n    # Flip the selected items\n    new_solution = base_solution.copy()\n    for i in selected_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing items in reverse order of marginal value if capacity is exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Find the item with the smallest marginal value to remove\n        remove_candidates = [(value1_lst[i] + value2_lst[i], i) for i in range(len(new_solution)) if new_solution[i] == 1]\n        remove_candidates.sort(key=lambda x: x[0])\n        if remove_candidates:\n            _, idx_to_remove = remove_candidates[0]\n            new_solution[idx_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8711908152026447,
            2.3595339953899384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [obj[0] + obj[1] for _, obj in archive]\n    best_idx = np.argmax(combined_values)\n    base_solution = archive[best_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal improvements for flipping each item\n    marginal_improvements = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # If item is included, calculate marginal if removed\n            marginal1 = -value1_lst[i]\n            marginal2 = -value2_lst[i]\n            new_weight = current_weight - weight_lst[i]\n        else:\n            # If item is not included, calculate marginal if added (if feasible)\n            if current_weight + weight_lst[i] <= capacity:\n                marginal1 = value1_lst[i]\n                marginal2 = value2_lst[i]\n                new_weight = current_weight + weight_lst[i]\n            else:\n                marginal1 = -np.inf\n                marginal2 = -np.inf\n\n        marginal_improvements.append((marginal1 + marginal2, i))\n\n    # Sort by marginal improvement and select top k items to flip\n    marginal_improvements.sort(reverse=True, key=lambda x: x[0])\n    k = min(3, len(marginal_improvements))  # Flip up to 3 items for diversity\n    selected_indices = [idx for _, idx in marginal_improvements[:k]]\n\n    # Flip the selected items\n    new_solution = base_solution.copy()\n    for i in selected_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing items in reverse order of marginal value if capacity is exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Find the item with the smallest marginal value to remove\n        remove_candidates = [(value1_lst[i] + value2_lst[i], i) for i in range(len(new_solution)) if new_solution[i] == 1]\n        remove_candidates.sort(key=lambda x: x[0])\n        if remove_candidates:\n            _, idx_to_remove = remove_candidates[0]\n            new_solution[idx_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective greedy insertion heuristic with a dynamic perturbation mechanism to explore high-potential regions of the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[sum(archive[i][0]) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify candidate items to add or remove\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Multi-objective greedy insertion\n    if len(zero_indices) > 0 and remaining_capacity > 0:\n        # Calculate potential improvements for zero items\n        potential_add = (value1_lst[zero_indices] + value2_lst[zero_indices]) / weight_lst[zero_indices]\n        # Select top candidates that fit within remaining capacity\n        valid_add = zero_indices[weight_lst[zero_indices] <= remaining_capacity]\n        if len(valid_add) > 0:\n            best_add = valid_add[np.argmax(potential_add[np.isin(zero_indices, valid_add)])]\n            new_solution[best_add] = 1\n\n    # Dynamic perturbation: randomly flip a small number of items\n    if len(one_indices) > 0:\n        flip_count = min(2, len(one_indices))\n        flip_indices = np.random.choice(one_indices, size=flip_count, replace=False)\n        new_solution[flip_indices] = 0\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items until feasible\n        while current_weight > capacity:\n            remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8280045839198318,
            3.9650242626667023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[sum(archive[i][0]) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify candidate items to add or remove\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Multi-objective greedy insertion\n    if len(zero_indices) > 0 and remaining_capacity > 0:\n        # Calculate potential improvements for zero items\n        potential_add = (value1_lst[zero_indices] + value2_lst[zero_indices]) / weight_lst[zero_indices]\n        # Select top candidates that fit within remaining capacity\n        valid_add = zero_indices[weight_lst[zero_indices] <= remaining_capacity]\n        if len(valid_add) > 0:\n            best_add = valid_add[np.argmax(potential_add[np.isin(zero_indices, valid_add)])]\n            new_solution[best_add] = 1\n\n    # Dynamic perturbation: randomly flip a small number of items\n    if len(one_indices) > 0:\n        flip_count = min(2, len(one_indices))\n        flip_indices = np.random.choice(one_indices, size=flip_count, replace=False)\n        new_solution[flip_indices] = 0\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items until feasible\n        while current_weight > capacity:\n            remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high crowding distance or low dominance count, then applies a hybrid local search combining item swapping and partial reoptimization to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (e.g., one with high crowding distance or low dominance count)\n    # For simplicity, we randomly select a solution here, but in practice, you'd use a more sophisticated criterion.\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search (item swapping + partial reoptimization)\n    # Randomly select a subset of items to consider for swapping\n    n_items = len(base_solution)\n    subset_size = min(10, n_items)  # Adjust subset size as needed\n    candidate_indices = np.random.choice(n_items, subset_size, replace=False)\n\n    for idx in candidate_indices:\n        # Try removing the item if it's included\n        if new_solution[idx] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                continue  # Skip adding back to avoid unnecessary checks\n\n        # Try adding the item if it's excluded\n        if new_solution[idx] == 0:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    # Step 3: Partial reoptimization (greedy addition of items with high marginal value)\n    # Calculate marginal values for excluded items\n    included_items = new_solution == 1\n    excluded_items = new_solution == 0\n    current_weight = np.sum(weight_lst[included_items])\n\n    # Sort excluded items by marginal value (combine both objectives)\n    marginal_value1 = value1_lst[excluded_items]\n    marginal_value2 = value2_lst[excluded_items]\n    marginal_scores = marginal_value1 + marginal_value2  # Simple combination, can be improved\n    sorted_indices = np.argsort(marginal_scores)[::-1]  # Descending order\n\n    for idx in sorted_indices:\n        item_idx = np.where(excluded_items)[0][idx]\n        if current_weight + weight_lst[item_idx] <= capacity:\n            new_solution[item_idx] = 1\n            current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4406427530795953,
            4.255959570407867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (e.g., one with high crowding distance or low dominance count)\n    # For simplicity, we randomly select a solution here, but in practice, you'd use a more sophisticated criterion.\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search (item swapping + partial reoptimization)\n    # Randomly select a subset of items to consider for swapping\n    n_items = len(base_solution)\n    subset_size = min(10, n_items)  # Adjust subset size as needed\n    candidate_indices = np.random.choice(n_items, subset_size, replace=False)\n\n    for idx in candidate_indices:\n        # Try removing the item if it's included\n        if new_solution[idx] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                continue  # Skip adding back to avoid unnecessary checks\n\n        # Try adding the item if it's excluded\n        if new_solution[idx] == 0:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    # Step 3: Partial reoptimization (greedy addition of items with high marginal value)\n    # Calculate marginal values for excluded items\n    included_items = new_solution == 1\n    excluded_items = new_solution == 0\n    current_weight = np.sum(weight_lst[included_items])\n\n    # Sort excluded items by marginal value (combine both objectives)\n    marginal_value1 = value1_lst[excluded_items]\n    marginal_value2 = value2_lst[excluded_items]\n    marginal_scores = marginal_value1 + marginal_value2  # Simple combination, can be improved\n    sorted_indices = np.argsort(marginal_scores)[::-1]  # Descending order\n\n    for idx in sorted_indices:\n        item_idx = np.where(excluded_items)[0][idx]\n        if current_weight + weight_lst[item_idx] <= capacity:\n            new_solution[item_idx] = 1\n            current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (added or removed) while maintaining feasibility\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Candidate for removal (must have at least one item)\n            if np.sum(new_solution) > 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Candidate for addition\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, 1))  # 1 indicates addition\n\n    if not candidates:\n        return new_solution  # No feasible moves, return current solution\n\n    # Randomly select a candidate to flip\n    idx, flip = candidates[np.random.randint(0, len(candidates))]\n    new_solution[idx] = 1 if flip == 1 else 0\n\n    # Apply a secondary move: swap two items if feasible\n    if len(candidates) >= 2:\n        # Select two distinct candidates\n        i1, flip1 = candidates[np.random.randint(0, len(candidates))]\n        i2, flip2 = candidates[np.random.randint(0, len(candidates))]\n        while i1 == i2:\n            i2, flip2 = candidates[np.random.randint(0, len(candidates))]\n\n        # Check feasibility of swap\n        if new_solution[i1] == 1 and new_solution[i2] == 0:\n            new_weight = current_weight - weight_lst[i1] + weight_lst[i2]\n            if new_weight <= capacity:\n                new_solution[i1], new_solution[i2] = 0, 1\n        elif new_solution[i1] == 0 and new_solution[i2] == 1:\n            new_weight = current_weight + weight_lst[i1] - weight_lst[i2]\n            if new_weight <= capacity:\n                new_solution[i1], new_solution[i2] = 1, 0\n\n    return new_solution\n\n",
        "score": [
            -0.868426862916793,
            3.6997702419757843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (added or removed) while maintaining feasibility\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Candidate for removal (must have at least one item)\n            if np.sum(new_solution) > 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Candidate for addition\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, 1))  # 1 indicates addition\n\n    if not candidates:\n        return new_solution  # No feasible moves, return current solution\n\n    # Randomly select a candidate to flip\n    idx, flip = candidates[np.random.randint(0, len(candidates))]\n    new_solution[idx] = 1 if flip == 1 else 0\n\n    # Apply a secondary move: swap two items if feasible\n    if len(candidates) >= 2:\n        # Select two distinct candidates\n        i1, flip1 = candidates[np.random.randint(0, len(candidates))]\n        i2, flip2 = candidates[np.random.randint(0, len(candidates))]\n        while i1 == i2:\n            i2, flip2 = candidates[np.random.randint(0, len(candidates))]\n\n        # Check feasibility of swap\n        if new_solution[i1] == 1 and new_solution[i2] == 0:\n            new_weight = current_weight - weight_lst[i1] + weight_lst[i2]\n            if new_weight <= capacity:\n                new_solution[i1], new_solution[i2] = 0, 1\n        elif new_solution[i1] == 0 and new_solution[i2] == 1:\n            new_weight = current_weight + weight_lst[i1] - weight_lst[i2]\n            if new_weight <= capacity:\n                new_solution[i1], new_solution[i2] = 1, 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid heuristic that combines diversity, proximity to the Pareto front, and potential for improvement, then applies a novel local search operator that intelligently flips item selections to balance the trade-off between objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with a hybrid heuristic\n    base_solution, base_obj = random.choice(archive)\n\n    # Calculate diversity and potential improvement\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(np.abs(sol - base_solution))\n        diversity_scores.append(diversity)\n    avg_diversity = np.mean(diversity_scores)\n\n    # Select solutions with above-average diversity\n    candidates = [(sol, obj) for (sol, obj), div in zip(archive, diversity_scores) if div >= avg_diversity]\n\n    if not candidates:\n        candidates = archive\n\n    # Select the solution with the highest potential improvement\n    def potential_improvement(sol, obj):\n        v1, v2 = obj\n        total_v1 = np.sum(value1_lst[sol == 1])\n        total_v2 = np.sum(value2_lst[sol == 1])\n        potential = (total_v1 - v1) + (total_v2 - v2)\n        return potential\n\n    base_solution, base_obj = max(candidates, key=lambda x: potential_improvement(x[0], x[1]))\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider flipping\n    subset_size = max(1, int(0.2 * n_items))\n    indices = random.sample(range(n_items), subset_size)\n\n    # Step 2: Evaluate flipping each item in the subset\n    best_flip = None\n    best_score = -float('inf')\n\n    for idx in indices:\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[temp_solution == 1])\n        if total_weight > capacity:\n            continue\n\n        # Calculate improvement score (combining both objectives)\n        v1 = np.sum(value1_lst[temp_solution == 1])\n        v2 = np.sum(value2_lst[temp_solution == 1])\n        improvement = (v1 - base_obj[0]) + (v2 - base_obj[1])\n\n        if improvement > best_score:\n            best_score = improvement\n            best_flip = idx\n\n    # Apply the best flip if found\n    if best_flip is not None:\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Step 3: Additional diversification - flip a random item if no improvement found\n    if best_flip is None:\n        idx = random.choice(range(n_items))\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n\n        total_weight = np.sum(weight_lst[temp_solution == 1])\n        if total_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.91442246495566,
            9.447330981492996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with a hybrid heuristic\n    base_solution, base_obj = random.choice(archive)\n\n    # Calculate diversity and potential improvement\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(np.abs(sol - base_solution))\n        diversity_scores.append(diversity)\n    avg_diversity = np.mean(diversity_scores)\n\n    # Select solutions with above-average diversity\n    candidates = [(sol, obj) for (sol, obj), div in zip(archive, diversity_scores) if div >= avg_diversity]\n\n    if not candidates:\n        candidates = archive\n\n    # Select the solution with the highest potential improvement\n    def potential_improvement(sol, obj):\n        v1, v2 = obj\n        total_v1 = np.sum(value1_lst[sol == 1])\n        total_v2 = np.sum(value2_lst[sol == 1])\n        potential = (total_v1 - v1) + (total_v2 - v2)\n        return potential\n\n    base_solution, base_obj = max(candidates, key=lambda x: potential_improvement(x[0], x[1]))\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider flipping\n    subset_size = max(1, int(0.2 * n_items))\n    indices = random.sample(range(n_items), subset_size)\n\n    # Step 2: Evaluate flipping each item in the subset\n    best_flip = None\n    best_score = -float('inf')\n\n    for idx in indices:\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[temp_solution == 1])\n        if total_weight > capacity:\n            continue\n\n        # Calculate improvement score (combining both objectives)\n        v1 = np.sum(value1_lst[temp_solution == 1])\n        v2 = np.sum(value2_lst[temp_solution == 1])\n        improvement = (v1 - base_obj[0]) + (v2 - base_obj[1])\n\n        if improvement > best_score:\n            best_score = improvement\n            best_flip = idx\n\n    # Apply the best flip if found\n    if best_flip is not None:\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Step 3: Additional diversification - flip a random item if no improvement found\n    if best_flip is None:\n        idx = random.choice(range(n_items))\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n\n        total_weight = np.sum(weight_lst[temp_solution == 1])\n        if total_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining random flips and targeted swaps to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flips with targeted swaps\n    for _ in range(3):  # Perform 3 iterations of local search\n        # Random flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]  # Revert if infeasible\n            continue\n\n        # Targeted swap: try to improve both objectives\n        if random.random() < 0.7:  # 70% chance to perform swap\n            # Find items to swap (one in, one out)\n            in_items = np.where(new_solution == 0)[0]\n            out_items = np.where(new_solution == 1)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                # Select item to add (highest potential improvement)\n                potential_add = value1_lst[in_items] + value2_lst[in_items]\n                add_idx = in_items[np.argmax(potential_add)]\n\n                # Select item to remove (lowest weight or least valuable)\n                potential_remove = np.where(new_solution == 1, weight_lst, 0) + np.where(new_solution == 1, value1_lst + value2_lst, 0)\n                remove_idx = out_items[np.argmin(potential_remove[out_items])]\n\n                # Perform swap\n                new_solution[add_idx] = 1\n                new_solution[remove_idx] = 0\n\n                # Check feasibility again\n                total_weight = np.sum(weight_lst[new_solution == 1])\n                if total_weight > capacity:\n                    new_solution[add_idx] = 0\n                    new_solution[remove_idx] = 1  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.36662516720655136,
            1.919217199087143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flips with targeted swaps\n    for _ in range(3):  # Perform 3 iterations of local search\n        # Random flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]  # Revert if infeasible\n            continue\n\n        # Targeted swap: try to improve both objectives\n        if random.random() < 0.7:  # 70% chance to perform swap\n            # Find items to swap (one in, one out)\n            in_items = np.where(new_solution == 0)[0]\n            out_items = np.where(new_solution == 1)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                # Select item to add (highest potential improvement)\n                potential_add = value1_lst[in_items] + value2_lst[in_items]\n                add_idx = in_items[np.argmax(potential_add)]\n\n                # Select item to remove (lowest weight or least valuable)\n                potential_remove = np.where(new_solution == 1, weight_lst, 0) + np.where(new_solution == 1, value1_lst + value2_lst, 0)\n                remove_idx = out_items[np.argmin(potential_remove[out_items])]\n\n                # Perform swap\n                new_solution[add_idx] = 1\n                new_solution[remove_idx] = 0\n\n                # Check feasibility again\n                total_weight = np.sum(weight_lst[new_solution == 1])\n                if total_weight > capacity:\n                    new_solution[add_idx] = 0\n                    new_solution[remove_idx] = 1  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = max(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Randomly select a subset of items to flip (add or remove)\n    n_items = len(new_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item (add if not present, remove if present)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            new_solution[idx] = 1\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Revert if infeasible\n            new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.307829030893622,
            1.6791574954986572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = max(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Randomly select a subset of items to flip (add or remove)\n    n_items = len(new_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item (add if not present, remove if present)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            new_solution[idx] = 1\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Revert if infeasible\n            new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on objective diversity and applies a hybrid local search operator that combines greedy item swaps with adaptive perturbation to explore high-potential regions of the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine greedy swaps with adaptive perturbation\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Greedy swap: replace one item with a better one if possible\n    if len(items) > 0:\n        swap_item = np.random.choice(items)\n        for candidate in non_items:\n            new_weight = current_weight - weight_lst[swap_item] + weight_lst[candidate]\n            if new_weight <= capacity:\n                # Evaluate both objectives for the swap\n                delta1 = value1_lst[candidate] - value1_lst[swap_item]\n                delta2 = value2_lst[candidate] - value2_lst[swap_item]\n                if delta1 > 0 or delta2 > 0:\n                    new_solution[swap_item] = 0\n                    new_solution[candidate] = 1\n                    break\n\n    # Adaptive perturbation: randomly flip a small number of bits\n    perturbation_size = max(1, len(items) // 5)\n    perturb_indices = np.random.choice(len(base_solution), size=perturbation_size, replace=False)\n    for idx in perturb_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3820817772120113,
            2.6670226454734802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine greedy swaps with adaptive perturbation\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Greedy swap: replace one item with a better one if possible\n    if len(items) > 0:\n        swap_item = np.random.choice(items)\n        for candidate in non_items:\n            new_weight = current_weight - weight_lst[swap_item] + weight_lst[candidate]\n            if new_weight <= capacity:\n                # Evaluate both objectives for the swap\n                delta1 = value1_lst[candidate] - value1_lst[swap_item]\n                delta2 = value2_lst[candidate] - value2_lst[swap_item]\n                if delta1 > 0 or delta2 > 0:\n                    new_solution[swap_item] = 0\n                    new_solution[candidate] = 1\n                    break\n\n    # Adaptive perturbation: randomly flip a small number of bits\n    perturbation_size = max(1, len(items) // 5)\n    perturb_indices = np.random.choice(len(base_solution), size=perturbation_size, replace=False)\n    for idx in perturb_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of objective diversity and solution quality, then applies a novel local search operator that combines random perturbation with objective-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives\n        min_vals = np.min(objectives, axis=0)\n        max_vals = np.max(objectives, axis=0)\n        normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n        # Select solution with highest diversity (sum of normalized objectives)\n        diversity_scores = np.sum(normalized, axis=1)\n        base_idx = np.argmax(diversity_scores)\n    else:\n        base_idx = 0\n\n    base_solution = archive[base_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + objective-aware swaps\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select a subset of items to consider\n        items_to_consider = np.where(base_solution == 1)[0]\n        if len(items_to_consider) == 0:\n            items_to_consider = np.arange(len(weight_lst))\n\n        # Randomly select an item to flip\n        item_idx = np.random.choice(items_to_consider)\n        if base_solution[item_idx] == 0:\n            # Try adding the item if it fits\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n        else:\n            # Try removing the item\n            new_solution[item_idx] = 0\n            current_weight -= weight_lst[item_idx]\n\n    # Objective-aware swaps: prioritize items that improve both objectives\n    for _ in range(5):  # Number of objective-aware attempts\n        # Calculate potential improvements for each item\n        improvements = np.zeros(len(weight_lst))\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 0:\n                # Potential improvement if added\n                if current_weight + weight_lst[i] <= capacity:\n                    improvements[i] = value1_lst[i] + value2_lst[i]\n            else:\n                # Potential improvement if removed\n                improvements[i] = value1_lst[i] + value2_lst[i]\n\n        # Select top-k items with highest potential improvement\n        top_k = min(3, len(improvements))\n        top_items = np.argsort(improvements)[-top_k:]\n\n        for item_idx in top_items:\n            if new_solution[item_idx] == 0:\n                # Add if it fits\n                if current_weight + weight_lst[item_idx] <= capacity:\n                    new_solution[item_idx] = 1\n                    current_weight += weight_lst[item_idx]\n            else:\n                # Remove\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6816869014018938,
            7.947464317083359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives\n        min_vals = np.min(objectives, axis=0)\n        max_vals = np.max(objectives, axis=0)\n        normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n        # Select solution with highest diversity (sum of normalized objectives)\n        diversity_scores = np.sum(normalized, axis=1)\n        base_idx = np.argmax(diversity_scores)\n    else:\n        base_idx = 0\n\n    base_solution = archive[base_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + objective-aware swaps\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select a subset of items to consider\n        items_to_consider = np.where(base_solution == 1)[0]\n        if len(items_to_consider) == 0:\n            items_to_consider = np.arange(len(weight_lst))\n\n        # Randomly select an item to flip\n        item_idx = np.random.choice(items_to_consider)\n        if base_solution[item_idx] == 0:\n            # Try adding the item if it fits\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n        else:\n            # Try removing the item\n            new_solution[item_idx] = 0\n            current_weight -= weight_lst[item_idx]\n\n    # Objective-aware swaps: prioritize items that improve both objectives\n    for _ in range(5):  # Number of objective-aware attempts\n        # Calculate potential improvements for each item\n        improvements = np.zeros(len(weight_lst))\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 0:\n                # Potential improvement if added\n                if current_weight + weight_lst[i] <= capacity:\n                    improvements[i] = value1_lst[i] + value2_lst[i]\n            else:\n                # Potential improvement if removed\n                improvements[i] = value1_lst[i] + value2_lst[i]\n\n        # Select top-k items with highest potential improvement\n        top_k = min(3, len(improvements))\n        top_items = np.argsort(improvements)[-top_k:]\n\n        for item_idx in top_items:\n            if new_solution[item_idx] == 0:\n                # Add if it fits\n                if current_weight + weight_lst[item_idx] <= capacity:\n                    new_solution[item_idx] = 1\n                    current_weight += weight_lst[item_idx]\n            else:\n                # Remove\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the utility score for each solution (weighted sum of objectives)\n    utility_scores = [obj[0] + obj[1] for obj in archive_objectives]\n\n    # Select the solution with the highest utility score\n    selected_idx = np.argmax(utility_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Strategy 1: Randomly flip a small subset of items to introduce diversity\n    num_flips = max(1, int(0.1 * len(new_solution)))  # Flip 10% of items or at least 1\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Strategy 2: Ensure feasibility by removing the heaviest items if capacity is exceeded\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Sort items by weight-to-value ratio (value1 + value2) / weight\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n\n        # Remove items with the lowest ratio until feasible\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight = np.sum(weight_lst * new_solution)\n                if total_weight <= capacity:\n                    break\n\n    # Strategy 3: Add the most valuable items not in the solution if there's remaining capacity\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        # Sort items by total value (value1 + value2) in descending order\n        sorted_indices = np.argsort(value1_lst + value2_lst)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.34080303492476904,
            2.97887846827507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the utility score for each solution (weighted sum of objectives)\n    utility_scores = [obj[0] + obj[1] for obj in archive_objectives]\n\n    # Select the solution with the highest utility score\n    selected_idx = np.argmax(utility_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Strategy 1: Randomly flip a small subset of items to introduce diversity\n    num_flips = max(1, int(0.1 * len(new_solution)))  # Flip 10% of items or at least 1\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Strategy 2: Ensure feasibility by removing the heaviest items if capacity is exceeded\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Sort items by weight-to-value ratio (value1 + value2) / weight\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n\n        # Remove items with the lowest ratio until feasible\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight = np.sum(weight_lst * new_solution)\n                if total_weight <= capacity:\n                    break\n\n    # Strategy 3: Add the most valuable items not in the solution if there's remaining capacity\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        # Sort items by total value (value1 + value2) in descending order\n        sorted_indices = np.argsort(value1_lst + value2_lst)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search strategy combining item swapping and greedy selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we choose one with high potential for improvement)\n    # For simplicity, we select a random solution with a higher value in one objective\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Apply hybrid local search: swap items and add/remove based on greedy criteria\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly swap two items (if possible)\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) >= 2:\n        i, j = random.sample(list(candidate_indices), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Greedily add items not in the solution\n    for i in np.where(base_solution == 0)[0]:\n        if current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Step 3: Greedily remove items in the solution to free up space\n    candidate_indices = np.where(new_solution == 1)[0]\n    for i in sorted(candidate_indices, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x]):\n        if (np.sum(weight_lst * new_solution) - weight_lst[i]) >= 0:\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8698023393177563,
            5.99796736240387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we choose one with high potential for improvement)\n    # For simplicity, we select a random solution with a higher value in one objective\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Apply hybrid local search: swap items and add/remove based on greedy criteria\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly swap two items (if possible)\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) >= 2:\n        i, j = random.sample(list(candidate_indices), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Greedily add items not in the solution\n    for i in np.where(base_solution == 0)[0]:\n        if current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Step 3: Greedily remove items in the solution to free up space\n    candidate_indices = np.where(new_solution == 1)[0]\n    for i in sorted(candidate_indices, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x]):\n        if (np.sum(weight_lst * new_solution) - weight_lst[i]) >= 0:\n            new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel local search operator that combines item swapping and bit-flipping with adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance for each solution in the archive\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Compute crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m])\n\n    # Select a solution with high crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Adaptive neighborhood exploration\n    for _ in range(10):  # Limit iterations to balance exploration and computation\n        # Randomly select a candidate item to flip\n        candidate = random.randint(0, n_items-1)\n\n        if base_solution[candidate] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 0\n                current_weight -= weight_lst[candidate]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n                current_weight += weight_lst[candidate]\n\n    # Additional swap-based local search\n    for _ in range(5):\n        # Randomly select two items\n        i, j = random.sample(range(n_items), 2)\n\n        # Calculate weight change\n        delta_weight = 0\n        if base_solution[i] != base_solution[j]:\n            delta_weight = (base_solution[j] - base_solution[i]) * weight_lst[i] + (base_solution[i] - base_solution[j]) * weight_lst[j]\n\n        # Check feasibility\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8823562382091528,
            3.2650144398212433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance for each solution in the archive\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Compute crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m])\n\n    # Select a solution with high crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Adaptive neighborhood exploration\n    for _ in range(10):  # Limit iterations to balance exploration and computation\n        # Randomly select a candidate item to flip\n        candidate = random.randint(0, n_items-1)\n\n        if base_solution[candidate] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 0\n                current_weight -= weight_lst[candidate]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n                current_weight += weight_lst[candidate]\n\n    # Additional swap-based local search\n    for _ in range(5):\n        # Randomly select two items\n        i, j = random.sample(range(n_items), 2)\n\n        # Calculate weight change\n        delta_weight = 0\n        if base_solution[i] != base_solution[j]:\n            delta_weight = (base_solution[j] - base_solution[i]) * weight_lst[i] + (base_solution[i] - base_solution[j]) * weight_lst[j]\n\n        # Check feasibility\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{A novel hybrid local search operator that intelligently selects a promising solution from the archive, applies a combination of item swaps and adaptive perturbations to explore the neighborhood while ensuring feasibility, and prioritizes solutions with high potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, (v1, v2) = random.choice(archive)\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combination of swaps and adaptive perturbations\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Check if swapping would maintain feasibility\n        delta_weight = weight_lst[item2] - weight_lst[item1]\n        if (base_solution[item1] == 1 and base_solution[item2] == 0 and\n            current_weight + delta_weight <= capacity):\n            # Perform the swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight += delta_weight\n\n        # Adaptive perturbation: flip a random item if it improves both objectives\n        if random.random() < 0.3:  # 30% chance for perturbation\n            item = random.randint(0, len(weight_lst) - 1)\n            if base_solution[item] == 1:\n                # Check if removing the item would maintain feasibility\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Check if adding the item would maintain feasibility\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.40462379072845783,
            3.5329190492630005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, (v1, v2) = random.choice(archive)\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combination of swaps and adaptive perturbations\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Check if swapping would maintain feasibility\n        delta_weight = weight_lst[item2] - weight_lst[item1]\n        if (base_solution[item1] == 1 and base_solution[item2] == 0 and\n            current_weight + delta_weight <= capacity):\n            # Perform the swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight += delta_weight\n\n        # Adaptive perturbation: flip a random item if it improves both objectives\n        if random.random() < 0.3:  # 30% chance for perturbation\n            item = random.randint(0, len(weight_lst) - 1)\n            if base_solution[item] == 1:\n                # Check if removing the item would maintain feasibility\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Check if adding the item would maintain feasibility\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This heuristic selects a high-potential solution from the archive, applies a hybrid local search combining item swaps and adaptive neighborhood exploration to generate a neighbor solution while ensuring feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential (e.g., top 20% by combined objective)\n    sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(int(0.2 * len(sorted_archive)), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and adaptive neighborhood exploration\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select items to swap\n        items = np.where(base_solution == 1)[0]\n        if len(items) < 2:\n            break\n        i, j = random.sample(list(items), 2)\n\n        # Try swapping items i and j\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            current_weight = temp_weight\n\n        # Adaptive neighborhood: explore nearby items\n        for k in [i-1, i+1, j-1, j+1]:\n            if 0 <= k < len(weight_lst) and new_solution[k] != new_solution[i]:\n                temp_solution = new_solution.copy()\n                temp_solution[k] = 1 - temp_solution[k]\n                temp_weight = np.sum(weight_lst * temp_solution)\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.7998793806835723,
            9.572689801454544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential (e.g., top 20% by combined objective)\n    sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(int(0.2 * len(sorted_archive)), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and adaptive neighborhood exploration\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select items to swap\n        items = np.where(base_solution == 1)[0]\n        if len(items) < 2:\n            break\n        i, j = random.sample(list(items), 2)\n\n        # Try swapping items i and j\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            current_weight = temp_weight\n\n        # Adaptive neighborhood: explore nearby items\n        for k in [i-1, i+1, j-1, j+1]:\n            if 0 <= k < len(weight_lst) and new_solution[k] != new_solution[i]:\n                temp_solution = new_solution.copy()\n                temp_solution[k] = 1 - temp_solution[k]\n                temp_weight = np.sum(weight_lst * temp_solution)\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on potential improvement, then applies a hybrid local search operator that combines random swaps of items with a greedy evaluation of the impact on both objectives to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps with greedy evaluation\n    for _ in range(min(10, len(base_solution))):  # Limit the number of attempts\n        # Randomly select two items to swap\n        i, j = random.sample(range(len(base_solution)), 2)\n\n        # Calculate the impact of swapping\n        delta_weight = (weight_lst[j] - weight_lst[i]) * (new_solution[i] - new_solution[j])\n        delta_value1 = (value1_lst[j] - value1_lst[i]) * (new_solution[i] - new_solution[j])\n        delta_value2 = (value2_lst[j] - value2_lst[i]) * (new_solution[i] - new_solution[j])\n\n        # Check feasibility and potential improvement\n        if (new_solution[i] == 1 and new_solution[j] == 0 and\n            sum(new_solution * weight_lst) - weight_lst[i] + weight_lst[j] <= capacity) or \\\n           (new_solution[i] == 0 and new_solution[j] == 1 and\n            sum(new_solution * weight_lst) - weight_lst[j] + weight_lst[i] <= capacity):\n\n            # Apply the swap if it improves at least one objective\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Otherwise, apply with some probability to explore\n            elif random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5756145237570744,
            6.547250002622604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps with greedy evaluation\n    for _ in range(min(10, len(base_solution))):  # Limit the number of attempts\n        # Randomly select two items to swap\n        i, j = random.sample(range(len(base_solution)), 2)\n\n        # Calculate the impact of swapping\n        delta_weight = (weight_lst[j] - weight_lst[i]) * (new_solution[i] - new_solution[j])\n        delta_value1 = (value1_lst[j] - value1_lst[i]) * (new_solution[i] - new_solution[j])\n        delta_value2 = (value2_lst[j] - value2_lst[i]) * (new_solution[i] - new_solution[j])\n\n        # Check feasibility and potential improvement\n        if (new_solution[i] == 1 and new_solution[j] == 0 and\n            sum(new_solution * weight_lst) - weight_lst[i] + weight_lst[j] <= capacity) or \\\n           (new_solution[i] == 0 and new_solution[j] == 1 and\n            sum(new_solution * weight_lst) - weight_lst[j] + weight_lst[i] <= capacity):\n\n            # Apply the swap if it improves at least one objective\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Otherwise, apply with some probability to explore\n            elif random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Find candidate items to flip (0->1 or 1->0) while maintaining feasibility\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if total_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 means remove\n        else:\n            # Check if adding this item keeps the solution feasible\n            if total_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))   # 1 means add\n\n    if not candidates:\n        return base_solution  # No feasible moves\n\n    # Select a random candidate to flip\n    item_idx, flip = random.choice(candidates)\n    new_solution = base_solution.copy()\n    new_solution[item_idx] = flip if flip == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.9061275241522322,
            4.137898921966553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Find candidate items to flip (0->1 or 1->0) while maintaining feasibility\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if total_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 means remove\n        else:\n            # Check if adding this item keeps the solution feasible\n            if total_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))   # 1 means add\n\n    if not candidates:\n        return base_solution  # No feasible moves\n\n    # Select a random candidate to flip\n    item_idx, flip = random.choice(candidates)\n    new_solution = base_solution.copy()\n    new_solution[item_idx] = flip if flip == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate the dominance count for each solution in the archive\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] >= obj_i[0] and obj_j[1] >= obj_i[1] and (obj_j[0] > obj_i[0] or obj_j[1] > obj_i[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    # Select the solution with the highest dominance count (most dominated by others)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Strategy 1: Randomly swap items between included and excluded\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select an item to remove\n        remove_idx = np.random.choice(included)\n        # Randomly select an item to add\n        add_idx = np.random.choice(excluded)\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n        if new_weight <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Strategy 2: Flip items with high value-to-weight ratio\n    if np.random.rand() < 0.5:  # 50% chance to apply this strategy\n        # Calculate value-to-weight ratios for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            ratios = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n            # Select top 20% or at least 1 item with highest ratio\n            k = max(1, int(0.2 * len(excluded)))\n            top_indices = np.argsort(ratios)[-k:]\n            selected = excluded[top_indices]\n\n            # Try to add the selected items\n            for idx in selected:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8359638035723426,
            5.2297616600990295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate the dominance count for each solution in the archive\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] >= obj_i[0] and obj_j[1] >= obj_i[1] and (obj_j[0] > obj_i[0] or obj_j[1] > obj_i[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    # Select the solution with the highest dominance count (most dominated by others)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Strategy 1: Randomly swap items between included and excluded\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select an item to remove\n        remove_idx = np.random.choice(included)\n        # Randomly select an item to add\n        add_idx = np.random.choice(excluded)\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n        if new_weight <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Strategy 2: Flip items with high value-to-weight ratio\n    if np.random.rand() < 0.5:  # 50% chance to apply this strategy\n        # Calculate value-to-weight ratios for excluded items\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) > 0:\n            ratios = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n            # Select top 20% or at least 1 item with highest ratio\n            k = max(1, int(0.2 * len(excluded)))\n            top_indices = np.argsort(ratios)[-k:]\n            selected = excluded[top_indices]\n\n            # Try to add the selected items\n            for idx in selected:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive bit-flipping with a dynamic neighborhood exploration strategy, prioritizing solutions with high potential for multi-objective improvement by selectively flipping bits of items with the highest marginal gains in either objective while ensuring feasibility through a capacity-aware adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    current_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * current_solution)\n\n    # Calculate marginal gains for each item\n    marginal_gains1 = value1_lst / (weight_lst + 1e-6)\n    marginal_gains2 = value2_lst / (weight_lst + 1e-6)\n    combined_gains = marginal_gains1 + marginal_gains2\n\n    # Sort items by combined marginal gains\n    sorted_items = np.argsort(combined_gains)[::-1]\n\n    # Perform hybrid local search\n    new_solution = current_solution.copy()\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1\n            temp_weight = current_weight + weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9091745100483071,
            9.739357590675354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    current_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * current_solution)\n\n    # Calculate marginal gains for each item\n    marginal_gains1 = value1_lst / (weight_lst + 1e-6)\n    marginal_gains2 = value2_lst / (weight_lst + 1e-6)\n    combined_gains = marginal_gains1 + marginal_gains2\n\n    # Sort items by combined marginal gains\n    sorted_items = np.argsort(combined_gains)[::-1]\n\n    # Perform hybrid local search\n    new_solution = current_solution.copy()\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1\n            temp_weight = current_weight + weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement by prioritizing solutions with low dominance counts and applies a hybrid local search combining random bit flips with objective-aware swaps to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., low dominance count)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Random bit flip with feasibility check\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        if new_solution[flip_idx] == 1:\n            new_weight = current_weight - weight_lst[flip_idx]\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight = new_weight\n\n    # Step 2: Objective-aware swap with feasibility check\n    zero_indices = np.where(new_solution == 0)[0]\n    if len(zero_indices) > 0:\n        # Select an item to add based on value1 and value2\n        candidate_indices = zero_indices[np.argsort(-value1_lst[zero_indices] - value2_lst[zero_indices])[:min(5, len(zero_indices))]]\n        if len(candidate_indices) > 0:\n            add_idx = np.random.choice(candidate_indices)\n            new_weight = current_weight + weight_lst[add_idx]\n            if new_weight <= capacity:\n                new_solution[add_idx] = 1\n                current_weight = new_weight\n\n    # Step 3: Random bit flip for diversification\n    if np.random.rand() < 0.3:\n        flip_idx = np.random.randint(len(new_solution))\n        if new_solution[flip_idx] == 1:\n            new_weight = current_weight - weight_lst[flip_idx]\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[flip_idx]\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.36619911805776173,
            3.349878877401352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., low dominance count)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Random bit flip with feasibility check\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        if new_solution[flip_idx] == 1:\n            new_weight = current_weight - weight_lst[flip_idx]\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight = new_weight\n\n    # Step 2: Objective-aware swap with feasibility check\n    zero_indices = np.where(new_solution == 0)[0]\n    if len(zero_indices) > 0:\n        # Select an item to add based on value1 and value2\n        candidate_indices = zero_indices[np.argsort(-value1_lst[zero_indices] - value2_lst[zero_indices])[:min(5, len(zero_indices))]]\n        if len(candidate_indices) > 0:\n            add_idx = np.random.choice(candidate_indices)\n            new_weight = current_weight + weight_lst[add_idx]\n            if new_weight <= capacity:\n                new_solution[add_idx] = 1\n                current_weight = new_weight\n\n    # Step 3: Random bit flip for diversification\n    if np.random.rand() < 0.3:\n        flip_idx = np.random.randint(len(new_solution))\n        if new_solution[flip_idx] == 1:\n            new_weight = current_weight - weight_lst[flip_idx]\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[flip_idx]\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{The heuristic selects a promising solution from the archive based on its objective values and applies a hybrid local search strategy combining item swaps and targeted flips to explore high-potential neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution (potential candidates to add)\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Randomly select a candidate to add if it fits\n        candidate = random.choice(candidate_items)\n        if weight_lst[candidate] <= remaining_capacity:\n            new_solution[candidate] = 1\n\n    # Identify items in the solution (potential candidates to remove)\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Randomly select a candidate to remove\n        candidate = random.choice(candidate_items)\n        new_solution[candidate] = 0\n\n    # Ensure feasibility (remove one item if weight exceeded)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        items_in_solution = np.where(new_solution == 1)[0]\n        if len(items_in_solution) > 0:\n            item_to_remove = random.choice(items_in_solution)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7978111468206568,
            2.5070595741271973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution (potential candidates to add)\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Randomly select a candidate to add if it fits\n        candidate = random.choice(candidate_items)\n        if weight_lst[candidate] <= remaining_capacity:\n            new_solution[candidate] = 1\n\n    # Identify items in the solution (potential candidates to remove)\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Randomly select a candidate to remove\n        candidate = random.choice(candidate_items)\n        new_solution[candidate] = 0\n\n    # Ensure feasibility (remove one item if weight exceeded)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        items_in_solution = np.where(new_solution == 1)[0]\n        if len(items_in_solution) > 0:\n            item_to_remove = random.choice(items_in_solution)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # Randomly select a subset of items to flip (add or remove)\n    n_items = len(selected_solution)\n    n_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(n_items, size=n_flips, replace=False)\n\n    new_solution = selected_solution.copy()\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility: if flipping causes overweight, undo the flip\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight = np.sum(weight_lst[new_solution == 1])\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3089660752865958,
            5.687328636646271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # Randomly select a subset of items to flip (add or remove)\n    n_items = len(selected_solution)\n    n_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(n_items, size=n_flips, replace=False)\n\n    new_solution = selected_solution.copy()\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility: if flipping causes overweight, undo the flip\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight = np.sum(weight_lst[new_solution == 1])\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps, flips, and guided moves to explore the solution space while ensuring feasibility, aiming to balance exploration and exploitation for multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., with high total value in one objective)\n    candidates = []\n    for sol, obj in archive:\n        total_value = obj[0] + obj[1]\n        candidates.append((sol, total_value))\n\n    candidates.sort(key=lambda x: -x[1])\n    selected_sol = candidates[0][0].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (exploration)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Guided move (exploitation) - swap items to improve both objectives\n    if np.random.random() < 0.5:\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_idx = np.random.choice(in_items)\n            out_idx = np.random.choice(out_items)\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[in_idx] + weight_lst[out_idx] <= capacity and\n                (value1_lst[out_idx] > value1_lst[in_idx] or value2_lst[out_idx] > value2_lst[in_idx])):\n                new_solution[in_idx] = 0\n                new_solution[out_idx] = 1\n\n    # Step 3: Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) == 0:\n            break\n        remove_idx = np.random.choice(in_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3178716712778955,
            7.399534195661545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., with high total value in one objective)\n    candidates = []\n    for sol, obj in archive:\n        total_value = obj[0] + obj[1]\n        candidates.append((sol, total_value))\n\n    candidates.sort(key=lambda x: -x[1])\n    selected_sol = candidates[0][0].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (exploration)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Guided move (exploitation) - swap items to improve both objectives\n    if np.random.random() < 0.5:\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_idx = np.random.choice(in_items)\n            out_idx = np.random.choice(out_items)\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[in_idx] + weight_lst[out_idx] <= capacity and\n                (value1_lst[out_idx] > value1_lst[in_idx] or value2_lst[out_idx] > value2_lst[in_idx])):\n                new_solution[in_idx] = 0\n                new_solution[out_idx] = 1\n\n    # Step 3: Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) == 0:\n            break\n        remove_idx = np.random.choice(in_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This heuristic selects a solution from the archive based on the highest combined objective values, then applies a novel local search that intelligently flips items by considering both objective improvements and weight constraints, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective values\n    best_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    current_solution = best_solution.copy()\n    current_weight = np.sum(weight_lst * current_solution)\n\n    # Generate candidate flips (items to flip)\n    candidate_indices = np.where(current_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    # Evaluate flipping each candidate item\n    best_improvement = -float('inf')\n    best_flip_index = -1\n\n    for idx in candidate_indices:\n        # Calculate the new solution if this item is flipped\n        new_solution = current_solution.copy()\n        new_solution[idx] = 1 - new_solution[idx]\n\n        # Calculate new weight\n        if new_solution[idx] == 1:\n            new_weight = current_weight + weight_lst[idx]\n        else:\n            new_weight = current_weight - weight_lst[idx]\n\n        # Check feasibility\n        if new_weight > capacity:\n            continue\n\n        # Calculate improvement in combined objectives\n        delta_value1 = (new_solution[idx] - current_solution[idx]) * value1_lst[idx]\n        delta_value2 = (new_solution[idx] - current_solution[idx]) * value2_lst[idx]\n        improvement = delta_value1 + delta_value2\n\n        # Track best improvement\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_flip_index = idx\n\n    # Apply the best flip if found\n    if best_flip_index != -1:\n        current_solution[best_flip_index] = 1 - current_solution[best_flip_index]\n\n    # If no improvement, try adding a random item not in the solution\n    if best_flip_index == -1:\n        remaining_items = np.where(current_solution == 0)[0]\n        if len(remaining_items) > 0:\n            random_item = random.choice(remaining_items)\n            if current_weight + weight_lst[random_item] <= capacity:\n                current_solution[random_item] = 1\n\n    return current_solution\n\n",
        "score": [
            -0.9778885105546434,
            7.171926826238632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective values\n    best_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    current_solution = best_solution.copy()\n    current_weight = np.sum(weight_lst * current_solution)\n\n    # Generate candidate flips (items to flip)\n    candidate_indices = np.where(current_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    # Evaluate flipping each candidate item\n    best_improvement = -float('inf')\n    best_flip_index = -1\n\n    for idx in candidate_indices:\n        # Calculate the new solution if this item is flipped\n        new_solution = current_solution.copy()\n        new_solution[idx] = 1 - new_solution[idx]\n\n        # Calculate new weight\n        if new_solution[idx] == 1:\n            new_weight = current_weight + weight_lst[idx]\n        else:\n            new_weight = current_weight - weight_lst[idx]\n\n        # Check feasibility\n        if new_weight > capacity:\n            continue\n\n        # Calculate improvement in combined objectives\n        delta_value1 = (new_solution[idx] - current_solution[idx]) * value1_lst[idx]\n        delta_value2 = (new_solution[idx] - current_solution[idx]) * value2_lst[idx]\n        improvement = delta_value1 + delta_value2\n\n        # Track best improvement\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_flip_index = idx\n\n    # Apply the best flip if found\n    if best_flip_index != -1:\n        current_solution[best_flip_index] = 1 - current_solution[best_flip_index]\n\n    # If no improvement, try adding a random item not in the solution\n    if best_flip_index == -1:\n        remaining_items = np.where(current_solution == 0)[0]\n        if len(remaining_items) > 0:\n            random_item = random.choice(remaining_items)\n            if current_weight + weight_lst[random_item] <= capacity:\n                current_solution[random_item] = 1\n\n    return current_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{A hybrid local search strategy that combines adaptive item swapping with probabilistic diversification to explore high-potential regions while ensuring feasibility through capacity-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))  # Select most packed solution\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Determine items to consider for swapping\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    # Adaptive swapping: prioritize items with high marginal gain in both objectives\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Calculate marginal gains for in_items\n        marginal_gains1 = value1_lst[in_items] / weight_lst[in_items]\n        marginal_gains2 = value2_lst[in_items] / weight_lst[in_items]\n\n        # Select item to remove (highest marginal gain in either objective)\n        remove_idx = in_items[np.argmax(marginal_gains1 + marginal_gains2)]\n\n        # Calculate potential items to add (must fit within remaining capacity)\n        potential_add = out_items[weight_lst[out_items] <= remaining_capacity + weight_lst[remove_idx]]\n\n        if len(potential_add) > 0:\n            # Calculate marginal gains for potential_add items\n            add_marginal_gains1 = value1_lst[potential_add] / weight_lst[potential_add]\n            add_marginal_gains2 = value2_lst[potential_add] / weight_lst[potential_add]\n\n            # Select item to add (highest marginal gain in either objective)\n            add_idx = potential_add[np.argmax(add_marginal_gains1 + add_marginal_gains2)]\n\n            # Perform swap\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Probabilistic diversification: with 20% chance, perform random swap\n    if random.random() < 0.2 and len(in_items) > 0 and len(out_items) > 0:\n        remove_idx = random.choice(in_items)\n        potential_add = out_items[weight_lst[out_items] <= remaining_capacity + weight_lst[remove_idx]]\n\n        if len(potential_add) > 0:\n            add_idx = random.choice(potential_add)\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3962748695176078,
            6.099317401647568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))  # Select most packed solution\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Determine items to consider for swapping\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    # Adaptive swapping: prioritize items with high marginal gain in both objectives\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Calculate marginal gains for in_items\n        marginal_gains1 = value1_lst[in_items] / weight_lst[in_items]\n        marginal_gains2 = value2_lst[in_items] / weight_lst[in_items]\n\n        # Select item to remove (highest marginal gain in either objective)\n        remove_idx = in_items[np.argmax(marginal_gains1 + marginal_gains2)]\n\n        # Calculate potential items to add (must fit within remaining capacity)\n        potential_add = out_items[weight_lst[out_items] <= remaining_capacity + weight_lst[remove_idx]]\n\n        if len(potential_add) > 0:\n            # Calculate marginal gains for potential_add items\n            add_marginal_gains1 = value1_lst[potential_add] / weight_lst[potential_add]\n            add_marginal_gains2 = value2_lst[potential_add] / weight_lst[potential_add]\n\n            # Select item to add (highest marginal gain in either objective)\n            add_idx = potential_add[np.argmax(add_marginal_gains1 + add_marginal_gains2)]\n\n            # Perform swap\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Probabilistic diversification: with 20% chance, perform random swap\n    if random.random() < 0.2 and len(in_items) > 0 and len(out_items) > 0:\n        remove_idx = random.choice(in_items)\n        potential_add = out_items[weight_lst[out_items] <= remaining_capacity + weight_lst[remove_idx]]\n\n        if len(potential_add) > 0:\n            add_idx = random.choice(potential_add)\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with higher total values in either objective, then applies a hybrid local search combining random perturbation and greedy improvement to generate a feasible neighbor solution by flipping a subset of items while ensuring weight constraints are satisfied.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: random perturbation + greedy improvement\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Randomly flip a subset of items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try to add the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Greedy improvement: add items with best marginal value\n    candidate_indices = np.where(new_solution == 0)[0]\n    for idx in candidate_indices:\n        new_weight = current_weight + weight_lst[idx]\n        if new_weight <= capacity:\n            # Calculate marginal value for both objectives\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n            # Accept if it improves at least one objective\n            if marginal_value1 > 0 or marginal_value2 > 0:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3317050513143869,
            6.226596295833588
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: random perturbation + greedy improvement\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Randomly flip a subset of items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try to add the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Greedy improvement: add items with best marginal value\n    candidate_indices = np.where(new_solution == 0)[0]\n    for idx in candidate_indices:\n        new_weight = current_weight + weight_lst[idx]\n        if new_weight <= capacity:\n            # Calculate marginal value for both objectives\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n            # Accept if it improves at least one objective\n            if marginal_value1 > 0 or marginal_value2 > 0:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{A novel hybrid local search algorithm that combines probabilistic item swaps with a dynamic neighborhood exploration strategy, prioritizing solutions with high potential for multi-objective improvement while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Dynamic neighborhood exploration: flip a random subset of items\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Add item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Probabilistic swap for multi-objective improvement\n    if random.random() < 0.3:  # 30% chance to perform a swap\n        candidate_items = [i for i in range(num_items) if new_solution[i] != base_solution[i]]\n        if len(candidate_items) >= 2:\n            swap_idx1, swap_idx2 = random.sample(candidate_items, 2)\n            new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.2984149083834955,
            3.1470887660980225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Dynamic neighborhood exploration: flip a random subset of items\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Add item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Probabilistic swap for multi-objective improvement\n    if random.random() < 0.3:  # 30% chance to perform a swap\n        candidate_items = [i for i in range(num_items) if new_solution[i] != base_solution[i]]\n        if len(candidate_items) >= 2:\n            swap_idx1, swap_idx2 = random.sample(candidate_items, 2)\n            new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive, then applies a combination of random perturbation and objective-guided flips to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of both objectives)\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% of solutions\n        top_solutions = sorted_archive[:max(1, int(0.3 * len(archive)))]\n        # Randomly select one from top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: random perturbation + objective-guided flips\n    # Step 1: Randomly flip a small number of items (1-3)\n    num_flips = random.randint(1, 3)\n    flip_indices = random.sample(range(len(base_solution)), num_flips)\n\n    # Step 2: For each flip, decide whether to include or exclude based on objective improvement\n    for idx in flip_indices:\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate potential improvement in both objectives\n                v1_improvement = -value1_lst[idx]\n                v2_improvement = -value2_lst[idx]\n                # If both objectives degrade, keep the item\n                if v1_improvement < 0 and v2_improvement < 0:\n                    continue\n                new_solution[idx] = 0\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate potential improvement in both objectives\n                v1_improvement = value1_lst[idx]\n                v2_improvement = value2_lst[idx]\n                # If both objectives improve, add the item\n                if v1_improvement > 0 and v2_improvement > 0:\n                    new_solution[idx] = 1\n\n    # Step 3: Additional random walk to escape local optima\n    for _ in range(2):\n        idx = random.randint(0, len(new_solution) - 1)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[idx] == 1:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.26149407933820423,
            10.92551502585411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of both objectives)\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% of solutions\n        top_solutions = sorted_archive[:max(1, int(0.3 * len(archive)))]\n        # Randomly select one from top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: random perturbation + objective-guided flips\n    # Step 1: Randomly flip a small number of items (1-3)\n    num_flips = random.randint(1, 3)\n    flip_indices = random.sample(range(len(base_solution)), num_flips)\n\n    # Step 2: For each flip, decide whether to include or exclude based on objective improvement\n    for idx in flip_indices:\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate potential improvement in both objectives\n                v1_improvement = -value1_lst[idx]\n                v2_improvement = -value2_lst[idx]\n                # If both objectives degrade, keep the item\n                if v1_improvement < 0 and v2_improvement < 0:\n                    continue\n                new_solution[idx] = 0\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate potential improvement in both objectives\n                v1_improvement = value1_lst[idx]\n                v2_improvement = value2_lst[idx]\n                # If both objectives improve, add the item\n                if v1_improvement > 0 and v2_improvement > 0:\n                    new_solution[idx] = 1\n\n    # Step 3: Additional random walk to escape local optima\n    for _ in range(2):\n        idx = random.randint(0, len(new_solution) - 1)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[idx] == 1:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement by identifying items with the highest marginal gains in both objectives, then applies a hybrid local search that combines random flips with targeted swaps to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: sum(x[0] * (value1_lst + value2_lst)))\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Identify items with high marginal gains\n    marginal_gains = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(-marginal_gains)\n\n    # Hybrid local search: random flips with targeted swaps\n    for _ in range(5):  # Number of attempts\n        # Random flip with bias towards high-gain items\n        flip_candidate = random.choices(sorted_indices[:len(sorted_indices)//2], k=1)[0]\n        if new_solution[flip_candidate] == 1:\n            if current_weight - weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 0\n                current_weight -= weight_lst[flip_candidate]\n        else:\n            if current_weight + weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 1\n                current_weight += weight_lst[flip_candidate]\n\n        # Targeted swap: swap with a low-gain item\n        if random.random() < 0.3:  # 30% chance for swap\n            swap_candidate = random.choices(sorted_indices[len(sorted_indices)//2:], k=1)[0]\n            if new_solution[swap_candidate] == 1:\n                # Find a high-gain item to swap with\n                for high_gain in sorted_indices[:len(sorted_indices)//2]:\n                    if new_solution[high_gain] == 0 and current_weight + weight_lst[high_gain] - weight_lst[swap_candidate] <= capacity:\n                        new_solution[swap_candidate] = 0\n                        new_solution[high_gain] = 1\n                        current_weight = current_weight + weight_lst[high_gain] - weight_lst[swap_candidate]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.3443377805173352,
            8.852697223424911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: sum(x[0] * (value1_lst + value2_lst)))\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Identify items with high marginal gains\n    marginal_gains = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(-marginal_gains)\n\n    # Hybrid local search: random flips with targeted swaps\n    for _ in range(5):  # Number of attempts\n        # Random flip with bias towards high-gain items\n        flip_candidate = random.choices(sorted_indices[:len(sorted_indices)//2], k=1)[0]\n        if new_solution[flip_candidate] == 1:\n            if current_weight - weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 0\n                current_weight -= weight_lst[flip_candidate]\n        else:\n            if current_weight + weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 1\n                current_weight += weight_lst[flip_candidate]\n\n        # Targeted swap: swap with a low-gain item\n        if random.random() < 0.3:  # 30% chance for swap\n            swap_candidate = random.choices(sorted_indices[len(sorted_indices)//2:], k=1)[0]\n            if new_solution[swap_candidate] == 1:\n                # Find a high-gain item to swap with\n                for high_gain in sorted_indices[:len(sorted_indices)//2]:\n                    if new_solution[high_gain] == 0 and current_weight + weight_lst[high_gain] - weight_lst[swap_candidate] <= capacity:\n                        new_solution[swap_candidate] = 0\n                        new_solution[high_gain] = 1\n                        current_weight = current_weight + weight_lst[high_gain] - weight_lst[swap_candidate]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search operator that combines item swaps and diversified perturbation to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with high potential for improvement\n        sorted_archive = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n        selected_solution = sorted_archive[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: item swaps and diversified perturbation\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = np.where(selected_solution == 1)[0]\n    if len(swap_indices) > 1:\n        np.random.shuffle(swap_indices)\n        swap_count = min(2, len(swap_indices))\n        for i in range(swap_count):\n            new_solution[swap_indices[i]] = 1 - new_solution[swap_indices[i]]\n\n    # Step 2: Diversified perturbation - add or remove random items\n    perturbation_indices = np.where(selected_solution == 0)[0]\n    if len(perturbation_indices) > 0:\n        np.random.shuffle(perturbation_indices)\n        perturb_count = min(1, len(perturbation_indices))\n        for i in range(perturb_count):\n            new_solution[perturbation_indices[i]] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items until feasible\n        while total_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            remove_idx = np.random.choice(included_indices)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5514523746662789,
            4.5108751356601715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with high potential for improvement\n        sorted_archive = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n        selected_solution = sorted_archive[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: item swaps and diversified perturbation\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = np.where(selected_solution == 1)[0]\n    if len(swap_indices) > 1:\n        np.random.shuffle(swap_indices)\n        swap_count = min(2, len(swap_indices))\n        for i in range(swap_count):\n            new_solution[swap_indices[i]] = 1 - new_solution[swap_indices[i]]\n\n    # Step 2: Diversified perturbation - add or remove random items\n    perturbation_indices = np.where(selected_solution == 0)[0]\n    if len(perturbation_indices) > 0:\n        np.random.shuffle(perturbation_indices)\n        perturb_count = min(1, len(perturbation_indices))\n        for i in range(perturb_count):\n            new_solution[perturbation_indices[i]] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items until feasible\n        while total_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            remove_idx = np.random.choice(included_indices)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{My heuristic algorithm intelligently selects a promising solution from the archive, then applies a novel hybrid local search operator that combines item swaps with adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a promising solution\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swap\n    subset_size = min(10, num_items)\n    candidate_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: Adaptive exploration - prioritize items that could improve both objectives\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # Consider removing this item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Consider adding this item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Additional local improvement - swap two items if beneficial\n    if len(candidate_indices) >= 2:\n        i, j = random.sample(candidate_indices, 2)\n        if new_solution[i] != new_solution[j]:\n            # Check if swap is feasible\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.35731332859144554,
            4.51354855298996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a promising solution\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swap\n    subset_size = min(10, num_items)\n    candidate_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: Adaptive exploration - prioritize items that could improve both objectives\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # Consider removing this item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Consider adding this item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Additional local improvement - swap two items if beneficial\n    if len(candidate_indices) >= 2:\n        i, j = random.sample(candidate_indices, 2)\n        if new_solution[i] != new_solution[j]:\n            # Check if swap is feasible\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This algorithm selects a promising solution from the archive based on its objective values and applies a hybrid local search operator that combines item swapping and probabilistic flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on objective values\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or flip items probabilistically\n    for _ in range(5):  # Number of attempts to find a feasible neighbor\n        candidate = new_solution.copy()\n\n        # Randomly select two items to swap\n        if len(candidate) >= 2:\n            i, j = random.sample(range(len(candidate)), 2)\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate new weight\n        new_weight = np.sum(weight_lst[candidate == 1])\n\n        # If feasible, accept the swap\n        if new_weight <= capacity:\n            new_solution = candidate\n            current_weight = new_weight\n            break\n\n    # Probabilistic flipping of items to explore further\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3597736665923198,
            6.989953637123108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on objective values\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or flip items probabilistically\n    for _ in range(5):  # Number of attempts to find a feasible neighbor\n        candidate = new_solution.copy()\n\n        # Randomly select two items to swap\n        if len(candidate) >= 2:\n            i, j = random.sample(range(len(candidate)), 2)\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate new weight\n        new_weight = np.sum(weight_lst[candidate == 1])\n\n        # If feasible, accept the swap\n        if new_weight <= capacity:\n            new_solution = candidate\n            current_weight = new_weight\n            break\n\n    # Probabilistic flipping of items to explore further\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{The heuristic function selects a solution from the archive based on its potential for improvement, then applies a hybrid local search that combines item swaps and random perturbations while ensuring feasibility, and finally evaluates the neighbor's quality to guide further exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and random perturbations\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swapping\n    candidates = np.where(new_solution == 1)[0]\n    np.random.shuffle(candidates)\n    candidates = candidates[:max(1, len(candidates) // 2)]\n\n    for i in candidates:\n        # Try removing the item\n        temp_weight = current_weight - weight_lst[i]\n        if temp_weight <= capacity:\n            new_solution[i] = 0\n            current_weight = temp_weight\n            # Try adding a random item not in the solution\n            possible_adds = np.where((new_solution == 0) & (weight_lst <= capacity - current_weight))[0]\n            if len(possible_adds) > 0:\n                add_idx = np.random.choice(possible_adds)\n                new_solution[add_idx] = 1\n                current_weight += weight_lst[add_idx]\n            break  # Only perform one swap per iteration to balance exploration\n\n    # Randomly flip a small number of bits to introduce diversity\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8324584564661062,
            8.365631878376007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and random perturbations\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swapping\n    candidates = np.where(new_solution == 1)[0]\n    np.random.shuffle(candidates)\n    candidates = candidates[:max(1, len(candidates) // 2)]\n\n    for i in candidates:\n        # Try removing the item\n        temp_weight = current_weight - weight_lst[i]\n        if temp_weight <= capacity:\n            new_solution[i] = 0\n            current_weight = temp_weight\n            # Try adding a random item not in the solution\n            possible_adds = np.where((new_solution == 0) & (weight_lst <= capacity - current_weight))[0]\n            if len(possible_adds) > 0:\n                add_idx = np.random.choice(possible_adds)\n                new_solution[add_idx] = 1\n                current_weight += weight_lst[add_idx]\n            break  # Only perform one swap per iteration to balance exploration\n\n    # Randomly flip a small number of bits to introduce diversity\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{A novel hybrid local search approach combines adaptive perturbation with guided mutation, selectively flipping items based on their marginal contribution to both objectives, while ensuring feasibility through dynamic weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = archive[np.random.choice(len(archive))]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items to consider for flipping\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(new_solution == 0)[0]\n\n    # Hybrid selection strategy: combine marginal contributions and randomness\n    scores = marginal1[candidate_indices] + marginal2[candidate_indices]\n    probs = scores / np.sum(scores) if np.sum(scores) > 0 else np.ones_like(scores) / len(scores)\n    selected_idx = np.random.choice(candidate_indices, p=probs)\n\n    # Flip the selected item\n    if new_solution[selected_idx] == 1:\n        # Remove item if feasible\n        if current_weight - weight_lst[selected_idx] <= capacity:\n            new_solution[selected_idx] = 0\n    else:\n        # Add item if feasible\n        if current_weight + weight_lst[selected_idx] <= capacity:\n            new_solution[selected_idx] = 1\n\n    # Additional mutation: flip a random item to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance of additional mutation\n        random_idx = np.random.choice(len(new_solution))\n        if new_solution[random_idx] == 1:\n            if current_weight - weight_lst[random_idx] <= capacity:\n                new_solution[random_idx] = 0\n        else:\n            if current_weight + weight_lst[random_idx] <= capacity:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.6131932367092234,
            8.081210762262344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = archive[np.random.choice(len(archive))]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items to consider for flipping\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(new_solution == 0)[0]\n\n    # Hybrid selection strategy: combine marginal contributions and randomness\n    scores = marginal1[candidate_indices] + marginal2[candidate_indices]\n    probs = scores / np.sum(scores) if np.sum(scores) > 0 else np.ones_like(scores) / len(scores)\n    selected_idx = np.random.choice(candidate_indices, p=probs)\n\n    # Flip the selected item\n    if new_solution[selected_idx] == 1:\n        # Remove item if feasible\n        if current_weight - weight_lst[selected_idx] <= capacity:\n            new_solution[selected_idx] = 0\n    else:\n        # Add item if feasible\n        if current_weight + weight_lst[selected_idx] <= capacity:\n            new_solution[selected_idx] = 1\n\n    # Additional mutation: flip a random item to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance of additional mutation\n        random_idx = np.random.choice(len(new_solution))\n        if new_solution[random_idx] == 1:\n            if current_weight - weight_lst[random_idx] <= capacity:\n                new_solution[random_idx] = 0\n        else:\n            if current_weight + weight_lst[random_idx] <= capacity:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive, prioritizes items with high marginal value-to-weight ratios for both objectives, and employs a hybrid local search strategy that combines swap and flip operations to explore the solution space efficiently while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on a weighted random choice\n    total_obj1 = sum(obj[0] for _, obj in archive)\n    total_obj2 = sum(obj[1] for _, obj in archive)\n    weights = [obj[0] / total_obj1 + obj[1] / total_obj2 for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: swap and flip operations\n    for _ in range(10):  # Number of iterations\n        # Calculate marginal values\n        marginal_value1 = value1_lst / weight_lst\n        marginal_value2 = value2_lst / weight_lst\n        marginal_value = marginal_value1 + marginal_value2\n\n        # Select items to swap or flip based on marginal value\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) < 2:\n            candidates = np.arange(len(weight_lst))\n\n        # Hybrid operation: swap two items or flip one item\n        if random.random() < 0.7:  # Higher probability for swap\n            i, j = random.sample(list(candidates), 2)\n            if weight_lst[i] <= weight_lst[j]:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n            else:\n                if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[j] + weight_lst[i]\n        else:  # Flip operation\n            i = random.choice(candidates)\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.43820085222718375,
            10.828063249588013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on a weighted random choice\n    total_obj1 = sum(obj[0] for _, obj in archive)\n    total_obj2 = sum(obj[1] for _, obj in archive)\n    weights = [obj[0] / total_obj1 + obj[1] / total_obj2 for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: swap and flip operations\n    for _ in range(10):  # Number of iterations\n        # Calculate marginal values\n        marginal_value1 = value1_lst / weight_lst\n        marginal_value2 = value2_lst / weight_lst\n        marginal_value = marginal_value1 + marginal_value2\n\n        # Select items to swap or flip based on marginal value\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) < 2:\n            candidates = np.arange(len(weight_lst))\n\n        # Hybrid operation: swap two items or flip one item\n        if random.random() < 0.7:  # Higher probability for swap\n            i, j = random.sample(list(candidates), 2)\n            if weight_lst[i] <= weight_lst[j]:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n            else:\n                if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[j] + weight_lst[i]\n        else:  # Flip operation\n            i = random.choice(candidates)\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objectives\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be swapped or flipped\n    candidates = [i for i in range(len(base_solution)) if base_solution[i] == 1]\n\n    # Hybrid local search: flip a random item if it improves both objectives\n    if candidates:\n        np.random.shuffle(candidates)\n        for i in candidates:\n            if base_solution[i] == 1:\n                # Try removing the item\n                new_weight = current_weight - weight_lst[i]\n                new_value1 = current_value1 - value1_lst[i]\n                new_value2 = current_value2 - value2_lst[i]\n\n                if new_weight <= capacity:\n                    # Check if the new solution is better in both objectives\n                    better_in_both = False\n                    for sol, obj in archive:\n                        if (new_value1 >= obj[0] and new_value2 > obj[1]) or (new_value1 > obj[0] and new_value2 >= obj[1]):\n                            better_in_both = True\n                            break\n\n                    if better_in_both:\n                        new_solution[i] = 0\n                        return new_solution\n\n                # Try swapping with a random item not in the solution\n                other_items = [j for j in range(len(base_solution)) if base_solution[j] == 0]\n                if other_items:\n                    j = np.random.choice(other_items)\n                    new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    new_value1 = current_value1 - value1_lst[i] + value1_lst[j]\n                    new_value2 = current_value2 - value2_lst[i] + value2_lst[j]\n\n                    if new_weight <= capacity:\n                        # Check if the new solution is better in both objectives\n                        better_in_both = False\n                        for sol, obj in archive:\n                            if (new_value1 >= obj[0] and new_value2 > obj[1]) or (new_value1 > obj[0] and new_value2 >= obj[1]):\n                                better_in_both = True\n                                break\n\n                        if better_in_both:\n                            new_solution[i] = 0\n                            new_solution[j] = 1\n                            return new_solution\n\n    # If no improvement found, perform a random flip to ensure diversity\n    if np.random.rand() < 0.5:\n        i = np.random.choice(range(len(base_solution)))\n        if base_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n        else:\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8193488568493346,
            8.837947696447372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objectives\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be swapped or flipped\n    candidates = [i for i in range(len(base_solution)) if base_solution[i] == 1]\n\n    # Hybrid local search: flip a random item if it improves both objectives\n    if candidates:\n        np.random.shuffle(candidates)\n        for i in candidates:\n            if base_solution[i] == 1:\n                # Try removing the item\n                new_weight = current_weight - weight_lst[i]\n                new_value1 = current_value1 - value1_lst[i]\n                new_value2 = current_value2 - value2_lst[i]\n\n                if new_weight <= capacity:\n                    # Check if the new solution is better in both objectives\n                    better_in_both = False\n                    for sol, obj in archive:\n                        if (new_value1 >= obj[0] and new_value2 > obj[1]) or (new_value1 > obj[0] and new_value2 >= obj[1]):\n                            better_in_both = True\n                            break\n\n                    if better_in_both:\n                        new_solution[i] = 0\n                        return new_solution\n\n                # Try swapping with a random item not in the solution\n                other_items = [j for j in range(len(base_solution)) if base_solution[j] == 0]\n                if other_items:\n                    j = np.random.choice(other_items)\n                    new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    new_value1 = current_value1 - value1_lst[i] + value1_lst[j]\n                    new_value2 = current_value2 - value2_lst[i] + value2_lst[j]\n\n                    if new_weight <= capacity:\n                        # Check if the new solution is better in both objectives\n                        better_in_both = False\n                        for sol, obj in archive:\n                            if (new_value1 >= obj[0] and new_value2 > obj[1]) or (new_value1 > obj[0] and new_value2 >= obj[1]):\n                                better_in_both = True\n                                break\n\n                        if better_in_both:\n                            new_solution[i] = 0\n                            new_solution[j] = 1\n                            return new_solution\n\n    # If no improvement found, perform a random flip to ensure diversity\n    if np.random.rand() < 0.5:\n        i = np.random.choice(range(len(base_solution)))\n        if base_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n        else:\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, evaluates its potential for improvement by examining both objective values and item contributions, and applies a dynamic swap-and-flip operator to generate a neighbor solution that explores both local and global search spaces while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to boundary)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (obj1, obj2) = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that could be flipped (0->1 or 1->0) without violating capacity\n    flip_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append(i)\n        else:\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        # If no flip candidates, perform a swap between two items\n        swap_candidates = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                for j in range(len(base_solution)):\n                    if base_solution[j] == 0:\n                        new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                        if new_weight <= capacity:\n                            swap_candidates.append((i, j))\n\n        if swap_candidates:\n            # Select a swap that maximizes the sum of normalized value improvements\n            best_swap = None\n            best_score = -float('inf')\n            for i, j in swap_candidates:\n                delta_value1 = value1_lst[j] - value1_lst[i]\n                delta_value2 = value2_lst[j] - value2_lst[i]\n                normalized_score = (delta_value1 / (current_value1 + 1e-6)) + (delta_value2 / (current_value2 + 1e-6))\n                if normalized_score > best_score:\n                    best_score = normalized_score\n                    best_swap = (i, j)\n\n            if best_swap:\n                i, j = best_swap\n                new_solution = base_solution.copy()\n                new_solution[i] = 0\n                new_solution[j] = 1\n                return new_solution\n        else:\n            # If no swaps possible, return the original solution\n            return base_solution\n\n    else:\n        # Select a flip that maximizes the sum of normalized value improvements\n        best_flip = None\n        best_score = -float('inf')\n        for i in flip_candidates:\n            if base_solution[i] == 1:\n                delta_value1 = -value1_lst[i]\n                delta_value2 = -value2_lst[i]\n            else:\n                delta_value1 = value1_lst[i]\n                delta_value2 = value2_lst[i]\n\n            normalized_score = (delta_value1 / (current_value1 + 1e-6)) + (delta_value2 / (current_value2 + 1e-6))\n            if normalized_score > best_score:\n                best_score = normalized_score\n                best_flip = i\n\n        if best_flip is not None:\n            new_solution = base_solution.copy()\n            new_solution[best_flip] = 1 - new_solution[best_flip]\n            return new_solution\n        else:\n            return base_solution\n\n",
        "score": [
            -0.8744209912468182,
            7.891558885574341
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to boundary)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (obj1, obj2) = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that could be flipped (0->1 or 1->0) without violating capacity\n    flip_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append(i)\n        else:\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        # If no flip candidates, perform a swap between two items\n        swap_candidates = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                for j in range(len(base_solution)):\n                    if base_solution[j] == 0:\n                        new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                        if new_weight <= capacity:\n                            swap_candidates.append((i, j))\n\n        if swap_candidates:\n            # Select a swap that maximizes the sum of normalized value improvements\n            best_swap = None\n            best_score = -float('inf')\n            for i, j in swap_candidates:\n                delta_value1 = value1_lst[j] - value1_lst[i]\n                delta_value2 = value2_lst[j] - value2_lst[i]\n                normalized_score = (delta_value1 / (current_value1 + 1e-6)) + (delta_value2 / (current_value2 + 1e-6))\n                if normalized_score > best_score:\n                    best_score = normalized_score\n                    best_swap = (i, j)\n\n            if best_swap:\n                i, j = best_swap\n                new_solution = base_solution.copy()\n                new_solution[i] = 0\n                new_solution[j] = 1\n                return new_solution\n        else:\n            # If no swaps possible, return the original solution\n            return base_solution\n\n    else:\n        # Select a flip that maximizes the sum of normalized value improvements\n        best_flip = None\n        best_score = -float('inf')\n        for i in flip_candidates:\n            if base_solution[i] == 1:\n                delta_value1 = -value1_lst[i]\n                delta_value2 = -value2_lst[i]\n            else:\n                delta_value1 = value1_lst[i]\n                delta_value2 = value2_lst[i]\n\n            normalized_score = (delta_value1 / (current_value1 + 1e-6)) + (delta_value2 / (current_value2 + 1e-6))\n            if normalized_score > best_score:\n                best_score = normalized_score\n                best_flip = i\n\n        if best_flip is not None:\n            new_solution = base_solution.copy()\n            new_solution[best_flip] = 1 - new_solution[best_flip]\n            return new_solution\n        else:\n            return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{A novel hybrid local search operator that combines adaptive item swapping with probabilistic diversification, guided by a dynamic trade-off estimation to balance improvements in both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Determine the objective to prioritize for improvement\n    priority = random.choice(['value1', 'value2'])\n\n    # Hybrid local search: adaptive swapping with diversification\n    for _ in range(10):  # Number of attempts to find a better neighbor\n        # Select a random item to potentially swap\n        item_idx = random.randint(0, len(base_solution) - 1)\n\n        if base_solution[item_idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 0\n            temp_weight = current_weight - weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 -= value1_lst[item_idx]\n                current_value2 -= value2_lst[item_idx]\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 1\n            temp_weight = current_weight + weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 += value1_lst[item_idx]\n                current_value2 += value2_lst[item_idx]\n\n        # Probabilistic diversification: randomly flip another item if no improvement\n        if random.random() < 0.3:\n            other_idx = random.randint(0, len(base_solution) - 1)\n            if other_idx != item_idx:\n                temp_solution = new_solution.copy()\n                temp_solution[other_idx] = 1 - temp_solution[other_idx]\n                temp_weight = current_weight + weight_lst[other_idx] * (2 * temp_solution[other_idx] - 1)\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    if temp_solution[other_idx] == 1:\n                        current_value1 += value1_lst[other_idx]\n                        current_value2 += value2_lst[other_idx]\n                    else:\n                        current_value1 -= value1_lst[other_idx]\n                        current_value2 -= value2_lst[other_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.35250574111813293,
            7.914377927780151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Determine the objective to prioritize for improvement\n    priority = random.choice(['value1', 'value2'])\n\n    # Hybrid local search: adaptive swapping with diversification\n    for _ in range(10):  # Number of attempts to find a better neighbor\n        # Select a random item to potentially swap\n        item_idx = random.randint(0, len(base_solution) - 1)\n\n        if base_solution[item_idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 0\n            temp_weight = current_weight - weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 -= value1_lst[item_idx]\n                current_value2 -= value2_lst[item_idx]\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 1\n            temp_weight = current_weight + weight_lst[item_idx]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 += value1_lst[item_idx]\n                current_value2 += value2_lst[item_idx]\n\n        # Probabilistic diversification: randomly flip another item if no improvement\n        if random.random() < 0.3:\n            other_idx = random.randint(0, len(base_solution) - 1)\n            if other_idx != item_idx:\n                temp_solution = new_solution.copy()\n                temp_solution[other_idx] = 1 - temp_solution[other_idx]\n                temp_weight = current_weight + weight_lst[other_idx] * (2 * temp_solution[other_idx] - 1)\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    if temp_solution[other_idx] == 1:\n                        current_value1 += value1_lst[other_idx]\n                        current_value2 += value2_lst[other_idx]\n                    else:\n                        current_value1 -= value1_lst[other_idx]\n                        current_value2 -= value2_lst[other_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high total values in either objective, then applies a novel hybrid local search operator that combines item swaps and flips with a probabilistic acceptance criterion to ensure feasibility and diversity in the neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by sum of objectives (prioritize high-value solutions)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to flip (1-3 items)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Check feasibility; if not, perform a swap to fix\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Find items to remove to satisfy capacity\n        excess = total_weight - capacity\n        current_weight = np.sum(selected * weight_lst)\n        # Randomly select items to remove until feasible\n        while total_weight > capacity:\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Step 3: Apply probabilistic acceptance to allow exploration\n    if random.random() < 0.3:  # 30% chance to further perturb\n        # Randomly swap two items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = random.choice(out_items)\n            swap_out = random.choice(in_items)\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.313067326917669,
            10.424484312534332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by sum of objectives (prioritize high-value solutions)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to flip (1-3 items)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Check feasibility; if not, perform a swap to fix\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Find items to remove to satisfy capacity\n        excess = total_weight - capacity\n        current_weight = np.sum(selected * weight_lst)\n        # Randomly select items to remove until feasible\n        while total_weight > capacity:\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Step 3: Apply probabilistic acceptance to allow exploration\n    if random.random() < 0.3:  # 30% chance to further perturb\n        # Randomly swap two items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = random.choice(out_items)\n            swap_out = random.choice(in_items)\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive based on its potential for improvement, then applies a combination of item swaps and probabilistic flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by combined objective value (ascending to prioritize less explored)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select solutions in the lower half (more potential for improvement)\n        candidates = archive_sorted[:len(archive_sorted)//2 + 1]\n        base_solution, _ = random.choice(candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: probabilistic flip + item swap\n    for _ in range(5):  # Number of attempts\n        # Probabilistic flip: flip items with low value-to-weight ratio\n        if random.random() < 0.5:\n            ratios = value1_lst / weight_lst\n            ratios[new_solution == 0] = np.inf  # Only consider included items\n            idx = np.argmin(ratios)\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Item swap: swap included and excluded items if feasible\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n            if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9085874966701659,
            6.826672941446304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by combined objective value (ascending to prioritize less explored)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select solutions in the lower half (more potential for improvement)\n        candidates = archive_sorted[:len(archive_sorted)//2 + 1]\n        base_solution, _ = random.choice(candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: probabilistic flip + item swap\n    for _ in range(5):  # Number of attempts\n        # Probabilistic flip: flip items with low value-to-weight ratio\n        if random.random() < 0.5:\n            ratios = value1_lst / weight_lst\n            ratios[new_solution == 0] = np.inf  # Only consider included items\n            idx = np.argmin(ratios)\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Item swap: swap included and excluded items if feasible\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n            if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps and adaptive perturbations to explore the solution space while ensuring feasibility through dynamic weight adjustments and objective-aware flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (either added or removed)\n    candidates = np.where(new_solution != 1)[0] if current_weight >= capacity else np.arange(len(new_solution))\n\n    if len(candidates) == 0:\n        return new_solution  # No feasible moves\n\n    # Hybrid local search: adaptive item swaps and perturbations\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        # Randomly select a candidate item\n        item_idx = np.random.choice(candidates)\n\n        # Flip the item's status\n        new_solution[item_idx] = 1 - new_solution[item_idx]\n\n        # Recalculate total weight\n        new_weight = current_weight + (weight_lst[item_idx] if new_solution[item_idx] == 1 else -weight_lst[item_idx])\n\n        # If infeasible, undo and try another item\n        if new_weight > capacity:\n            new_solution[item_idx] = 1 - new_solution[item_idx]\n            continue\n\n        # Update current weight and candidates\n        current_weight = new_weight\n        candidates = np.where(new_solution != 1)[0] if current_weight >= capacity else np.arange(len(new_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.36486890321545506,
            10.276618391275406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (either added or removed)\n    candidates = np.where(new_solution != 1)[0] if current_weight >= capacity else np.arange(len(new_solution))\n\n    if len(candidates) == 0:\n        return new_solution  # No feasible moves\n\n    # Hybrid local search: adaptive item swaps and perturbations\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        # Randomly select a candidate item\n        item_idx = np.random.choice(candidates)\n\n        # Flip the item's status\n        new_solution[item_idx] = 1 - new_solution[item_idx]\n\n        # Recalculate total weight\n        new_weight = current_weight + (weight_lst[item_idx] if new_solution[item_idx] == 1 else -weight_lst[item_idx])\n\n        # If infeasible, undo and try another item\n        if new_weight > capacity:\n            new_solution[item_idx] = 1 - new_solution[item_idx]\n            continue\n\n        # Update current weight and candidates\n        current_weight = new_weight\n        candidates = np.where(new_solution != 1)[0] if current_weight >= capacity else np.arange(len(new_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement (e.g., using a combination of objective values and solution density) and applies a hybrid local search operator that combines swap-based moves with item replacement, ensuring feasibility while exploring the solution space more effectively than standard 2-opt.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Criteria: Select a solution with high potential for improvement (e.g., not too dense)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    # Strategy: Randomly select a subset of items to swap or replace, ensuring feasibility\n    num_items = len(weight_lst)\n    if num_items <= 1:\n        return new_solution\n\n    # Randomly select a subset of items to modify\n    num_to_modify = min(3, num_items)  # Modify up to 3 items\n    items_to_modify = random.sample(range(num_items), num_to_modify)\n\n    # Track total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    for item in items_to_modify:\n        if new_solution[item] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 += value1_lst[item]\n                current_value2 += value2_lst[item]\n\n    # Step 3: Ensure feasibility\n    if current_weight > capacity:\n        # If still infeasible, remove the heaviest items until feasible\n        while current_weight > capacity:\n            # Find the heaviest item in the solution\n            heavy_items = np.where(new_solution == 1)[0]\n            if len(heavy_items) == 0:\n                break\n            heaviest_item = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest_item] = 0\n            current_weight -= weight_lst[heaviest_item]\n            current_value1 -= value1_lst[heaviest_item]\n            current_value2 -= value2_lst[heaviest_item]\n\n    return new_solution\n\n",
        "score": [
            -0.3865105022213306,
            8.131990224123001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Criteria: Select a solution with high potential for improvement (e.g., not too dense)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    # Strategy: Randomly select a subset of items to swap or replace, ensuring feasibility\n    num_items = len(weight_lst)\n    if num_items <= 1:\n        return new_solution\n\n    # Randomly select a subset of items to modify\n    num_to_modify = min(3, num_items)  # Modify up to 3 items\n    items_to_modify = random.sample(range(num_items), num_to_modify)\n\n    # Track total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    for item in items_to_modify:\n        if new_solution[item] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 += value1_lst[item]\n                current_value2 += value2_lst[item]\n\n    # Step 3: Ensure feasibility\n    if current_weight > capacity:\n        # If still infeasible, remove the heaviest items until feasible\n        while current_weight > capacity:\n            # Find the heaviest item in the solution\n            heavy_items = np.where(new_solution == 1)[0]\n            if len(heavy_items) == 0:\n                break\n            heaviest_item = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest_item] = 0\n            current_weight -= weight_lst[heaviest_item]\n            current_value1 -= value1_lst[heaviest_item]\n            current_value2 -= value2_lst[heaviest_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{A novel hybrid local search strategy that combines probabilistic item swapping with adaptive neighborhood exploration, prioritizing solutions with high potential for multi-objective improvement while ensuring feasibility through constrained random flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        total_value1, total_value2 = obj\n        # Check if solution is not already optimal in both objectives\n        if total_weight < capacity:\n            candidates.append((sol, obj, total_weight))\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback to first solution if no candidates\n\n    # Select a candidate with high potential (e.g., high total weight or high value)\n    selected = max(candidates, key=lambda x: x[2] + x[1][0] + x[1][1])\n    base_solution = selected[0].copy()\n\n    # Generate neighbor using adaptive local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    max_attempts = 10  # Limit attempts to avoid infinite loops\n\n    for _ in range(max_attempts):\n        # Randomly select a subset of items to flip (1-3 items)\n        flip_indices = random.sample(range(n_items), random.randint(1, min(3, n_items)))\n\n        # Temporarily flip the selected items\n        temp_solution = new_solution.copy()\n        temp_solution[flip_indices] = 1 - temp_solution[flip_indices]\n\n        # Check feasibility\n        temp_weight = np.sum(weight_lst * temp_solution)\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            break\n\n    # If no feasible neighbor found, perform a single random flip\n    if np.array_equal(new_solution, base_solution):\n        flip_index = random.randint(0, n_items - 1)\n        new_solution[flip_index] = 1 - new_solution[flip_index]\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[flip_index] = base_solution[flip_index]  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.3547709391529113,
            10.138826161623001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        total_value1, total_value2 = obj\n        # Check if solution is not already optimal in both objectives\n        if total_weight < capacity:\n            candidates.append((sol, obj, total_weight))\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback to first solution if no candidates\n\n    # Select a candidate with high potential (e.g., high total weight or high value)\n    selected = max(candidates, key=lambda x: x[2] + x[1][0] + x[1][1])\n    base_solution = selected[0].copy()\n\n    # Generate neighbor using adaptive local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    max_attempts = 10  # Limit attempts to avoid infinite loops\n\n    for _ in range(max_attempts):\n        # Randomly select a subset of items to flip (1-3 items)\n        flip_indices = random.sample(range(n_items), random.randint(1, min(3, n_items)))\n\n        # Temporarily flip the selected items\n        temp_solution = new_solution.copy()\n        temp_solution[flip_indices] = 1 - temp_solution[flip_indices]\n\n        # Check feasibility\n        temp_weight = np.sum(weight_lst * temp_solution)\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            break\n\n    # If no feasible neighbor found, perform a single random flip\n    if np.array_equal(new_solution, base_solution):\n        flip_index = random.randint(0, n_items - 1)\n        new_solution[flip_index] = 1 - new_solution[flip_index]\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[flip_index] = base_solution[flip_index]  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with high diversity and potential for improvement, then applies a novel local search operator that intelligently flips item selections based on a weighted combination of their marginal contributions to both objectives, ensuring feasibility by dynamically adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Compute marginal contributions for each item\n    marginal_value1 = value1_lst * (1 - base_solution)\n    marginal_value2 = value2_lst * (1 - base_solution)\n    marginal_weight = weight_lst * (1 - base_solution)\n\n    # Compute a combined score for each item (weighted sum of marginal contributions)\n    combined_score = 0.6 * marginal_value1 + 0.4 * marginal_value2\n\n    # Sort items by combined score in descending order\n    sorted_indices = np.argsort(-combined_score)\n\n    # Try to add high-scoring items first, ensuring feasibility\n    new_solution = base_solution.copy()\n    remaining_capacity = capacity - current_weight\n\n    for idx in sorted_indices:\n        if marginal_weight[idx] <= remaining_capacity and new_solution[idx] == 0:\n            new_solution[idx] = 1\n            remaining_capacity -= marginal_weight[idx]\n\n    # If no additions possible, try to remove low-scoring items\n    if np.array_equal(new_solution, base_solution):\n        marginal_value1 = value1_lst * base_solution\n        marginal_value2 = value2_lst * base_solution\n        combined_score = 0.6 * marginal_value1 + 0.4 * marginal_value2\n        sorted_indices = np.argsort(combined_score)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9231046652322494,
            8.414694547653198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Compute marginal contributions for each item\n    marginal_value1 = value1_lst * (1 - base_solution)\n    marginal_value2 = value2_lst * (1 - base_solution)\n    marginal_weight = weight_lst * (1 - base_solution)\n\n    # Compute a combined score for each item (weighted sum of marginal contributions)\n    combined_score = 0.6 * marginal_value1 + 0.4 * marginal_value2\n\n    # Sort items by combined score in descending order\n    sorted_indices = np.argsort(-combined_score)\n\n    # Try to add high-scoring items first, ensuring feasibility\n    new_solution = base_solution.copy()\n    remaining_capacity = capacity - current_weight\n\n    for idx in sorted_indices:\n        if marginal_weight[idx] <= remaining_capacity and new_solution[idx] == 0:\n            new_solution[idx] = 1\n            remaining_capacity -= marginal_weight[idx]\n\n    # If no additions possible, try to remove low-scoring items\n    if np.array_equal(new_solution, base_solution):\n        marginal_value1 = value1_lst * base_solution\n        marginal_value2 = value2_lst * base_solution\n        combined_score = 0.6 * marginal_value1 + 0.4 * marginal_value2\n        sorted_indices = np.argsort(combined_score)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement by considering both objectives, then applies a hybrid local search operator that combines random item swaps with a greedy selection of items to maximize marginal gains in either objective, ensuring feasibility while exploring the solution space for better trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive based on its potential for improvement\n    # Here, we select a solution with a high total value in either objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: random swaps followed by greedy selection\n    num_items = len(weight_lst)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select an item to flip\n        item_idx = random.randint(0, num_items - 1)\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 1\n                current_weight = new_weight\n\n    # Greedy selection of items based on marginal gain\n    for _ in range(5):  # Additional greedy steps\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) == 0:\n            break\n        # Calculate marginal gains for excluded items\n        marginal_gains = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n        best_item = excluded_items[np.argmax(marginal_gains)]\n        if current_weight + weight_lst[best_item] <= capacity:\n            new_solution[best_item] = 1\n            current_weight += weight_lst[best_item]\n\n    return new_solution\n\n",
        "score": [
            -0.30638908174207163,
            10.227888524532318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive based on its potential for improvement\n    # Here, we select a solution with a high total value in either objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: random swaps followed by greedy selection\n    num_items = len(weight_lst)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select an item to flip\n        item_idx = random.randint(0, num_items - 1)\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item_idx]\n            if new_weight <= capacity:\n                new_solution[item_idx] = 1\n                current_weight = new_weight\n\n    # Greedy selection of items based on marginal gain\n    for _ in range(5):  # Additional greedy steps\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) == 0:\n            break\n        # Calculate marginal gains for excluded items\n        marginal_gains = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n        best_item = excluded_items[np.argmax(marginal_gains)]\n        if current_weight + weight_lst[best_item] <= capacity:\n            new_solution[best_item] = 1\n            current_weight += weight_lst[best_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This algorithm intelligently selects a non-dominated solution from the archive, applies a hybrid local search that combines random item swaps and value-based perturbations to explore the objective space while ensuring feasibility, and returns the improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine random swaps and value-based perturbations\n    for _ in range(3):  # Perform up to 3 perturbations\n        # Randomly select two items to swap\n        indices = np.where(new_solution == 1)[0]\n        if len(indices) >= 2:\n            i, j = random.sample(list(indices), 2)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # If infeasible, revert and try another approach\n            new_solution = selected_solution.copy()\n            continue\n\n        # Value-based perturbation: flip items with high ratio of value1/weight and value2/weight\n        ratios1 = value1_lst / weight_lst\n        ratios2 = value2_lst / weight_lst\n        combined_ratios = ratios1 + ratios2\n        sorted_indices = np.argsort(combined_ratios)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                # Try removing the item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n            else:\n                # Try adding the item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8523931898494883,
            8.265171200037003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine random swaps and value-based perturbations\n    for _ in range(3):  # Perform up to 3 perturbations\n        # Randomly select two items to swap\n        indices = np.where(new_solution == 1)[0]\n        if len(indices) >= 2:\n            i, j = random.sample(list(indices), 2)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # If infeasible, revert and try another approach\n            new_solution = selected_solution.copy()\n            continue\n\n        # Value-based perturbation: flip items with high ratio of value1/weight and value2/weight\n        ratios1 = value1_lst / weight_lst\n        ratios2 = value2_lst / weight_lst\n        combined_ratios = ratios1 + ratios2\n        sorted_indices = np.argsort(combined_ratios)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                # Try removing the item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n            else:\n                # Try adding the item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a combination of objective diversity and potential improvement, then applies a novel hybrid local search operator that combines item swapping and subset replacement to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly select a subset of items to potentially replace\n    items_to_replace = np.where(base_solution == 1)[0]\n    if len(items_to_replace) > 0:\n        num_to_replace = min(3, len(items_to_replace))\n        replace_indices = np.random.choice(items_to_replace, num_to_replace, replace=False)\n        new_solution[replace_indices] = 0\n\n    # Step 2: Add items that are not in the current solution but have high potential\n    # Calculate potential based on value-to-weight ratio and objective diversity\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate potential scores for each objective\n        potential_score1 = value1_lst / (weight_lst + 1e-6)\n        potential_score2 = value2_lst / (weight_lst + 1e-6)\n        combined_score = (potential_score1 + potential_score2) / 2\n\n        # Select top k items based on combined score\n        k = min(3, len(potential_items))\n        top_items = np.argpartition(combined_score[potential_items], -k)[-k:]\n        candidate_items = potential_items[top_items]\n\n        # Try to add items while maintaining feasibility\n        current_weight = np.sum(weight_lst * new_solution)\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 3: Perform a small perturbation to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        flip_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        new_solution[flip_indices[0]], new_solution[flip_indices[1]] = new_solution[flip_indices[1]], new_solution[flip_indices[0]]\n\n    # Ensure feasibility in case of any errors\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        items_in_solution = np.where(new_solution == 1)[0]\n        np.random.shuffle(items_in_solution)\n        for item in items_in_solution:\n            if current_weight <= capacity:\n                break\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4657259120515158,
            8.81441143155098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly select a subset of items to potentially replace\n    items_to_replace = np.where(base_solution == 1)[0]\n    if len(items_to_replace) > 0:\n        num_to_replace = min(3, len(items_to_replace))\n        replace_indices = np.random.choice(items_to_replace, num_to_replace, replace=False)\n        new_solution[replace_indices] = 0\n\n    # Step 2: Add items that are not in the current solution but have high potential\n    # Calculate potential based on value-to-weight ratio and objective diversity\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate potential scores for each objective\n        potential_score1 = value1_lst / (weight_lst + 1e-6)\n        potential_score2 = value2_lst / (weight_lst + 1e-6)\n        combined_score = (potential_score1 + potential_score2) / 2\n\n        # Select top k items based on combined score\n        k = min(3, len(potential_items))\n        top_items = np.argpartition(combined_score[potential_items], -k)[-k:]\n        candidate_items = potential_items[top_items]\n\n        # Try to add items while maintaining feasibility\n        current_weight = np.sum(weight_lst * new_solution)\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 3: Perform a small perturbation to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        flip_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        new_solution[flip_indices[0]], new_solution[flip_indices[1]] = new_solution[flip_indices[1]], new_solution[flip_indices[0]]\n\n    # Ensure feasibility in case of any errors\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        items_in_solution = np.where(new_solution == 1)[0]\n        np.random.shuffle(items_in_solution)\n        for item in items_in_solution:\n            if current_weight <= capacity:\n                break\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{A novel hybrid local search algorithm that combines cluster-based exploration with adaptive perturbation, prioritizing solutions near the Pareto frontier and dynamically adjusting perturbations based on local objective gradients to escape plateaus while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the most promising solution (closest to the Pareto frontier)\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_values = np.max(objectives, axis=0)\n    distances = np.linalg.norm(objectives - max_values, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 3: Hybrid local search - cluster-based perturbation with adaptive step\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Cluster items into high-value and low-value groups for each objective\n    value1_ratios = value1_lst / (weight_lst + 1e-10)\n    value2_ratios = value2_lst / (weight_lst + 1e-10)\n\n    # Select perturbation candidates based on both objectives\n    high_value1 = np.argsort(value1_ratios)[-n_items//4:]\n    high_value2 = np.argsort(value2_ratios)[-n_items//4:]\n    candidates = np.union1d(high_value1, high_value2)\n\n    # Adaptive perturbation: flip a random subset of candidates\n    flip_count = min(3, len(candidates))\n    np.random.shuffle(candidates)\n    flip_indices = candidates[:flip_count]\n\n    # Flip selected items while maintaining feasibility\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional small random perturbation to escape local optima\n    if np.random.random() < 0.3:\n        random_idx = np.random.randint(0, n_items)\n        if base_solution[random_idx] == 1:\n            if current_weight - weight_lst[random_idx] <= capacity:\n                new_solution[random_idx] = 0\n        else:\n            if current_weight + weight_lst[random_idx] <= capacity:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3842774361768886,
            10.608799427747726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the most promising solution (closest to the Pareto frontier)\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_values = np.max(objectives, axis=0)\n    distances = np.linalg.norm(objectives - max_values, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 3: Hybrid local search - cluster-based perturbation with adaptive step\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Cluster items into high-value and low-value groups for each objective\n    value1_ratios = value1_lst / (weight_lst + 1e-10)\n    value2_ratios = value2_lst / (weight_lst + 1e-10)\n\n    # Select perturbation candidates based on both objectives\n    high_value1 = np.argsort(value1_ratios)[-n_items//4:]\n    high_value2 = np.argsort(value2_ratios)[-n_items//4:]\n    candidates = np.union1d(high_value1, high_value2)\n\n    # Adaptive perturbation: flip a random subset of candidates\n    flip_count = min(3, len(candidates))\n    np.random.shuffle(candidates)\n    flip_indices = candidates[:flip_count]\n\n    # Flip selected items while maintaining feasibility\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional small random perturbation to escape local optima\n    if np.random.random() < 0.3:\n        random_idx = np.random.randint(0, n_items)\n        if base_solution[random_idx] == 1:\n            if current_weight - weight_lst[random_idx] <= capacity:\n                new_solution[random_idx] = 0\n        else:\n            if current_weight + weight_lst[random_idx] <= capacity:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be added (not in current solution and within capacity)\n    candidate_items = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    if len(candidate_items) > 0:\n        # Select an item to add based on the highest marginal gain in either objective\n        marginal_gain1 = value1_lst[candidate_items]\n        marginal_gain2 = value2_lst[candidate_items]\n        best_item_idx = candidate_items[np.argmax(marginal_gain1 + marginal_gain2)]\n\n        # Create a new solution by adding the best item\n        new_solution = base_solution.copy()\n        new_solution[best_item_idx] = 1\n    else:\n        # If no items can be added, try removing the item with the smallest marginal loss\n        candidate_items = np.where(base_solution == 1)[0]\n        marginal_loss1 = value1_lst[candidate_items]\n        marginal_loss2 = value2_lst[candidate_items]\n        worst_item_idx = candidate_items[np.argmin(marginal_loss1 + marginal_loss2)]\n\n        new_solution = base_solution.copy()\n        new_solution[worst_item_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9015275893970669,
            6.714410096406937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be added (not in current solution and within capacity)\n    candidate_items = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    if len(candidate_items) > 0:\n        # Select an item to add based on the highest marginal gain in either objective\n        marginal_gain1 = value1_lst[candidate_items]\n        marginal_gain2 = value2_lst[candidate_items]\n        best_item_idx = candidate_items[np.argmax(marginal_gain1 + marginal_gain2)]\n\n        # Create a new solution by adding the best item\n        new_solution = base_solution.copy()\n        new_solution[best_item_idx] = 1\n    else:\n        # If no items can be added, try removing the item with the smallest marginal loss\n        candidate_items = np.where(base_solution == 1)[0]\n        marginal_loss1 = value1_lst[candidate_items]\n        marginal_loss2 = value2_lst[candidate_items]\n        worst_item_idx = candidate_items[np.argmin(marginal_loss1 + marginal_loss2)]\n\n        new_solution = base_solution.copy()\n        new_solution[worst_item_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify items to potentially swap or flip\n    included = np.where(selected_solution == 1)[0]\n    excluded = np.where(selected_solution == 0)[0]\n\n    # Hybrid local search: flip a random included item and add a random excluded item if feasible\n    if len(included) > 0:\n        flip_idx = np.random.choice(included)\n        new_solution[flip_idx] = 0\n\n    if len(excluded) > 0:\n        add_idx = np.random.choice(excluded)\n        if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_idx] <= capacity:\n            new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.30840750610569384,
            7.606284946203232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify items to potentially swap or flip\n    included = np.where(selected_solution == 1)[0]\n    excluded = np.where(selected_solution == 0)[0]\n\n    # Hybrid local search: flip a random included item and add a random excluded item if feasible\n    if len(included) > 0:\n        flip_idx = np.random.choice(included)\n        new_solution[flip_idx] = 0\n\n    if len(excluded) > 0:\n        add_idx = np.random.choice(excluded)\n        if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_idx] <= capacity:\n            new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{The algorithm first selects a promising solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search combining item swaps and probabilistic flips to generate a feasible neighbor solution while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: probabilistic item flips with weight balance\n    new_solution = base_solution.copy()\n\n    # First, try to add items not in the solution\n    available_items = np.where(base_solution == 0)[0]\n    for item in available_items:\n        if current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.7:  # Higher probability to add promising items\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Then, try to remove items from the solution\n    included_items = np.where(base_solution == 1)[0]\n    for item in included_items:\n        if random.random() < 0.3:  # Lower probability to remove\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility (in case of any errors)\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If still infeasible, randomly remove items until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            included = np.where(new_solution == 1)[0]\n            if len(included) == 0:\n                break\n            item_to_remove = random.choice(included)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8676540240772406,
            7.120405167341232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: probabilistic item flips with weight balance\n    new_solution = base_solution.copy()\n\n    # First, try to add items not in the solution\n    available_items = np.where(base_solution == 0)[0]\n    for item in available_items:\n        if current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.7:  # Higher probability to add promising items\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Then, try to remove items from the solution\n    included_items = np.where(base_solution == 1)[0]\n    for item in included_items:\n        if random.random() < 0.3:  # Lower probability to remove\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility (in case of any errors)\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If still infeasible, randomly remove items until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            included = np.where(new_solution == 1)[0]\n            if len(included) == 0:\n                break\n            item_to_remove = random.choice(included)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{The heuristic function selects a promising solution from the archive using a weighted random selection based on the solution's potential for improvement, then applies a hybrid local search operator that combines item swapping and dynamic subset flipping to explore non-dominated neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using weighted random selection\n    weights = [1.0 / (i + 1) for i in range(len(archive))]  # Higher weight for earlier solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly swap two items if feasible\n    items = np.where(base_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        if (np.sum(weight_lst[new_solution == 1]) - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Dynamically flip a subset of items if feasible\n    subset_size = min(3, len(items))\n    if subset_size > 0:\n        subset = random.sample(list(items), subset_size)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        for item in subset:\n            if new_solution[item] == 1:\n                if (current_weight - weight_lst[item]) <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if (current_weight + weight_lst[item]) <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8700415116534077,
            6.739141374826431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using weighted random selection\n    weights = [1.0 / (i + 1) for i in range(len(archive))]  # Higher weight for earlier solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly swap two items if feasible\n    items = np.where(base_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        if (np.sum(weight_lst[new_solution == 1]) - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Dynamically flip a subset of items if feasible\n    subset_size = min(3, len(items))\n    if subset_size > 0:\n        subset = random.sample(list(items), subset_size)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        for item in subset:\n            if new_solution[item] == 1:\n                if (current_weight - weight_lst[item]) <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if (current_weight + weight_lst[item]) <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines multi-objective selection with a dynamic neighborhood exploration strategy, prioritizing solutions with high potential for improvement while ensuring feasibility through adaptive item swaps and reinsertions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not on the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Find items to potentially swap or remove\n    candidate_indices = np.where(base_solution == 1)[0]\n\n    if len(candidate_indices) == 0:\n        # If no items are selected, try adding items\n        candidate_indices = np.where(base_solution == 0)[0]\n        if len(candidate_indices) == 0:\n            return base_solution  # No possible moves\n\n    # Hybrid local search: swap or remove items with high impact\n    new_solution = base_solution.copy()\n\n    for _ in range(3):  # Perform up to 3 moves\n        # Randomly select an item to modify\n        item_idx = random.choice(candidate_indices)\n\n        if base_solution[item_idx] == 1:\n            # Remove the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 0\n            temp_weight = current_weight - weight_lst[item_idx]\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 -= value1_lst[item_idx]\n                current_value2 -= value2_lst[item_idx]\n        else:\n            # Add the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 1\n            temp_weight = current_weight + weight_lst[item_idx]\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 += value1_lst[item_idx]\n                current_value2 += value2_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7948544869915841,
            4.682496041059494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not on the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Find items to potentially swap or remove\n    candidate_indices = np.where(base_solution == 1)[0]\n\n    if len(candidate_indices) == 0:\n        # If no items are selected, try adding items\n        candidate_indices = np.where(base_solution == 0)[0]\n        if len(candidate_indices) == 0:\n            return base_solution  # No possible moves\n\n    # Hybrid local search: swap or remove items with high impact\n    new_solution = base_solution.copy()\n\n    for _ in range(3):  # Perform up to 3 moves\n        # Randomly select an item to modify\n        item_idx = random.choice(candidate_indices)\n\n        if base_solution[item_idx] == 1:\n            # Remove the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 0\n            temp_weight = current_weight - weight_lst[item_idx]\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 -= value1_lst[item_idx]\n                current_value2 -= value2_lst[item_idx]\n        else:\n            # Add the item\n            temp_solution = new_solution.copy()\n            temp_solution[item_idx] = 1\n            temp_weight = current_weight + weight_lst[item_idx]\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 += value1_lst[item_idx]\n                current_value2 += value2_lst[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{A novel hybrid local search operator combines random diversification with a dynamic objective-weighted greedy improvement, selecting items based on a weighted sum of both objectives and a random perturbation to escape local optima, while ensuring feasibility by strict weight constraint checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic objective weights for weighted greedy improvement\n    alpha = random.random()\n    weighted_value = alpha * value1_lst + (1 - alpha) * value2_lst\n\n    # Randomly perturb the objective weights to escape local optima\n    perturbation = random.uniform(0.1, 0.3)\n    weighted_value = weighted_value * (1 + perturbation * np.random.randn(len(weighted_value)))\n\n    # Create a list of items sorted by weighted value\n    items_sorted = np.argsort(weighted_value)[::-1]\n\n    # Perform hybrid local search: flip items with highest marginal gain\n    for item in items_sorted:\n        if new_solution[item] == 0:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n        else:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Randomly flip some items to diversify the solution\n    flip_prob = 0.1\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.33643391450452825,
            9.580013006925583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic objective weights for weighted greedy improvement\n    alpha = random.random()\n    weighted_value = alpha * value1_lst + (1 - alpha) * value2_lst\n\n    # Randomly perturb the objective weights to escape local optima\n    perturbation = random.uniform(0.1, 0.3)\n    weighted_value = weighted_value * (1 + perturbation * np.random.randn(len(weighted_value)))\n\n    # Create a list of items sorted by weighted value\n    items_sorted = np.argsort(weighted_value)[::-1]\n\n    # Perform hybrid local search: flip items with highest marginal gain\n    for item in items_sorted:\n        if new_solution[item] == 0:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n        else:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Randomly flip some items to diversify the solution\n    flip_prob = 0.1\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values or those that are close to the Pareto front, then applies a novel local search operator that intelligently flips a subset of items to balance the trade-off between the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Prioritize solutions that are not too close to the Pareto front\n        candidates.append((sol, obj, np.sum(sol), obj[0] + obj[1]))\n\n    # Sort by sum of items and total objective value (higher is better)\n    candidates.sort(key=lambda x: (-x[2], -x[3]))\n    selected_sol = candidates[0][0].copy()\n\n    # Generate neighbor by flipping a subset of items to balance objectives\n    new_solution = selected_sol.copy()\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(candidate_indices, size=min(3, len(candidate_indices)), replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it doesn't violate capacity\n            if np.sum(weight_lst[new_solution == 1] - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add item if it fits within capacity\n            if np.sum(weight_lst[new_solution == 1] + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8348547382587317,
            10.321558237075806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Prioritize solutions that are not too close to the Pareto front\n        candidates.append((sol, obj, np.sum(sol), obj[0] + obj[1]))\n\n    # Sort by sum of items and total objective value (higher is better)\n    candidates.sort(key=lambda x: (-x[2], -x[3]))\n    selected_sol = candidates[0][0].copy()\n\n    # Generate neighbor by flipping a subset of items to balance objectives\n    new_solution = selected_sol.copy()\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(candidate_indices, size=min(3, len(candidate_indices)), replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it doesn't violate capacity\n            if np.sum(weight_lst[new_solution == 1] - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add item if it fits within capacity\n            if np.sum(weight_lst[new_solution == 1] + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swap and flip with adaptive step size\n    n_items = len(base_solution)\n    step_size = max(1, int(np.sqrt(n_items)))\n\n    # Randomly select a segment to modify\n    start = np.random.randint(n_items - step_size)\n    end = start + step_size\n\n    # Flip a segment of the solution\n    new_solution[start:end] = 1 - new_solution[start:end]\n\n    # Ensure feasibility by removing items if exceeding capacity\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        excess = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for i in excess_items:\n            if excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    # Additional swap operation to diversify\n    if np.random.random() < 0.3:\n        swap_indices = np.random.choice(n_items, size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Ensure at least one item is added if solution is empty\n    if np.sum(new_solution) == 0:\n        new_solution[np.random.randint(n_items)] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3982426812623451,
            11.144662857055664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swap and flip with adaptive step size\n    n_items = len(base_solution)\n    step_size = max(1, int(np.sqrt(n_items)))\n\n    # Randomly select a segment to modify\n    start = np.random.randint(n_items - step_size)\n    end = start + step_size\n\n    # Flip a segment of the solution\n    new_solution[start:end] = 1 - new_solution[start:end]\n\n    # Ensure feasibility by removing items if exceeding capacity\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        excess = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for i in excess_items:\n            if excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    # Additional swap operation to diversify\n    if np.random.random() < 0.3:\n        swap_indices = np.random.choice(n_items, size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Ensure at least one item is added if solution is empty\n    if np.sum(new_solution) == 0:\n        new_solution[np.random.randint(n_items)] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify items that can be flipped (added or removed) to improve both objectives\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    potential_items = []\n\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                potential_items.append((i, 'remove'))\n        else:\n            # Check if adding the item improves both objectives\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                potential_items.append((i, 'add'))\n\n    if not potential_items:\n        return new_solution\n\n    # Randomly select a flip operation from potential items\n    item_idx, action = random.choice(potential_items)\n    if action == 'remove':\n        new_solution[item_idx] = 0\n    else:\n        new_solution[item_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8256219118759514,
            8.262980908155441
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify items that can be flipped (added or removed) to improve both objectives\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    potential_items = []\n\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                potential_items.append((i, 'remove'))\n        else:\n            # Check if adding the item improves both objectives\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                potential_items.append((i, 'add'))\n\n    if not potential_items:\n        return new_solution\n\n    # Randomly select a flip operation from potential items\n    item_idx, action = random.choice(potential_items)\n    if action == 'remove':\n        new_solution[item_idx] = 0\n    else:\n        new_solution[item_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive, applies a hybrid local search strategy combining item swaps, probabilistic flips, and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Generate a neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Probabilistic flip of items with high marginal utility\n    # 2. Swap items between high and low utility groups\n    # 3. Randomly flip a small number of items\n\n    # Calculate marginal utility (value per weight) for each item\n    marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal utilities\n    combined_marginal = marginal1 + marginal2\n\n    # Identify high and low utility items\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n    high_util_items = sorted_indices[:len(sorted_indices)//2]\n    low_util_items = sorted_indices[len(sorted_indices)//2:]\n\n    # Probabilistic flip of high utility items\n    for item in high_util_items:\n        if random.random() < 0.3:  # 30% chance to flip\n            if base_solution[item] == 1:\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Swap items between high and low utility groups\n    for _ in range(3):  # Perform 3 swaps\n        if len(high_util_items) > 0 and len(low_util_items) > 0:\n            high_item = random.choice(high_util_items)\n            low_item = random.choice(low_util_items)\n\n            if base_solution[high_item] == 1 and base_solution[low_item] == 0:\n                if (current_weight - weight_lst[high_item] + weight_lst[low_item]) <= capacity:\n                    new_solution[high_item] = 0\n                    new_solution[low_item] = 1\n                    current_weight = current_weight - weight_lst[high_item] + weight_lst[low_item]\n\n    # Randomly flip a small number of items (1-3)\n    flip_count = random.randint(1, 3)\n    for _ in range(flip_count):\n        item = random.randint(0, len(weight_lst) - 1)\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove random item until feasible\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            remove_item = random.choice(included_items)\n            new_solution[remove_item] = 0\n        else:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.39617008435175816,
            7.453691691160202
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Generate a neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Probabilistic flip of items with high marginal utility\n    # 2. Swap items between high and low utility groups\n    # 3. Randomly flip a small number of items\n\n    # Calculate marginal utility (value per weight) for each item\n    marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal utilities\n    combined_marginal = marginal1 + marginal2\n\n    # Identify high and low utility items\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n    high_util_items = sorted_indices[:len(sorted_indices)//2]\n    low_util_items = sorted_indices[len(sorted_indices)//2:]\n\n    # Probabilistic flip of high utility items\n    for item in high_util_items:\n        if random.random() < 0.3:  # 30% chance to flip\n            if base_solution[item] == 1:\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Swap items between high and low utility groups\n    for _ in range(3):  # Perform 3 swaps\n        if len(high_util_items) > 0 and len(low_util_items) > 0:\n            high_item = random.choice(high_util_items)\n            low_item = random.choice(low_util_items)\n\n            if base_solution[high_item] == 1 and base_solution[low_item] == 0:\n                if (current_weight - weight_lst[high_item] + weight_lst[low_item]) <= capacity:\n                    new_solution[high_item] = 0\n                    new_solution[low_item] = 1\n                    current_weight = current_weight - weight_lst[high_item] + weight_lst[low_item]\n\n    # Randomly flip a small number of items (1-3)\n    flip_count = random.randint(1, 3)\n    for _ in range(flip_count):\n        item = random.randint(0, len(weight_lst) - 1)\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove random item until feasible\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            remove_item = random.choice(included_items)\n            new_solution[remove_item] = 0\n        else:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential: prioritize solutions with high diversity or high marginal gains\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Hybrid local search: random flip with bias towards improving objectives\n    flip_indices = np.where(new_solution == 1)[0]\n    if len(flip_indices) == 0:\n        flip_indices = np.where(new_solution == 0)[0]\n\n    # Randomly select an item to flip\n    if len(flip_indices) > 0:\n        flip_idx = np.random.choice(flip_indices)\n        if new_solution[flip_idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Additional exploration: flip a random item to escape local optima\n    explore_idx = np.random.choice(len(new_solution))\n    if new_solution[explore_idx] == 1:\n        if current_weight - weight_lst[explore_idx] <= capacity:\n            new_solution[explore_idx] = 0\n    else:\n        if current_weight + weight_lst[explore_idx] <= capacity:\n            new_solution[explore_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8509622901307432,
            7.248419523239136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential: prioritize solutions with high diversity or high marginal gains\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Hybrid local search: random flip with bias towards improving objectives\n    flip_indices = np.where(new_solution == 1)[0]\n    if len(flip_indices) == 0:\n        flip_indices = np.where(new_solution == 0)[0]\n\n    # Randomly select an item to flip\n    if len(flip_indices) > 0:\n        flip_idx = np.random.choice(flip_indices)\n        if new_solution[flip_idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Additional exploration: flip a random item to escape local optima\n    explore_idx = np.random.choice(len(new_solution))\n    if new_solution[explore_idx] == 1:\n        if current_weight - weight_lst[explore_idx] <= capacity:\n            new_solution[explore_idx] = 0\n    else:\n        if current_weight + weight_lst[explore_idx] <= capacity:\n            new_solution[explore_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines random swap and greedy selection of items with the highest marginal gain in the objective space to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution for local search\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for flip\n    flip_candidates = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    for i in flip_candidates:\n        if new_solution[i] == 1:\n            # Try removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                # Evaluate marginal gain for both objectives\n                marginal_gain1 = value1_lst[i]\n                marginal_gain2 = value2_lst[i]\n                # Accept if both objectives improve or one improves significantly\n                if (marginal_gain1 > 0 and marginal_gain2 > 0) or \\\n                   (marginal_gain1 > 0 and random.random() < 0.3) or \\\n                   (marginal_gain2 > 0 and random.random() < 0.3):\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    # Additional random swap operation\n    if len(weight_lst) > 1:\n        i, j = random.sample(range(len(weight_lst)), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1 and (current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif new_solution[j] == 1 and (current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.36276681975853287,
            7.438210695981979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution for local search\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for flip\n    flip_candidates = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    for i in flip_candidates:\n        if new_solution[i] == 1:\n            # Try removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                # Evaluate marginal gain for both objectives\n                marginal_gain1 = value1_lst[i]\n                marginal_gain2 = value2_lst[i]\n                # Accept if both objectives improve or one improves significantly\n                if (marginal_gain1 > 0 and marginal_gain2 > 0) or \\\n                   (marginal_gain1 > 0 and random.random() < 0.3) or \\\n                   (marginal_gain2 > 0 and random.random() < 0.3):\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    # Additional random swap operation\n    if len(weight_lst) > 1:\n        i, j = random.sample(range(len(weight_lst)), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1 and (current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif new_solution[j] == 1 and (current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by sum of objectives (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions\n        top_solutions = archive_sorted[int(0.7 * len(archive_sorted)):]\n        selected_idx = np.random.choice(len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a subset of items based on their marginal contribution\n    # Calculate marginal contribution for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n\n    # Combine marginal contributions (simple average)\n    combined_marginal = (marginal1 + marginal2) / 2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Select top k items (k is a fraction of total items)\n    k = max(1, int(0.1 * len(new_solution)))\n    selected_items = sorted_items[:k]\n\n    # Flip the selected items (toggle 0 to 1 or 1 to 0)\n    for item in selected_items:\n        new_solution[item] = 1 - new_solution[item]\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Sort items by marginal contribution (ascending) and remove until feasible\n        sorted_items = np.argsort(combined_marginal)\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                total_weight = np.sum(new_solution * weight_lst)\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.42415165396890875,
            6.521550387144089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by sum of objectives (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions\n        top_solutions = archive_sorted[int(0.7 * len(archive_sorted)):]\n        selected_idx = np.random.choice(len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a subset of items based on their marginal contribution\n    # Calculate marginal contribution for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n\n    # Combine marginal contributions (simple average)\n    combined_marginal = (marginal1 + marginal2) / 2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Select top k items (k is a fraction of total items)\n    k = max(1, int(0.1 * len(new_solution)))\n    selected_items = sorted_items[:k]\n\n    # Flip the selected items (toggle 0 to 1 or 1 to 0)\n    for item in selected_items:\n        new_solution[item] = 1 - new_solution[item]\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Sort items by marginal contribution (ascending) and remove until feasible\n        sorted_items = np.argsort(combined_marginal)\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                total_weight = np.sum(new_solution * weight_lst)\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive item swapping with objective-aware perturbation, prioritizing solutions with high potential for improvement by evaluating both objective values and their dominance relationships to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions based on their objective values (prioritize higher values)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        selected = sorted_archive[0][0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Find items to swap or flip\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            new_value1 = current_value1 - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1, new_weight, new_value1, new_value2))  # -1 indicates removal\n        else:\n            # Check if adding this item improves both objectives\n            new_weight = current_weight + weight_lst[i]\n            new_value1 = current_value1 + value1_lst[i]\n            new_value2 = current_value2 + value2_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, 1, new_weight, new_value1, new_value2))  # 1 indicates addition\n\n    if not candidates:\n        # If no candidates, perform a random flip\n        i = np.random.randint(len(new_solution))\n        if current_weight + (1 if new_solution[i] == 0 else -1) * weight_lst[i] <= capacity:\n            new_solution[i] = 1 - new_solution[i]\n        return new_solution\n\n    # Select the best candidate based on combined improvement in both objectives\n    best_candidate = max(candidates, key=lambda x: (x[3] + x[4] - (current_value1 + current_value2)))\n\n    # Apply the best candidate\n    i, action, _, _, _ = best_candidate\n    new_solution[i] = 1 if action == 1 else 0\n\n    # Perform additional perturbation to escape local optima\n    if np.random.random() < 0.3:  # 30% chance for perturbation\n        i = np.random.choice(np.where(new_solution == 1)[0], size=1)[0]\n        j = np.random.choice(np.where(new_solution == 0)[0], size=1)[0]\n        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = 0, 1\n\n    return new_solution\n\n",
        "score": [
            -0.37770166553580786,
            6.475190907716751
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions based on their objective values (prioritize higher values)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        selected = sorted_archive[0][0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Find items to swap or flip\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            new_value1 = current_value1 - value1_lst[i]\n            new_value2 = current_value2 - value2_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1, new_weight, new_value1, new_value2))  # -1 indicates removal\n        else:\n            # Check if adding this item improves both objectives\n            new_weight = current_weight + weight_lst[i]\n            new_value1 = current_value1 + value1_lst[i]\n            new_value2 = current_value2 + value2_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, 1, new_weight, new_value1, new_value2))  # 1 indicates addition\n\n    if not candidates:\n        # If no candidates, perform a random flip\n        i = np.random.randint(len(new_solution))\n        if current_weight + (1 if new_solution[i] == 0 else -1) * weight_lst[i] <= capacity:\n            new_solution[i] = 1 - new_solution[i]\n        return new_solution\n\n    # Select the best candidate based on combined improvement in both objectives\n    best_candidate = max(candidates, key=lambda x: (x[3] + x[4] - (current_value1 + current_value2)))\n\n    # Apply the best candidate\n    i, action, _, _, _ = best_candidate\n    new_solution[i] = 1 if action == 1 else 0\n\n    # Perform additional perturbation to escape local optima\n    if np.random.random() < 0.3:  # 30% chance for perturbation\n        i = np.random.choice(np.where(new_solution == 1)[0], size=1)[0]\n        j = np.random.choice(np.where(new_solution == 0)[0], size=1)[0]\n        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = 0, 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objective = max(archive, key=lambda x: sum(x[1]))\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that are not in the solution and could potentially be added\n    not_in_solution = np.where(base_solution == 0)[0]\n    marginal_weights = weight_lst[not_in_solution]\n    marginal_value1 = value1_lst[not_in_solution]\n    marginal_value2 = value2_lst[not_in_solution]\n\n    # Calculate the potential improvement per weight unit for both objectives\n    marginal_ratio1 = marginal_value1 / (marginal_weights + 1e-8)\n    marginal_ratio2 = marginal_value2 / (marginal_weights + 1e-8)\n\n    # Combine the ratios to identify promising items to add\n    combined_ratio = marginal_ratio1 + marginal_ratio2\n    sorted_indices = np.argsort(combined_ratio)[::-1]  # Sort in descending order\n\n    # Try to add the top items first\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        item_idx = not_in_solution[idx]\n        if current_weight + weight_lst[item_idx] <= capacity:\n            new_solution[item_idx] = 1\n            current_weight += weight_lst[item_idx]\n\n    # Perform a random swap of items between included and excluded to diversify the solution\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select an item to remove\n        remove_idx = np.random.choice(included)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n        # Randomly select an item to add (from excluded) that fits the remaining capacity\n        add_candidates = excluded[weight_lst[excluded] <= (capacity - current_weight)]\n        if len(add_candidates) > 0:\n            add_idx = np.random.choice(add_candidates)\n            new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.32025805392489565,
            7.618563413619995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objective = max(archive, key=lambda x: sum(x[1]))\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that are not in the solution and could potentially be added\n    not_in_solution = np.where(base_solution == 0)[0]\n    marginal_weights = weight_lst[not_in_solution]\n    marginal_value1 = value1_lst[not_in_solution]\n    marginal_value2 = value2_lst[not_in_solution]\n\n    # Calculate the potential improvement per weight unit for both objectives\n    marginal_ratio1 = marginal_value1 / (marginal_weights + 1e-8)\n    marginal_ratio2 = marginal_value2 / (marginal_weights + 1e-8)\n\n    # Combine the ratios to identify promising items to add\n    combined_ratio = marginal_ratio1 + marginal_ratio2\n    sorted_indices = np.argsort(combined_ratio)[::-1]  # Sort in descending order\n\n    # Try to add the top items first\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        item_idx = not_in_solution[idx]\n        if current_weight + weight_lst[item_idx] <= capacity:\n            new_solution[item_idx] = 1\n            current_weight += weight_lst[item_idx]\n\n    # Perform a random swap of items between included and excluded to diversify the solution\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select an item to remove\n        remove_idx = np.random.choice(included)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n        # Randomly select an item to add (from excluded) that fits the remaining capacity\n        add_candidates = excluded[weight_lst[excluded] <= (capacity - current_weight)]\n        if len(add_candidates) > 0:\n            add_idx = np.random.choice(add_candidates)\n            new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping, value-aware perturbation, and non-dominated solution exploration to generate high-quality neighbors by intelligently flipping items based on their contribution to both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (either added or removed) without violating capacity\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 indicates addition\n\n    if not candidates:\n        return new_solution  # No feasible moves\n\n    # Select a candidate based on value contribution\n    # Prioritize items with high value-to-weight ratio for both objectives\n    best_candidate = None\n    best_score = -1\n    for i, flip in candidates:\n        if flip == 1:\n            # Adding item i\n            value1_contribution = value1_lst[i] / weight_lst[i]\n            value2_contribution = value2_lst[i] / weight_lst[i]\n        else:\n            # Removing item i\n            value1_contribution = -value1_lst[i] / weight_lst[i]\n            value2_contribution = -value2_lst[i] / weight_lst[i]\n\n        # Score combines contributions to both objectives\n        score = value1_contribution + value2_contribution\n        if score > best_score:\n            best_score = score\n            best_candidate = (i, flip)\n\n    if best_candidate:\n        i, flip = best_candidate\n        new_solution[i] = flip if flip == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8487965763697266,
            7.27621003985405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (either added or removed) without violating capacity\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 indicates addition\n\n    if not candidates:\n        return new_solution  # No feasible moves\n\n    # Select a candidate based on value contribution\n    # Prioritize items with high value-to-weight ratio for both objectives\n    best_candidate = None\n    best_score = -1\n    for i, flip in candidates:\n        if flip == 1:\n            # Adding item i\n            value1_contribution = value1_lst[i] / weight_lst[i]\n            value2_contribution = value2_lst[i] / weight_lst[i]\n        else:\n            # Removing item i\n            value1_contribution = -value1_lst[i] / weight_lst[i]\n            value2_contribution = -value2_lst[i] / weight_lst[i]\n\n        # Score combines contributions to both objectives\n        score = value1_contribution + value2_contribution\n        if score > best_score:\n            best_score = score\n            best_candidate = (i, flip)\n\n    if best_candidate:\n        i, flip = best_candidate\n        new_solution[i] = flip if flip == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with higher combined objective values, then applies a hybrid local search combining random item swaps and targeted flips based on marginal gains in both objectives, ensuring feasibility and exploring diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (higher combined objective value)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Hybrid local search: random swaps + targeted flips\n    new_solution = selected_solution.copy()\n    items = np.arange(len(weight_lst))\n\n    # Randomly select a subset of items for potential swap/flip\n    random_items = np.random.choice(items, size=min(10, len(items)), replace=False)\n\n    for item in random_items:\n        # Try flipping the item (add if not in, remove if in)\n        if new_solution[item] == 0:\n            # Check if adding this item is feasible\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n        else:\n            # Try removing this item if it improves marginal gains\n            marginal_gain1 = value1_lst[item]\n            marginal_gain2 = value2_lst[item]\n            if marginal_gain1 + marginal_gain2 > 0:  # Only remove if it doesn't hurt both objectives\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Additional random swap for diversity\n    if len(items) >= 2:\n        i, j = np.random.choice(items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility after swap\n            if (new_solution[i] == 1 and new_solution[j] == 0 and\n                current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif (new_solution[i] == 0 and new_solution[j] == 1 and\n                  current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.37583514899019227,
            8.79556143283844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (higher combined objective value)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Hybrid local search: random swaps + targeted flips\n    new_solution = selected_solution.copy()\n    items = np.arange(len(weight_lst))\n\n    # Randomly select a subset of items for potential swap/flip\n    random_items = np.random.choice(items, size=min(10, len(items)), replace=False)\n\n    for item in random_items:\n        # Try flipping the item (add if not in, remove if in)\n        if new_solution[item] == 0:\n            # Check if adding this item is feasible\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n        else:\n            # Try removing this item if it improves marginal gains\n            marginal_gain1 = value1_lst[item]\n            marginal_gain2 = value2_lst[item]\n            if marginal_gain1 + marginal_gain2 > 0:  # Only remove if it doesn't hurt both objectives\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Additional random swap for diversity\n    if len(items) >= 2:\n        i, j = np.random.choice(items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility after swap\n            if (new_solution[i] == 1 and new_solution[j] == 0 and\n                current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif (new_solution[i] == 0 and new_solution[j] == 1 and\n                  current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{A novel hybrid local search strategy that combines random item swaps with targeted objective-based flips, guided by the archive's diversity and objective gradients, to intelligently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a random solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution\n    new_solution = base_solution.copy()\n\n    # Randomly select items to flip\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(3, num_items))\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional targeted flip based on objective gradients\n    if random.random() < 0.5:  # 50% chance for targeted flip\n        # Calculate marginal contributions\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n        # Select items with highest marginal contribution for the underperforming objective\n        if current_value1 < current_value2:\n            target_indices = np.argsort(marginal_value1)[-3:]\n        else:\n            target_indices = np.argsort(marginal_value2)[-3:]\n\n        for idx in target_indices:\n            if base_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3477122258690718,
            6.453751027584076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a random solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution\n    new_solution = base_solution.copy()\n\n    # Randomly select items to flip\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(3, num_items))\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional targeted flip based on objective gradients\n    if random.random() < 0.5:  # 50% chance for targeted flip\n        # Calculate marginal contributions\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n        # Select items with highest marginal contribution for the underperforming objective\n        if current_value1 < current_value2:\n            target_indices = np.argsort(marginal_value1)[-3:]\n        else:\n            target_indices = np.argsort(marginal_value2)[-3:]\n\n        for idx in target_indices:\n            if base_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a novel hybrid local search strategy that combines adaptive random selection and a multi-objective-aware perturbation mechanism, ensuring feasibility and high-quality neighbors by dynamically adjusting item swaps and flips based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using a hybrid selection strategy\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Generate a neighbor using a novel hybrid local search operator\n    for _ in range(10):  # Perform multiple perturbations\n        # Randomly select a subset of items to consider for flip/swap\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            candidate_indices = np.arange(len(weight_lst))\n\n        # Select two distinct items for potential swap or flip\n        i, j = random.sample(list(candidate_indices), 2)\n\n        # Calculate potential changes\n        delta_weight_i = -weight_lst[i] if new_solution[i] == 1 else weight_lst[i]\n        delta_weight_j = -weight_lst[j] if new_solution[j] == 1 else weight_lst[j]\n\n        # Check feasibility for swap\n        if current_weight + delta_weight_i + delta_weight_j <= capacity:\n            # Perform swap or flip with probability based on marginal improvement\n            if random.random() < 0.7:  # Higher probability for swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight_i + delta_weight_j\n            else:  # Flip one item\n                flip_item = random.choice([i, j])\n                if new_solution[flip_item] == 1:\n                    new_solution[flip_item] = 0\n                    current_weight -= weight_lst[flip_item]\n                else:\n                    new_solution[flip_item] = 1\n                    current_weight += weight_lst[flip_item]\n\n    # Ensure feasibility by forcing removal of excess items if needed\n    while current_weight > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        item_to_remove = random.choice(excess_items)\n        new_solution[item_to_remove] = 0\n        current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.5054243427114286,
            9.725869953632355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using a hybrid selection strategy\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Generate a neighbor using a novel hybrid local search operator\n    for _ in range(10):  # Perform multiple perturbations\n        # Randomly select a subset of items to consider for flip/swap\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            candidate_indices = np.arange(len(weight_lst))\n\n        # Select two distinct items for potential swap or flip\n        i, j = random.sample(list(candidate_indices), 2)\n\n        # Calculate potential changes\n        delta_weight_i = -weight_lst[i] if new_solution[i] == 1 else weight_lst[i]\n        delta_weight_j = -weight_lst[j] if new_solution[j] == 1 else weight_lst[j]\n\n        # Check feasibility for swap\n        if current_weight + delta_weight_i + delta_weight_j <= capacity:\n            # Perform swap or flip with probability based on marginal improvement\n            if random.random() < 0.7:  # Higher probability for swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight_i + delta_weight_j\n            else:  # Flip one item\n                flip_item = random.choice([i, j])\n                if new_solution[flip_item] == 1:\n                    new_solution[flip_item] = 0\n                    current_weight -= weight_lst[flip_item]\n                else:\n                    new_solution[flip_item] = 1\n                    current_weight += weight_lst[flip_item]\n\n    # Ensure feasibility by forcing removal of excess items if needed\n    while current_weight > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        item_to_remove = random.choice(excess_items)\n        new_solution[item_to_remove] = 0\n        current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search strategy combining item swapping, weighted greedy addition, and adaptive perturbation to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Item swapping (flip two random items)\n    if len(weight_lst) >= 2:\n        items = np.where(base_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = random.sample(list(items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Weighted greedy addition (add best item not in solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            # Weighted by normalized value1 + value2\n            values = (value1_lst + value2_lst) / np.sum(value1_lst + value2_lst)\n            candidates = [(i, values[i]) for i in available_items if weight_lst[i] <= remaining_weight]\n            if candidates:\n                best_item = max(candidates, key=lambda x: x[1])[0]\n                new_solution[best_item] = 1\n\n    # Step 3: Adaptive perturbation (flip a random item if solution is poor)\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n    max_value1 = np.sum(value1_lst)\n    max_value2 = np.sum(value2_lst)\n\n    # If solution is significantly worse than potential, perturb\n    if (current_value1 < 0.7 * max_value1) or (current_value2 < 0.7 * max_value2):\n        items = np.where(new_solution == 1)[0]\n        if len(items) > 0:\n            i = random.choice(items)\n            new_solution[i] = 0\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    while current_weight > capacity:\n        items = np.where(new_solution == 1)[0]\n        if len(items) == 0:\n            break\n        i = random.choice(items)\n        new_solution[i] = 0\n        current_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.9291012305588722,
            8.349794149398804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Item swapping (flip two random items)\n    if len(weight_lst) >= 2:\n        items = np.where(base_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = random.sample(list(items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Weighted greedy addition (add best item not in solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            # Weighted by normalized value1 + value2\n            values = (value1_lst + value2_lst) / np.sum(value1_lst + value2_lst)\n            candidates = [(i, values[i]) for i in available_items if weight_lst[i] <= remaining_weight]\n            if candidates:\n                best_item = max(candidates, key=lambda x: x[1])[0]\n                new_solution[best_item] = 1\n\n    # Step 3: Adaptive perturbation (flip a random item if solution is poor)\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n    max_value1 = np.sum(value1_lst)\n    max_value2 = np.sum(value2_lst)\n\n    # If solution is significantly worse than potential, perturb\n    if (current_value1 < 0.7 * max_value1) or (current_value2 < 0.7 * max_value2):\n        items = np.where(new_solution == 1)[0]\n        if len(items) > 0:\n            i = random.choice(items)\n            new_solution[i] = 0\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    while current_weight > capacity:\n        items = np.where(new_solution == 1)[0]\n        if len(items) == 0:\n            break\n        i = random.choice(items)\n        new_solution[i] = 0\n        current_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement by prioritizing those with lower objective values or higher weight utilization, then applies a novel local search operator that intelligently flips items based on their marginal contribution to both objectives, ensuring feasibility and diversity in the neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (obj[0] + obj[1] + 1) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (either included or excluded)\n    candidates = np.where((base_solution == 1) | ((current_weight + weight_lst) <= capacity))[0]\n\n    if len(candidates) == 0:\n        return base_solution  # No feasible moves\n\n    # Evaluate marginal contribution of flipping each candidate item\n    marginals = []\n    for i in candidates:\n        if base_solution[i] == 1:\n            # If item is included, calculate marginal if removed\n            marginal = (-value1_lst[i], -value2_lst[i])\n        else:\n            # If item is excluded, calculate marginal if added\n            marginal = (value1_lst[i], value2_lst[i])\n        marginals.append((i, marginal))\n\n    # Sort candidates by a hybrid of marginal contributions (prioritize balanced improvements)\n    marginals.sort(key=lambda x: (x[1][0] * x[1][1]), reverse=True)  # Sort by product of marginals\n\n    # Select top candidates for flipping\n    top_candidates = [x[0] for x in marginals[:min(3, len(marginals))]]  # Consider top 3 candidates\n\n    # Apply local search: flip a selected candidate\n    if len(top_candidates) > 0:\n        selected_item = random.choice(top_candidates)\n        new_solution[selected_item] = 1 - new_solution[selected_item]\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If not feasible, revert to base solution\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7838611287491626,
            7.397518217563629
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (obj[0] + obj[1] + 1) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (either included or excluded)\n    candidates = np.where((base_solution == 1) | ((current_weight + weight_lst) <= capacity))[0]\n\n    if len(candidates) == 0:\n        return base_solution  # No feasible moves\n\n    # Evaluate marginal contribution of flipping each candidate item\n    marginals = []\n    for i in candidates:\n        if base_solution[i] == 1:\n            # If item is included, calculate marginal if removed\n            marginal = (-value1_lst[i], -value2_lst[i])\n        else:\n            # If item is excluded, calculate marginal if added\n            marginal = (value1_lst[i], value2_lst[i])\n        marginals.append((i, marginal))\n\n    # Sort candidates by a hybrid of marginal contributions (prioritize balanced improvements)\n    marginals.sort(key=lambda x: (x[1][0] * x[1][1]), reverse=True)  # Sort by product of marginals\n\n    # Select top candidates for flipping\n    top_candidates = [x[0] for x in marginals[:min(3, len(marginals))]]  # Consider top 3 candidates\n\n    # Apply local search: flip a selected candidate\n    if len(top_candidates) > 0:\n        selected_item = random.choice(top_candidates)\n        new_solution[selected_item] = 1 - new_solution[selected_item]\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If not feasible, revert to base solution\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current weight and available capacity\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution\n    not_in_solution = np.where(base_solution == 0)[0]\n\n    # Filter items that can be added without exceeding capacity\n    feasible_items = [i for i in not_in_solution if weight_lst[i] <= remaining_capacity]\n\n    if not feasible_items:\n        # If no items can be added, remove the least valuable item (either value1 or value2)\n        in_solution = np.where(base_solution == 1)[0]\n        if len(in_solution) == 0:\n            return base_solution  # No items to remove\n\n        # Choose the item to remove based on the objective with the smallest improvement\n        obj1, obj2 = archive[selected_idx][1]\n        if obj1 > obj2:\n            remove_idx = np.argmin(value1_lst[in_solution])\n        else:\n            remove_idx = np.argmin(value2_lst[in_solution])\n        remove_idx = in_solution[remove_idx]\n\n        new_solution = base_solution.copy()\n        new_solution[remove_idx] = 0\n        return new_solution\n\n    # Add the most promising item (highest sum of normalized values)\n    item_values = np.column_stack((value1_lst[feasible_items], value2_lst[feasible_items]))\n    normalized_item_values = (item_values - item_values.min(axis=0)) / (item_values.max(axis=0) - item_values.min(axis=0) + 1e-8)\n    item_scores = normalized_item_values.sum(axis=1)\n    best_item_idx = feasible_items[np.argmax(item_scores)]\n\n    new_solution = base_solution.copy()\n    new_solution[best_item_idx] = 1\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If adding the item exceeds capacity, remove the least valuable item from the solution\n        in_solution = np.where(new_solution == 1)[0]\n        remove_idx = np.argmin(value1_lst[in_solution] + value2_lst[in_solution])\n        remove_idx = in_solution[remove_idx]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.78579119708446,
            7.068088173866272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current weight and available capacity\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution\n    not_in_solution = np.where(base_solution == 0)[0]\n\n    # Filter items that can be added without exceeding capacity\n    feasible_items = [i for i in not_in_solution if weight_lst[i] <= remaining_capacity]\n\n    if not feasible_items:\n        # If no items can be added, remove the least valuable item (either value1 or value2)\n        in_solution = np.where(base_solution == 1)[0]\n        if len(in_solution) == 0:\n            return base_solution  # No items to remove\n\n        # Choose the item to remove based on the objective with the smallest improvement\n        obj1, obj2 = archive[selected_idx][1]\n        if obj1 > obj2:\n            remove_idx = np.argmin(value1_lst[in_solution])\n        else:\n            remove_idx = np.argmin(value2_lst[in_solution])\n        remove_idx = in_solution[remove_idx]\n\n        new_solution = base_solution.copy()\n        new_solution[remove_idx] = 0\n        return new_solution\n\n    # Add the most promising item (highest sum of normalized values)\n    item_values = np.column_stack((value1_lst[feasible_items], value2_lst[feasible_items]))\n    normalized_item_values = (item_values - item_values.min(axis=0)) / (item_values.max(axis=0) - item_values.min(axis=0) + 1e-8)\n    item_scores = normalized_item_values.sum(axis=1)\n    best_item_idx = feasible_items[np.argmax(item_scores)]\n\n    new_solution = base_solution.copy()\n    new_solution[best_item_idx] = 1\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If adding the item exceeds capacity, remove the least valuable item from the solution\n        in_solution = np.where(new_solution == 1)[0]\n        remove_idx = np.argmin(value1_lst[in_solution] + value2_lst[in_solution])\n        remove_idx = in_solution[remove_idx]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution, _ = archive[0]\n    new_solution = selected_solution.copy()\n\n    # Step 2: Identify critical items (those with high marginal contribution)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    # Calculate marginal contributions for each objective\n    marginal_value1 = value1_lst[included] / weight_lst[included]\n    marginal_value2 = value2_lst[included] / weight_lst[included]\n\n    # Step 3: Apply a hybrid local search operator\n    # Option 1: Flip a critical item (highest marginal contribution) if feasible\n    if len(included) > 0:\n        critical_item = included[np.argmax(marginal_value1 + marginal_value2)]\n        if new_solution[critical_item] == 1:\n            new_solution[critical_item] = 0\n            if np.dot(new_solution, weight_lst) > capacity:\n                new_solution[critical_item] = 1\n\n    # Option 2: Add a promising excluded item if feasible\n    if len(excluded) > 0:\n        promising_item = excluded[np.argmax(value1_lst[excluded] + value2_lst[excluded])]\n        if new_solution[promising_item] == 0 and weight_lst[promising_item] <= capacity - np.dot(new_solution, weight_lst):\n            new_solution[promising_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8172764644625796,
            5.342500776052475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution, _ = archive[0]\n    new_solution = selected_solution.copy()\n\n    # Step 2: Identify critical items (those with high marginal contribution)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    # Calculate marginal contributions for each objective\n    marginal_value1 = value1_lst[included] / weight_lst[included]\n    marginal_value2 = value2_lst[included] / weight_lst[included]\n\n    # Step 3: Apply a hybrid local search operator\n    # Option 1: Flip a critical item (highest marginal contribution) if feasible\n    if len(included) > 0:\n        critical_item = included[np.argmax(marginal_value1 + marginal_value2)]\n        if new_solution[critical_item] == 1:\n            new_solution[critical_item] = 0\n            if np.dot(new_solution, weight_lst) > capacity:\n                new_solution[critical_item] = 1\n\n    # Option 2: Add a promising excluded item if feasible\n    if len(excluded) > 0:\n        promising_item = excluded[np.argmax(value1_lst[excluded] + value2_lst[excluded])]\n        if new_solution[promising_item] == 0 and weight_lst[promising_item] <= capacity - np.dot(new_solution, weight_lst):\n            new_solution[promising_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{A novel hybrid local search strategy that intelligently combines random swaps and guided flips of items based on their marginal contributions to both objectives, ensuring feasibility and promoting exploration of high-potential regions in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution, (current_value1, current_value2) = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Identify items not in the solution\n    excluded_items = np.where(selected_solution == 0)[0]\n\n    # Calculate marginal contributions for excluded items\n    marginal_weights = weight_lst[excluded_items]\n    marginal_value1 = value1_lst[excluded_items]\n    marginal_value2 = value2_lst[excluded_items]\n\n    # Filter items that can be added without exceeding capacity\n    feasible_items = excluded_items[marginal_weights <= (capacity - current_weight)]\n\n    if len(feasible_items) > 0:\n        # Select the item with the highest combined marginal value\n        combined_marginal = marginal_value1 + marginal_value2\n        best_item = feasible_items[np.argmax(combined_marginal)]\n        new_solution[best_item] = 1\n    else:\n        # If no items can be added, try flipping an item out of the solution\n        included_items = np.where(selected_solution == 1)[0]\n        if len(included_items) > 0:\n            # Select the item with the lowest combined value\n            combined_value = value1_lst[included_items] + value2_lst[included_items]\n            worst_item = included_items[np.argmin(combined_value)]\n            new_solution[worst_item] = 0\n\n    # Perform a random swap if possible\n    if len(included_items) > 1:\n        i, j = random.sample(list(included_items), 2)\n        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9321402052301935,
            4.998986154794693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution, (current_value1, current_value2) = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Identify items not in the solution\n    excluded_items = np.where(selected_solution == 0)[0]\n\n    # Calculate marginal contributions for excluded items\n    marginal_weights = weight_lst[excluded_items]\n    marginal_value1 = value1_lst[excluded_items]\n    marginal_value2 = value2_lst[excluded_items]\n\n    # Filter items that can be added without exceeding capacity\n    feasible_items = excluded_items[marginal_weights <= (capacity - current_weight)]\n\n    if len(feasible_items) > 0:\n        # Select the item with the highest combined marginal value\n        combined_marginal = marginal_value1 + marginal_value2\n        best_item = feasible_items[np.argmax(combined_marginal)]\n        new_solution[best_item] = 1\n    else:\n        # If no items can be added, try flipping an item out of the solution\n        included_items = np.where(selected_solution == 1)[0]\n        if len(included_items) > 0:\n            # Select the item with the lowest combined value\n            combined_value = value1_lst[included_items] + value2_lst[included_items]\n            worst_item = included_items[np.argmin(combined_value)]\n            new_solution[worst_item] = 0\n\n    # Perform a random swap if possible\n    if len(included_items) > 1:\n        i, j = random.sample(list(included_items), 2)\n        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating trade-offs between objectives and applies a hybrid local search combining item swaps, value-based perturbations, and capacity-aware adjustments to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj[:, 0] + normalized_obj[:, 1]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly swap items between included and excluded, ensuring feasibility\n    for _ in range(3):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Perturb based on value trade-offs (swap items with high value ratios)\n    value_ratio = value1_lst / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(value_ratio)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n        else:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n\n    # Step 3: Capacity-aware adjustment (remove low-value items if over capacity)\n    while current_weight > capacity:\n        included = np.where(new_solution == 1)[0]\n        if len(included) == 0:\n            break\n        total_value = value1_lst[included] + value2_lst[included]\n        to_remove = included[np.argmin(total_value)]\n        new_solution[to_remove] = 0\n        current_weight -= weight_lst[to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.37480395618360685,
            8.173923343420029
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj[:, 0] + normalized_obj[:, 1]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly swap items between included and excluded, ensuring feasibility\n    for _ in range(3):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Perturb based on value trade-offs (swap items with high value ratios)\n    value_ratio = value1_lst / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(value_ratio)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n        else:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n\n    # Step 3: Capacity-aware adjustment (remove low-value items if over capacity)\n    while current_weight > capacity:\n        included = np.where(new_solution == 1)[0]\n        if len(included) == 0:\n            break\n        total_value = value1_lst[included] + value2_lst[included]\n        to_remove = included[np.argmin(total_value)]\n        new_solution[to_remove] = 0\n        current_weight -= weight_lst[to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{A novel hybrid local search strategy combines a value-driven swap heuristic with a diversity-aware perturbation scheme, where solutions are intelligently selected based on their objective space density and then refined by swapping high-value items while ensuring feasibility and promoting multi-objective exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    # Select solution with highest crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Value-driven swap heuristic\n    # Calculate value ratios and select high-value items to consider swapping\n    value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    high_value_indices = np.argsort(value_ratio)[-min(5, len(value_ratio)):]  # Top 5 high-value items\n\n    for idx in high_value_indices:\n        if new_solution[idx] == 0:\n            # Try adding the item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            # Try removing the item to make space for better items\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Step 2: Diversity-aware perturbation\n    # Randomly flip a small number of items to explore neighborhood\n    num_flips = min(2, len(new_solution))\n    flip_indices = np.random.choice(len(new_solution), num_flips, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7627345100159003,
            7.660545200109482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    # Select solution with highest crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Value-driven swap heuristic\n    # Calculate value ratios and select high-value items to consider swapping\n    value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    high_value_indices = np.argsort(value_ratio)[-min(5, len(value_ratio)):]  # Top 5 high-value items\n\n    for idx in high_value_indices:\n        if new_solution[idx] == 0:\n            # Try adding the item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            # Try removing the item to make space for better items\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Step 2: Diversity-aware perturbation\n    # Randomly flip a small number of items to explore neighborhood\n    num_flips = min(2, len(new_solution))\n    flip_indices = np.random.choice(len(new_solution), num_flips, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{The heuristic selects a solution from the archive by prioritizing those with high objective values, then applies a hybrid local search combining item swaps and probabilistic flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective values\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and flip with probability\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Randomly select a subset of items to swap\n    swap_candidates = np.where(base_solution == 1)[0]\n    if len(swap_candidates) > 1:\n        i, j = random.sample(list(swap_candidates), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistically flip items to improve objectives\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% probability to flip\n            if new_solution[i] == 1:\n                # Remove item if weight allows\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Add item if weight allows\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility (should be redundant due to checks above)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove random item if over capacity\n        over_items = np.where(new_solution == 1)[0]\n        if len(over_items) > 0:\n            remove_idx = random.choice(over_items)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4652600202614666,
            5.162813574075699
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective values\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and flip with probability\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Randomly select a subset of items to swap\n    swap_candidates = np.where(base_solution == 1)[0]\n    if len(swap_candidates) > 1:\n        i, j = random.sample(list(swap_candidates), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistically flip items to improve objectives\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% probability to flip\n            if new_solution[i] == 1:\n                # Remove item if weight allows\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Add item if weight allows\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility (should be redundant due to checks above)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove random item if over capacity\n        over_items = np.where(new_solution == 1)[0]\n        if len(over_items) > 0:\n            remove_idx = random.choice(over_items)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This heuristic function first selects a promising solution from the archive by prioritizing those with the highest total weight utilization and diversity in objective values, then applies a hybrid local search operator that combines random item swaps with a greedy improvement phase to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high weight utilization and diversity in objectives\n    def selection_criteria(sol_obj_pair):\n        sol, (v1, v2) = sol_obj_pair\n        total_weight = np.sum(weight_lst * sol)\n        diversity = abs(v1 - v2)\n        return (total_weight / capacity) * diversity\n\n    selected = max(archive, key=selection_criteria)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Random swap with feasibility check\n    for _ in range(10):\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] == base_solution[j]:\n            continue\n\n        delta_weight = weight_lst[i] - weight_lst[j]\n        if (base_solution[i] == 1 and base_solution[j] == 0 and current_weight + delta_weight <= capacity) or \\\n           (base_solution[i] == 0 and base_solution[j] == 1 and current_weight + delta_weight >= 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    # Greedy improvement phase\n    for i in range(n_items):\n        if base_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5290702809750198,
            8.446431964635849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high weight utilization and diversity in objectives\n    def selection_criteria(sol_obj_pair):\n        sol, (v1, v2) = sol_obj_pair\n        total_weight = np.sum(weight_lst * sol)\n        diversity = abs(v1 - v2)\n        return (total_weight / capacity) * diversity\n\n    selected = max(archive, key=selection_criteria)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Random swap with feasibility check\n    for _ in range(10):\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] == base_solution[j]:\n            continue\n\n        delta_weight = weight_lst[i] - weight_lst[j]\n        if (base_solution[i] == 1 and base_solution[j] == 0 and current_weight + delta_weight <= capacity) or \\\n           (base_solution[i] == 0 and base_solution[j] == 1 and current_weight + delta_weight >= 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    # Greedy improvement phase\n    for i in range(n_items):\n        if base_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{The heuristic selects a promising solution from the archive based on a weighted combination of objective values, then applies a novel hybrid local search operator combining random item swaps and value-driven flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a weighted combination of objectives\n    def score(sol_obj):\n        sol, obj = sol_obj\n        return 0.6 * obj[0] + 0.4 * obj[1]  # Weighted combination\n\n    scored_archive = [(sol, score((sol, obj))) for sol, obj in archive]\n    scored_archive.sort(key=lambda x: -x[1])\n    selected_sol = scored_archive[0][0].copy()\n\n    # Hybrid local search: random swaps and value-driven flips\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Random swap operation\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Check feasibility after swap\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # If infeasible, undo swap and try value-driven flip\n        new_solution = selected_sol.copy()\n        # Find items to flip (value-driven)\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                # Try removing item with lowest value contribution\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    break\n            else:\n                # Try adding item with highest value contribution\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    # Prioritize items with high value in both objectives\n                    value_score = 0.6 * value1_lst[i] + 0.4 * value2_lst[i]\n                    if value_score > 0:  # Only add if positive value\n                        new_solution[i] = 1\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.5001200405830089,
            10.414023756980896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a weighted combination of objectives\n    def score(sol_obj):\n        sol, obj = sol_obj\n        return 0.6 * obj[0] + 0.4 * obj[1]  # Weighted combination\n\n    scored_archive = [(sol, score((sol, obj))) for sol, obj in archive]\n    scored_archive.sort(key=lambda x: -x[1])\n    selected_sol = scored_archive[0][0].copy()\n\n    # Hybrid local search: random swaps and value-driven flips\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Random swap operation\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Check feasibility after swap\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # If infeasible, undo swap and try value-driven flip\n        new_solution = selected_sol.copy()\n        # Find items to flip (value-driven)\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                # Try removing item with lowest value contribution\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    break\n            else:\n                # Try adding item with highest value contribution\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    # Prioritize items with high value in both objectives\n                    value_score = 0.6 * value1_lst[i] + 0.4 * value2_lst[i]\n                    if value_score > 0:  # Only add if positive value\n                        new_solution[i] = 1\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive, identifies critical items via a weighted margin analysis, and applies a novel \"adaptive flip and swap\" operator to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution from the archive (prioritize those with high marginal gains)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate total weight of the base solution\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify critical items (those with high value-to-weight ratio)\n    value_ratio1 = value1_lst / (weight_lst + 1e-10)\n    value_ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = (value_ratio1 + value_ratio2) / 2\n\n    # Sort items by combined ratio and select top 20% for potential flipping\n    sorted_indices = np.argsort(combined_ratio)[::-1]\n    critical_items = sorted_indices[:max(1, len(sorted_indices) // 5)]\n\n    # Adaptive flip and swap operator\n    for item in critical_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            new_weight = total_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                total_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = total_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                total_weight = new_weight\n\n    # Additional swap operation to explore better combinations\n    if len(critical_items) >= 2:\n        i, j = np.random.choice(critical_items, 2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Swap the items if feasible\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if total_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7837749801372309,
            3.882092922925949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution from the archive (prioritize those with high marginal gains)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate total weight of the base solution\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify critical items (those with high value-to-weight ratio)\n    value_ratio1 = value1_lst / (weight_lst + 1e-10)\n    value_ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = (value_ratio1 + value_ratio2) / 2\n\n    # Sort items by combined ratio and select top 20% for potential flipping\n    sorted_indices = np.argsort(combined_ratio)[::-1]\n    critical_items = sorted_indices[:max(1, len(sorted_indices) // 5)]\n\n    # Adaptive flip and swap operator\n    for item in critical_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            new_weight = total_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                total_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = total_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                total_weight = new_weight\n\n    # Additional swap operation to explore better combinations\n    if len(critical_items) >= 2:\n        i, j = np.random.choice(critical_items, 2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Swap the items if feasible\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if total_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining greedy addition of promising items and targeted removal of redundant items to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a solution with high potential for improvement (combination of high objective values and diversity)\n    selected_idx = random.choices(range(len(archive)), weights=[(obj[0] + obj[1]) * (1 + 0.1 * np.sum(sol)) for sol, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: greedy addition of promising items and targeted removal\n    # Step 1: Identify items not in the current solution\n    candidate_items = np.where(new_solution == 0)[0]\n\n    # Step 2: Evaluate potential additions (consider both objectives)\n    if len(candidate_items) > 0:\n        # Calculate potential improvement for each candidate item\n        potential_improvement = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n\n        # Select top 30% candidates by potential improvement\n        top_candidates = candidate_items[np.argsort(potential_improvement)[-max(1, len(candidate_items) // 3):]]\n\n        # Randomly select one of the top candidates\n        if len(top_candidates) > 0:\n            selected_item = random.choice(top_candidates)\n            if current_weight + weight_lst[selected_item] <= capacity:\n                new_solution[selected_item] = 1\n                current_weight += weight_lst[selected_item]\n\n    # Step 3: Consider removal of redundant items (if any)\n    included_items = np.where(new_solution == 1)[0]\n    if len(included_items) > 0:\n        # Calculate the \"redundancy\" of each included item (ratio of its contribution to total value)\n        total_value1 = np.sum(value1_lst * new_solution)\n        total_value2 = np.sum(value2_lst * new_solution)\n\n        if total_value1 > 0 and total_value2 > 0:\n            redundancy = (value1_lst[included_items] / total_value1 + value2_lst[included_items] / total_value2) / weight_lst[included_items]\n\n            # Remove items with the lowest redundancy (most redundant)\n            least_redundant = included_items[np.argmin(redundancy)]\n            if least_redundant in included_items:\n                new_solution[least_redundant] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9458293817974829,
            3.586798459291458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a solution with high potential for improvement (combination of high objective values and diversity)\n    selected_idx = random.choices(range(len(archive)), weights=[(obj[0] + obj[1]) * (1 + 0.1 * np.sum(sol)) for sol, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: greedy addition of promising items and targeted removal\n    # Step 1: Identify items not in the current solution\n    candidate_items = np.where(new_solution == 0)[0]\n\n    # Step 2: Evaluate potential additions (consider both objectives)\n    if len(candidate_items) > 0:\n        # Calculate potential improvement for each candidate item\n        potential_improvement = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n\n        # Select top 30% candidates by potential improvement\n        top_candidates = candidate_items[np.argsort(potential_improvement)[-max(1, len(candidate_items) // 3):]]\n\n        # Randomly select one of the top candidates\n        if len(top_candidates) > 0:\n            selected_item = random.choice(top_candidates)\n            if current_weight + weight_lst[selected_item] <= capacity:\n                new_solution[selected_item] = 1\n                current_weight += weight_lst[selected_item]\n\n    # Step 3: Consider removal of redundant items (if any)\n    included_items = np.where(new_solution == 1)[0]\n    if len(included_items) > 0:\n        # Calculate the \"redundancy\" of each included item (ratio of its contribution to total value)\n        total_value1 = np.sum(value1_lst * new_solution)\n        total_value2 = np.sum(value2_lst * new_solution)\n\n        if total_value1 > 0 and total_value2 > 0:\n            redundancy = (value1_lst[included_items] / total_value1 + value2_lst[included_items] / total_value2) / weight_lst[included_items]\n\n            # Remove items with the lowest redundancy (most redundant)\n            least_redundant = included_items[np.argmin(redundancy)]\n            if least_redundant in included_items:\n                new_solution[least_redundant] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines cluster-based exploration and adaptive perturbation to generate high-quality neighbors by dynamically balancing exploitation of promising regions and exploration of uncharted areas in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by the sum of normalized objectives to prioritize high-performing solutions\n    normalized_objectives = []\n    for sol, (v1, v2) in archive:\n        norm_v1 = v1 / (np.sum(value1_lst) + 1e-10)\n        norm_v2 = v2 / (np.sum(value2_lst) + 1e-10)\n        normalized_objectives.append((sol, norm_v1 + norm_v2))\n\n    # Select top 20% solutions and pick one randomly\n    top_k = max(1, len(archive) // 5)\n    top_solutions = sorted(normalized_objectives, key=lambda x: -x[1])[:top_k]\n    selected_sol, _ = top_solutions[np.random.randint(0, len(top_solutions))]\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = selected_sol.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2.1: Cluster-based perturbation (exploration)\n    # Identify items that are often included together in high-quality solutions\n    cluster_size = min(5, len(new_solution))\n    cluster_indices = np.random.choice(len(new_solution), cluster_size, replace=False)\n    for i in cluster_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif new_solution[i] == 1:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 2.2: Adaptive perturbation (exploitation)\n    # Flip items based on their marginal contribution to both objectives\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 0:\n                if current_weight + weight_lst[i] <= capacity:\n                    # Calculate marginal contribution\n                    marginal_v1 = value1_lst[i]\n                    marginal_v2 = value2_lst[i]\n                    if marginal_v1 + marginal_v2 > 0:  # Positive contribution\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n            else:\n                # Calculate marginal contribution of removing\n                marginal_v1 = -value1_lst[i]\n                marginal_v2 = -value2_lst[i]\n                if marginal_v1 + marginal_v2 > 0:  # Positive contribution to removal\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3394421533742208,
            8.313312441110611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by the sum of normalized objectives to prioritize high-performing solutions\n    normalized_objectives = []\n    for sol, (v1, v2) in archive:\n        norm_v1 = v1 / (np.sum(value1_lst) + 1e-10)\n        norm_v2 = v2 / (np.sum(value2_lst) + 1e-10)\n        normalized_objectives.append((sol, norm_v1 + norm_v2))\n\n    # Select top 20% solutions and pick one randomly\n    top_k = max(1, len(archive) // 5)\n    top_solutions = sorted(normalized_objectives, key=lambda x: -x[1])[:top_k]\n    selected_sol, _ = top_solutions[np.random.randint(0, len(top_solutions))]\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = selected_sol.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2.1: Cluster-based perturbation (exploration)\n    # Identify items that are often included together in high-quality solutions\n    cluster_size = min(5, len(new_solution))\n    cluster_indices = np.random.choice(len(new_solution), cluster_size, replace=False)\n    for i in cluster_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif new_solution[i] == 1:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 2.2: Adaptive perturbation (exploitation)\n    # Flip items based on their marginal contribution to both objectives\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 0:\n                if current_weight + weight_lst[i] <= capacity:\n                    # Calculate marginal contribution\n                    marginal_v1 = value1_lst[i]\n                    marginal_v2 = value2_lst[i]\n                    if marginal_v1 + marginal_v2 > 0:  # Positive contribution\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n            else:\n                # Calculate marginal contribution of removing\n                marginal_v1 = -value1_lst[i]\n                marginal_v2 = -value2_lst[i]\n                if marginal_v1 + marginal_v2 > 0:  # Positive contribution to removal\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{The new algorithm selects a promising solution from the archive based on a hybrid metric combining objective values and solution diversity, then applies a novel multi-flip local search that adaptively flips subsets of items based on their marginal contributions to both objectives, ensuring feasibility and aiming to improve both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a hybrid metric\n    def hybrid_metric(solution, obj):\n        # Combine objective values and solution diversity\n        v1, v2 = obj\n        diversity = np.sum(solution) / len(solution)\n        return (v1 + v2) * diversity\n\n    archive.sort(key=lambda x: -hybrid_metric(x[0], x[1]))\n    base_solution, _ = archive[0]\n\n    # Generate neighbor using adaptive multi-flip local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Calculate marginal contributions for available items\n    marginal_weights = weight_lst[available_items]\n    marginal_v1 = value1_lst[available_items]\n    marginal_v2 = value2_lst[available_items]\n\n    # Calculate marginal contributions for included items\n    if len(included_items) > 0:\n        marginal_weights_in = weight_lst[included_items]\n        marginal_v1_in = value1_lst[included_items]\n        marginal_v2_in = value2_lst[included_items]\n\n    # Adaptive flipping strategy\n    flip_count = min(3, len(available_items))  # Flip up to 3 items at a time\n    if flip_count > 0:\n        # Select items with highest combined marginal value\n        combined_marginal = marginal_v1 + marginal_v2\n        top_indices = np.argsort(combined_marginal)[-flip_count:]\n\n        for idx in top_indices:\n            if current_weight + marginal_weights[idx] <= capacity:\n                new_solution[available_items[idx]] = 1\n                current_weight += marginal_weights[idx]\n\n    # Optional: Flip some low-value items to create room for better items\n    if len(included_items) > 0 and flip_count > 0:\n        # Select items with lowest combined marginal value\n        combined_marginal_in = marginal_v1_in + marginal_v2_in\n        bottom_indices = np.argsort(combined_marginal_in)[:flip_count]\n\n        for idx in bottom_indices:\n            new_solution[included_items[idx]] = 0\n            current_weight -= marginal_weights_in[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8608524092086511,
            4.1064262092113495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a hybrid metric\n    def hybrid_metric(solution, obj):\n        # Combine objective values and solution diversity\n        v1, v2 = obj\n        diversity = np.sum(solution) / len(solution)\n        return (v1 + v2) * diversity\n\n    archive.sort(key=lambda x: -hybrid_metric(x[0], x[1]))\n    base_solution, _ = archive[0]\n\n    # Generate neighbor using adaptive multi-flip local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Calculate marginal contributions for available items\n    marginal_weights = weight_lst[available_items]\n    marginal_v1 = value1_lst[available_items]\n    marginal_v2 = value2_lst[available_items]\n\n    # Calculate marginal contributions for included items\n    if len(included_items) > 0:\n        marginal_weights_in = weight_lst[included_items]\n        marginal_v1_in = value1_lst[included_items]\n        marginal_v2_in = value2_lst[included_items]\n\n    # Adaptive flipping strategy\n    flip_count = min(3, len(available_items))  # Flip up to 3 items at a time\n    if flip_count > 0:\n        # Select items with highest combined marginal value\n        combined_marginal = marginal_v1 + marginal_v2\n        top_indices = np.argsort(combined_marginal)[-flip_count:]\n\n        for idx in top_indices:\n            if current_weight + marginal_weights[idx] <= capacity:\n                new_solution[available_items[idx]] = 1\n                current_weight += marginal_weights[idx]\n\n    # Optional: Flip some low-value items to create room for better items\n    if len(included_items) > 0 and flip_count > 0:\n        # Select items with lowest combined marginal value\n        combined_marginal_in = marginal_v1_in + marginal_v2_in\n        bottom_indices = np.argsort(combined_marginal_in)[:flip_count]\n\n        for idx in bottom_indices:\n            new_solution[included_items[idx]] = 0\n            current_weight -= marginal_weights_in[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a novel hybrid local search strategy that combines adaptive random swaps with weighted objective-based perturbations, ensuring feasibility by dynamically adjusting item selections while prioritizing high-potential regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards higher objective values\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    weights = normalized_obj[:, 0] + normalized_obj[:, 1]\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: adaptive random swaps with objective-based perturbations\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select a candidate item to flip\n        candidate_idx = random.randint(0, len(new_solution) - 1)\n\n        if new_solution[candidate_idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[candidate_idx]\n            if new_weight <= capacity:\n                new_solution[candidate_idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[candidate_idx]\n            if new_weight <= capacity:\n                new_solution[candidate_idx] = 1\n                current_weight = new_weight\n\n        # Objective-based perturbation: with probability, swap based on which objective is weaker\n        if random.random() < 0.3:\n            obj1 = np.sum(value1_lst[new_solution == 1])\n            obj2 = np.sum(value2_lst[new_solution == 1])\n            if obj1 < obj2:\n                # Try to improve obj1 by adding high-value1 items\n                value_ratios = value1_lst / (weight_lst + 1e-6)\n                best_candidate = np.argmax(value_ratios * (1 - new_solution))\n                if weight_lst[best_candidate] <= capacity - current_weight:\n                    new_solution[best_candidate] = 1\n                    current_weight += weight_lst[best_candidate]\n            else:\n                # Try to improve obj2 by adding high-value2 items\n                value_ratios = value2_lst / (weight_lst + 1e-6)\n                best_candidate = np.argmax(value_ratios * (1 - new_solution))\n                if weight_lst[best_candidate] <= capacity - current_weight:\n                    new_solution[best_candidate] = 1\n                    current_weight += weight_lst[best_candidate]\n\n    return new_solution\n\n",
        "score": [
            -0.3272849489353268,
            3.1581109762191772
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards higher objective values\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    weights = normalized_obj[:, 0] + normalized_obj[:, 1]\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: adaptive random swaps with objective-based perturbations\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select a candidate item to flip\n        candidate_idx = random.randint(0, len(new_solution) - 1)\n\n        if new_solution[candidate_idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[candidate_idx]\n            if new_weight <= capacity:\n                new_solution[candidate_idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[candidate_idx]\n            if new_weight <= capacity:\n                new_solution[candidate_idx] = 1\n                current_weight = new_weight\n\n        # Objective-based perturbation: with probability, swap based on which objective is weaker\n        if random.random() < 0.3:\n            obj1 = np.sum(value1_lst[new_solution == 1])\n            obj2 = np.sum(value2_lst[new_solution == 1])\n            if obj1 < obj2:\n                # Try to improve obj1 by adding high-value1 items\n                value_ratios = value1_lst / (weight_lst + 1e-6)\n                best_candidate = np.argmax(value_ratios * (1 - new_solution))\n                if weight_lst[best_candidate] <= capacity - current_weight:\n                    new_solution[best_candidate] = 1\n                    current_weight += weight_lst[best_candidate]\n            else:\n                # Try to improve obj2 by adding high-value2 items\n                value_ratios = value2_lst / (weight_lst + 1e-6)\n                best_candidate = np.argmax(value_ratios * (1 - new_solution))\n                if weight_lst[best_candidate] <= capacity - current_weight:\n                    new_solution[best_candidate] = 1\n                    current_weight += weight_lst[best_candidate]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating its dominance and diversity, then applies a hybrid local search combining adaptive perturbation and objective-specific flipping to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive perturbation and objective-specific flipping\n    # Step 1: Adaptive perturbation - flip items with low marginal contribution\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Calculate marginal contribution\n            marginal_val1 = value1_lst[i]\n            marginal_val2 = value2_lst[i]\n            # Flip if low marginal contribution\n            if (marginal_val1 < np.mean(value1_lst) and marginal_val2 < np.mean(value2_lst)) or \\\n               (current_weight - weight_lst[i] <= capacity):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 2: Objective-specific flipping - prioritize flipping items that improve the weaker objective\n    # Determine which objective to prioritize\n    if base_val1 < base_val2:\n        # Prioritize value1\n        sorted_indices = np.argsort(value1_lst)\n    else:\n        # Prioritize value2\n        sorted_indices = np.argsort(value2_lst)\n\n    # Try to add items that improve the weaker objective while maintaining feasibility\n    for i in sorted_indices[::-1]:  # Start with highest value items\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n            # Early exit if capacity is almost full\n            if current_weight >= 0.95 * capacity:\n                break\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:  # 30% chance of random flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1 and (current_weight - weight_lst[flip_idx] <= capacity):\n            new_solution[flip_idx] = 0\n        elif new_solution[flip_idx] == 0 and (current_weight + weight_lst[flip_idx] <= capacity):\n            new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9028566089439178,
            9.480074942111969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive perturbation and objective-specific flipping\n    # Step 1: Adaptive perturbation - flip items with low marginal contribution\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Calculate marginal contribution\n            marginal_val1 = value1_lst[i]\n            marginal_val2 = value2_lst[i]\n            # Flip if low marginal contribution\n            if (marginal_val1 < np.mean(value1_lst) and marginal_val2 < np.mean(value2_lst)) or \\\n               (current_weight - weight_lst[i] <= capacity):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 2: Objective-specific flipping - prioritize flipping items that improve the weaker objective\n    # Determine which objective to prioritize\n    if base_val1 < base_val2:\n        # Prioritize value1\n        sorted_indices = np.argsort(value1_lst)\n    else:\n        # Prioritize value2\n        sorted_indices = np.argsort(value2_lst)\n\n    # Try to add items that improve the weaker objective while maintaining feasibility\n    for i in sorted_indices[::-1]:  # Start with highest value items\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n            # Early exit if capacity is almost full\n            if current_weight >= 0.95 * capacity:\n                break\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:  # 30% chance of random flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1 and (current_weight - weight_lst[flip_idx] <= capacity):\n            new_solution[flip_idx] = 0\n        elif new_solution[flip_idx] == 0 and (current_weight + weight_lst[flip_idx] <= capacity):\n            new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{A novel hybrid local search operator combines random walk with adaptive neighborhood exploration, prioritizing items with high marginal gains in both objectives while dynamically adjusting the exploration radius to escape local optima and ensure feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (highest marginal gain)\n    selected_solution, _ = max(archive, key=lambda x: np.sum((value1_lst + value2_lst) * (1 - x[0])))\n\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Random walk with adaptive step size\n    step_size = max(1, int(np.sqrt(n_items) / 2))\n    indices = np.random.choice(n_items, step_size, replace=False)\n\n    for i in indices:\n        # Flip the item if it improves at least one objective and maintains feasibility\n        current_weight = np.sum(new_solution * weight_lst)\n        if new_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n        else:\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n\n    # Additional local improvement: greedy addition of high-margin items\n    remaining_weight = capacity - np.sum(new_solution * weight_lst)\n    if remaining_weight > 0:\n        # Calculate marginal gains for items not in the solution\n        marginal_gains = (value1_lst + value2_lst) * (1 - new_solution)\n        candidate_items = np.where((marginal_gains > 0) & (weight_lst <= remaining_weight))[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(marginal_gains[candidate_items])]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8555636146850054,
            4.60475817322731
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (highest marginal gain)\n    selected_solution, _ = max(archive, key=lambda x: np.sum((value1_lst + value2_lst) * (1 - x[0])))\n\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Random walk with adaptive step size\n    step_size = max(1, int(np.sqrt(n_items) / 2))\n    indices = np.random.choice(n_items, step_size, replace=False)\n\n    for i in indices:\n        # Flip the item if it improves at least one objective and maintains feasibility\n        current_weight = np.sum(new_solution * weight_lst)\n        if new_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n        else:\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n\n    # Additional local improvement: greedy addition of high-margin items\n    remaining_weight = capacity - np.sum(new_solution * weight_lst)\n    if remaining_weight > 0:\n        # Calculate marginal gains for items not in the solution\n        marginal_gains = (value1_lst + value2_lst) * (1 - new_solution)\n        candidate_items = np.where((marginal_gains > 0) & (weight_lst <= remaining_weight))[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(marginal_gains[candidate_items])]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by combined objective value\n    selected_solution = archive[0][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(n_items), min(5, n_items))\n\n    # Step 2: Perform adaptive swapping (flip items if feasible)\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n\n    # Step 3: Apply adaptive perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance of perturbation\n        perturb_candidates = random.sample(range(n_items), min(3, n_items))\n        for i in perturb_candidates:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n            else:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.3524404288756551,
            1.7309929430484772
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by combined objective value\n    selected_solution = archive[0][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(n_items), min(5, n_items))\n\n    # Step 2: Perform adaptive swapping (flip items if feasible)\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n\n    # Step 3: Apply adaptive perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance of perturbation\n        perturb_candidates = random.sample(range(n_items), min(3, n_items))\n        for i in perturb_candidates:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n            else:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_value1, base_value2 = archive[selected_idx][1]\n\n    # Identify items to flip (swap inclusion/exclusion)\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n        if len(candidate_indices) == 0:\n            return base_solution\n\n    # Select a random item to flip\n    flip_idx = np.random.choice(candidate_indices)\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Check feasibility and adjust if needed\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            remove_idx = np.random.choice(included_indices)\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # If no items left, revert to base solution\n    if np.sum(new_solution) == 0:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7424003833720794,
            1.9905346632003784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_value1, base_value2 = archive[selected_idx][1]\n\n    # Identify items to flip (swap inclusion/exclusion)\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n        if len(candidate_indices) == 0:\n            return base_solution\n\n    # Select a random item to flip\n    flip_idx = np.random.choice(candidate_indices)\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Check feasibility and adjust if needed\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            remove_idx = np.random.choice(included_indices)\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # If no items left, revert to base solution\n    if np.sum(new_solution) == 0:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search that combines item swaps and probabilistic flips to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest combined objective value)\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objects = [obj for sol, obj in archive]\n    combined_values = np.array([v1 + v2 for v1, v2 in archive_objects])\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for flipping\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n            else:\n                # If removing doesn't work, try swapping with another item\n                swap_candidates = np.where((new_solution == 0) &\n                                          (weight_lst <= capacity - current_weight + weight_lst[idx]))[0]\n                if len(swap_candidates) > 0:\n                    swap_idx = np.random.choice(swap_candidates)\n                    new_solution[idx] = 0\n                    new_solution[swap_idx] = 1\n                    current_weight = current_weight - weight_lst[idx] + weight_lst[swap_idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            else:\n                # If adding doesn't work, try swapping with another item\n                swap_candidates = np.where((new_solution == 1) &\n                                         (weight_lst[idx] - weight_lst <= capacity - current_weight))[0]\n                if len(swap_candidates) > 0:\n                    swap_idx = np.random.choice(swap_candidates)\n                    new_solution[swap_idx] = 0\n                    new_solution[idx] = 1\n                    current_weight = current_weight - weight_lst[swap_idx] + weight_lst[idx]\n\n    # Step 2: Probabilistic flip based on marginal gain\n    for idx in range(n_items):\n        if np.random.rand() < 0.2:  # 20% chance to consider flipping\n            if new_solution[idx] == 1:\n                # Calculate marginal gain if removed\n                marginal_gain = value1_lst[idx] + value2_lst[idx]\n                if marginal_gain < 0:  # Remove if negative contribution\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n            else:\n                # Calculate marginal gain if added\n                marginal_gain = value1_lst[idx] + value2_lst[idx]\n                if marginal_gain > 0 and current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3148649686589199,
            4.035624474287033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest combined objective value)\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objects = [obj for sol, obj in archive]\n    combined_values = np.array([v1 + v2 for v1, v2 in archive_objects])\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for flipping\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n            else:\n                # If removing doesn't work, try swapping with another item\n                swap_candidates = np.where((new_solution == 0) &\n                                          (weight_lst <= capacity - current_weight + weight_lst[idx]))[0]\n                if len(swap_candidates) > 0:\n                    swap_idx = np.random.choice(swap_candidates)\n                    new_solution[idx] = 0\n                    new_solution[swap_idx] = 1\n                    current_weight = current_weight - weight_lst[idx] + weight_lst[swap_idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            else:\n                # If adding doesn't work, try swapping with another item\n                swap_candidates = np.where((new_solution == 1) &\n                                         (weight_lst[idx] - weight_lst <= capacity - current_weight))[0]\n                if len(swap_candidates) > 0:\n                    swap_idx = np.random.choice(swap_candidates)\n                    new_solution[swap_idx] = 0\n                    new_solution[idx] = 1\n                    current_weight = current_weight - weight_lst[swap_idx] + weight_lst[idx]\n\n    # Step 2: Probabilistic flip based on marginal gain\n    for idx in range(n_items):\n        if np.random.rand() < 0.2:  # 20% chance to consider flipping\n            if new_solution[idx] == 1:\n                # Calculate marginal gain if removed\n                marginal_gain = value1_lst[idx] + value2_lst[idx]\n                if marginal_gain < 0:  # Remove if negative contribution\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n            else:\n                # Calculate marginal gain if added\n                marginal_gain = value1_lst[idx] + value2_lst[idx]\n                if marginal_gain > 0 and current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high diversity and marginal improvement potential, then applies a hybrid local search combining random item swaps and objective-specific greedy flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + objective-specific greedy flips\n    num_items = len(weight_lst)\n    remaining_weight = capacity - np.sum(weight_lst[base_solution == 1])\n\n    # Random swaps (exploration)\n    for _ in range(3):  # Perform a few random swaps\n        if np.sum(new_solution) == 0:\n            break\n        i = random.randint(0, num_items - 1)\n        j = random.randint(0, num_items - 1)\n        if i != j:\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if weight_lst[j] <= remaining_weight + weight_lst[i]:\n                    new_solution[i], new_solution[j] = 0, 1\n                    remaining_weight += weight_lst[i] - weight_lst[j]\n\n    # Objective-specific greedy flips (exploitation)\n    for _ in range(2):  # Perform a few greedy flips\n        # Try to improve objective 1\n        for i in range(num_items):\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_weight:\n                potential_v1 = current_v1 + value1_lst[i]\n                if potential_v1 > current_v1:\n                    new_solution[i] = 1\n                    remaining_weight -= weight_lst[i]\n                    current_v1 = potential_v1\n                    break\n\n        # Try to improve objective 2\n        for i in range(num_items):\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_weight:\n                potential_v2 = current_v2 + value2_lst[i]\n                if potential_v2 > current_v2:\n                    new_solution[i] = 1\n                    remaining_weight -= weight_lst[i]\n                    current_v2 = potential_v2\n                    break\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            # Remove the item with the smallest ratio of (value1 + value2)/weight\n            ratios = [(value1_lst[i] + value2_lst[i]) / weight_lst[i] for i in items_in]\n            remove_idx = items_in[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.37518395336994115,
            8.904256910085678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + objective-specific greedy flips\n    num_items = len(weight_lst)\n    remaining_weight = capacity - np.sum(weight_lst[base_solution == 1])\n\n    # Random swaps (exploration)\n    for _ in range(3):  # Perform a few random swaps\n        if np.sum(new_solution) == 0:\n            break\n        i = random.randint(0, num_items - 1)\n        j = random.randint(0, num_items - 1)\n        if i != j:\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if weight_lst[j] <= remaining_weight + weight_lst[i]:\n                    new_solution[i], new_solution[j] = 0, 1\n                    remaining_weight += weight_lst[i] - weight_lst[j]\n\n    # Objective-specific greedy flips (exploitation)\n    for _ in range(2):  # Perform a few greedy flips\n        # Try to improve objective 1\n        for i in range(num_items):\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_weight:\n                potential_v1 = current_v1 + value1_lst[i]\n                if potential_v1 > current_v1:\n                    new_solution[i] = 1\n                    remaining_weight -= weight_lst[i]\n                    current_v1 = potential_v1\n                    break\n\n        # Try to improve objective 2\n        for i in range(num_items):\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_weight:\n                potential_v2 = current_v2 + value2_lst[i]\n                if potential_v2 > current_v2:\n                    new_solution[i] = 1\n                    remaining_weight -= weight_lst[i]\n                    current_v2 = potential_v2\n                    break\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            # Remove the item with the smallest ratio of (value1 + value2)/weight\n            ratios = [(value1_lst[i] + value2_lst[i]) / weight_lst[i] for i in items_in]\n            remove_idx = items_in[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that intelligently combines item swaps, flips, and guided random perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Guided flip for improving both objectives\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Find items to flip (prioritize those that improve both objectives)\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity:\n                    # Flip to 0 if it doesn't significantly degrade both objectives\n                    if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                        new_solution[i] = 0\n                        total_weight -= weight_lst[i]\n                        break\n            else:\n                if total_weight + weight_lst[i] <= capacity:\n                    # Flip to 1 if it improves both objectives\n                    if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                        new_solution[i] = 1\n                        total_weight += weight_lst[i]\n                        break\n\n    # Step 2: Random swap for diversification\n    if np.random.rand() < 0.3:  # 30% chance to perform swap\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        i, j = swap_indices[0], swap_indices[1]\n        if (new_solution[i] == 1 and new_solution[j] == 0 and total_weight - weight_lst[i] + weight_lst[j] <= capacity) or \\\n           (new_solution[i] == 0 and new_solution[j] == 1 and total_weight + weight_lst[i] - weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Guided perturbation (flip a random item if it improves both objectives)\n    if np.random.rand() < 0.5:  # 50% chance to perturb\n        for _ in range(3):\n            i = np.random.randint(len(new_solution))\n            if new_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity and (value1_lst[i] > 0 or value2_lst[i] > 0):\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n                    break\n            else:\n                if total_weight + weight_lst[i] <= capacity and (value1_lst[i] > 0 or value2_lst[i] > 0):\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.40986228239714595,
            2.9429017901420593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Guided flip for improving both objectives\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Find items to flip (prioritize those that improve both objectives)\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity:\n                    # Flip to 0 if it doesn't significantly degrade both objectives\n                    if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                        new_solution[i] = 0\n                        total_weight -= weight_lst[i]\n                        break\n            else:\n                if total_weight + weight_lst[i] <= capacity:\n                    # Flip to 1 if it improves both objectives\n                    if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                        new_solution[i] = 1\n                        total_weight += weight_lst[i]\n                        break\n\n    # Step 2: Random swap for diversification\n    if np.random.rand() < 0.3:  # 30% chance to perform swap\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        i, j = swap_indices[0], swap_indices[1]\n        if (new_solution[i] == 1 and new_solution[j] == 0 and total_weight - weight_lst[i] + weight_lst[j] <= capacity) or \\\n           (new_solution[i] == 0 and new_solution[j] == 1 and total_weight + weight_lst[i] - weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Guided perturbation (flip a random item if it improves both objectives)\n    if np.random.rand() < 0.5:  # 50% chance to perturb\n        for _ in range(3):\n            i = np.random.randint(len(new_solution))\n            if new_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity and (value1_lst[i] > 0 or value2_lst[i] > 0):\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n                    break\n            else:\n                if total_weight + weight_lst[i] <= capacity and (value1_lst[i] > 0 or value2_lst[i] > 0):\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and applies a hybrid local search operator that intelligently combines item swaps and flips to generate a feasible neighbor solution, ensuring the total weight does not exceed the capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: flip a random item and swap two items\n    new_solution = base_solution.copy()\n\n    # Flip a random item\n    flip_candidate = np.where(new_solution == 0)[0]\n    if len(flip_candidate) > 0:\n        flip_idx = np.random.choice(flip_candidate)\n        new_solution[flip_idx] = 1\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            new_solution[flip_idx] = 0\n\n    # Swap two items (one in, one out)\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n    if len(in_items) > 0 and len(out_items) > 0:\n        out_idx = np.random.choice(in_items)\n        in_idx = np.random.choice(out_items)\n        new_solution[out_idx] = 0\n        new_solution[in_idx] = 1\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            new_solution[in_idx] = 0\n            new_solution[out_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.29153275159951797,
            10.120694696903229
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: flip a random item and swap two items\n    new_solution = base_solution.copy()\n\n    # Flip a random item\n    flip_candidate = np.where(new_solution == 0)[0]\n    if len(flip_candidate) > 0:\n        flip_idx = np.random.choice(flip_candidate)\n        new_solution[flip_idx] = 1\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            new_solution[flip_idx] = 0\n\n    # Swap two items (one in, one out)\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n    if len(in_items) > 0 and len(out_items) > 0:\n        out_idx = np.random.choice(in_items)\n        in_idx = np.random.choice(out_items)\n        new_solution[out_idx] = 0\n        new_solution[in_idx] = 1\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            new_solution[in_idx] = 0\n            new_solution[out_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel local search operator that combines item swapping and adaptive perturbation to explore high-potential regions of the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            if objectives[sorted_idx[i+1], m] == objectives[sorted_idx[i-1], m]:\n                continue\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solutions with high crowding distance (promising for improvement)\n    candidate_indices = np.argsort(-crowding_distances)[:max(3, len(archive) // 3)]\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a novel local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: item swapping + adaptive perturbation\n    # First, try to swap a pair of items (in/out) if feasible\n    for _ in range(min(5, n_items)):\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                break\n\n    # Then, perform adaptive perturbation: flip items that improve both objectives\n    current_weight = np.dot(new_solution, weight_lst)\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding item i if feasible\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                # Check if adding improves both objectives\n                if (value1_lst[i] > 0 and value2_lst[i] > 0) or np.random.rand() < 0.3:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.43361658968956607,
            4.360657662153244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            if objectives[sorted_idx[i+1], m] == objectives[sorted_idx[i-1], m]:\n                continue\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solutions with high crowding distance (promising for improvement)\n    candidate_indices = np.argsort(-crowding_distances)[:max(3, len(archive) // 3)]\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a novel local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: item swapping + adaptive perturbation\n    # First, try to swap a pair of items (in/out) if feasible\n    for _ in range(min(5, n_items)):\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                break\n\n    # Then, perform adaptive perturbation: flip items that improve both objectives\n    current_weight = np.dot(new_solution, weight_lst)\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding item i if feasible\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                # Check if adding improves both objectives\n                if (value1_lst[i] > 0 and value2_lst[i] > 0) or np.random.rand() < 0.3:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining random item swaps and value-based perturbations to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor via hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select items to swap (prioritize low-weight, high-value items)\n    items = np.arange(len(new_solution))\n    np.random.shuffle(items)\n\n    for i in items:\n        if new_solution[i] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try adding the item (if feasible)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Apply value-based perturbation (swap with high-value items)\n    if random.random() < 0.3:\n        for i in items:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                # Add high-value item if it improves both objectives\n                if (value1_lst[i] > np.mean(value1_lst[new_solution == 1]) and\n                    value2_lst[i] > np.mean(value2_lst[new_solution == 1])):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.39752499625099574,
            5.320531964302063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor via hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select items to swap (prioritize low-weight, high-value items)\n    items = np.arange(len(new_solution))\n    np.random.shuffle(items)\n\n    for i in items:\n        if new_solution[i] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try adding the item (if feasible)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Apply value-based perturbation (swap with high-value items)\n    if random.random() < 0.3:\n        for i in items:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                # Add high-value item if it improves both objectives\n                if (value1_lst[i] > np.mean(value1_lst[new_solution == 1]) and\n                    value2_lst[i] > np.mean(value2_lst[new_solution == 1])):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be toggled (added or removed) to generate a neighbor\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Randomly select an item to toggle\n    toggle_idx = np.random.choice(candidate_indices)\n    new_solution = base_solution.copy()\n\n    # Toggle the selected item and ensure feasibility\n    if new_solution[toggle_idx] == 1:\n        new_solution[toggle_idx] = 0\n    else:\n        if current_weight + weight_lst[toggle_idx] <= capacity:\n            new_solution[toggle_idx] = 1\n\n    # If toggling didn't work, try adding a random item not in the solution\n    if np.array_equal(new_solution, base_solution):\n        available_indices = np.where(base_solution == 0)[0]\n        if len(available_indices) > 0:\n            add_idx = np.random.choice(available_indices)\n            if current_weight + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.946405376436652,
            2.678647458553314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be toggled (added or removed) to generate a neighbor\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Randomly select an item to toggle\n    toggle_idx = np.random.choice(candidate_indices)\n    new_solution = base_solution.copy()\n\n    # Toggle the selected item and ensure feasibility\n    if new_solution[toggle_idx] == 1:\n        new_solution[toggle_idx] = 0\n    else:\n        if current_weight + weight_lst[toggle_idx] <= capacity:\n            new_solution[toggle_idx] = 1\n\n    # If toggling didn't work, try adding a random item not in the solution\n    if np.array_equal(new_solution, base_solution):\n        available_indices = np.where(base_solution == 0)[0]\n        if len(available_indices) > 0:\n            add_idx = np.random.choice(available_indices)\n            if current_weight + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swapping and probabilistic item flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = 0\n    max_potential = 0.0\n    for i, (solution, _) in enumerate(archive):\n        # Calculate potential for improvement (e.g., based on diversity or proximity to Pareto front)\n        current_weight = np.sum(weight_lst[solution == 1])\n        potential = (capacity - current_weight) / capacity  # Higher if more capacity left\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap two items or flip a random item with probability\n    if random.random() < 0.7:  # Higher probability for swap\n        # Find two items to swap (one included, one excluded)\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n            # Check if swap keeps solution feasible\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Flip a random item with probability to improve objectives\n        flip_candidates = np.where((new_solution == 1) | (np.random.random(len(new_solution)) < 0.3))[0]\n        if len(flip_candidates) > 0:\n            k = random.choice(flip_candidates)\n            if new_solution[k] == 1:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[k] <= capacity:\n                    new_solution[k] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[k] <= capacity:\n                    new_solution[k] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.6487064417141758,
            6.892677694559097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = 0\n    max_potential = 0.0\n    for i, (solution, _) in enumerate(archive):\n        # Calculate potential for improvement (e.g., based on diversity or proximity to Pareto front)\n        current_weight = np.sum(weight_lst[solution == 1])\n        potential = (capacity - current_weight) / capacity  # Higher if more capacity left\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap two items or flip a random item with probability\n    if random.random() < 0.7:  # Higher probability for swap\n        # Find two items to swap (one included, one excluded)\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n            # Check if swap keeps solution feasible\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Flip a random item with probability to improve objectives\n        flip_candidates = np.where((new_solution == 1) | (np.random.random(len(new_solution)) < 0.3))[0]\n        if len(flip_candidates) > 0:\n            k = random.choice(flip_candidates)\n            if new_solution[k] == 1:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[k] <= capacity:\n                    new_solution[k] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[k] <= capacity:\n                    new_solution[k] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive item swapping with probabilistic neighborhood exploration to intelligently select and perturb solutions, ensuring feasibility while maximizing exploration of high-potential regions in the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(value1_lst) + np.sum(value2_lst)), reverse=True)\n    base_solution, _ = random.choices(sorted_solutions[:max(3, len(sorted_solutions)//4)], k=1)[0]\n    new_solution = base_solution.copy()\n\n    # Step 2: Calculate current total weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Step 3: Identify items that can be added (not in solution and weight <= remaining capacity)\n    candidate_add = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n    # Identify items that can be removed (in solution)\n    candidate_remove = np.where(new_solution == 1)[0]\n\n    # Step 4: Perform adaptive local search\n    if len(candidate_add) > 0 and len(candidate_remove) > 0:\n        # Strategy 1: Swap one item in solution with a new item (if beneficial)\n        item_to_remove = random.choice(candidate_remove)\n        item_to_add = random.choice(candidate_add)\n\n        # Check if swap improves at least one objective\n        delta_weight = weight_lst[item_to_add] - weight_lst[item_to_remove]\n        if delta_weight <= remaining_capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[item_to_add] = 1\n    else:\n        # Strategy 2: Randomly flip a single item (if no swap possible)\n        if len(candidate_add) > 0:\n            item_to_add = random.choice(candidate_add)\n            new_solution[item_to_add] = 1\n        elif len(candidate_remove) > 0:\n            item_to_remove = random.choice(candidate_remove)\n            new_solution[item_to_remove] = 0\n\n    # Step 5: Ensure feasibility (should not be needed due to checks above, but added as safeguard)\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = np.where((new_solution == 1) & (weight_lst > 0))[0]\n        if len(excess_items) > 0:\n            item_to_remove = random.choice(excess_items)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.970853133111018,
            7.528407603502274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(value1_lst) + np.sum(value2_lst)), reverse=True)\n    base_solution, _ = random.choices(sorted_solutions[:max(3, len(sorted_solutions)//4)], k=1)[0]\n    new_solution = base_solution.copy()\n\n    # Step 2: Calculate current total weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Step 3: Identify items that can be added (not in solution and weight <= remaining capacity)\n    candidate_add = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n    # Identify items that can be removed (in solution)\n    candidate_remove = np.where(new_solution == 1)[0]\n\n    # Step 4: Perform adaptive local search\n    if len(candidate_add) > 0 and len(candidate_remove) > 0:\n        # Strategy 1: Swap one item in solution with a new item (if beneficial)\n        item_to_remove = random.choice(candidate_remove)\n        item_to_add = random.choice(candidate_add)\n\n        # Check if swap improves at least one objective\n        delta_weight = weight_lst[item_to_add] - weight_lst[item_to_remove]\n        if delta_weight <= remaining_capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[item_to_add] = 1\n    else:\n        # Strategy 2: Randomly flip a single item (if no swap possible)\n        if len(candidate_add) > 0:\n            item_to_add = random.choice(candidate_add)\n            new_solution[item_to_add] = 1\n        elif len(candidate_remove) > 0:\n            item_to_remove = random.choice(candidate_remove)\n            new_solution[item_to_remove] = 0\n\n    # Step 5: Ensure feasibility (should not be needed due to checks above, but added as safeguard)\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = np.where((new_solution == 1) & (weight_lst > 0))[0]\n        if len(excess_items) > 0:\n            item_to_remove = random.choice(excess_items)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that prioritizes solutions with high potential for improvement, then applies a hybrid local search operator combining item swaps and random flips to generate a feasible neighbor solution while ensuring the weight constraint is satisfied.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Heuristic: Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Prioritize solutions with higher potential for improvement\n    candidates.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives (descending)\n    selected_sol = candidates[0][0].copy()\n\n    # Hybrid local search: Randomly swap or flip items while maintaining feasibility\n    new_solution = selected_sol.copy()\n    num_items = len(weight_lst)\n\n    # Randomly select a subset of items to flip or swap\n    num_changes = min(3, num_items)  # Limit changes to avoid excessive computation\n    indices = random.sample(range(num_items), num_changes)\n\n    for i in indices:\n        # Try flipping the item\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n        else:\n            new_solution[i] = 1\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            new_solution[i] = 1 - new_solution[i]  # Revert if infeasible\n\n    # Optional: Randomly swap two items if feasible\n    if num_items >= 2 and random.random() < 0.5:\n        i, j = random.sample(range(num_items), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            total_weight = np.sum(weight_lst * new_solution)\n            if total_weight > capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.34344787171945,
            9.727736830711365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Heuristic: Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Prioritize solutions with higher potential for improvement\n    candidates.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives (descending)\n    selected_sol = candidates[0][0].copy()\n\n    # Hybrid local search: Randomly swap or flip items while maintaining feasibility\n    new_solution = selected_sol.copy()\n    num_items = len(weight_lst)\n\n    # Randomly select a subset of items to flip or swap\n    num_changes = min(3, num_items)  # Limit changes to avoid excessive computation\n    indices = random.sample(range(num_items), num_changes)\n\n    for i in indices:\n        # Try flipping the item\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n        else:\n            new_solution[i] = 1\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            new_solution[i] = 1 - new_solution[i]  # Revert if infeasible\n\n    # Optional: Randomly swap two items if feasible\n    if num_items >= 2 and random.random() < 0.5:\n        i, j = random.sample(range(num_items), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            total_weight = np.sum(weight_lst * new_solution)\n            if total_weight > capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping based on marginal utility ratios and probabilistic item reinsertion, guided by a diversity-aware selection mechanism to explore non-dominated regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with probability proportional to its non-dominated rank\n    ranks = np.array([i for i in range(len(archive))])\n    probs = np.exp(-ranks / len(archive))  # Higher rank -> higher probability\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal utility ratios for each item\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    marginal_combined = marginal1 + marginal2\n\n    # Identify items to potentially swap or flip\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # With 70% probability, perform a swap with a promising item outside the solution\n        if random.random() < 0.7:\n            outside_indices = np.where(new_solution == 0)[0]\n            if len(outside_indices) > 0:\n                # Select items with high marginal utility\n                top_outside = outside_indices[np.argsort(marginal_combined[outside_indices])[-min(5, len(outside_indices)):]]\n                if len(top_outside) > 0:\n                    swap_out = random.choice(candidate_indices)\n                    swap_in = random.choice(top_outside)\n                    if current_weight - weight_lst[swap_out] + weight_lst[swap_in] <= capacity:\n                        new_solution[swap_out] = 0\n                        new_solution[swap_in] = 1\n        else:\n            # With 30% probability, flip a low-marginal-utility item\n            low_marginal = candidate_indices[np.argsort(marginal_combined[candidate_indices])[:min(3, len(candidate_indices))]]\n            if len(low_marginal) > 0:\n                flip_item = random.choice(low_marginal)\n                if current_weight - weight_lst[flip_item] <= capacity:\n                    new_solution[flip_item] = 0\n\n    # With 20% probability, add a high-marginal-utility item if possible\n    if random.random() < 0.2:\n        outside_indices = np.where(new_solution == 0)[0]\n        if len(outside_indices) > 0:\n            top_outside = outside_indices[np.argsort(marginal_combined[outside_indices])[-min(3, len(outside_indices)):]]\n            for item in top_outside:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3572510933971417,
            9.720140308141708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with probability proportional to its non-dominated rank\n    ranks = np.array([i for i in range(len(archive))])\n    probs = np.exp(-ranks / len(archive))  # Higher rank -> higher probability\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal utility ratios for each item\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    marginal_combined = marginal1 + marginal2\n\n    # Identify items to potentially swap or flip\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # With 70% probability, perform a swap with a promising item outside the solution\n        if random.random() < 0.7:\n            outside_indices = np.where(new_solution == 0)[0]\n            if len(outside_indices) > 0:\n                # Select items with high marginal utility\n                top_outside = outside_indices[np.argsort(marginal_combined[outside_indices])[-min(5, len(outside_indices)):]]\n                if len(top_outside) > 0:\n                    swap_out = random.choice(candidate_indices)\n                    swap_in = random.choice(top_outside)\n                    if current_weight - weight_lst[swap_out] + weight_lst[swap_in] <= capacity:\n                        new_solution[swap_out] = 0\n                        new_solution[swap_in] = 1\n        else:\n            # With 30% probability, flip a low-marginal-utility item\n            low_marginal = candidate_indices[np.argsort(marginal_combined[candidate_indices])[:min(3, len(candidate_indices))]]\n            if len(low_marginal) > 0:\n                flip_item = random.choice(low_marginal)\n                if current_weight - weight_lst[flip_item] <= capacity:\n                    new_solution[flip_item] = 0\n\n    # With 20% probability, add a high-marginal-utility item if possible\n    if random.random() < 0.2:\n        outside_indices = np.where(new_solution == 0)[0]\n        if len(outside_indices) > 0:\n            top_outside = outside_indices[np.argsort(marginal_combined[outside_indices])[-min(3, len(outside_indices)):]]\n            for item in top_outside:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator that combines item swaps and probabilistic flips to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Evaluate solutions based on the ratio of value1 to value2\n    ratios = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: perform item swaps and probabilistic flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Swap two items if feasible\n    for _ in range(10):  # Limit iterations to avoid long computation\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] == base_solution[j]:\n            continue  # No change if both are the same\n\n        if base_solution[i] == 1 and base_solution[j] == 0:\n            # Swap item i (in) with item j (out)\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = 0, 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                break\n        elif base_solution[i] == 0 and base_solution[j] == 1:\n            # Swap item j (in) with item i (out)\n            if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                new_solution[i], new_solution[j] = 1, 0\n                current_weight = current_weight - weight_lst[j] + weight_lst[i]\n                break\n\n    # Probabilistic flip: flip items with a probability based on their value-to-weight ratio\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% probability to flip\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4337634381641426,
            4.0399274826049805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Evaluate solutions based on the ratio of value1 to value2\n    ratios = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: perform item swaps and probabilistic flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Swap two items if feasible\n    for _ in range(10):  # Limit iterations to avoid long computation\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] == base_solution[j]:\n            continue  # No change if both are the same\n\n        if base_solution[i] == 1 and base_solution[j] == 0:\n            # Swap item i (in) with item j (out)\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = 0, 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                break\n        elif base_solution[i] == 0 and base_solution[j] == 1:\n            # Swap item j (in) with item i (out)\n            if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                new_solution[i], new_solution[j] = 1, 0\n                current_weight = current_weight - weight_lst[j] + weight_lst[i]\n                break\n\n    # Probabilistic flip: flip items with a probability based on their value-to-weight ratio\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% probability to flip\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping with probabilistic neighborhood exploration to intelligently refine non-dominated solutions by dynamically balancing objective improvements while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be flipped (added or removed) without violating capacity\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        return base_solution  # No feasible neighbors\n\n    # Select a candidate item with high potential for improvement\n    # Prioritize items that can increase the worse objective more\n    max_improvement = -1\n    best_candidate = None\n    for item_idx, action in candidate_items:\n        if action == 1:\n            # Adding item: calculate potential improvement\n            improvement1 = value1_lst[item_idx]\n            improvement2 = value2_lst[item_idx]\n            # Prefer items that improve the worse objective more\n            if min(current_value1 + improvement1, current_value2 + improvement2) > min(current_value1, current_value2):\n                if improvement1 + improvement2 > max_improvement:\n                    max_improvement = improvement1 + improvement2\n                    best_candidate = (item_idx, action)\n        else:\n            # Removing item: calculate potential improvement\n            improvement1 = -value1_lst[item_idx]\n            improvement2 = -value2_lst[item_idx]\n            if min(current_value1 + improvement1, current_value2 + improvement2) > min(current_value1, current_value2):\n                if improvement1 + improvement2 > max_improvement:\n                    max_improvement = improvement1 + improvement2\n                    best_candidate = (item_idx, action)\n\n    if best_candidate is None:\n        # If no candidate improves both objectives, pick randomly\n        best_candidate = random.choice(candidate_items)\n\n    # Apply the best candidate move\n    item_idx, action = best_candidate\n    new_solution[item_idx] = 1 if action == 1 else 0\n\n    # Additional probabilistic exploration: flip another item if beneficial\n    if random.random() < 0.3:  # 30% chance to flip another item\n        for _ in range(3):  # Try up to 3 times\n            candidate = random.choice(candidate_items)\n            temp_solution = new_solution.copy()\n            temp_solution[candidate[0]] = 1 if candidate[1] == 1 else 0\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7922938847947174,
            3.657367527484894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be flipped (added or removed) without violating capacity\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        return base_solution  # No feasible neighbors\n\n    # Select a candidate item with high potential for improvement\n    # Prioritize items that can increase the worse objective more\n    max_improvement = -1\n    best_candidate = None\n    for item_idx, action in candidate_items:\n        if action == 1:\n            # Adding item: calculate potential improvement\n            improvement1 = value1_lst[item_idx]\n            improvement2 = value2_lst[item_idx]\n            # Prefer items that improve the worse objective more\n            if min(current_value1 + improvement1, current_value2 + improvement2) > min(current_value1, current_value2):\n                if improvement1 + improvement2 > max_improvement:\n                    max_improvement = improvement1 + improvement2\n                    best_candidate = (item_idx, action)\n        else:\n            # Removing item: calculate potential improvement\n            improvement1 = -value1_lst[item_idx]\n            improvement2 = -value2_lst[item_idx]\n            if min(current_value1 + improvement1, current_value2 + improvement2) > min(current_value1, current_value2):\n                if improvement1 + improvement2 > max_improvement:\n                    max_improvement = improvement1 + improvement2\n                    best_candidate = (item_idx, action)\n\n    if best_candidate is None:\n        # If no candidate improves both objectives, pick randomly\n        best_candidate = random.choice(candidate_items)\n\n    # Apply the best candidate move\n    item_idx, action = best_candidate\n    new_solution[item_idx] = 1 if action == 1 else 0\n\n    # Additional probabilistic exploration: flip another item if beneficial\n    if random.random() < 0.3:  # 30% chance to flip another item\n        for _ in range(3):  # Try up to 3 times\n            candidate = random.choice(candidate_items)\n            temp_solution = new_solution.copy()\n            temp_solution[candidate[0]] = 1 if candidate[1] == 1 else 0\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive, then applies a combination of random perturbation, greedy improvement, and adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            continue\n\n        # Potential is based on the ratio of remaining capacity to total capacity\n        # and the current objective values\n        potential = remaining_capacity / capacity * (obj[0] + obj[1])\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]  # fallback to first solution if no potential found\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search\n    # Step 1: Random perturbation (flip a few bits)\n    num_flips = min(3, len(new_solution))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for i in flip_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility after perturbation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        while current_weight > capacity and np.sum(new_solution) > 0:\n            remove_indices = np.where(new_solution == 1)[0]\n            if len(remove_indices) == 0:\n                break\n            i = random.choice(remove_indices)\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 2: Greedy improvement (add items that improve both objectives)\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        # Calculate marginal gains for each item\n        marginal_gains = (value1_lst + value2_lst) * (1 - new_solution)\n        # Sort by marginal gain and weight\n        sorted_indices = np.argsort(-marginal_gains / weight_lst)\n        for i in sorted_indices:\n            if weight_lst[i] <= remaining_capacity and new_solution[i] == 0:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    # Step 3: Adaptive neighborhood exploration (flip items with high marginal gain)\n    if random.random() < 0.3:  # 30% chance for this step\n        marginal_gains = (value1_lst + value2_lst) * new_solution\n        sorted_indices = np.argsort(-marginal_gains)\n        for i in sorted_indices[:min(3, len(sorted_indices))]:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[i] = 1\n                else:\n                    # Try to add another item to compensate\n                    remaining_capacity = capacity - current_weight\n                    add_candidates = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n                    if len(add_candidates) > 0:\n                        j = random.choice(add_candidates)\n                        new_solution[j] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3340080126685554,
            8.811390370130539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            continue\n\n        # Potential is based on the ratio of remaining capacity to total capacity\n        # and the current objective values\n        potential = remaining_capacity / capacity * (obj[0] + obj[1])\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]  # fallback to first solution if no potential found\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search\n    # Step 1: Random perturbation (flip a few bits)\n    num_flips = min(3, len(new_solution))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for i in flip_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility after perturbation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        while current_weight > capacity and np.sum(new_solution) > 0:\n            remove_indices = np.where(new_solution == 1)[0]\n            if len(remove_indices) == 0:\n                break\n            i = random.choice(remove_indices)\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 2: Greedy improvement (add items that improve both objectives)\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        # Calculate marginal gains for each item\n        marginal_gains = (value1_lst + value2_lst) * (1 - new_solution)\n        # Sort by marginal gain and weight\n        sorted_indices = np.argsort(-marginal_gains / weight_lst)\n        for i in sorted_indices:\n            if weight_lst[i] <= remaining_capacity and new_solution[i] == 0:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    # Step 3: Adaptive neighborhood exploration (flip items with high marginal gain)\n    if random.random() < 0.3:  # 30% chance for this step\n        marginal_gains = (value1_lst + value2_lst) * new_solution\n        sorted_indices = np.argsort(-marginal_gains)\n        for i in sorted_indices[:min(3, len(sorted_indices))]:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight > capacity:\n                    new_solution[i] = 1\n                else:\n                    # Try to add another item to compensate\n                    remaining_capacity = capacity - current_weight\n                    add_candidates = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n                    if len(add_candidates) > 0:\n                        j = random.choice(add_candidates)\n                        new_solution[j] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values, then applies a hybrid local search that combines item swaps with adaptive flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive (prioritize higher objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    sorted_indices = np.lexsort((-np.array([obj[0] for obj in archive_objectives]), -np.array([obj[1] for obj in archive_objectives])))\n    selected_solution = archive_solutions[sorted_indices[0]].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a subset of items to potentially flip\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(num_items // 2, 5))  # Flip up to 5 items\n\n    # Step 2: For each selected item, decide to flip it based on its contribution\n    for idx in flip_indices:\n        current_value1 = value1_lst[idx] if new_solution[idx] else 0\n        current_value2 = value2_lst[idx] if new_solution[idx] else 0\n        current_weight = weight_lst[idx] if new_solution[idx] else 0\n\n        # Calculate potential change if flipped\n        new_value1 = value1_lst[idx] if not new_solution[idx] else 0\n        new_value2 = value2_lst[idx] if not new_solution[idx] else 0\n        new_weight = weight_lst[idx] if not new_solution[idx] else 0\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1]) - current_weight + new_weight\n        if total_weight <= capacity:\n            # Flip based on the ratio of marginal gains\n            marginal_gain1 = new_value1 - current_value1\n            marginal_gain2 = new_value2 - current_value2\n            if (marginal_gain1 > 0 or marginal_gain2 > 0) or random.random() < 0.3:  # Allow some exploration\n                new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 3: Apply a swap operator to further explore the neighborhood\n    if num_items > 1:\n        i, j = random.sample(range(num_items), 2)\n        # Check feasibility of swap\n        total_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[i] - weight_lst[j] + weight_lst[j] + weight_lst[i]\n        if total_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.31502668990127625,
            5.377532780170441
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive (prioritize higher objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    sorted_indices = np.lexsort((-np.array([obj[0] for obj in archive_objectives]), -np.array([obj[1] for obj in archive_objectives])))\n    selected_solution = archive_solutions[sorted_indices[0]].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a subset of items to potentially flip\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(num_items // 2, 5))  # Flip up to 5 items\n\n    # Step 2: For each selected item, decide to flip it based on its contribution\n    for idx in flip_indices:\n        current_value1 = value1_lst[idx] if new_solution[idx] else 0\n        current_value2 = value2_lst[idx] if new_solution[idx] else 0\n        current_weight = weight_lst[idx] if new_solution[idx] else 0\n\n        # Calculate potential change if flipped\n        new_value1 = value1_lst[idx] if not new_solution[idx] else 0\n        new_value2 = value2_lst[idx] if not new_solution[idx] else 0\n        new_weight = weight_lst[idx] if not new_solution[idx] else 0\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1]) - current_weight + new_weight\n        if total_weight <= capacity:\n            # Flip based on the ratio of marginal gains\n            marginal_gain1 = new_value1 - current_value1\n            marginal_gain2 = new_value2 - current_value2\n            if (marginal_gain1 > 0 or marginal_gain2 > 0) or random.random() < 0.3:  # Allow some exploration\n                new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 3: Apply a swap operator to further explore the neighborhood\n    if num_items > 1:\n        i, j = random.sample(range(num_items), 2)\n        # Check feasibility of swap\n        total_weight = np.sum(weight_lst[new_solution == 1]) - weight_lst[i] - weight_lst[j] + weight_lst[j] + weight_lst[i]\n        if total_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([np.sum(s[0]) / capacity for s in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine flip-based and swap-based moves\n    # Step 1: Flip a random item to explore different neighborhoods\n    flip_idx = np.random.choice(np.where(base_solution == 1)[0]) if np.any(base_solution) else np.random.randint(len(base_solution))\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, remove the most expensive item (highest weight) in the flip\n        if new_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n        else:\n            # If flipping made it feasible, try adding another item\n            candidates = np.where((base_solution == 0) & (weight_lst <= capacity - total_weight))[0]\n            if len(candidates) > 0:\n                add_idx = np.random.choice(candidates)\n                new_solution[add_idx] = 1\n\n    # Step 2: Perform a swap-based move to diversify\n    if np.sum(new_solution) >= 2:\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Ensure feasibility after swap\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove the heavier item in the swap\n        if weight_lst[swap_indices[0]] > weight_lst[swap_indices[1]]:\n            new_solution[swap_indices[0]] = 0\n        else:\n            new_solution[swap_indices[1]] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8852501269924674,
            3.7505044043064117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([np.sum(s[0]) / capacity for s in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine flip-based and swap-based moves\n    # Step 1: Flip a random item to explore different neighborhoods\n    flip_idx = np.random.choice(np.where(base_solution == 1)[0]) if np.any(base_solution) else np.random.randint(len(base_solution))\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, remove the most expensive item (highest weight) in the flip\n        if new_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n        else:\n            # If flipping made it feasible, try adding another item\n            candidates = np.where((base_solution == 0) & (weight_lst <= capacity - total_weight))[0]\n            if len(candidates) > 0:\n                add_idx = np.random.choice(candidates)\n                new_solution[add_idx] = 1\n\n    # Step 2: Perform a swap-based move to diversify\n    if np.sum(new_solution) >= 2:\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Ensure feasibility after swap\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove the heavier item in the swap\n        if weight_lst[swap_indices[0]] > weight_lst[swap_indices[1]]:\n            new_solution[swap_indices[0]] = 0\n        else:\n            new_solution[swap_indices[1]] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive, then applies a hybrid local search strategy combining item swaps, random flips, and adaptive weight adjustments to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Normalize objectives to make them comparable\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution with a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to flip (with adaptive probability)\n    flip_prob = 0.3  # Base probability to flip an item\n    for i in range(n_items):\n        if np.random.rand() < flip_prob:\n            # Flip the item and check feasibility\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1 - temp_solution[i]\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution[i] = temp_solution[i]\n\n    # Step 2: Perform a weighted swap to improve both objectives\n    if n_items >= 2:\n        # Calculate weights for each item based on their contribution to both objectives\n        item_weights = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        # Select two items to swap (prioritize items with higher weights)\n        idx1, idx2 = np.random.choice(n_items, size=2, p=item_weights / item_weights.sum(), replace=False)\n        # Swap the items if feasible\n        temp_solution = new_solution.copy()\n        temp_solution[idx1], temp_solution[idx2] = temp_solution[idx2], temp_solution[idx1]\n        total_weight = np.sum(weight_lst[temp_solution == 1])\n        if total_weight <= capacity:\n            new_solution = temp_solution\n\n    # Step 3: Add or remove a random item to explore new regions\n    if np.random.rand() < 0.2:  # 20% chance to add/remove\n        action = np.random.choice(['add', 'remove'])\n        if action == 'add':\n            # Randomly select an item to add (prioritize items with high total value)\n            item_weights = value1_lst + value2_lst\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                idx = np.random.choice(candidate_items, p=item_weights[candidate_items] / item_weights[candidate_items].sum())\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n        else:\n            # Randomly select an item to remove (prioritize items with low total value)\n            item_weights = 1 / (value1_lst + value2_lst + 1e-10)\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                idx = np.random.choice(candidate_items, p=item_weights[candidate_items] / item_weights[candidate_items].sum())\n                new_solution[idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3470191352819646,
            10.254669845104218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Normalize objectives to make them comparable\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution with a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to flip (with adaptive probability)\n    flip_prob = 0.3  # Base probability to flip an item\n    for i in range(n_items):\n        if np.random.rand() < flip_prob:\n            # Flip the item and check feasibility\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1 - temp_solution[i]\n            total_weight = np.sum(weight_lst[temp_solution == 1])\n            if total_weight <= capacity:\n                new_solution[i] = temp_solution[i]\n\n    # Step 2: Perform a weighted swap to improve both objectives\n    if n_items >= 2:\n        # Calculate weights for each item based on their contribution to both objectives\n        item_weights = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        # Select two items to swap (prioritize items with higher weights)\n        idx1, idx2 = np.random.choice(n_items, size=2, p=item_weights / item_weights.sum(), replace=False)\n        # Swap the items if feasible\n        temp_solution = new_solution.copy()\n        temp_solution[idx1], temp_solution[idx2] = temp_solution[idx2], temp_solution[idx1]\n        total_weight = np.sum(weight_lst[temp_solution == 1])\n        if total_weight <= capacity:\n            new_solution = temp_solution\n\n    # Step 3: Add or remove a random item to explore new regions\n    if np.random.rand() < 0.2:  # 20% chance to add/remove\n        action = np.random.choice(['add', 'remove'])\n        if action == 'add':\n            # Randomly select an item to add (prioritize items with high total value)\n            item_weights = value1_lst + value2_lst\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                idx = np.random.choice(candidate_items, p=item_weights[candidate_items] / item_weights[candidate_items].sum())\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n        else:\n            # Randomly select an item to remove (prioritize items with low total value)\n            item_weights = 1 / (value1_lst + value2_lst + 1e-10)\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                idx = np.random.choice(candidate_items, p=item_weights[candidate_items] / item_weights[candidate_items].sum())\n                new_solution[idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search that combines bit-flipping and item swapping, ensuring feasibility by dynamically adjusting the neighborhood to respect capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest combined objective value)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: bit-flip with item swapping\n    for _ in range(10):  # Limit iterations for efficiency\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Check if adding the item is feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n        # Randomly swap two items (one in, one out if feasible)\n        idx1, idx2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[idx1] == 1 and new_solution[idx2] == 0:\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[idx1] + weight_lst[idx2]) <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.3228801229495401,
            2.3054518699645996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest combined objective value)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: bit-flip with item swapping\n    for _ in range(10):  # Limit iterations for efficiency\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Check if adding the item is feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n        # Randomly swap two items (one in, one out if feasible)\n        idx1, idx2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[idx1] == 1 and new_solution[idx2] == 0:\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[idx1] + weight_lst[idx2]) <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{The novel heuristic combines a biased random selection of solutions with a guided local search that prioritizes high-value items while respecting the knapsack capacity, using a combination of swap and insertion moves to escape local optima and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Compute normalized scores for each solution\n        scores = np.zeros(len(archive))\n        for i, (sol, obj) in enumerate(archive):\n            scores[i] = obj[0] + obj[1]  # Simple sum of objectives as a proxy for quality\n        scores = scores / np.sum(scores)  # Normalize to probabilities\n        selected_idx = np.random.choice(len(archive), p=scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combination of swap and insertion moves\n    for _ in range(10):  # Small number of iterations to balance exploration/exploitation\n        # Try to swap two items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = np.random.choice(in_items)\n            swap_out = np.random.choice(out_items)\n\n            # Check if swap is feasible\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                current_weight = new_weight\n\n        # Try to insert a high-value item if possible\n        if current_weight < capacity:\n            # Select high-value items not currently in the knapsack\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                # Prioritize items with high combined value\n                candidate_values = (value1_lst[candidates] + value2_lst[candidates]) / weight_lst[candidates]\n                best_candidate = candidates[np.argmax(candidate_values)]\n\n                if current_weight + weight_lst[best_candidate] <= capacity:\n                    new_solution[best_candidate] = 1\n                    current_weight += weight_lst[best_candidate]\n\n    return new_solution\n\n",
        "score": [
            -0.35560273239484286,
            9.824610829353333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Compute normalized scores for each solution\n        scores = np.zeros(len(archive))\n        for i, (sol, obj) in enumerate(archive):\n            scores[i] = obj[0] + obj[1]  # Simple sum of objectives as a proxy for quality\n        scores = scores / np.sum(scores)  # Normalize to probabilities\n        selected_idx = np.random.choice(len(archive), p=scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combination of swap and insertion moves\n    for _ in range(10):  # Small number of iterations to balance exploration/exploitation\n        # Try to swap two items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = np.random.choice(in_items)\n            swap_out = np.random.choice(out_items)\n\n            # Check if swap is feasible\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                current_weight = new_weight\n\n        # Try to insert a high-value item if possible\n        if current_weight < capacity:\n            # Select high-value items not currently in the knapsack\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                # Prioritize items with high combined value\n                candidate_values = (value1_lst[candidates] + value2_lst[candidates]) / weight_lst[candidates]\n                best_candidate = candidates[np.argmax(candidate_values)]\n\n                if current_weight + weight_lst[best_candidate] <= capacity:\n                    new_solution[best_candidate] = 1\n                    current_weight += weight_lst[best_candidate]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{The heuristic selects a promising solution from the archive based on a diversity and improvement potential metric, then applies a hybrid local search combining greedy value augmentation and random perturbation to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., not too crowded in objective space)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: Greedy value augmentation + random perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Greedy augmentation - add items with highest value-to-weight ratio\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        # Compute value-to-weight ratios for both objectives\n        v1_ratio = value1_lst / weight_lst\n        v2_ratio = value2_lst / weight_lst\n\n        # Combine ratios (simple average for this example)\n        combined_ratio = (v1_ratio + v2_ratio) / 2\n\n        # Sort items by combined ratio (descending)\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    # Step 2: Random perturbation - flip a few items to escape local optima\n    num_perturbations = min(3, len(new_solution))\n    perturb_indices = random.sample(range(len(new_solution)), num_perturbations)\n\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Ensure adding doesn't exceed capacity\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        while total_weight > capacity:\n            # Find items to remove (prioritize low value-to-weight ratio)\n            combined_ratio = (value1_lst + value2_lst) / weight_lst\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break\n            remove_idx = candidate_indices[np.argmin(combined_ratio[candidate_indices])]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.34434129624444565,
            2.868403971195221
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., not too crowded in objective space)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: Greedy value augmentation + random perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Greedy augmentation - add items with highest value-to-weight ratio\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        # Compute value-to-weight ratios for both objectives\n        v1_ratio = value1_lst / weight_lst\n        v2_ratio = value2_lst / weight_lst\n\n        # Combine ratios (simple average for this example)\n        combined_ratio = (v1_ratio + v2_ratio) / 2\n\n        # Sort items by combined ratio (descending)\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    # Step 2: Random perturbation - flip a few items to escape local optima\n    num_perturbations = min(3, len(new_solution))\n    perturb_indices = random.sample(range(len(new_solution)), num_perturbations)\n\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Ensure adding doesn't exceed capacity\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        while total_weight > capacity:\n            # Find items to remove (prioritize low value-to-weight ratio)\n            combined_ratio = (value1_lst + value2_lst) / weight_lst\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break\n            remove_idx = candidate_indices[np.argmin(combined_ratio[candidate_indices])]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid metric combining objective values and solution diversity, then applies a novel local search operator that intelligently flips item selections while ensuring feasibility by dynamically adjusting the flip probability to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate a hybrid score combining objective values and diversity\n    scores = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions\n        # Hybrid score: weighted sum of normalized objectives + diversity (number of unique items)\n        norm_v1 = v1 / (np.sum(value1_lst) + 1e-6)\n        norm_v2 = v2 / (np.sum(value2_lst) + 1e-6)\n        diversity = np.sum(sol)\n        score = 0.6 * norm_v1 + 0.3 * norm_v2 + 0.1 * (diversity / len(sol))\n        scores.append((score, sol))\n\n    if not scores:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest score\n    selected_score, base_solution = max(scores, key=lambda x: x[0])\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply the novel local search operator\n    # Dynamically adjust flip probability based on solution quality and diversity\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_prob = 0.3  # Base flip probability\n\n    # Adjust based on solution quality (higher quality -> lower flip probability)\n    if selected_score > 0.8:\n        flip_prob *= 0.5\n    elif selected_score < 0.4:\n        flip_prob *= 1.5\n\n    # Adjust based on diversity (higher diversity -> higher flip probability)\n    diversity = np.sum(new_solution) / len(new_solution)\n    if diversity < 0.3:\n        flip_prob *= 1.2\n    elif diversity > 0.7:\n        flip_prob *= 0.8\n\n    # Apply the flip operator with the adjusted probability\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            # Flip the item if it fits or can be swapped\n            if new_solution[i] == 1:\n                # Try to remove it\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add it\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5026547739462486,
            3.224909782409668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate a hybrid score combining objective values and diversity\n    scores = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions\n        # Hybrid score: weighted sum of normalized objectives + diversity (number of unique items)\n        norm_v1 = v1 / (np.sum(value1_lst) + 1e-6)\n        norm_v2 = v2 / (np.sum(value2_lst) + 1e-6)\n        diversity = np.sum(sol)\n        score = 0.6 * norm_v1 + 0.3 * norm_v2 + 0.1 * (diversity / len(sol))\n        scores.append((score, sol))\n\n    if not scores:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest score\n    selected_score, base_solution = max(scores, key=lambda x: x[0])\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply the novel local search operator\n    # Dynamically adjust flip probability based on solution quality and diversity\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_prob = 0.3  # Base flip probability\n\n    # Adjust based on solution quality (higher quality -> lower flip probability)\n    if selected_score > 0.8:\n        flip_prob *= 0.5\n    elif selected_score < 0.4:\n        flip_prob *= 1.5\n\n    # Adjust based on diversity (higher diversity -> higher flip probability)\n    diversity = np.sum(new_solution) / len(new_solution)\n    if diversity < 0.3:\n        flip_prob *= 1.2\n    elif diversity > 0.7:\n        flip_prob *= 0.8\n\n    # Apply the flip operator with the adjusted probability\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            # Flip the item if it fits or can be swapped\n            if new_solution[i] == 1:\n                # Try to remove it\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add it\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines neighborhood exploration, adaptive selection of items for swap, and feasibility checks to generate high-quality neighbors by leveraging the archive's non-dominated solutions and exploiting item value ratios for improved multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and value ratios\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    value1_ratio = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items to consider for swap (either in or out)\n    candidate_items = np.where((new_solution == 1) | (np.random.rand(len(weight_lst)) < 0.3))[0]\n\n    # Perform a novel hybrid local search\n    for item in candidate_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n\n            if temp_weight <= capacity:\n                # Evaluate the potential gain in both objectives\n                gain1 = -value1_lst[item]\n                gain2 = -value2_lst[item]\n\n                # Consider adding another item to compensate (if possible)\n                for other_item in np.where((new_solution == 0) & (weight_lst <= (capacity - temp_weight)))[0]:\n                    temp_solution[other_item] = 1\n                    new_weight = temp_weight + weight_lst[other_item]\n\n                    if new_weight <= capacity:\n                        # Accept the swap if it improves at least one objective\n                        if (value1_lst[other_item] + gain1) > 0 or (value2_lst[other_item] + gain2) > 0:\n                            new_solution = temp_solution.copy()\n                            current_weight = new_weight\n                            break\n                    temp_solution[other_item] = 0\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n\n                # Evaluate the potential gain in both objectives\n                gain1 = value1_lst[item]\n                gain2 = value2_lst[item]\n\n                # Consider removing another item to compensate (if possible)\n                for other_item in np.where(new_solution == 1)[0]:\n                    if value1_ratio[other_item] < value1_ratio[item] or value2_ratio[other_item] < value2_ratio[item]:\n                        temp_solution[other_item] = 0\n                        new_weight = current_weight + weight_lst[item] - weight_lst[other_item]\n\n                        if new_weight <= capacity:\n                            # Accept the swap if it improves at least one objective\n                            if (gain1 - value1_lst[other_item]) > 0 or (gain2 - value2_lst[other_item]) > 0:\n                                new_solution = temp_solution.copy()\n                                current_weight = new_weight\n                                break\n                        temp_solution[other_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5856885668054241,
            10.766845226287842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and value ratios\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    value1_ratio = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    value2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items to consider for swap (either in or out)\n    candidate_items = np.where((new_solution == 1) | (np.random.rand(len(weight_lst)) < 0.3))[0]\n\n    # Perform a novel hybrid local search\n    for item in candidate_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n\n            if temp_weight <= capacity:\n                # Evaluate the potential gain in both objectives\n                gain1 = -value1_lst[item]\n                gain2 = -value2_lst[item]\n\n                # Consider adding another item to compensate (if possible)\n                for other_item in np.where((new_solution == 0) & (weight_lst <= (capacity - temp_weight)))[0]:\n                    temp_solution[other_item] = 1\n                    new_weight = temp_weight + weight_lst[other_item]\n\n                    if new_weight <= capacity:\n                        # Accept the swap if it improves at least one objective\n                        if (value1_lst[other_item] + gain1) > 0 or (value2_lst[other_item] + gain2) > 0:\n                            new_solution = temp_solution.copy()\n                            current_weight = new_weight\n                            break\n                    temp_solution[other_item] = 0\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n\n                # Evaluate the potential gain in both objectives\n                gain1 = value1_lst[item]\n                gain2 = value2_lst[item]\n\n                # Consider removing another item to compensate (if possible)\n                for other_item in np.where(new_solution == 1)[0]:\n                    if value1_ratio[other_item] < value1_ratio[item] or value2_ratio[other_item] < value2_ratio[item]:\n                        temp_solution[other_item] = 0\n                        new_weight = current_weight + weight_lst[item] - weight_lst[other_item]\n\n                        if new_weight <= capacity:\n                            # Accept the swap if it improves at least one objective\n                            if (gain1 - value1_lst[other_item]) > 0 or (gain2 - value2_lst[other_item]) > 0:\n                                new_solution = temp_solution.copy()\n                                current_weight = new_weight\n                                break\n                        temp_solution[other_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with a weighted objective-guided perturbation to explore promising regions in the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swapping (flip items with high potential)\n    for _ in range(3):  # Number of swaps\n        # Calculate potential of each item (weighted by both objectives)\n        potential = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        potential[base_solution == 0] *= -1  # Prefer flipping out low-potential items\n\n        # Select item with highest potential\n        item_to_flip = np.argmax(potential)\n\n        # Flip the item if it maintains feasibility\n        if base_solution[item_to_flip] == 1:\n            if current_weight - weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 0\n                current_weight -= weight_lst[item_to_flip]\n        else:\n            if current_weight + weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 1\n                current_weight += weight_lst[item_to_flip]\n\n    # Step 2: Weighted objective-guided perturbation\n    # Calculate weights for objectives based on current solution's position\n    obj1_weight = 1.0 / (current_obj1 + 1e-6)\n    obj2_weight = 1.0 / (current_obj2 + 1e-6)\n\n    # Select items to flip based on weighted objectives\n    combined_value = (obj1_weight * value1_lst + obj2_weight * value2_lst)\n    combined_value[base_solution == 0] *= -1  # Prefer flipping out low-value items\n\n    # Flip top 2 items with highest weighted value\n    top_items = np.argsort(combined_value)[-2:]\n    for item in top_items:\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8649443114618767,
            2.2006531059741974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swapping (flip items with high potential)\n    for _ in range(3):  # Number of swaps\n        # Calculate potential of each item (weighted by both objectives)\n        potential = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        potential[base_solution == 0] *= -1  # Prefer flipping out low-potential items\n\n        # Select item with highest potential\n        item_to_flip = np.argmax(potential)\n\n        # Flip the item if it maintains feasibility\n        if base_solution[item_to_flip] == 1:\n            if current_weight - weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 0\n                current_weight -= weight_lst[item_to_flip]\n        else:\n            if current_weight + weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 1\n                current_weight += weight_lst[item_to_flip]\n\n    # Step 2: Weighted objective-guided perturbation\n    # Calculate weights for objectives based on current solution's position\n    obj1_weight = 1.0 / (current_obj1 + 1e-6)\n    obj2_weight = 1.0 / (current_obj2 + 1e-6)\n\n    # Select items to flip based on weighted objectives\n    combined_value = (obj1_weight * value1_lst + obj2_weight * value2_lst)\n    combined_value[base_solution == 0] *= -1  # Prefer flipping out low-value items\n\n    # Flip top 2 items with highest weighted value\n    top_items = np.argsort(combined_value)[-2:]\n    for item in top_items:\n        if base_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (greedy selection)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions and pick one randomly\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        selected_idx = np.random.randint(0, len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a random subset of items with high marginal impact\n    num_items = len(weight_lst)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n\n    for idx in flip_indices:\n        # Calculate marginal impact of flipping this item\n        if new_solution[idx] == 1:\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            new_weight = np.sum(weight_lst * new_solution) + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3366582682432827,
            2.059339255094528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (greedy selection)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions and pick one randomly\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        selected_idx = np.random.randint(0, len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a random subset of items with high marginal impact\n    num_items = len(weight_lst)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n\n    for idx in flip_indices:\n        # Calculate marginal impact of flipping this item\n        if new_solution[idx] == 1:\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            new_weight = np.sum(weight_lst * new_solution) + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor by flipping a random subset of items (intelligent random selection)\n    n_items = len(selected_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)  # Flip up to 3 items\n    new_solution = selected_solution.copy()\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by checking total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, revert the flips until feasible\n        for idx in flip_indices:\n            new_solution[idx] = selected_solution[idx]\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight <= capacity:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.2930784516845145,
            6.128455311059952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor by flipping a random subset of items (intelligent random selection)\n    n_items = len(selected_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)  # Flip up to 3 items\n    new_solution = selected_solution.copy()\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by checking total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, revert the flips until feasible\n        for idx in flip_indices:\n            new_solution[idx] = selected_solution[idx]\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight <= capacity:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, dynamically balances exploration and exploitation by combining randomized item swaps and objective-aware perturbations, while ensuring feasibility through adaptive weight constraints and multi-objective gradient guidance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate potential improvement metrics (e.g., diversity, potential gain)\n        potentials = []\n        for sol, obj in archive:\n            current_weight = np.sum(weight_lst * sol)\n            potential_gain = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))\n            potentials.append((potential_gain / (current_weight + 1e-6), sol))\n\n        # Select the solution with highest potential (weighted by remaining capacity)\n        potentials.sort(reverse=True, key=lambda x: x[0])\n        selected_sol = potentials[0][1]\n    else:\n        selected_sol = archive[0][0]\n\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search operator:\n    # 1. Randomized item swap with objective-aware selection\n    # 2. Dynamic perturbation based on objective gradients\n    # 3. Feasibility-preserving adjustments\n\n    # Step 1: Identify items to potentially swap\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # Select items with high value-to-weight ratio for potential removal\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        swap_candidates = np.argsort(-item_ratios)[::-1][:min(3, len(item_ratios))]\n        swap_candidates = [i for i in swap_candidates if i in candidate_indices]\n\n        # Perform the swap if feasible\n        if len(swap_candidates) > 0:\n            swap_item = np.random.choice(swap_candidates)\n            new_solution[swap_item] = 0\n\n    # Step 2: Add items that improve both objectives\n    available_indices = np.where(new_solution == 0)[0]\n    if len(available_indices) > 0:\n        # Calculate potential improvements for each available item\n        improvements = []\n        for i in available_indices:\n            if weight_lst[i] <= remaining_capacity:\n                improvement = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                improvements.append((improvement, i))\n\n        if improvements:\n            improvements.sort(reverse=True, key=lambda x: x[0])\n            best_add = improvements[0][1]\n            new_solution[best_add] = 1\n\n    # Step 3: Ensure feasibility through minor adjustments\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess = current_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            # Remove items with lowest value-to-weight ratio\n            item_ratios = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) > 0:\n                worst_item = np.argmin(item_ratios[remove_candidates])\n                worst_idx = remove_candidates[worst_item]\n                new_solution[worst_idx] = 0\n                excess -= weight_lst[worst_idx]\n            else:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9680618586323704,
            8.050227582454681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate potential improvement metrics (e.g., diversity, potential gain)\n        potentials = []\n        for sol, obj in archive:\n            current_weight = np.sum(weight_lst * sol)\n            potential_gain = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))\n            potentials.append((potential_gain / (current_weight + 1e-6), sol))\n\n        # Select the solution with highest potential (weighted by remaining capacity)\n        potentials.sort(reverse=True, key=lambda x: x[0])\n        selected_sol = potentials[0][1]\n    else:\n        selected_sol = archive[0][0]\n\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search operator:\n    # 1. Randomized item swap with objective-aware selection\n    # 2. Dynamic perturbation based on objective gradients\n    # 3. Feasibility-preserving adjustments\n\n    # Step 1: Identify items to potentially swap\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # Select items with high value-to-weight ratio for potential removal\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        swap_candidates = np.argsort(-item_ratios)[::-1][:min(3, len(item_ratios))]\n        swap_candidates = [i for i in swap_candidates if i in candidate_indices]\n\n        # Perform the swap if feasible\n        if len(swap_candidates) > 0:\n            swap_item = np.random.choice(swap_candidates)\n            new_solution[swap_item] = 0\n\n    # Step 2: Add items that improve both objectives\n    available_indices = np.where(new_solution == 0)[0]\n    if len(available_indices) > 0:\n        # Calculate potential improvements for each available item\n        improvements = []\n        for i in available_indices:\n            if weight_lst[i] <= remaining_capacity:\n                improvement = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                improvements.append((improvement, i))\n\n        if improvements:\n            improvements.sort(reverse=True, key=lambda x: x[0])\n            best_add = improvements[0][1]\n            new_solution[best_add] = 1\n\n    # Step 3: Ensure feasibility through minor adjustments\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess = current_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            # Remove items with lowest value-to-weight ratio\n            item_ratios = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) > 0:\n                worst_item = np.argmin(item_ratios[remove_candidates])\n                worst_idx = remove_candidates[worst_item]\n                new_solution[worst_idx] = 0\n                excess -= weight_lst[worst_idx]\n            else:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (added or removed)\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # Randomly select an item to remove\n        remove_idx = np.random.choice(candidate_indices)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    # Add items that can fit without exceeding capacity\n    available_indices = np.where(new_solution == 0)[0]\n    np.random.shuffle(available_indices)\n    for idx in available_indices:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Flip a random item to introduce diversity\n    if len(new_solution) > 0:\n        flip_idx = np.random.randint(0, len(new_solution))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.37499333678436875,
            4.625473290681839
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (added or removed)\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # Randomly select an item to remove\n        remove_idx = np.random.choice(candidate_indices)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    # Add items that can fit without exceeding capacity\n    available_indices = np.where(new_solution == 0)[0]\n    np.random.shuffle(available_indices)\n    for idx in available_indices:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Flip a random item to introduce diversity\n    if len(new_solution) > 0:\n        flip_idx = np.random.randint(0, len(new_solution))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive based on its potential for improvement, then applies a novel combination of item swaps and value-weighted perturbations to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid approach: item swaps + value-weighted perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        swap_idx = random.choice(candidate_indices)\n        new_solution[swap_idx] = 0  # Remove the selected item\n\n        # Find items not in the solution that can be added without exceeding capacity\n        available_indices = np.where(base_solution == 0)[0]\n        feasible_indices = []\n        for idx in available_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                feasible_indices.append(idx)\n\n        if feasible_indices:\n            # Select an item to add based on a combination of value and weight efficiency\n            efficiencies = []\n            for idx in feasible_indices:\n                # Hybrid efficiency score: weighted sum of normalized value and inverse weight\n                value_score = (value1_lst[idx] + value2_lst[idx]) / (weight_lst[idx] + 1e-6)\n                weight_score = capacity / (weight_lst[idx] + 1e-6)\n                efficiencies.append(0.7 * value_score + 0.3 * weight_score)\n\n            selected_idx = feasible_indices[np.argmax(efficiencies)]\n            new_solution[selected_idx] = 1\n\n    # Step 2: Apply value-weighted perturbations to further improve the solution\n    for _ in range(2):  # Apply 2 random perturbations\n        # Randomly select an item to flip (add or remove)\n        flip_idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[flip_idx] == 1:\n            # Remove the item\n            new_solution[flip_idx] = 0\n        else:\n            # Add the item if it doesn't exceed capacity\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9058473021407631,
            2.2296484410762787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid approach: item swaps + value-weighted perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        swap_idx = random.choice(candidate_indices)\n        new_solution[swap_idx] = 0  # Remove the selected item\n\n        # Find items not in the solution that can be added without exceeding capacity\n        available_indices = np.where(base_solution == 0)[0]\n        feasible_indices = []\n        for idx in available_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                feasible_indices.append(idx)\n\n        if feasible_indices:\n            # Select an item to add based on a combination of value and weight efficiency\n            efficiencies = []\n            for idx in feasible_indices:\n                # Hybrid efficiency score: weighted sum of normalized value and inverse weight\n                value_score = (value1_lst[idx] + value2_lst[idx]) / (weight_lst[idx] + 1e-6)\n                weight_score = capacity / (weight_lst[idx] + 1e-6)\n                efficiencies.append(0.7 * value_score + 0.3 * weight_score)\n\n            selected_idx = feasible_indices[np.argmax(efficiencies)]\n            new_solution[selected_idx] = 1\n\n    # Step 2: Apply value-weighted perturbations to further improve the solution\n    for _ in range(2):  # Apply 2 random perturbations\n        # Randomly select an item to flip (add or remove)\n        flip_idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[flip_idx] == 1:\n            # Remove the item\n            new_solution[flip_idx] = 0\n        else:\n            # Add the item if it doesn't exceed capacity\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of diversity and objective-space dominance, then applies a novel local search operator that combines item swaps and probabilistic flips to explore high-potential regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Hybrid selection: prefer solutions with high diversity and non-dominated potential\n    selected = random.choice(candidates)\n    new_solution = selected.copy()\n\n    # Novel local search operator: probabilistic item flips with value-based bias\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% probability to consider flipping\n            current_weight = np.sum(weight_lst * new_solution)\n            if new_solution[i] == 1:\n                # Consider removing item if it's not critical\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n            else:\n                # Consider adding item if it improves both objectives\n                if current_weight + weight_lst[i] <= capacity:\n                    if (value1_lst[i] > 0 or value2_lst[i] > 0):\n                        new_solution[i] = 1\n\n    # Additional swap-based local search\n    for _ in range(3):  # Limited iterations to balance exploration/exploitation\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = random.sample(list(items), 2)\n            # Swap items if it maintains feasibility\n            if (np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j] <= capacity and\n                np.sum(weight_lst * new_solution) - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4421818361543754,
            8.395532608032227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Hybrid selection: prefer solutions with high diversity and non-dominated potential\n    selected = random.choice(candidates)\n    new_solution = selected.copy()\n\n    # Novel local search operator: probabilistic item flips with value-based bias\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% probability to consider flipping\n            current_weight = np.sum(weight_lst * new_solution)\n            if new_solution[i] == 1:\n                # Consider removing item if it's not critical\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n            else:\n                # Consider adding item if it improves both objectives\n                if current_weight + weight_lst[i] <= capacity:\n                    if (value1_lst[i] > 0 or value2_lst[i] > 0):\n                        new_solution[i] = 1\n\n    # Additional swap-based local search\n    for _ in range(3):  # Limited iterations to balance exploration/exploitation\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = random.sample(list(items), 2)\n            # Swap items if it maintains feasibility\n            if (np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j] <= capacity and\n                np.sum(weight_lst * new_solution) - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines adaptive item swaps and probabilistic flips to explore the neighborhood while ensuring feasibility, balancing exploration of both objective spaces through a novel objective-aware selection criterion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    base_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Adaptive item swaps\n    for _ in range(min(3, n_items)):\n        i = random.randint(0, n_items - 1)\n        j = random.randint(0, n_items - 1)\n        if i == j:\n            continue\n\n        # Calculate new weight if we swap items i and j\n        delta_weight = (weight_lst[j] - weight_lst[i]) * (base_solution[j] - base_solution[i])\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    # Phase 2: Probabilistic flips based on objective potential\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to flip each item\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Phase 3: Objective-aware selection\n    # Calculate potential improvement in both objectives\n    potential_val1 = np.sum(value1_lst * new_solution)\n    potential_val2 = np.sum(value2_lst * new_solution)\n\n    # If no improvement, try to find a better solution in the neighborhood\n    if potential_val1 <= current_val1 and potential_val2 <= current_val2:\n        for _ in range(5):\n            temp_solution = new_solution.copy()\n            i = random.randint(0, n_items - 1)\n            if temp_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    temp_solution[i] = 0\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    temp_solution[i] = 1\n\n            temp_val1 = np.sum(value1_lst * temp_solution)\n            temp_val2 = np.sum(value2_lst * temp_solution)\n\n            if (temp_val1 > potential_val1 and temp_val2 >= potential_val2) or (temp_val1 >= potential_val1 and temp_val2 > potential_val2):\n                new_solution = temp_solution\n                potential_val1, potential_val2 = temp_val1, temp_val2\n\n    return new_solution\n\n",
        "score": [
            -0.38858894336565475,
            3.7443986237049103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    base_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Adaptive item swaps\n    for _ in range(min(3, n_items)):\n        i = random.randint(0, n_items - 1)\n        j = random.randint(0, n_items - 1)\n        if i == j:\n            continue\n\n        # Calculate new weight if we swap items i and j\n        delta_weight = (weight_lst[j] - weight_lst[i]) * (base_solution[j] - base_solution[i])\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    # Phase 2: Probabilistic flips based on objective potential\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to flip each item\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Phase 3: Objective-aware selection\n    # Calculate potential improvement in both objectives\n    potential_val1 = np.sum(value1_lst * new_solution)\n    potential_val2 = np.sum(value2_lst * new_solution)\n\n    # If no improvement, try to find a better solution in the neighborhood\n    if potential_val1 <= current_val1 and potential_val2 <= current_val2:\n        for _ in range(5):\n            temp_solution = new_solution.copy()\n            i = random.randint(0, n_items - 1)\n            if temp_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    temp_solution[i] = 0\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    temp_solution[i] = 1\n\n            temp_val1 = np.sum(value1_lst * temp_solution)\n            temp_val2 = np.sum(value2_lst * temp_solution)\n\n            if (temp_val1 > potential_val1 and temp_val2 >= potential_val2) or (temp_val1 >= potential_val1 and temp_val2 > potential_val2):\n                new_solution = temp_solution\n                potential_val1, potential_val2 = temp_val1, temp_val2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid local search strategy that combines adaptive neighborhood exploration, guided by both objectives, with probabilistic item swaps to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Identify items to potentially swap (adaptive neighborhood)\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Step 2: Probabilistic item swaps to escape local optima\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Select a random item to remove and a random item to add\n        remove_idx = random.choice(items_in)\n        add_idx = random.choice(items_out)\n\n        # Check feasibility before swapping\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n        if new_weight <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Step 3: Guided local search based on objective dominance\n    # If the solution is dominated, perform a more aggressive swap\n    for sol, (v1, v2) in archive:\n        if v1 > current_value1 and v2 > current_value2:\n            # The selected solution is dominated, perform a more aggressive swap\n            if len(items_in) > 0 and len(items_out) > 0:\n                remove_idx = random.choice(items_in)\n                add_idx = random.choice(items_out)\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n                if new_weight <= capacity:\n                    new_solution[remove_idx] = 0\n                    new_solution[add_idx] = 1\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.46209915627855125,
            2.586465448141098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Identify items to potentially swap (adaptive neighborhood)\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Step 2: Probabilistic item swaps to escape local optima\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Select a random item to remove and a random item to add\n        remove_idx = random.choice(items_in)\n        add_idx = random.choice(items_out)\n\n        # Check feasibility before swapping\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n        if new_weight <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Step 3: Guided local search based on objective dominance\n    # If the solution is dominated, perform a more aggressive swap\n    for sol, (v1, v2) in archive:\n        if v1 > current_value1 and v2 > current_value2:\n            # The selected solution is dominated, perform a more aggressive swap\n            if len(items_in) > 0 and len(items_out) > 0:\n                remove_idx = random.choice(items_in)\n                add_idx = random.choice(items_out)\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n                if new_weight <= capacity:\n                    new_solution[remove_idx] = 0\n                    new_solution[add_idx] = 1\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{A novel hybrid local search algorithm is proposed: it first intelligently selects a solution from the archive by prioritizing those with high potential improvement (e.g., solutions near the Pareto front or with high diversity), then applies a dynamic swap-based local search that adaptively adjusts the number of swaps based on the solution's proximity to the Pareto front, ensuring feasibility and maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., random but prioritize high diversity or near Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Dynamic swap-based local search\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    max_swaps = min(3, num_items // 2)  # Adaptive swap limit\n\n    for _ in range(max_swaps):\n        # Find candidates for swap (items to remove and add)\n        remove_candidates = np.where(new_solution == 1)[0]\n        add_candidates = np.where(new_solution == 0)[0]\n\n        if len(remove_candidates) == 0 or len(add_candidates) == 0:\n            break\n\n        # Randomly select items to swap\n        remove_item = np.random.choice(remove_candidates)\n        add_item = np.random.choice(add_candidates)\n\n        # Check feasibility of swap\n        delta_weight = weight_lst[add_item] - weight_lst[remove_item]\n        if current_weight + delta_weight <= capacity:\n            new_solution[remove_item] = 0\n            new_solution[add_item] = 1\n            current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.5374900140483777,
            2.8153666853904724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., random but prioritize high diversity or near Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Dynamic swap-based local search\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    max_swaps = min(3, num_items // 2)  # Adaptive swap limit\n\n    for _ in range(max_swaps):\n        # Find candidates for swap (items to remove and add)\n        remove_candidates = np.where(new_solution == 1)[0]\n        add_candidates = np.where(new_solution == 0)[0]\n\n        if len(remove_candidates) == 0 or len(add_candidates) == 0:\n            break\n\n        # Randomly select items to swap\n        remove_item = np.random.choice(remove_candidates)\n        add_item = np.random.choice(add_candidates)\n\n        # Check feasibility of swap\n        delta_weight = weight_lst[add_item] - weight_lst[remove_item]\n        if current_weight + delta_weight <= capacity:\n            new_solution[remove_item] = 0\n            new_solution[add_item] = 1\n            current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, then applies a creative neighborhood exploration by dynamically adjusting item inclusions/exclusions based on both objective values and weights, ensuring feasibility while promoting high-quality trade-offs between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution based on a heuristic\n    selected_idx = np.argmax([(v1 + v2) / (1 + np.sum(sol * weight_lst)) for sol, (v1, v2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize the new solution\n    new_solution = base_solution.copy()\n\n    # Dynamically adjust items based on both objectives and weights\n    for _ in range(2):  # Perform multiple adjustments\n        # Calculate the utility of each item for both objectives\n        utility1 = value1_lst / (weight_lst + 1e-6)\n        utility2 = value2_lst / (weight_lst + 1e-6)\n\n        # Combine utilities to prioritize items that improve both objectives\n        combined_utility = utility1 + utility2\n\n        # Randomly select items to potentially flip based on utility\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            # Select the most promising candidate\n            best_candidate = candidates[np.argmax(combined_utility[candidates])]\n\n            # Flip the selected item if feasible\n            if np.sum(new_solution * weight_lst) + weight_lst[best_candidate] <= capacity:\n                new_solution[best_candidate] = 1\n\n        # Randomly select items to potentially remove based on utility\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            # Select the least promising candidate\n            worst_candidate = candidates[np.argmin(combined_utility[candidates])]\n\n            # Flip the selected item\n            new_solution[worst_candidate] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.38408011382969726,
            1.9169714152812958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution based on a heuristic\n    selected_idx = np.argmax([(v1 + v2) / (1 + np.sum(sol * weight_lst)) for sol, (v1, v2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize the new solution\n    new_solution = base_solution.copy()\n\n    # Dynamically adjust items based on both objectives and weights\n    for _ in range(2):  # Perform multiple adjustments\n        # Calculate the utility of each item for both objectives\n        utility1 = value1_lst / (weight_lst + 1e-6)\n        utility2 = value2_lst / (weight_lst + 1e-6)\n\n        # Combine utilities to prioritize items that improve both objectives\n        combined_utility = utility1 + utility2\n\n        # Randomly select items to potentially flip based on utility\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            # Select the most promising candidate\n            best_candidate = candidates[np.argmax(combined_utility[candidates])]\n\n            # Flip the selected item if feasible\n            if np.sum(new_solution * weight_lst) + weight_lst[best_candidate] <= capacity:\n                new_solution[best_candidate] = 1\n\n        # Randomly select items to potentially remove based on utility\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            # Select the least promising candidate\n            worst_candidate = candidates[np.argmin(combined_utility[candidates])]\n\n            # Flip the selected item\n            new_solution[worst_candidate] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high marginal gains in either objective, then applies a hybrid local search combining item swaps, flips, and probabilistic perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high marginal potential\n    def marginal_gain(solution):\n        current_weight = np.sum(weight_lst * solution)\n        remaining_capacity = capacity - current_weight\n        # Calculate marginal gains for each item not in the solution\n        marginal1 = np.where(solution == 0, value1_lst, 0)\n        marginal2 = np.where(solution == 0, value2_lst, 0)\n        # Prioritize items with high marginal gain in either objective\n        total_gain = marginal1 + marginal2\n        return np.sum(total_gain)\n\n    # Sort solutions by marginal gain and select the top 30% with randomness\n    archive_sorted = sorted(archive, key=lambda x: marginal_gain(x[0]), reverse=True)\n    top_k = max(1, len(archive_sorted) // 3)\n    candidates = random.sample(archive_sorted[:top_k], min(3, top_k))\n    base_solution, _ = random.choice(candidates)\n\n    # Hybrid local search: item swaps, flips, and probabilistic perturbations\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly flip items with high marginal gain\n    marginal1 = np.where(new_solution == 0, value1_lst, 0)\n    marginal2 = np.where(new_solution == 0, value2_lst, 0)\n    total_gain = marginal1 + marginal2\n    candidates = np.argsort(total_gain)[-min(5, len(total_gain)):]\n\n    for idx in candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Step 2: Randomly swap items to diversify\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Step 3: Probabilistic perturbations to escape local optima\n    for idx in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            elif current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5609478239914835,
            7.0856433510780334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high marginal potential\n    def marginal_gain(solution):\n        current_weight = np.sum(weight_lst * solution)\n        remaining_capacity = capacity - current_weight\n        # Calculate marginal gains for each item not in the solution\n        marginal1 = np.where(solution == 0, value1_lst, 0)\n        marginal2 = np.where(solution == 0, value2_lst, 0)\n        # Prioritize items with high marginal gain in either objective\n        total_gain = marginal1 + marginal2\n        return np.sum(total_gain)\n\n    # Sort solutions by marginal gain and select the top 30% with randomness\n    archive_sorted = sorted(archive, key=lambda x: marginal_gain(x[0]), reverse=True)\n    top_k = max(1, len(archive_sorted) // 3)\n    candidates = random.sample(archive_sorted[:top_k], min(3, top_k))\n    base_solution, _ = random.choice(candidates)\n\n    # Hybrid local search: item swaps, flips, and probabilistic perturbations\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly flip items with high marginal gain\n    marginal1 = np.where(new_solution == 0, value1_lst, 0)\n    marginal2 = np.where(new_solution == 0, value2_lst, 0)\n    total_gain = marginal1 + marginal2\n    candidates = np.argsort(total_gain)[-min(5, len(total_gain)):]\n\n    for idx in candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Step 2: Randomly swap items to diversify\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Step 3: Probabilistic perturbations to escape local optima\n    for idx in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            elif current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))  # Select solution with highest average inclusion\n    new_solution = base_solution.copy()\n\n    # Find items that can be flipped to improve either objective\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    flip_candidates = []\n\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if total_weight - weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n        else:\n            # Check if adding the item keeps the solution feasible\n            if total_weight + weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        # If no candidates, perform a random flip among feasible items\n        feasible_indices = [i for i in range(len(new_solution)) if (new_solution[i] == 0 and total_weight + weight_lst[i] <= capacity) or\n                           (new_solution[i] == 1 and total_weight - weight_lst[i] <= capacity)]\n        if feasible_indices:\n            i = np.random.choice(feasible_indices)\n            new_solution[i] = 1 - new_solution[i]\n    else:\n        # Select the item that offers the best marginal improvement in either objective\n        best_item = None\n        best_improvement = -1\n\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                # Potential improvement from removing item\n                improvement = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            else:\n                # Potential improvement from adding item\n                improvement = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_item = i\n\n        if best_item is not None:\n            new_solution[best_item] = 1 - new_solution[best_item]\n\n    return new_solution\n\n",
        "score": [
            -0.8622511981861299,
            4.021444231271744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))  # Select solution with highest average inclusion\n    new_solution = base_solution.copy()\n\n    # Find items that can be flipped to improve either objective\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    flip_candidates = []\n\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if total_weight - weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n        else:\n            # Check if adding the item keeps the solution feasible\n            if total_weight + weight_lst[i] <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        # If no candidates, perform a random flip among feasible items\n        feasible_indices = [i for i in range(len(new_solution)) if (new_solution[i] == 0 and total_weight + weight_lst[i] <= capacity) or\n                           (new_solution[i] == 1 and total_weight - weight_lst[i] <= capacity)]\n        if feasible_indices:\n            i = np.random.choice(feasible_indices)\n            new_solution[i] = 1 - new_solution[i]\n    else:\n        # Select the item that offers the best marginal improvement in either objective\n        best_item = None\n        best_improvement = -1\n\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                # Potential improvement from removing item\n                improvement = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            else:\n                # Potential improvement from adding item\n                improvement = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_item = i\n\n        if best_item is not None:\n            new_solution[best_item] = 1 - new_solution[best_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Identify items that could be swapped or flipped\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Randomly decide between swapping or flipping\n    if random.random() < 0.5 and len(included_items) > 0 and len(excluded_items) > 0:\n        # Swap one included item with one excluded item\n        swap_in = random.choice(included_items)\n        swap_out = random.choice(excluded_items)\n        if current_weight - weight_lst[swap_in] + weight_lst[swap_out] <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n    else:\n        # Flip a random included item to excluded or vice versa\n        if random.random() < 0.5 and len(included_items) > 0:\n            flip_index = random.choice(included_items)\n            if current_weight - weight_lst[flip_index] <= capacity:\n                new_solution[flip_index] = 0\n        else:\n            flip_index = random.choice(excluded_items)\n            if current_weight + weight_lst[flip_index] <= capacity:\n                new_solution[flip_index] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.37436568804639875,
            3.0019499361515045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Identify items that could be swapped or flipped\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Randomly decide between swapping or flipping\n    if random.random() < 0.5 and len(included_items) > 0 and len(excluded_items) > 0:\n        # Swap one included item with one excluded item\n        swap_in = random.choice(included_items)\n        swap_out = random.choice(excluded_items)\n        if current_weight - weight_lst[swap_in] + weight_lst[swap_out] <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n    else:\n        # Flip a random included item to excluded or vice versa\n        if random.random() < 0.5 and len(included_items) > 0:\n            flip_index = random.choice(included_items)\n            if current_weight - weight_lst[flip_index] <= capacity:\n                new_solution[flip_index] = 0\n        else:\n            flip_index = random.choice(excluded_items)\n            if current_weight + weight_lst[flip_index] <= capacity:\n                new_solution[flip_index] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping and value-aware perturbation, prioritizing high-potential solutions for exploration while ensuring feasibility through dynamic weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[np.sum(sol[0]) for sol in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive item swapping and value-aware perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swapping (prioritize high-value items)\n    for _ in range(min(3, np.sum(base_solution))):  # Limit swaps to avoid excessive changes\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) < 2:\n            break\n        i, j = random.sample(list(candidates), 2)\n        if (current_weight - weight_lst[i] + weight_lst[j] <= capacity and\n            (value1_lst[i] < value1_lst[j] or value2_lst[i] < value2_lst[j])):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Value-aware perturbation (add/remove items based on value ratios)\n    for _ in range(2):  # Limit perturbations\n        if random.random() < 0.5:  # Add item\n            excluded = np.where(base_solution == 0)[0]\n            if len(excluded) == 0:\n                break\n            candidate = random.choice(excluded)\n            if current_weight + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n                current_weight += weight_lst[candidate]\n        else:  # Remove item\n            included = np.where(base_solution == 1)[0]\n            if len(included) == 0:\n                break\n            candidate = random.choice(included)\n            new_solution[candidate] = 0\n            current_weight -= weight_lst[candidate]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        included = np.where(new_solution == 1)[0]\n        if len(included) == 0:\n            break\n        candidate = random.choice(included)\n        new_solution[candidate] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4394119894650564,
            4.076345860958099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[np.sum(sol[0]) for sol in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive item swapping and value-aware perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swapping (prioritize high-value items)\n    for _ in range(min(3, np.sum(base_solution))):  # Limit swaps to avoid excessive changes\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) < 2:\n            break\n        i, j = random.sample(list(candidates), 2)\n        if (current_weight - weight_lst[i] + weight_lst[j] <= capacity and\n            (value1_lst[i] < value1_lst[j] or value2_lst[i] < value2_lst[j])):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Value-aware perturbation (add/remove items based on value ratios)\n    for _ in range(2):  # Limit perturbations\n        if random.random() < 0.5:  # Add item\n            excluded = np.where(base_solution == 0)[0]\n            if len(excluded) == 0:\n                break\n            candidate = random.choice(excluded)\n            if current_weight + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n                current_weight += weight_lst[candidate]\n        else:  # Remove item\n            included = np.where(base_solution == 1)[0]\n            if len(included) == 0:\n                break\n            candidate = random.choice(included)\n            new_solution[candidate] = 0\n            current_weight -= weight_lst[candidate]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        included = np.where(new_solution == 1)[0]\n        if len(included) == 0:\n            break\n        candidate = random.choice(included)\n        new_solution[candidate] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_solutions = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append((sol, obj))\n\n    if not potential_solutions:\n        return archive[0][0].copy()\n\n    # Intelligent random selection based on objective diversity\n    selected_sol, selected_obj = random.choice(potential_solutions)\n\n    # Hybrid local search: Combine value-based swaps with diversity exploration\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Value-based swaps for both objectives\n    for _ in range(min(3, n_items)):\n        # Swap items with high marginal value for both objectives\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n        combined_value = marginal_value1 + marginal_value2\n\n        # Select items to swap\n        candidates = np.argsort(combined_value)[::-1]\n        for i in candidates:\n            if new_solution[i] == 0:\n                # Try to add this item\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n            else:\n                # Try to remove this item\n                new_solution[i] = 0\n                break\n\n    # Step 2: Diversity exploration - flip random bits with probability\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 0:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n            else:\n                new_solution[i] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove heaviest item\n        heaviest_items = np.argsort(weight_lst * new_solution)[::-1]\n        for i in heaviest_items:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.46097695640440706,
            3.5654744803905487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_solutions = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            potential_solutions.append((sol, obj))\n\n    if not potential_solutions:\n        return archive[0][0].copy()\n\n    # Intelligent random selection based on objective diversity\n    selected_sol, selected_obj = random.choice(potential_solutions)\n\n    # Hybrid local search: Combine value-based swaps with diversity exploration\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Value-based swaps for both objectives\n    for _ in range(min(3, n_items)):\n        # Swap items with high marginal value for both objectives\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n        combined_value = marginal_value1 + marginal_value2\n\n        # Select items to swap\n        candidates = np.argsort(combined_value)[::-1]\n        for i in candidates:\n            if new_solution[i] == 0:\n                # Try to add this item\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n            else:\n                # Try to remove this item\n                new_solution[i] = 0\n                break\n\n    # Step 2: Diversity exploration - flip random bits with probability\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 0:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n            else:\n                new_solution[i] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove heaviest item\n        heaviest_items = np.argsort(weight_lst * new_solution)[::-1]\n        for i in heaviest_items:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: flip a subset of items based on value-to-weight ratio and objective dominance\n    new_solution = base_solution.copy()\n    item_indices = np.where(base_solution == 1)[0]\n\n    # Calculate value-to-weight ratios for included items\n    included_weights = weight_lst[item_indices]\n    included_value1 = value1_lst[item_indices]\n    included_value2 = value2_lst[item_indices]\n    v1_ratio = included_value1 / included_weights\n    v2_ratio = included_value2 / included_weights\n\n    # Select items to flip based on combined dominance and value-to-weight ratios\n    flip_candidates = np.argsort(-(v1_ratio + v2_ratio))[:max(1, len(item_indices) // 3)]\n    flip_indices = item_indices[flip_candidates]\n\n    # Flip selected items and ensure feasibility\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7967004361429652,
            2.4585374891757965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: flip a subset of items based on value-to-weight ratio and objective dominance\n    new_solution = base_solution.copy()\n    item_indices = np.where(base_solution == 1)[0]\n\n    # Calculate value-to-weight ratios for included items\n    included_weights = weight_lst[item_indices]\n    included_value1 = value1_lst[item_indices]\n    included_value2 = value2_lst[item_indices]\n    v1_ratio = included_value1 / included_weights\n    v2_ratio = included_value2 / included_weights\n\n    # Select items to flip based on combined dominance and value-to-weight ratios\n    flip_candidates = np.argsort(-(v1_ratio + v2_ratio))[:max(1, len(item_indices) // 3)]\n    flip_indices = item_indices[flip_candidates]\n\n    # Flip selected items and ensure feasibility\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{The heuristic function intelligently selects a solution from the archive by prioritizing those with the highest combined normalized objective scores, then applies a hybrid local search that combines random swaps with a greedy selection of items based on their marginal contributions to both objectives, ensuring feasibility through weight checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution from the archive\n    # Normalize objectives and select solution with highest combined score\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    num_items = len(weight_lst)\n    candidates = np.random.permutation(num_items)[:max(1, num_items // 3)]\n    shuffled_candidates = np.random.permutation(candidates)\n\n    for idx in shuffled_candidates:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Greedily select items with high marginal contribution\n                marginal_v1 = value1_lst[idx]\n                marginal_v2 = value2_lst[idx]\n                if marginal_v1 + marginal_v2 > 0:  # Only consider positive contributions\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.47303416458081904,
            2.3148715794086456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution from the archive\n    # Normalize objectives and select solution with highest combined score\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    num_items = len(weight_lst)\n    candidates = np.random.permutation(num_items)[:max(1, num_items // 3)]\n    shuffled_candidates = np.random.permutation(candidates)\n\n    for idx in shuffled_candidates:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Greedily select items with high marginal contribution\n                marginal_v1 = value1_lst[idx]\n                marginal_v2 = value2_lst[idx]\n                if marginal_v1 + marginal_v2 > 0:  # Only consider positive contributions\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not dominated by many others)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: flip a subset of items based on marginal utility\n    # Calculate marginal utility for each item (value1 + value2 / weight)\n    marginal_utility = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # Identify items to flip: those with highest marginal utility not currently in the solution\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) == 0:\n        return new_solution\n\n    # Sort candidates by marginal utility in descending order\n    sorted_candidates = sorted(candidate_items, key=lambda x: -marginal_utility[x])\n\n    # Flip top k items (k = min(3, len(sorted_candidates))) if feasible\n    k = min(3, len(sorted_candidates))\n    for i in range(k):\n        item = sorted_candidates[i]\n        if weight_lst[item] <= capacity - np.sum(weight_lst * new_solution):\n            new_solution[item] = 1\n\n    # If no items were added, try removing low-utility items\n    if np.array_equal(new_solution, selected_solution):\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            sorted_candidates = sorted(candidate_items, key=lambda x: marginal_utility[x])\n            for item in sorted_candidates:\n                new_solution[item] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7592703416830038,
            3.599747657775879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not dominated by many others)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: flip a subset of items based on marginal utility\n    # Calculate marginal utility for each item (value1 + value2 / weight)\n    marginal_utility = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # Identify items to flip: those with highest marginal utility not currently in the solution\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) == 0:\n        return new_solution\n\n    # Sort candidates by marginal utility in descending order\n    sorted_candidates = sorted(candidate_items, key=lambda x: -marginal_utility[x])\n\n    # Flip top k items (k = min(3, len(sorted_candidates))) if feasible\n    k = min(3, len(sorted_candidates))\n    for i in range(k):\n        item = sorted_candidates[i]\n        if weight_lst[item] <= capacity - np.sum(weight_lst * new_solution):\n            new_solution[item] = 1\n\n    # If no items were added, try removing low-utility items\n    if np.array_equal(new_solution, selected_solution):\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            sorted_candidates = sorted(candidate_items, key=lambda x: marginal_utility[x])\n            for item in sorted_candidates:\n                new_solution[item] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of values (promising candidates)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select from top 30% of solutions\n        selected_idx = np.random.randint(0, max(1, int(0.3 * len(archive_sorted))))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swap and flip operations\n    # Step 1: Randomly select a subset of items to flip\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Check feasibility and repair if needed\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with lowest marginal value contribution until feasible\n        while total_weight > capacity:\n            # Calculate marginal value contributions for included items\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            marginal_values = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            worst_item = included_items[np.argmin(marginal_values)]\n            new_solution[worst_item] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 3: Apply a swap operation between two random items if feasible\n    if len(np.where(new_solution == 1)[0]) >= 2:\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], size=2, replace=False)\n        # Check if swapping reduces weight or improves value\n        if np.sum(weight_lst[swap_indices]) <= capacity:\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.3033930907705973,
            3.7755336463451385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of values (promising candidates)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select from top 30% of solutions\n        selected_idx = np.random.randint(0, max(1, int(0.3 * len(archive_sorted))))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swap and flip operations\n    # Step 1: Randomly select a subset of items to flip\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Check feasibility and repair if needed\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with lowest marginal value contribution until feasible\n        while total_weight > capacity:\n            # Calculate marginal value contributions for included items\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            marginal_values = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            worst_item = included_items[np.argmin(marginal_values)]\n            new_solution[worst_item] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 3: Apply a swap operation between two random items if feasible\n    if len(np.where(new_solution == 1)[0]) >= 2:\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], size=2, replace=False)\n        # Check if swapping reduces weight or improves value\n        if np.sum(weight_lst[swap_indices]) <= capacity:\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_archive = []\n    max_val1 = max(obj[0] for _, obj in archive)\n    max_val2 = max(obj[1] for _, obj in archive)\n    for sol, obj in archive:\n        norm_val1 = obj[0] / max_val1 if max_val1 > 0 else 0\n        norm_val2 = obj[1] / max_val2 if max_val2 > 0 else 0\n        normalized_archive.append((sol, obj, norm_val1 + norm_val2))\n\n    # Sort by normalized sum in descending order\n    normalized_archive.sort(key=lambda x: -x[2])\n    selected_sol = normalized_archive[0][0]\n\n    # Generate neighbor using a hybrid approach: flip a random item with high marginal utility\n    new_solution = selected_sol.copy()\n    current_weight = np.sum(weight_lst[selected_sol == 1])\n    current_val1 = np.sum(value1_lst[selected_sol == 1])\n    current_val2 = np.sum(value2_lst[selected_sol == 1])\n\n    # Calculate marginal utility for each item\n    marginal_utils = []\n    for i in range(len(selected_sol)):\n        if selected_sol[i] == 1:\n            # Utility of removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                marginal_utils.append((i, value1_lst[i] + value2_lst[i], -1))  # -1 for removal\n        else:\n            # Utility of adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                marginal_utils.append((i, value1_lst[i] + value2_lst[i], 1))  # 1 for addition\n\n    if not marginal_utils:\n        return selected_sol\n\n    # Select top 5 items with highest marginal utility\n    marginal_utils.sort(key=lambda x: -x[1])\n    top_items = marginal_utils[:min(5, len(marginal_utils))]\n\n    # Randomly select one of the top items to flip\n    selected_item = random.choice(top_items)\n    new_solution[selected_item[0]] = 1 if selected_item[2] == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8289542308561368,
            2.9795671105384827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_archive = []\n    max_val1 = max(obj[0] for _, obj in archive)\n    max_val2 = max(obj[1] for _, obj in archive)\n    for sol, obj in archive:\n        norm_val1 = obj[0] / max_val1 if max_val1 > 0 else 0\n        norm_val2 = obj[1] / max_val2 if max_val2 > 0 else 0\n        normalized_archive.append((sol, obj, norm_val1 + norm_val2))\n\n    # Sort by normalized sum in descending order\n    normalized_archive.sort(key=lambda x: -x[2])\n    selected_sol = normalized_archive[0][0]\n\n    # Generate neighbor using a hybrid approach: flip a random item with high marginal utility\n    new_solution = selected_sol.copy()\n    current_weight = np.sum(weight_lst[selected_sol == 1])\n    current_val1 = np.sum(value1_lst[selected_sol == 1])\n    current_val2 = np.sum(value2_lst[selected_sol == 1])\n\n    # Calculate marginal utility for each item\n    marginal_utils = []\n    for i in range(len(selected_sol)):\n        if selected_sol[i] == 1:\n            # Utility of removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                marginal_utils.append((i, value1_lst[i] + value2_lst[i], -1))  # -1 for removal\n        else:\n            # Utility of adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                marginal_utils.append((i, value1_lst[i] + value2_lst[i], 1))  # 1 for addition\n\n    if not marginal_utils:\n        return selected_sol\n\n    # Select top 5 items with highest marginal utility\n    marginal_utils.sort(key=lambda x: -x[1])\n    top_items = marginal_utils[:min(5, len(marginal_utils))]\n\n    # Randomly select one of the top items to flip\n    selected_item = random.choice(top_items)\n    new_solution[selected_item[0]] = 1 if selected_item[2] == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{A novel hybrid local search strategy combines random walk with guided mutation, intelligently selecting items to flip based on their marginal contribution to both objectives, while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to consider for flipping\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Select items to flip based on marginal contribution and randomness\n    flip_candidates = np.random.choice(candidate_indices, size=min(3, len(candidate_indices)), replace=False)\n    new_solution = base_solution.copy()\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Apply guided mutation based on combined marginal contribution\n    guided_indices = np.argsort(combined_marginal)[-min(5, len(combined_marginal)):]\n    for idx in guided_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4595781878692783,
            3.1769520938396454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to consider for flipping\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Select items to flip based on marginal contribution and randomness\n    flip_candidates = np.random.choice(candidate_indices, size=min(3, len(candidate_indices)), replace=False)\n    new_solution = base_solution.copy()\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Apply guided mutation based on combined marginal contribution\n    guided_indices = np.argsort(combined_marginal)[-min(5, len(combined_marginal)):]\n    for idx in guided_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item flipping with a guided diversification mechanism to explore the solution space intelligently, ensuring feasibility and promoting Pareto front expansion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]))\n    base_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be flipped (either added or removed) while maintaining feasibility\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        # If no candidates, return the base solution as is\n        return base_solution\n\n    # Select a candidate with a bias towards items that offer the highest marginal gain\n    item, flip = max(candidate_items, key=lambda x: (value1_lst[x[0]] + value2_lst[x[0]]) if x[1] == 1 else -(value1_lst[x[0]] + value2_lst[x[0]]))\n\n    # Generate the new solution by flipping the selected item\n    new_solution = base_solution.copy()\n    new_solution[item] = 1 - new_solution[item]\n\n    # Apply additional diversification by flipping a random item if possible\n    if len(candidate_items) > 1 and random.random() < 0.3:\n        # Filter out the already selected item\n        remaining_candidates = [x for x in candidate_items if x[0] != item]\n        if remaining_candidates:\n            extra_item, extra_flip = random.choice(remaining_candidates)\n            new_solution[extra_item] = 1 - new_solution[extra_item]\n\n    return new_solution\n\n",
        "score": [
            -0.7636479287881218,
            4.395946174860001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]))\n    base_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be flipped (either added or removed) while maintaining feasibility\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        # If no candidates, return the base solution as is\n        return base_solution\n\n    # Select a candidate with a bias towards items that offer the highest marginal gain\n    item, flip = max(candidate_items, key=lambda x: (value1_lst[x[0]] + value2_lst[x[0]]) if x[1] == 1 else -(value1_lst[x[0]] + value2_lst[x[0]]))\n\n    # Generate the new solution by flipping the selected item\n    new_solution = base_solution.copy()\n    new_solution[item] = 1 - new_solution[item]\n\n    # Apply additional diversification by flipping a random item if possible\n    if len(candidate_items) > 1 and random.random() < 0.3:\n        # Filter out the already selected item\n        remaining_candidates = [x for x in candidate_items if x[0] != item]\n        if remaining_candidates:\n            extra_item, extra_flip = random.choice(remaining_candidates)\n            new_solution[extra_item] = 1 - new_solution[extra_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with probabilistic item flipping, guided by a dynamic trade-off between objective improvements, to intelligently explore the solution space while ensuring feasibility and diversification.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: adaptive item swapping and probabilistic flipping\n    for _ in range(10):  # Number of local search iterations\n        # Adaptive item swapping\n        if np.random.rand() < 0.7:  # Higher probability for swapping\n            # Select two items to swap\n            item1 = np.random.choice(np.where(new_solution == 1)[0])\n            item2 = np.random.choice(np.where(new_solution == 0)[0])\n\n            # Calculate new weight after swap\n            new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n\n            if new_weight <= capacity:\n                # Accept the swap\n                new_solution[item1] = 0\n                new_solution[item2] = 1\n                current_weight = new_weight\n\n        # Probabilistic item flipping\n        else:\n            # Select a random item to flip\n            item = np.random.randint(0, len(new_solution))\n\n            if new_solution[item] == 1:\n                # Try to remove the item\n                new_weight = current_weight - weight_lst[item]\n                if new_weight >= 0:  # Ensure non-negative weight\n                    new_solution[item] = 0\n                    current_weight = new_weight\n            else:\n                # Try to add the item\n                new_weight = current_weight + weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.40281190947879497,
            3.9860103130340576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: adaptive item swapping and probabilistic flipping\n    for _ in range(10):  # Number of local search iterations\n        # Adaptive item swapping\n        if np.random.rand() < 0.7:  # Higher probability for swapping\n            # Select two items to swap\n            item1 = np.random.choice(np.where(new_solution == 1)[0])\n            item2 = np.random.choice(np.where(new_solution == 0)[0])\n\n            # Calculate new weight after swap\n            new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n\n            if new_weight <= capacity:\n                # Accept the swap\n                new_solution[item1] = 0\n                new_solution[item2] = 1\n                current_weight = new_weight\n\n        # Probabilistic item flipping\n        else:\n            # Select a random item to flip\n            item = np.random.randint(0, len(new_solution))\n\n            if new_solution[item] == 1:\n                # Try to remove the item\n                new_weight = current_weight - weight_lst[item]\n                if new_weight >= 0:  # Ensure non-negative weight\n                    new_solution[item] = 0\n                    current_weight = new_weight\n            else:\n                # Try to add the item\n                new_weight = current_weight + weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines item swapping, flipping, and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility, and prioritizes solutions with higher potential for further improvement based on their objective values and diversity in the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def solution_potential(sol_obj):\n        sol, obj = sol_obj\n        # Potential based on objective values and diversity\n        return (obj[0] + obj[1]) * (1 + random.uniform(0, 0.1))  # Add small randomness for exploration\n\n    selected_sol, _ = max(archive, key=solution_potential)\n    base_solution = selected_sol.copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (with adaptive size)\n    flip_size = min(5, n_items)\n    flip_indices = np.random.choice(n_items, size=flip_size, replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            if np.sum(weight_lst[new_solution == 1] - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Step 2: Swap pairs of items (to explore different combinations)\n    swap_pairs = min(3, n_items // 2)\n    for _ in range(swap_pairs):\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Calculate net change in weight\n            net_change = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + net_change <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Add or remove a single high-value item if feasible\n    # Find items not in the solution\n    not_in_solution = np.where(new_solution == 0)[0]\n    in_solution = np.where(new_solution == 1)[0]\n\n    # Try to add a high-value item\n    if len(not_in_solution) > 0:\n        # Consider both objectives\n        combined_value = value1_lst + value2_lst\n        best_candidate = max(not_in_solution, key=lambda x: combined_value[x])\n        if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_candidate] <= capacity:\n            new_solution[best_candidate] = 1\n\n    # Try to remove a low-value item\n    if len(in_solution) > 0:\n        combined_value = value1_lst + value2_lst\n        worst_candidate = min(in_solution, key=lambda x: combined_value[x])\n        if np.sum(weight_lst[new_solution == 1] - weight_lst[worst_candidate]) <= capacity:\n            new_solution[worst_candidate] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.34815648947254635,
            4.1521788239479065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def solution_potential(sol_obj):\n        sol, obj = sol_obj\n        # Potential based on objective values and diversity\n        return (obj[0] + obj[1]) * (1 + random.uniform(0, 0.1))  # Add small randomness for exploration\n\n    selected_sol, _ = max(archive, key=solution_potential)\n    base_solution = selected_sol.copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (with adaptive size)\n    flip_size = min(5, n_items)\n    flip_indices = np.random.choice(n_items, size=flip_size, replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            if np.sum(weight_lst[new_solution == 1] - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Step 2: Swap pairs of items (to explore different combinations)\n    swap_pairs = min(3, n_items // 2)\n    for _ in range(swap_pairs):\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Calculate net change in weight\n            net_change = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + net_change <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Add or remove a single high-value item if feasible\n    # Find items not in the solution\n    not_in_solution = np.where(new_solution == 0)[0]\n    in_solution = np.where(new_solution == 1)[0]\n\n    # Try to add a high-value item\n    if len(not_in_solution) > 0:\n        # Consider both objectives\n        combined_value = value1_lst + value2_lst\n        best_candidate = max(not_in_solution, key=lambda x: combined_value[x])\n        if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_candidate] <= capacity:\n            new_solution[best_candidate] = 1\n\n    # Try to remove a low-value item\n    if len(in_solution) > 0:\n        combined_value = value1_lst + value2_lst\n        worst_candidate = min(in_solution, key=lambda x: combined_value[x])\n        if np.sum(weight_lst[new_solution == 1] - weight_lst[worst_candidate]) <= capacity:\n            new_solution[worst_candidate] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search strategy combining item swaps and adaptive flips to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and adaptive flips\n    n_items = len(base_solution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # First, try to swap two items (one in, one out)\n    candidates_in = np.where(base_solution == 0)[0]\n    candidates_out = np.where(base_solution == 1)[0]\n\n    if len(candidates_in) > 0 and len(candidates_out) > 0:\n        for _ in range(10):  # Try multiple random swaps\n            in_idx = random.choice(candidates_in)\n            out_idx = random.choice(candidates_out)\n            new_weight = current_weight - weight_lst[out_idx] + weight_lst[in_idx]\n\n            if new_weight <= capacity:\n                new_solution[out_idx] = 0\n                new_solution[in_idx] = 1\n                return new_solution\n\n    # If no swap worked, try adaptive flips (flip items with high marginal gain)\n    marginal_gain1 = value1_lst / weight_lst\n    marginal_gain2 = value2_lst / weight_lst\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort items by combined marginal gain\n    sorted_indices = np.argsort(combined_gain)[::-1]\n\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing this item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                return new_solution\n        else:\n            # Try adding this item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                return new_solution\n\n    # If no improvement possible, return base solution\n    return base_solution\n\n",
        "score": [
            -0.534101046879488,
            1.7716006338596344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and adaptive flips\n    n_items = len(base_solution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # First, try to swap two items (one in, one out)\n    candidates_in = np.where(base_solution == 0)[0]\n    candidates_out = np.where(base_solution == 1)[0]\n\n    if len(candidates_in) > 0 and len(candidates_out) > 0:\n        for _ in range(10):  # Try multiple random swaps\n            in_idx = random.choice(candidates_in)\n            out_idx = random.choice(candidates_out)\n            new_weight = current_weight - weight_lst[out_idx] + weight_lst[in_idx]\n\n            if new_weight <= capacity:\n                new_solution[out_idx] = 0\n                new_solution[in_idx] = 1\n                return new_solution\n\n    # If no swap worked, try adaptive flips (flip items with high marginal gain)\n    marginal_gain1 = value1_lst / weight_lst\n    marginal_gain2 = value2_lst / weight_lst\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort items by combined marginal gain\n    sorted_indices = np.argsort(combined_gain)[::-1]\n\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing this item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                return new_solution\n        else:\n            # Try adding this item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                return new_solution\n\n    # If no improvement possible, return base solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This heuristic selects a promising solution from the archive, identifies critical items based on their marginal contributions to both objectives, and applies a hybrid local search that combines item swaps and strategic flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution based on diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Identify critical items (high value/weight ratio for both objectives)\n    selected_items = np.where(base_solution == 1)[0]\n    non_selected_items = np.where(base_solution == 0)[0]\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n\n    # Step 3: Hybrid local search - swap critical items or flip based on marginals\n    if len(selected_items) > 0 and len(non_selected_items) > 0:\n        # Option 1: Swap a critical selected item with a non-critical non-selected item\n        critical_selected = selected_items[np.argsort(marginal1[selected_items] + marginal2[selected_items])[-1]]\n        non_critical_non_selected = non_selected_items[np.argsort(marginal1[non_selected_items] + marginal2[non_selected_items])[0]]\n\n        # Check feasibility of swap\n        if (weight_lst[critical_selected] + np.sum(weight_lst[non_selected_items]) - weight_lst[non_critical_non_selected]) <= capacity:\n            new_solution[critical_selected] = 0\n            new_solution[non_critical_non_selected] = 1\n        else:\n            # Option 2: Flip a non-critical selected item if swap is infeasible\n            non_critical_selected = selected_items[np.argsort(marginal1[selected_items] + marginal2[selected_items])[0]]\n            new_solution[non_critical_selected] = 0\n    else:\n        # If no items selected or all items selected, flip a random item\n        if len(selected_items) == 0:\n            candidate_items = non_selected_items\n        else:\n            candidate_items = selected_items\n\n        if len(candidate_items) > 0:\n            flip_idx = np.random.choice(candidate_items)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9148413901020988,
            1.751089334487915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution based on diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Identify critical items (high value/weight ratio for both objectives)\n    selected_items = np.where(base_solution == 1)[0]\n    non_selected_items = np.where(base_solution == 0)[0]\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n\n    # Step 3: Hybrid local search - swap critical items or flip based on marginals\n    if len(selected_items) > 0 and len(non_selected_items) > 0:\n        # Option 1: Swap a critical selected item with a non-critical non-selected item\n        critical_selected = selected_items[np.argsort(marginal1[selected_items] + marginal2[selected_items])[-1]]\n        non_critical_non_selected = non_selected_items[np.argsort(marginal1[non_selected_items] + marginal2[non_selected_items])[0]]\n\n        # Check feasibility of swap\n        if (weight_lst[critical_selected] + np.sum(weight_lst[non_selected_items]) - weight_lst[non_critical_non_selected]) <= capacity:\n            new_solution[critical_selected] = 0\n            new_solution[non_critical_non_selected] = 1\n        else:\n            # Option 2: Flip a non-critical selected item if swap is infeasible\n            non_critical_selected = selected_items[np.argsort(marginal1[selected_items] + marginal2[selected_items])[0]]\n            new_solution[non_critical_selected] = 0\n    else:\n        # If no items selected or all items selected, flip a random item\n        if len(selected_items) == 0:\n            candidate_items = non_selected_items\n        else:\n            candidate_items = selected_items\n\n        if len(candidate_items) > 0:\n            flip_idx = np.random.choice(candidate_items)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{The algorithm first identifies promising solutions in the archive by evaluating their potential for improvement through a hybrid local search strategy that combines item swaps, flips, and guided random walks, ensuring feasibility and maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with higher potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swap, flip, and guided random walk\n    for _ in range(3):  # Number of local search steps\n        # Item swap\n        if len(np.where(new_solution == 1)[0]) >= 2:\n            items_in = np.where(new_solution == 1)[0]\n            i, j = random.sample(list(items_in), 2)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            if np.sum(weight_lst[temp_solution == 1]) <= capacity:\n                new_solution = temp_solution\n\n        # Item flip\n        items_out = np.where(new_solution == 0)[0]\n        if len(items_out) > 0:\n            k = random.choice(items_out)\n            temp_solution = new_solution.copy()\n            temp_solution[k] = 1\n            if np.sum(weight_lst[temp_solution == 1]) <= capacity:\n                new_solution = temp_solution\n\n        # Guided random walk: add or remove items based on value density\n        value_density1 = value1_lst / weight_lst\n        value_density2 = value2_lst / weight_lst\n        combined_density = value_density1 + value_density2\n        sorted_indices = np.argsort(combined_density)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                if np.sum(weight_lst[temp_solution == 1]) <= capacity:\n                    new_solution = temp_solution\n                    break\n            else:\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                if np.sum(weight_lst[temp_solution == 1]) <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4393938951027325,
            3.063188999891281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with higher potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swap, flip, and guided random walk\n    for _ in range(3):  # Number of local search steps\n        # Item swap\n        if len(np.where(new_solution == 1)[0]) >= 2:\n            items_in = np.where(new_solution == 1)[0]\n            i, j = random.sample(list(items_in), 2)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            if np.sum(weight_lst[temp_solution == 1]) <= capacity:\n                new_solution = temp_solution\n\n        # Item flip\n        items_out = np.where(new_solution == 0)[0]\n        if len(items_out) > 0:\n            k = random.choice(items_out)\n            temp_solution = new_solution.copy()\n            temp_solution[k] = 1\n            if np.sum(weight_lst[temp_solution == 1]) <= capacity:\n                new_solution = temp_solution\n\n        # Guided random walk: add or remove items based on value density\n        value_density1 = value1_lst / weight_lst\n        value_density2 = value2_lst / weight_lst\n        combined_density = value_density1 + value_density2\n        sorted_indices = np.argsort(combined_density)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                if np.sum(weight_lst[temp_solution == 1]) <= capacity:\n                    new_solution = temp_solution\n                    break\n            else:\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                if np.sum(weight_lst[temp_solution == 1]) <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines item swaps, flips, and guided random walks to explore the solution space, ensuring feasibility and maximizing both objectives by dynamically balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Prioritize solutions with higher diversity or potential improvement\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * random.random())\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Step 3: Perform item swaps and flips with guided randomness\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two items to swap\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = random.sample(list(items), 2)\n            # Calculate new weight and values if we swap\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n            new_value1 = current_value1 - value1_lst[i] + value1_lst[j]\n            new_value2 = current_value2 - value2_lst[i] + value2_lst[j]\n\n            if new_weight <= capacity:\n                # Accept the swap if it improves at least one objective\n                if (new_value1 > current_value1) or (new_value2 > current_value2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n\n        # Randomly flip a single item\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Accept flip if it improves at least one objective\n                potential_value1 = current_value1 + value1_lst[item]\n                potential_value2 = current_value2 + value2_lst[item]\n                if (potential_value1 > current_value1) or (potential_value2 > current_value2):\n                    new_solution[item] = 1\n                    current_weight = new_weight\n\n    # Step 4: Perform guided random walk for exploration\n    for _ in range(5):\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3311193881077911,
            5.125269740819931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Prioritize solutions with higher diversity or potential improvement\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * random.random())\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Step 3: Perform item swaps and flips with guided randomness\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two items to swap\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = random.sample(list(items), 2)\n            # Calculate new weight and values if we swap\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n            new_value1 = current_value1 - value1_lst[i] + value1_lst[j]\n            new_value2 = current_value2 - value2_lst[i] + value2_lst[j]\n\n            if new_weight <= capacity:\n                # Accept the swap if it improves at least one objective\n                if (new_value1 > current_value1) or (new_value2 > current_value2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n\n        # Randomly flip a single item\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Accept flip if it improves at least one objective\n                potential_value1 = current_value1 + value1_lst[item]\n                potential_value2 = current_value2 + value2_lst[item]\n                if (potential_value1 > current_value1) or (potential_value2 > current_value2):\n                    new_solution[item] = 1\n                    current_weight = new_weight\n\n    # Step 4: Perform guided random walk for exploration\n    for _ in range(5):\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive by prioritizing those with high objective values and low redundancy, then applies a hybrid local search operator that combines random item swaps with objective-specific perturbations to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives\n    candidates = archive[:max(1, len(archive)//2)]  # Top half candidates\n    base_solution, _ = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to manipulate\n    subset_size = min(5, n_items)  # Small subset for efficiency\n    subset = random.sample(range(n_items), subset_size)\n\n    for i in subset:\n        # Objective-aware perturbation\n        if new_solution[i] == 1:\n            # Try to remove if it's not critical\n            if current_weight - weight_lst[i] <= capacity:\n                if random.random() < 0.5 or (value1_lst[i] + value2_lst[i]) < np.mean(value1_lst + value2_lst):\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n        else:\n            # Try to add if it fits and has high potential\n            if current_weight + weight_lst[i] <= capacity:\n                if random.random() < 0.7 or (value1_lst[i] + value2_lst[i]) > np.mean(value1_lst + value2_lst):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If overweight, remove items until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            # Remove the item with lowest combined value\n            item_to_remove = items_in[np.argmin(value1_lst[items_in] + value2_lst[items_in])]\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.2977940873491667,
            2.5631627440452576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives\n    candidates = archive[:max(1, len(archive)//2)]  # Top half candidates\n    base_solution, _ = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to manipulate\n    subset_size = min(5, n_items)  # Small subset for efficiency\n    subset = random.sample(range(n_items), subset_size)\n\n    for i in subset:\n        # Objective-aware perturbation\n        if new_solution[i] == 1:\n            # Try to remove if it's not critical\n            if current_weight - weight_lst[i] <= capacity:\n                if random.random() < 0.5 or (value1_lst[i] + value2_lst[i]) < np.mean(value1_lst + value2_lst):\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n        else:\n            # Try to add if it fits and has high potential\n            if current_weight + weight_lst[i] <= capacity:\n                if random.random() < 0.7 or (value1_lst[i] + value2_lst[i]) > np.mean(value1_lst + value2_lst):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If overweight, remove items until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            # Remove the item with lowest combined value\n            item_to_remove = items_in[np.argmin(value1_lst[items_in] + value2_lst[items_in])]\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined value of the two objectives, then applies a novel local search operator that probabilistically flips items based on their marginal contribution to both objectives, ensuring feasibility by dynamically adjusting the selection probability to respect the capacity constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Probabilistic flip based on marginal contributions\n    for i in range(len(base_solution)):\n        if random.random() < 0.3:  # Base probability to explore\n            if base_solution[i] == 1:\n                # Probability to remove item based on marginal contribution and current weight\n                prob_remove = 0.5 * (1 - combined_marginal[i] / np.max(combined_marginal + 1e-10)) * (current_weight / capacity)\n                if random.random() < prob_remove:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Probability to add item based on marginal contribution and remaining capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    prob_add = 0.5 * (combined_marginal[i] / np.max(combined_marginal + 1e-10)) * (1 - current_weight / capacity)\n                    if random.random() < prob_add:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.579232668192254,
            5.481158077716827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Probabilistic flip based on marginal contributions\n    for i in range(len(base_solution)):\n        if random.random() < 0.3:  # Base probability to explore\n            if base_solution[i] == 1:\n                # Probability to remove item based on marginal contribution and current weight\n                prob_remove = 0.5 * (1 - combined_marginal[i] / np.max(combined_marginal + 1e-10)) * (current_weight / capacity)\n                if random.random() < prob_remove:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Probability to add item based on marginal contribution and remaining capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    prob_add = 0.5 * (combined_marginal[i] / np.max(combined_marginal + 1e-10)) * (1 - current_weight / capacity)\n                    if random.random() < prob_add:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on its objective values and applies a hybrid local search strategy that combines item swapping and dynamic neighborhood exploration to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on objective values (prioritize solutions with higher combined value)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: item swapping and dynamic neighborhood exploration\n    N = len(base_solution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Randomly select items to swap (considering both objectives)\n    swap_indices = random.sample(range(N), min(5, N))\n    for i in swap_indices:\n        if base_solution[i] == 1:\n            # Try to remove the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try to add the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Step 2: Dynamic neighborhood exploration (consider items with high marginal gains)\n    if current_weight < capacity:\n        # Calculate marginal gains for both objectives\n        marginal_gain1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n        combined_gain = marginal_gain1 + marginal_gain2\n\n        # Select top-k items with highest combined marginal gain\n        k = min(3, N)\n        top_indices = np.argsort(-combined_gain)[:k]\n        for i in top_indices:\n            if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3034985031263036,
            1.82338747382164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on objective values (prioritize solutions with higher combined value)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: item swapping and dynamic neighborhood exploration\n    N = len(base_solution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Randomly select items to swap (considering both objectives)\n    swap_indices = random.sample(range(N), min(5, N))\n    for i in swap_indices:\n        if base_solution[i] == 1:\n            # Try to remove the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try to add the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Step 2: Dynamic neighborhood exploration (consider items with high marginal gains)\n    if current_weight < capacity:\n        # Calculate marginal gains for both objectives\n        marginal_gain1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n        combined_gain = marginal_gain1 + marginal_gain2\n\n        # Select top-k items with highest combined marginal gain\n        k = min(3, N)\n        top_indices = np.argsort(-combined_gain)[:k]\n        for i in top_indices:\n            if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search that combines item swapping and probabilistic flipping to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swapping and probabilistic flipping\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Item swapping (swap two items if feasible)\n    if n_items > 1:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = 0, 1\n            else:\n                if total_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = 1, 0\n\n    # Step 2: Probabilistic flipping (flip items with high value-to-weight ratio)\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 0:\n                if total_weight + weight_lst[i] <= capacity:\n                    # Prefer items with high value-to-weight ratio for both objectives\n                    ratio1 = value1_lst[i] / weight_lst[i] if weight_lst[i] != 0 else 0\n                    ratio2 = value2_lst[i] / weight_lst[i] if weight_lst[i] != 0 else 0\n                    if ratio1 > 0.5 * np.mean(value1_lst / weight_lst[weight_lst != 0]) or \\\n                       ratio2 > 0.5 * np.mean(value2_lst / weight_lst[weight_lst != 0]):\n                        new_solution[i] = 1\n            else:\n                if random.random() < 0.1:  # Lower chance to remove items\n                    new_solution[i] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            remove_idx = random.choice(included_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.478362106535403,
            3.097105234861374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swapping and probabilistic flipping\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Item swapping (swap two items if feasible)\n    if n_items > 1:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = 0, 1\n            else:\n                if total_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = 1, 0\n\n    # Step 2: Probabilistic flipping (flip items with high value-to-weight ratio)\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 0:\n                if total_weight + weight_lst[i] <= capacity:\n                    # Prefer items with high value-to-weight ratio for both objectives\n                    ratio1 = value1_lst[i] / weight_lst[i] if weight_lst[i] != 0 else 0\n                    ratio2 = value2_lst[i] / weight_lst[i] if weight_lst[i] != 0 else 0\n                    if ratio1 > 0.5 * np.mean(value1_lst / weight_lst[weight_lst != 0]) or \\\n                       ratio2 > 0.5 * np.mean(value2_lst / weight_lst[weight_lst != 0]):\n                        new_solution[i] = 1\n            else:\n                if random.random() < 0.1:  # Lower chance to remove items\n                    new_solution[i] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            remove_idx = random.choice(included_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{A novel hybrid local search strategy combines a guided random walk with a value-to-weight ratio-based perturbation to intelligently explore the solution space while ensuring feasibility, prioritizing solutions with high potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected = random.choices(archive_sorted[:max(3, len(archive)//2)], k=1)[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = selected.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2.1: Guided random walk - flip a random bit with probability based on value-to-weight ratio\n    for _ in range(min(3, len(new_solution))):  # Limit the number of flips\n        # Calculate value-to-weight ratio for each item\n        v1_ratio = value1_lst / (weight_lst + 1e-6)\n        v2_ratio = value2_lst / (weight_lst + 1e-6)\n        combined_ratio = v1_ratio + v2_ratio\n\n        # Probability of flipping based on combined ratio\n        flip_probs = combined_ratio / (np.sum(combined_ratio) + 1e-6)\n        flip_idx = np.random.choice(len(new_solution), p=flip_probs)\n\n        # Flip the bit and check feasibility\n        if new_solution[flip_idx] == 1:\n            if total_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                total_weight -= weight_lst[flip_idx]\n        else:\n            if total_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                total_weight += weight_lst[flip_idx]\n\n    # Step 2.2: Value-based perturbation - flip items with high value but low weight\n    # Identify items with high value-to-weight ratio and low weight\n    high_value_low_weight = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    threshold = np.percentile(high_value_low_weight, 75)  # Top 25% of items\n\n    for idx in np.where(high_value_low_weight >= threshold)[0]:\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.37201287044812004,
            5.235015571117401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected = random.choices(archive_sorted[:max(3, len(archive)//2)], k=1)[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = selected.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2.1: Guided random walk - flip a random bit with probability based on value-to-weight ratio\n    for _ in range(min(3, len(new_solution))):  # Limit the number of flips\n        # Calculate value-to-weight ratio for each item\n        v1_ratio = value1_lst / (weight_lst + 1e-6)\n        v2_ratio = value2_lst / (weight_lst + 1e-6)\n        combined_ratio = v1_ratio + v2_ratio\n\n        # Probability of flipping based on combined ratio\n        flip_probs = combined_ratio / (np.sum(combined_ratio) + 1e-6)\n        flip_idx = np.random.choice(len(new_solution), p=flip_probs)\n\n        # Flip the bit and check feasibility\n        if new_solution[flip_idx] == 1:\n            if total_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                total_weight -= weight_lst[flip_idx]\n        else:\n            if total_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                total_weight += weight_lst[flip_idx]\n\n    # Step 2.2: Value-based perturbation - flip items with high value but low weight\n    # Identify items with high value-to-weight ratio and low weight\n    high_value_low_weight = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    threshold = np.percentile(high_value_low_weight, 75)  # Top 25% of items\n\n    for idx in np.where(high_value_low_weight >= threshold)[0]:\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with probabilistic diversification to intelligently explore the solution space while ensuring feasibility, focusing on both objectives through a weighted random selection of promising solutions and targeted neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Intelligently select a promising solution from the archive\n    # Weigh solutions based on their potential for improvement (e.g., solutions with high diversity or marginal improvement)\n    scores = []\n    for sol, _ in archive:\n        # Calculate the number of items that can be swapped without violating capacity\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Count items that can be added (not in solution and weight <= remaining capacity)\n        addable_items = np.sum((sol == 0) & (weight_lst <= remaining_capacity))\n        # Count items that can be removed (in solution)\n        removable_items = np.sum(sol)\n        # Score is based on potential for improvement (addable + removable items)\n        scores.append(addable_items + removable_items)\n\n    # Normalize scores to probabilities\n    total_score = sum(scores)\n    if total_score == 0:\n        # If all scores are zero, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probabilities = [score / total_score for score in scores]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search to generate a neighbor\n    # Hybrid approach: adaptive swapping based on objective weights and probabilistic diversification\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate weights for objectives (normalized)\n    obj1_total = archive[selected_idx][1][0]\n    obj2_total = archive[selected_idx][1][1]\n    total_obj = obj1_total + obj2_total\n    if total_obj == 0:\n        obj1_weight, obj2_weight = 0.5, 0.5\n    else:\n        obj1_weight = obj1_total / total_obj\n        obj2_weight = obj2_total / total_obj\n\n    # Step 2.1: Adaptive item swapping based on objective weights\n    # Identify items to consider for swapping\n    candidate_items = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing this item (if it improves at least one objective)\n            new_weight = current_weight - weight_lst[i]\n            new_obj1 = obj1_total - value1_lst[i]\n            new_obj2 = obj2_total - value2_lst[i]\n            # Check if removing improves at least one objective\n            if (new_obj1 > obj1_total) or (new_obj2 > obj2_total):\n                candidate_items.append((i, 'remove'))\n        else:\n            # Consider adding this item (if it fits and improves at least one objective)\n            if weight_lst[i] <= remaining_capacity:\n                new_weight = current_weight + weight_lst[i]\n                new_obj1 = obj1_total + value1_lst[i]\n                new_obj2 = obj2_total + value2_lst[i]\n                # Check if adding improves at least one objective\n                if (new_obj1 > obj1_total) or (new_obj2 > obj2_total):\n                    candidate_items.append((i, 'add'))\n\n    # Step 2.2: Apply probabilistic diversification\n    if candidate_items:\n        # Weighted random selection based on objective weights\n        weights = []\n        for item, action in candidate_items:\n            if action == 'add':\n                # Prefer adding items that improve the objective with higher weight\n                weight = obj1_weight * value1_lst[item] + obj2_weight * value2_lst[item]\n            else:  # 'remove'\n                # Prefer removing items that have lower value for the objective with higher weight\n                weight = - (obj1_weight * value1_lst[item] + obj2_weight * value2_lst[item])\n            weights.append(weight)\n\n        # Normalize weights to probabilities\n        total_weight = sum(weights)\n        if total_weight == 0:\n            selected_item = random.choice(candidate_items)\n        else:\n            probabilities = [w / total_weight for w in weights]\n            selected_item = np.random.choice(len(candidate_items), p=probabilities)\n            selected_item = candidate_items[selected_item]\n\n        # Apply the selected action\n        item_idx, action = selected_item\n        if action == 'add':\n            new_solution[item_idx] = 1\n        else:\n            new_solution[item_idx] = 0\n    else:\n        # If no candidates, perform a random valid swap\n        # Find all items that can be added (not in solution and weight <= remaining capacity)\n        addable = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n        # Find all items that can be removed (in solution)\n        removable = np.where(new_solution == 1)[0]\n\n        if len(addable) > 0 and len(removable) > 0:\n            # Randomly select one to add and one to remove\n            add_idx = random.choice(addable)\n            remove_idx = random.choice(removable)\n            new_solution[add_idx] = 1\n            new_solution[remove_idx] = 0\n        elif len(addable) > 0:\n            # Only add\n            add_idx = random.choice(addable)\n            new_solution[add_idx] = 1\n        elif len(removable) > 0:\n            # Only remove\n            remove_idx = random.choice(removable)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8478732883063163,
            7.821203708648682
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Intelligently select a promising solution from the archive\n    # Weigh solutions based on their potential for improvement (e.g., solutions with high diversity or marginal improvement)\n    scores = []\n    for sol, _ in archive:\n        # Calculate the number of items that can be swapped without violating capacity\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Count items that can be added (not in solution and weight <= remaining capacity)\n        addable_items = np.sum((sol == 0) & (weight_lst <= remaining_capacity))\n        # Count items that can be removed (in solution)\n        removable_items = np.sum(sol)\n        # Score is based on potential for improvement (addable + removable items)\n        scores.append(addable_items + removable_items)\n\n    # Normalize scores to probabilities\n    total_score = sum(scores)\n    if total_score == 0:\n        # If all scores are zero, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probabilities = [score / total_score for score in scores]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search to generate a neighbor\n    # Hybrid approach: adaptive swapping based on objective weights and probabilistic diversification\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate weights for objectives (normalized)\n    obj1_total = archive[selected_idx][1][0]\n    obj2_total = archive[selected_idx][1][1]\n    total_obj = obj1_total + obj2_total\n    if total_obj == 0:\n        obj1_weight, obj2_weight = 0.5, 0.5\n    else:\n        obj1_weight = obj1_total / total_obj\n        obj2_weight = obj2_total / total_obj\n\n    # Step 2.1: Adaptive item swapping based on objective weights\n    # Identify items to consider for swapping\n    candidate_items = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing this item (if it improves at least one objective)\n            new_weight = current_weight - weight_lst[i]\n            new_obj1 = obj1_total - value1_lst[i]\n            new_obj2 = obj2_total - value2_lst[i]\n            # Check if removing improves at least one objective\n            if (new_obj1 > obj1_total) or (new_obj2 > obj2_total):\n                candidate_items.append((i, 'remove'))\n        else:\n            # Consider adding this item (if it fits and improves at least one objective)\n            if weight_lst[i] <= remaining_capacity:\n                new_weight = current_weight + weight_lst[i]\n                new_obj1 = obj1_total + value1_lst[i]\n                new_obj2 = obj2_total + value2_lst[i]\n                # Check if adding improves at least one objective\n                if (new_obj1 > obj1_total) or (new_obj2 > obj2_total):\n                    candidate_items.append((i, 'add'))\n\n    # Step 2.2: Apply probabilistic diversification\n    if candidate_items:\n        # Weighted random selection based on objective weights\n        weights = []\n        for item, action in candidate_items:\n            if action == 'add':\n                # Prefer adding items that improve the objective with higher weight\n                weight = obj1_weight * value1_lst[item] + obj2_weight * value2_lst[item]\n            else:  # 'remove'\n                # Prefer removing items that have lower value for the objective with higher weight\n                weight = - (obj1_weight * value1_lst[item] + obj2_weight * value2_lst[item])\n            weights.append(weight)\n\n        # Normalize weights to probabilities\n        total_weight = sum(weights)\n        if total_weight == 0:\n            selected_item = random.choice(candidate_items)\n        else:\n            probabilities = [w / total_weight for w in weights]\n            selected_item = np.random.choice(len(candidate_items), p=probabilities)\n            selected_item = candidate_items[selected_item]\n\n        # Apply the selected action\n        item_idx, action = selected_item\n        if action == 'add':\n            new_solution[item_idx] = 1\n        else:\n            new_solution[item_idx] = 0\n    else:\n        # If no candidates, perform a random valid swap\n        # Find all items that can be added (not in solution and weight <= remaining capacity)\n        addable = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n        # Find all items that can be removed (in solution)\n        removable = np.where(new_solution == 1)[0]\n\n        if len(addable) > 0 and len(removable) > 0:\n            # Randomly select one to add and one to remove\n            add_idx = random.choice(addable)\n            remove_idx = random.choice(removable)\n            new_solution[add_idx] = 1\n            new_solution[remove_idx] = 0\n        elif len(addable) > 0:\n            # Only add\n            add_idx = random.choice(addable)\n            new_solution[add_idx] = 1\n        elif len(removable) > 0:\n            # Only remove\n            remove_idx = random.choice(removable)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swaps and adaptive flips to explore high-quality neighbors while ensuring feasibility through dynamic weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swaps and flips\n    # Step 1: Randomly select a subset of items to consider for swap/flip\n    num_items = len(weight_lst)\n    subset_size = min(max(2, num_items // 10), 10)\n    selected_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: Adaptive flip (flip items with high value-weight ratio)\n    for idx in selected_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try removing it\n            temp_weight = np.sum(weight_lst[new_solution == 1])\n            if temp_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, try adding it\n            temp_weight = np.sum(weight_lst[new_solution == 1])\n            if temp_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Item swap (swap two items if it improves both objectives)\n    if len(selected_indices) >= 2:\n        i, j = random.sample(selected_indices, 2)\n        if new_solution[i] != new_solution[j]:\n            # Calculate current and potential new weights\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[i] + weight_lst[j] if new_solution[i] == 1 else current_weight + weight_lst[i] - weight_lst[j]\n\n            if new_weight <= capacity:\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.38130754352603713,
            2.8194843232631683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swaps and flips\n    # Step 1: Randomly select a subset of items to consider for swap/flip\n    num_items = len(weight_lst)\n    subset_size = min(max(2, num_items // 10), 10)\n    selected_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: Adaptive flip (flip items with high value-weight ratio)\n    for idx in selected_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try removing it\n            temp_weight = np.sum(weight_lst[new_solution == 1])\n            if temp_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, try adding it\n            temp_weight = np.sum(weight_lst[new_solution == 1])\n            if temp_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Item swap (swap two items if it improves both objectives)\n    if len(selected_indices) >= 2:\n        i, j = random.sample(selected_indices, 2)\n        if new_solution[i] != new_solution[j]:\n            # Calculate current and potential new weights\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[i] + weight_lst[j] if new_solution[i] == 1 else current_weight + weight_lst[i] - weight_lst[j]\n\n            if new_weight <= capacity:\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high marginal gains in both objectives, then applies a hybrid local search combining random swaps and objective-weighted flips to generate a feasible neighbor solution, ensuring the total weight stays within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest combined value)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution, _ = archive[0]\n    current_solution = selected_solution.copy()\n\n    # Calculate current total weight and feasible indices\n    total_weight = np.sum(weight_lst[current_solution == 1])\n    feasible_indices = np.where(current_solution == 0)[0]\n    non_feasible_indices = np.where(current_solution == 1)[0]\n\n    # Hybrid local search: random swap + objective-weighted flip\n    for _ in range(10):  # Number of local search steps\n        # Random swap between included and excluded items\n        if len(feasible_indices) > 0 and len(non_feasible_indices) > 0:\n            swap_in = np.random.choice(non_feasible_indices)\n            swap_out = np.random.choice(feasible_indices)\n            new_weight = total_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                current_solution[swap_in] = 1\n                current_solution[swap_out] = 0\n                total_weight = new_weight\n                feasible_indices = np.where(current_solution == 0)[0]\n                non_feasible_indices = np.where(current_solution == 1)[0]\n\n        # Objective-weighted flip: prioritize items with high marginal gain\n        for idx in feasible_indices:\n            if total_weight + weight_lst[idx] <= capacity:\n                marginal_gain1 = value1_lst[idx]\n                marginal_gain2 = value2_lst[idx]\n                if marginal_gain1 + marginal_gain2 > 0:  # Only flip if positive marginal gain\n                    current_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n                    feasible_indices = np.where(current_solution == 0)[0]\n                    break\n\n    return current_solution\n\n",
        "score": [
            -0.5271338350398683,
            9.767039954662323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest combined value)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution, _ = archive[0]\n    current_solution = selected_solution.copy()\n\n    # Calculate current total weight and feasible indices\n    total_weight = np.sum(weight_lst[current_solution == 1])\n    feasible_indices = np.where(current_solution == 0)[0]\n    non_feasible_indices = np.where(current_solution == 1)[0]\n\n    # Hybrid local search: random swap + objective-weighted flip\n    for _ in range(10):  # Number of local search steps\n        # Random swap between included and excluded items\n        if len(feasible_indices) > 0 and len(non_feasible_indices) > 0:\n            swap_in = np.random.choice(non_feasible_indices)\n            swap_out = np.random.choice(feasible_indices)\n            new_weight = total_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                current_solution[swap_in] = 1\n                current_solution[swap_out] = 0\n                total_weight = new_weight\n                feasible_indices = np.where(current_solution == 0)[0]\n                non_feasible_indices = np.where(current_solution == 1)[0]\n\n        # Objective-weighted flip: prioritize items with high marginal gain\n        for idx in feasible_indices:\n            if total_weight + weight_lst[idx] <= capacity:\n                marginal_gain1 = value1_lst[idx]\n                marginal_gain2 = value2_lst[idx]\n                if marginal_gain1 + marginal_gain2 > 0:  # Only flip if positive marginal gain\n                    current_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n                    feasible_indices = np.where(current_solution == 0)[0]\n                    break\n\n    return current_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high diversity in objectives, then applies a hybrid local search operator that combines random swaps with a biased selection of items based on their marginal contribution to both objectives, ensuring feasibility and maximizing improvement potential in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives to avoid scale bias\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        # Select solution with highest diversity (max sum of normalized objectives)\n        selected_idx = np.argmax(np.sum(normalized, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (either added or removed)\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, 'remove'))\n        else:\n            # Check if adding this item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 'add'))\n\n    if not candidates:\n        return base_solution  # No feasible moves\n\n    # Select a candidate with high potential for improvement\n    max_potential = -1\n    best_candidate = None\n    for i, action in candidates:\n        if action == 'remove':\n            # Potential is based on marginal contribution to both objectives\n            marginal1 = -value1_lst[i]\n            marginal2 = -value2_lst[i]\n        else:\n            marginal1 = value1_lst[i]\n            marginal2 = value2_lst[i]\n\n        # Combine potential from both objectives (weighted sum)\n        potential = 0.5 * marginal1 + 0.5 * marginal2\n\n        if potential > max_potential:\n            max_potential = potential\n            best_candidate = (i, action)\n\n    if best_candidate is None:\n        return base_solution\n\n    i, action = best_candidate\n    if action == 'remove':\n        new_solution[i] = 0\n    else:\n        new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8683297684970823,
            4.0345712304115295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives to avoid scale bias\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        # Select solution with highest diversity (max sum of normalized objectives)\n        selected_idx = np.argmax(np.sum(normalized, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (either added or removed)\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, 'remove'))\n        else:\n            # Check if adding this item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 'add'))\n\n    if not candidates:\n        return base_solution  # No feasible moves\n\n    # Select a candidate with high potential for improvement\n    max_potential = -1\n    best_candidate = None\n    for i, action in candidates:\n        if action == 'remove':\n            # Potential is based on marginal contribution to both objectives\n            marginal1 = -value1_lst[i]\n            marginal2 = -value2_lst[i]\n        else:\n            marginal1 = value1_lst[i]\n            marginal2 = value2_lst[i]\n\n        # Combine potential from both objectives (weighted sum)\n        potential = 0.5 * marginal1 + 0.5 * marginal2\n\n        if potential > max_potential:\n            max_potential = potential\n            best_candidate = (i, action)\n\n    if best_candidate is None:\n        return base_solution\n\n    i, action = best_candidate\n    if action == 'remove':\n        new_solution[i] = 0\n    else:\n        new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_archive = []\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(value1_lst) if np.max(value1_lst) != 0 else 0\n        norm_obj2 = obj2 / np.max(value2_lst) if np.max(value2_lst) != 0 else 0\n        normalized_archive.append((sol, (norm_obj1 + norm_obj2)))\n\n    # Sort by normalized sum of objectives (descending)\n    normalized_archive.sort(key=lambda x: -x[1])\n    base_solution = normalized_archive[0][0].copy()\n\n    # Generate neighbor using a hybrid local search: flip a subset of bits based on objective marginal gains\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # If item is included, consider removing it\n            marginal_gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_gains.append((i, -marginal_gain))  # Negative gain for removal\n        else:\n            # If item is not included, consider adding it if feasible\n            if current_weight + weight_lst[i] <= capacity:\n                marginal_gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                marginal_gains.append((i, marginal_gain))\n\n    # Sort marginal gains and flip top 20% items\n    marginal_gains.sort(key=lambda x: -x[1])\n    flip_count = max(1, len(marginal_gains) // 5)  # Flip at least 1 item\n    for i, _ in marginal_gains[:flip_count]:\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8881364267109453,
            7.979368180036545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_archive = []\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(value1_lst) if np.max(value1_lst) != 0 else 0\n        norm_obj2 = obj2 / np.max(value2_lst) if np.max(value2_lst) != 0 else 0\n        normalized_archive.append((sol, (norm_obj1 + norm_obj2)))\n\n    # Sort by normalized sum of objectives (descending)\n    normalized_archive.sort(key=lambda x: -x[1])\n    base_solution = normalized_archive[0][0].copy()\n\n    # Generate neighbor using a hybrid local search: flip a subset of bits based on objective marginal gains\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # If item is included, consider removing it\n            marginal_gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_gains.append((i, -marginal_gain))  # Negative gain for removal\n        else:\n            # If item is not included, consider adding it if feasible\n            if current_weight + weight_lst[i] <= capacity:\n                marginal_gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                marginal_gains.append((i, marginal_gain))\n\n    # Sort marginal gains and flip top 20% items\n    marginal_gains.sort(key=lambda x: -x[1])\n    flip_count = max(1, len(marginal_gains) // 5)  # Flip at least 1 item\n    for i, _ in marginal_gains[:flip_count]:\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement by evaluating the density of items (value per weight) and applies a novel local search operator that combines item swaps with a probabilistic flip mechanism to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (highest density)\n    densities = []\n    for sol, _ in archive:\n        included = np.where(sol == 1)[0]\n        if len(included) == 0:\n            densities.append(0)\n            continue\n        total_weight = np.sum(weight_lst[included])\n        total_value1 = np.sum(value1_lst[included])\n        total_value2 = np.sum(value2_lst[included])\n        density = (total_value1 + total_value2) / total_weight if total_weight > 0 else 0\n        densities.append(density)\n\n    selected_idx = np.argmax(densities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n    if n_items <= 1:\n        return new_solution\n\n    # Step 1: Randomly select a subset of items to flip\n    flip_mask = np.random.random(n_items) < 0.3  # 30% chance to flip each item\n    candidate_solution = new_solution.copy()\n    candidate_solution[flip_mask] = 1 - candidate_solution[flip_mask]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[candidate_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, remove items with lowest (value1 + value2)/weight ratio\n        included = np.where(candidate_solution == 1)[0]\n        if len(included) == 0:\n            return new_solution\n        values = value1_lst[included] + value2_lst[included]\n        weights = weight_lst[included]\n        ratios = values / weights\n        sorted_indices = np.argsort(ratios)\n        for idx in sorted_indices:\n            candidate_solution[included[idx]] = 0\n            total_weight = np.sum(weight_lst[candidate_solution == 1])\n            if total_weight <= capacity:\n                break\n\n    # Step 2: Apply probabilistic swap\n    swap_indices = np.random.choice(n_items, size=2, replace=False)\n    i, j = swap_indices\n    if new_solution[i] != new_solution[j]:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Revert swap if infeasible\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Combine results\n    final_solution = candidate_solution.copy()\n    for i in range(n_items):\n        if np.random.random() < 0.5:  # 50% chance to inherit from swap-based neighbor\n            final_solution[i] = new_solution[i]\n\n    return final_solution\n\n",
        "score": [
            -0.38701416080308587,
            8.18176856637001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (highest density)\n    densities = []\n    for sol, _ in archive:\n        included = np.where(sol == 1)[0]\n        if len(included) == 0:\n            densities.append(0)\n            continue\n        total_weight = np.sum(weight_lst[included])\n        total_value1 = np.sum(value1_lst[included])\n        total_value2 = np.sum(value2_lst[included])\n        density = (total_value1 + total_value2) / total_weight if total_weight > 0 else 0\n        densities.append(density)\n\n    selected_idx = np.argmax(densities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n    if n_items <= 1:\n        return new_solution\n\n    # Step 1: Randomly select a subset of items to flip\n    flip_mask = np.random.random(n_items) < 0.3  # 30% chance to flip each item\n    candidate_solution = new_solution.copy()\n    candidate_solution[flip_mask] = 1 - candidate_solution[flip_mask]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[candidate_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, remove items with lowest (value1 + value2)/weight ratio\n        included = np.where(candidate_solution == 1)[0]\n        if len(included) == 0:\n            return new_solution\n        values = value1_lst[included] + value2_lst[included]\n        weights = weight_lst[included]\n        ratios = values / weights\n        sorted_indices = np.argsort(ratios)\n        for idx in sorted_indices:\n            candidate_solution[included[idx]] = 0\n            total_weight = np.sum(weight_lst[candidate_solution == 1])\n            if total_weight <= capacity:\n                break\n\n    # Step 2: Apply probabilistic swap\n    swap_indices = np.random.choice(n_items, size=2, replace=False)\n    i, j = swap_indices\n    if new_solution[i] != new_solution[j]:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Revert swap if infeasible\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Combine results\n    final_solution = candidate_solution.copy()\n    for i in range(n_items):\n        if np.random.random() < 0.5:  # 50% chance to inherit from swap-based neighbor\n            final_solution[i] = new_solution[i]\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This algorithm selects a promising solution from the archive based on the highest combined value of the two objectives, then applies a hybrid local search operator that intelligently flips a subset of items to maximize both objectives while ensuring feasibility, using a novel weighted random selection strategy to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined value\n    selected_idx = np.argmax([v1 + v2 for _, (v1, v2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst - np.sum(value1_lst * base_solution) / len(base_solution)\n    marginal_value2 = value2_lst - np.sum(value2_lst * base_solution) / len(base_solution)\n    marginal_scores = marginal_value1 + marginal_value2\n\n    # Weighted random selection for candidate items to flip\n    weights = np.maximum(0, marginal_scores)\n    if np.sum(weights) == 0:\n        weights = np.ones_like(weights)\n\n    candidate_indices = np.random.choice(len(weights), size=min(5, len(weights)), replace=False, p=weights/np.sum(weights))\n\n    new_solution = base_solution.copy()\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it's in the solution\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if it's not in the solution\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.38871359396377875,
            3.3214140832424164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined value\n    selected_idx = np.argmax([v1 + v2 for _, (v1, v2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst - np.sum(value1_lst * base_solution) / len(base_solution)\n    marginal_value2 = value2_lst - np.sum(value2_lst * base_solution) / len(base_solution)\n    marginal_scores = marginal_value1 + marginal_value2\n\n    # Weighted random selection for candidate items to flip\n    weights = np.maximum(0, marginal_scores)\n    if np.sum(weights) == 0:\n        weights = np.ones_like(weights)\n\n    candidate_indices = np.random.choice(len(weights), size=min(5, len(weights)), replace=False, p=weights/np.sum(weights))\n\n    new_solution = base_solution.copy()\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it's in the solution\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if it's not in the solution\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search strategy combining item swapping and adaptive perturbation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by crowding distance (higher potential for improvement)\n        crowding_distances = []\n        for i, (sol, _) in enumerate(archive):\n            if i == 0 or i == len(archive) - 1:\n                crowding_distances.append(float('inf'))\n            else:\n                dist = np.linalg.norm(np.array(archive[i+1][1]) - np.array(archive[i-1][1]))\n                crowding_distances.append(dist)\n        # Select a solution with high crowding distance (more potential for improvement)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    # Step 1: Item swapping (flip two items)\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Adaptive perturbation (flip a random item if solution is not improving)\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(new_solution != base_solution)[0]\n        if len(candidate_items) > 0:\n            k = random.choice(candidate_items)\n            new_solution[k] = 1 - new_solution[k]\n            # Ensure feasibility\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[k] = 1 - new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8175794828012128,
            3.3826840817928314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by crowding distance (higher potential for improvement)\n        crowding_distances = []\n        for i, (sol, _) in enumerate(archive):\n            if i == 0 or i == len(archive) - 1:\n                crowding_distances.append(float('inf'))\n            else:\n                dist = np.linalg.norm(np.array(archive[i+1][1]) - np.array(archive[i-1][1]))\n                crowding_distances.append(dist)\n        # Select a solution with high crowding distance (more potential for improvement)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    # Step 1: Item swapping (flip two items)\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Adaptive perturbation (flip a random item if solution is not improving)\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(new_solution != base_solution)[0]\n        if len(candidate_items) > 0:\n            k = random.choice(candidate_items)\n            new_solution[k] = 1 - new_solution[k]\n            # Ensure feasibility\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[k] = 1 - new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its objective values and applies a hybrid local search strategy, combining item swaps, random flips, and capacity-aware perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized.sum(axis=1)\n        # Select top 30% of solutions\n        top_indices = np.argsort(scores)[-max(1, len(archive) // 3):]\n        selected_idx = random.choice(top_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy\n    # Step 1: Randomly flip a small number of items (1-3) to create diversity\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if it exists\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Add item if capacity allows\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Perform capacity-aware swaps between items\n    # Find items not in the solution with positive value\n    not_included = np.where(new_solution == 0)[0]\n    positive_items = [i for i in not_included if value1_lst[i] > 0 or value2_lst[i] > 0]\n    if len(positive_items) > 0:\n        # Try to add one such item\n        candidate = random.choice(positive_items)\n        if current_weight + weight_lst[candidate] <= capacity:\n            new_solution[candidate] = 1\n            current_weight += weight_lst[candidate]\n\n    # Step 3: Remove items to make space if still over capacity\n    if current_weight > capacity:\n        # Sort items in solution by value density (sum of normalized values / weight)\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            normalized_values = (value1_lst[in_solution] + value2_lst[in_solution]) / (weight_lst[in_solution] + 1e-10)\n            # Remove items with lowest value density first\n            remove_order = np.argsort(normalized_values)\n            for i in remove_order:\n                if current_weight - weight_lst[in_solution[i]] >= 0:\n                    new_solution[in_solution[i]] = 0\n                    current_weight -= weight_lst[in_solution[i]]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.32934670637216723,
            2.8563351035118103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized.sum(axis=1)\n        # Select top 30% of solutions\n        top_indices = np.argsort(scores)[-max(1, len(archive) // 3):]\n        selected_idx = random.choice(top_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy\n    # Step 1: Randomly flip a small number of items (1-3) to create diversity\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if it exists\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Add item if capacity allows\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Perform capacity-aware swaps between items\n    # Find items not in the solution with positive value\n    not_included = np.where(new_solution == 0)[0]\n    positive_items = [i for i in not_included if value1_lst[i] > 0 or value2_lst[i] > 0]\n    if len(positive_items) > 0:\n        # Try to add one such item\n        candidate = random.choice(positive_items)\n        if current_weight + weight_lst[candidate] <= capacity:\n            new_solution[candidate] = 1\n            current_weight += weight_lst[candidate]\n\n    # Step 3: Remove items to make space if still over capacity\n    if current_weight > capacity:\n        # Sort items in solution by value density (sum of normalized values / weight)\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            normalized_values = (value1_lst[in_solution] + value2_lst[in_solution]) / (weight_lst[in_solution] + 1e-10)\n            # Remove items with lowest value density first\n            remove_order = np.argsort(normalized_values)\n            for i in remove_order:\n                if current_weight - weight_lst[in_solution[i]] >= 0:\n                    new_solution[in_solution[i]] = 0\n                    current_weight -= weight_lst[in_solution[i]]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator that combines item swaps and dynamic adjustments based on objective gradients to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Choose a solution with high potential for improvement (e.g., high trade-off between objectives)\n    selected_idx = np.argmax([(v1 + v2) / (np.sum(weight_lst[sol]) + 1e-6) for sol, (v1, v2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 2.1: Randomly select a subset of items to consider for swapping\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(n_items)\n\n    # Step 2.2: Evaluate the marginal contribution of each item in the candidate subset\n    marginal_contributions = []\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # If item is included, evaluate removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                marginal_contributions.append((idx, -weight_lst[idx], -value1_lst[idx], -value2_lst[idx]))\n        else:\n            # If item is excluded, evaluate adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                marginal_contributions.append((idx, weight_lst[idx], value1_lst[idx], value2_lst[idx]))\n\n    if not marginal_contributions:\n        # If no feasible moves, return the base solution\n        return base_solution\n\n    # Step 2.3: Select the move with the highest combined marginal contribution\n    best_move = max(marginal_contributions, key=lambda x: (x[2] + x[3]) / (abs(x[1]) + 1e-6))\n    idx_to_flip = best_move[0]\n\n    # Step 2.4: Apply the move\n    new_solution[idx_to_flip] = 1 - new_solution[idx_to_flip]\n\n    # Step 2.5: Ensure feasibility (should already be handled by the marginal contribution check)\n    new_weight = np.sum(weight_lst[new_solution == 1])\n    if new_weight > capacity:\n        # If not feasible, revert to the base solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8322738814879372,
            4.524841070175171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Choose a solution with high potential for improvement (e.g., high trade-off between objectives)\n    selected_idx = np.argmax([(v1 + v2) / (np.sum(weight_lst[sol]) + 1e-6) for sol, (v1, v2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 2.1: Randomly select a subset of items to consider for swapping\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(n_items)\n\n    # Step 2.2: Evaluate the marginal contribution of each item in the candidate subset\n    marginal_contributions = []\n    for idx in candidate_indices:\n        if base_solution[idx] == 1:\n            # If item is included, evaluate removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                marginal_contributions.append((idx, -weight_lst[idx], -value1_lst[idx], -value2_lst[idx]))\n        else:\n            # If item is excluded, evaluate adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                marginal_contributions.append((idx, weight_lst[idx], value1_lst[idx], value2_lst[idx]))\n\n    if not marginal_contributions:\n        # If no feasible moves, return the base solution\n        return base_solution\n\n    # Step 2.3: Select the move with the highest combined marginal contribution\n    best_move = max(marginal_contributions, key=lambda x: (x[2] + x[3]) / (abs(x[1]) + 1e-6))\n    idx_to_flip = best_move[0]\n\n    # Step 2.4: Apply the move\n    new_solution[idx_to_flip] = 1 - new_solution[idx_to_flip]\n\n    # Step 2.5: Ensure feasibility (should already be handled by the marginal contribution check)\n    new_weight = np.sum(weight_lst[new_solution == 1])\n    if new_weight > capacity:\n        # If not feasible, revert to the base solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., one with low objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify items to potentially swap or flip\n    candidate_indices = np.where(selected_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(selected_solution == 0)[0]\n\n    # Randomly select an item to flip or swap\n    if len(candidate_indices) > 1:\n        i, j = np.random.choice(candidate_indices, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        i = np.random.choice(candidate_indices)\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by adjusting if necessary\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            remove_idx = np.random.choice(included_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8971880693733743,
            1.4026212692260742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., one with low objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify items to potentially swap or flip\n    candidate_indices = np.where(selected_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(selected_solution == 0)[0]\n\n    # Randomly select an item to flip or swap\n    if len(candidate_indices) > 1:\n        i, j = np.random.choice(candidate_indices, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        i = np.random.choice(candidate_indices)\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by adjusting if necessary\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            remove_idx = np.random.choice(included_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{A novel hybrid local search strategy that intelligently combines random swaps of items with a biased selection of promising solutions based on their objective values, while ensuring feasibility through a dynamic adjustment of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution based on a biased random choice\n    # Higher probability for solutions with higher combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined = objectives[:, 0] + objectives[:, 1]\n    probabilities = combined / np.sum(combined)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for swapping\n    n_swap = min(3, n_items)  # Limit the number of swaps to avoid excessive changes\n    swap_indices = np.random.choice(n_items, size=n_swap, replace=False)\n\n    for idx in swap_indices:\n        # Attempt to flip the item (add if not present, remove if present)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            new_solution[idx] = 1\n\n        # Check feasibility and revert if necessary\n        total_weight = np.dot(new_solution, weight_lst)\n        if total_weight > capacity:\n            new_solution[idx] = 1 - new_solution[idx]  # Revert the change\n\n    # Step 3: Apply a secondary local improvement (e.g., greedy addition of items)\n    current_weight = np.dot(new_solution, weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Find items not in the current solution that can be added without exceeding capacity\n    candidate_indices = np.where(new_solution == 0)[0]\n    feasible_indices = [idx for idx in candidate_indices if weight_lst[idx] <= remaining_capacity]\n\n    if feasible_indices:\n        # Select the item with the highest combined value\n        candidate_values = value1_lst[feasible_indices] + value2_lst[feasible_indices]\n        best_idx = feasible_indices[np.argmax(candidate_values)]\n        new_solution[best_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.36580753842554276,
            6.755292296409607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution based on a biased random choice\n    # Higher probability for solutions with higher combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined = objectives[:, 0] + objectives[:, 1]\n    probabilities = combined / np.sum(combined)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for swapping\n    n_swap = min(3, n_items)  # Limit the number of swaps to avoid excessive changes\n    swap_indices = np.random.choice(n_items, size=n_swap, replace=False)\n\n    for idx in swap_indices:\n        # Attempt to flip the item (add if not present, remove if present)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            new_solution[idx] = 1\n\n        # Check feasibility and revert if necessary\n        total_weight = np.dot(new_solution, weight_lst)\n        if total_weight > capacity:\n            new_solution[idx] = 1 - new_solution[idx]  # Revert the change\n\n    # Step 3: Apply a secondary local improvement (e.g., greedy addition of items)\n    current_weight = np.dot(new_solution, weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Find items not in the current solution that can be added without exceeding capacity\n    candidate_indices = np.where(new_solution == 0)[0]\n    feasible_indices = [idx for idx in candidate_indices if weight_lst[idx] <= remaining_capacity]\n\n    if feasible_indices:\n        # Select the item with the highest combined value\n        candidate_values = value1_lst[feasible_indices] + value2_lst[feasible_indices]\n        best_idx = feasible_indices[np.argmax(candidate_values)]\n        new_solution[best_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search that combines item swapping and probabilistic flipping to generate a neighbor solution while ensuring feasibility, balancing exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate potential improvement by considering item ratios\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight >= capacity:\n            continue  # Skip infeasible solutions (shouldn't happen as archive should contain feasible solutions)\n        total_value1, total_value2 = obj\n        # Calculate potential improvement as (value1 + value2) / weight ratio\n        potential = (total_value1 + total_value2) / (total_weight + 1e-6)\n        candidates.append((sol, potential))\n\n    if not candidates:\n        # Fallback to random selection if no good candidates\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select the solution with highest potential\n        candidates.sort(key=lambda x: -x[1])\n        base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swapping and probabilistic flipping\n    # Step 1: Randomly swap two items (if possible)\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistically flip items based on their value-to-weight ratio\n    for idx in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            current_weight = np.sum(weight_lst * new_solution)\n            if new_solution[idx] == 1:\n                # Consider removing item\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n            else:\n                # Consider adding item\n                if current_weight + weight_lst[idx] <= capacity:\n                    # Probability based on value-to-weight ratio\n                    ratio = (value1_lst[idx] + value2_lst[idx]) / weight_lst[idx]\n                    if random.random() < (ratio / (ratio + 10)):  # Normalized probability\n                        new_solution[idx] = 1\n\n    # Ensure solution remains feasible (shouldn't be needed due to checks above)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If still infeasible, remove items until feasible\n        items = np.where(new_solution == 1)[0]\n        random.shuffle(items)\n        for idx in items:\n            if np.sum(weight_lst * new_solution) <= capacity:\n                break\n            new_solution[idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5810572709275544,
            6.504059433937073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate potential improvement by considering item ratios\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight >= capacity:\n            continue  # Skip infeasible solutions (shouldn't happen as archive should contain feasible solutions)\n        total_value1, total_value2 = obj\n        # Calculate potential improvement as (value1 + value2) / weight ratio\n        potential = (total_value1 + total_value2) / (total_weight + 1e-6)\n        candidates.append((sol, potential))\n\n    if not candidates:\n        # Fallback to random selection if no good candidates\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select the solution with highest potential\n        candidates.sort(key=lambda x: -x[1])\n        base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swapping and probabilistic flipping\n    # Step 1: Randomly swap two items (if possible)\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistically flip items based on their value-to-weight ratio\n    for idx in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            current_weight = np.sum(weight_lst * new_solution)\n            if new_solution[idx] == 1:\n                # Consider removing item\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n            else:\n                # Consider adding item\n                if current_weight + weight_lst[idx] <= capacity:\n                    # Probability based on value-to-weight ratio\n                    ratio = (value1_lst[idx] + value2_lst[idx]) / weight_lst[idx]\n                    if random.random() < (ratio / (ratio + 10)):  # Normalized probability\n                        new_solution[idx] = 1\n\n    # Ensure solution remains feasible (shouldn't be needed due to checks above)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If still infeasible, remove items until feasible\n        items = np.where(new_solution == 1)[0]\n        random.shuffle(items)\n        for idx in items:\n            if np.sum(weight_lst * new_solution) <= capacity:\n                break\n            new_solution[idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with high objective values and high diversity in their item selections, then applies a novel hybrid local search that combines random item swaps with a guided probabilistic flip to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective values and high diversity\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + guided probabilistic flip\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random swaps (2-3 items)\n    swap_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Guided probabilistic flip: flip items with high marginal contribution\n    marginal_contrib = (value1_lst + value2_lst) / weight_lst\n    for idx in np.argsort(-marginal_contrib):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3433141529150757,
            4.448228240013123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high objective values and high diversity\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + guided probabilistic flip\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random swaps (2-3 items)\n    swap_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Guided probabilistic flip: flip items with high marginal contribution\n    marginal_contrib = (value1_lst + value2_lst) / weight_lst\n    for idx in np.argsort(-marginal_contrib):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{A novel local search strategy that intelligently selects a solution from the archive, then applies a hybrid of swap and perturbation operators to generate a neighbor solution by flipping a subset of items while ensuring feasibility and maximizing objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high objective values or diversity\n        objectives = np.array([obj for (sol, obj) in archive])\n        if np.random.rand() < 0.7:  # 70% chance to select a high-value solution\n            idx = np.argmax(np.sum(objectives, axis=1))\n        else:  # 30% chance to select a diverse solution\n            idx = np.random.choice(len(archive))\n        base_solution = archive[idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap + perturbation\n    num_items = len(new_solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            # Try to remove item if it's included\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try to add item if it's excluded\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Additional perturbation: randomly flip a few more items\n    perturb_indices = np.random.choice(num_items, size=min(2, num_items), replace=False)\n    for i in perturb_indices:\n        if np.random.rand() < 0.5:  # 50% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3058714054027204,
            3.0549640357494354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high objective values or diversity\n        objectives = np.array([obj for (sol, obj) in archive])\n        if np.random.rand() < 0.7:  # 70% chance to select a high-value solution\n            idx = np.argmax(np.sum(objectives, axis=1))\n        else:  # 30% chance to select a diverse solution\n            idx = np.random.choice(len(archive))\n        base_solution = archive[idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap + perturbation\n    num_items = len(new_solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            # Try to remove item if it's included\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try to add item if it's excluded\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Additional perturbation: randomly flip a few more items\n    perturb_indices = np.random.choice(num_items, size=min(2, num_items), replace=False)\n    for i in perturb_indices:\n        if np.random.rand() < 0.5:  # 50% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by prioritizing those with the highest objective values, then applies a hybrid local search combining item swaps and a novel \"value-ratio-based\" perturbation to explore high-value regions while ensuring feasibility through dynamic weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Find items not in the solution\n    candidate_items = np.where(base_solution == 0)[0]\n    if len(candidate_items) == 0:\n        return base_solution  # No improvement possible\n\n    # Calculate value ratios for candidate items\n    value_ratios = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n    sorted_indices = np.argsort(value_ratios)[::-1]\n    top_candidates = candidate_items[sorted_indices[:min(3, len(candidate_items))]]\n\n    new_solution = base_solution.copy()\n\n    # Try adding the top candidate items if feasible\n    for item in top_candidates:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Try removing low-value items to create space\n    if current_weight < capacity:\n        current_items = np.where(new_solution == 1)[0]\n        if len(current_items) > 0:\n            value_ratios_current = (value1_lst[current_items] + value2_lst[current_items]) / weight_lst[current_items]\n            sorted_current = np.argsort(value_ratios_current)\n            for i in sorted_current:\n                item = current_items[i]\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    if current_weight <= capacity:\n                        break\n\n    # Apply a small random perturbation to escape local optima\n    if np.random.rand() < 0.3:\n        perturb_items = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n        for item in perturb_items:\n            if new_solution[item] == 1 and current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            elif new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.30431499222722846,
            1.8412139415740967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Find items not in the solution\n    candidate_items = np.where(base_solution == 0)[0]\n    if len(candidate_items) == 0:\n        return base_solution  # No improvement possible\n\n    # Calculate value ratios for candidate items\n    value_ratios = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n    sorted_indices = np.argsort(value_ratios)[::-1]\n    top_candidates = candidate_items[sorted_indices[:min(3, len(candidate_items))]]\n\n    new_solution = base_solution.copy()\n\n    # Try adding the top candidate items if feasible\n    for item in top_candidates:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Try removing low-value items to create space\n    if current_weight < capacity:\n        current_items = np.where(new_solution == 1)[0]\n        if len(current_items) > 0:\n            value_ratios_current = (value1_lst[current_items] + value2_lst[current_items]) / weight_lst[current_items]\n            sorted_current = np.argsort(value_ratios_current)\n            for i in sorted_current:\n                item = current_items[i]\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    if current_weight <= capacity:\n                        break\n\n    # Apply a small random perturbation to escape local optima\n    if np.random.rand() < 0.3:\n        perturb_items = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n        for item in perturb_items:\n            if new_solution[item] == 1 and current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            elif new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining random insertion of high-value items and targeted removal of low-value items to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in objective space)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for insertion/removal\n    excluded_items = np.where(base_solution == 0)[0]\n    included_items = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: insert high-value items and remove low-value items\n    new_solution = base_solution.copy()\n\n    # Insert high-value items (prioritize items that improve both objectives)\n    if len(excluded_items) > 0:\n        # Calculate potential improvement for each excluded item\n        potential_improvements = []\n        for item in excluded_items:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                value1_gain = value1_lst[item]\n                value2_gain = value2_lst[item]\n                potential_improvements.append((item, value1_gain + value2_gain))\n\n        if potential_improvements:\n            # Select top 3 items with highest combined improvement\n            top_items = sorted(potential_improvements, key=lambda x: -x[1])[:3]\n            for item, _ in top_items:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Remove low-value items (prioritize items that are least valuable)\n    if len(included_items) > 0 and current_weight > 0:\n        # Calculate value-to-weight ratio for included items\n        value_ratios = []\n        for item in included_items:\n            ratio = (value1_lst[item] + value2_lst[item]) / weight_lst[item]\n            value_ratios.append((item, ratio))\n\n        # Select items to remove (lowest ratio)\n        if value_ratios:\n            sorted_items = sorted(value_ratios, key=lambda x: x[1])\n            # Remove up to 2 lowest-value items if feasible\n            for item, _ in sorted_items[:2]:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9408876880171009,
            3.0937251448631287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in objective space)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for insertion/removal\n    excluded_items = np.where(base_solution == 0)[0]\n    included_items = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: insert high-value items and remove low-value items\n    new_solution = base_solution.copy()\n\n    # Insert high-value items (prioritize items that improve both objectives)\n    if len(excluded_items) > 0:\n        # Calculate potential improvement for each excluded item\n        potential_improvements = []\n        for item in excluded_items:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                value1_gain = value1_lst[item]\n                value2_gain = value2_lst[item]\n                potential_improvements.append((item, value1_gain + value2_gain))\n\n        if potential_improvements:\n            # Select top 3 items with highest combined improvement\n            top_items = sorted(potential_improvements, key=lambda x: -x[1])[:3]\n            for item, _ in top_items:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Remove low-value items (prioritize items that are least valuable)\n    if len(included_items) > 0 and current_weight > 0:\n        # Calculate value-to-weight ratio for included items\n        value_ratios = []\n        for item in included_items:\n            ratio = (value1_lst[item] + value2_lst[item]) / weight_lst[item]\n            value_ratios.append((item, ratio))\n\n        # Select items to remove (lowest ratio)\n        if value_ratios:\n            sorted_items = sorted(value_ratios, key=lambda x: x[1])\n            # Remove up to 2 lowest-value items if feasible\n            for item, _ in sorted_items[:2]:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    }
]