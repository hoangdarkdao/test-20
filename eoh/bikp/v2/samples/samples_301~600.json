[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that could be flipped (added or removed)\n    candidates = np.where(new_solution != base_solution)[0]\n    if len(candidates) == 0:\n        # If no candidates, randomly select a subset of items\n        candidates = np.random.permutation(len(weight_lst))[:max(2, len(weight_lst) // 5)]\n\n    # Evaluate potential flips\n    best_gain = -np.inf\n    best_candidate = None\n    best_action = None\n\n    for i in candidates:\n        if new_solution[i] == 1:\n            # Try removing item i\n            new_weight = total_weight - weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[i]\n                gain2 = -value2_lst[i]\n                # Use a weighted sum of gains to balance both objectives\n                total_gain = 0.5 * gain1 + 0.5 * gain2\n                if total_gain > best_gain:\n                    best_gain = total_gain\n                    best_candidate = i\n                    best_action = 0\n        else:\n            # Try adding item i\n            new_weight = total_weight + weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                total_gain = 0.5 * gain1 + 0.5 * gain2\n                if total_gain > best_gain:\n                    best_gain = total_gain\n                    best_candidate = i\n                    best_action = 1\n\n    # Apply the best move if found\n    if best_candidate is not None:\n        new_solution[best_candidate] = best_action\n\n    # Step 3: Apply a second-order move (swap two items)\n    # Select two items with high potential for improvement\n    item_pairs = np.random.choice(len(weight_lst), size=(10, 2), replace=False)\n    best_swap_gain = -np.inf\n    best_swap_pair = None\n\n    for i, j in item_pairs:\n        if new_solution[i] != new_solution[j]:\n            # Calculate the effect of swapping items i and j\n            delta_weight = weight_lst[i] - weight_lst[j]\n            new_total_weight = total_weight + delta_weight\n            if new_total_weight <= capacity:\n                delta_value1 = value1_lst[i] - value1_lst[j]\n                delta_value2 = value2_lst[i] - value2_lst[j]\n                swap_gain = 0.5 * delta_value1 + 0.5 * delta_value2\n                if swap_gain > best_swap_gain:\n                    best_swap_gain = swap_gain\n                    best_swap_pair = (i, j)\n\n    # Apply the best swap if found\n    if best_swap_pair is not None:\n        i, j = best_swap_pair\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3809938318375996,
            4.549461245536804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that could be flipped (added or removed)\n    candidates = np.where(new_solution != base_solution)[0]\n    if len(candidates) == 0:\n        # If no candidates, randomly select a subset of items\n        candidates = np.random.permutation(len(weight_lst))[:max(2, len(weight_lst) // 5)]\n\n    # Evaluate potential flips\n    best_gain = -np.inf\n    best_candidate = None\n    best_action = None\n\n    for i in candidates:\n        if new_solution[i] == 1:\n            # Try removing item i\n            new_weight = total_weight - weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[i]\n                gain2 = -value2_lst[i]\n                # Use a weighted sum of gains to balance both objectives\n                total_gain = 0.5 * gain1 + 0.5 * gain2\n                if total_gain > best_gain:\n                    best_gain = total_gain\n                    best_candidate = i\n                    best_action = 0\n        else:\n            # Try adding item i\n            new_weight = total_weight + weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                total_gain = 0.5 * gain1 + 0.5 * gain2\n                if total_gain > best_gain:\n                    best_gain = total_gain\n                    best_candidate = i\n                    best_action = 1\n\n    # Apply the best move if found\n    if best_candidate is not None:\n        new_solution[best_candidate] = best_action\n\n    # Step 3: Apply a second-order move (swap two items)\n    # Select two items with high potential for improvement\n    item_pairs = np.random.choice(len(weight_lst), size=(10, 2), replace=False)\n    best_swap_gain = -np.inf\n    best_swap_pair = None\n\n    for i, j in item_pairs:\n        if new_solution[i] != new_solution[j]:\n            # Calculate the effect of swapping items i and j\n            delta_weight = weight_lst[i] - weight_lst[j]\n            new_total_weight = total_weight + delta_weight\n            if new_total_weight <= capacity:\n                delta_value1 = value1_lst[i] - value1_lst[j]\n                delta_value2 = value2_lst[i] - value2_lst[j]\n                swap_gain = 0.5 * delta_value1 + 0.5 * delta_value2\n                if swap_gain > best_swap_gain:\n                    best_swap_gain = swap_gain\n                    best_swap_pair = (i, j)\n\n    # Apply the best swap if found\n    if best_swap_pair is not None:\n        i, j = best_swap_pair\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[0]))[0].copy()  # Example: select the solution with the most items\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: flip a subset of items based on their marginal contributions\n    # Calculate marginal contributions for value1 and value2\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal contributions (e.g., weighted sum)\n    combined_marginal = 0.5 * marginal_value1 + 0.5 * marginal_value2\n\n    # Identify items to flip: those with the highest combined marginal contributions not in the solution\n    candidate_items = np.where(selected_solution == 0)[0]\n    if len(candidate_items) > 0:\n        top_items = candidate_items[np.argsort(combined_marginal[candidate_items])[-min(3, len(candidate_items)):]]  # Top 3 candidates\n        for item in top_items:\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n\n    # Identify items to remove: those with the lowest combined marginal contributions in the solution\n    candidate_items = np.where(selected_solution == 1)[0]\n    if len(candidate_items) > 0:\n        bottom_items = candidate_items[np.argsort(combined_marginal[candidate_items])[:min(3, len(candidate_items))]]  # Bottom 3 candidates\n        for item in bottom_items:\n            new_solution[item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9350369185218399,
            7.025612145662308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[0]))[0].copy()  # Example: select the solution with the most items\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: flip a subset of items based on their marginal contributions\n    # Calculate marginal contributions for value1 and value2\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal contributions (e.g., weighted sum)\n    combined_marginal = 0.5 * marginal_value1 + 0.5 * marginal_value2\n\n    # Identify items to flip: those with the highest combined marginal contributions not in the solution\n    candidate_items = np.where(selected_solution == 0)[0]\n    if len(candidate_items) > 0:\n        top_items = candidate_items[np.argsort(combined_marginal[candidate_items])[-min(3, len(candidate_items)):]]  # Top 3 candidates\n        for item in top_items:\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n\n    # Identify items to remove: those with the lowest combined marginal contributions in the solution\n    candidate_items = np.where(selected_solution == 1)[0]\n    if len(candidate_items) > 0:\n        bottom_items = candidate_items[np.argsort(combined_marginal[candidate_items])[:min(3, len(candidate_items))]]  # Bottom 3 candidates\n        for item in bottom_items:\n            new_solution[item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with lower crowding distances in objective space, then applies a hybrid local search that combines item swapping and probabilistic flipping based on value-to-weight ratios to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (lower crowding distance)\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0] + objectives[:, 1])  # Simple heuristic\n    selected_idx = sorted_indices[0] if len(sorted_indices) == 1 else sorted_indices[1]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Probabilistic flipping based on value-to-weight ratio\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if np.random.rand() < 0.3:  # 30% chance to remove\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                ratio1 = value1_lst[i] / weight_lst[i]\n                ratio2 = value2_lst[i] / weight_lst[i]\n                if np.random.rand() < (ratio1 + ratio2) / 100:  # Higher ratio, higher chance to add\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 3: Item swapping for diversification\n    for _ in range(3):\n        zero_indices = np.where(new_solution == 0)[0]\n        one_indices = np.where(new_solution == 1)[0]\n        if len(zero_indices) > 0 and len(one_indices) > 0:\n            a, b = np.random.choice(zero_indices), np.random.choice(one_indices)\n            if current_weight - weight_lst[b] + weight_lst[a] <= capacity:\n                new_solution[b], new_solution[a] = new_solution[a], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.6477063776729503,
            6.858263254165649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (lower crowding distance)\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0] + objectives[:, 1])  # Simple heuristic\n    selected_idx = sorted_indices[0] if len(sorted_indices) == 1 else sorted_indices[1]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Probabilistic flipping based on value-to-weight ratio\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if np.random.rand() < 0.3:  # 30% chance to remove\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                ratio1 = value1_lst[i] / weight_lst[i]\n                ratio2 = value2_lst[i] / weight_lst[i]\n                if np.random.rand() < (ratio1 + ratio2) / 100:  # Higher ratio, higher chance to add\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 3: Item swapping for diversification\n    for _ in range(3):\n        zero_indices = np.where(new_solution == 0)[0]\n        one_indices = np.where(new_solution == 1)[0]\n        if len(zero_indices) > 0 and len(one_indices) > 0:\n            a, b = np.random.choice(zero_indices), np.random.choice(one_indices)\n            if current_weight - weight_lst[b] + weight_lst[a] <= capacity:\n                new_solution[b], new_solution[a] = new_solution[a], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of diversity and potential improvement, then applies a novel hybrid local search that combines item swapping and probabilistic flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        # Score based on how close to capacity and how many items can potentially be added\n        remaining_capacity = capacity - total_weight\n        potential_items = np.where((weight_lst <= remaining_capacity) & (sol == 0))[0]\n        score = len(potential_items) * (1 - total_weight / capacity)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Identify critical items (high value, low weight)\n    value_ratio1 = value1_lst / (weight_lst + 1e-6)\n    value_ratio2 = value2_lst / (weight_lst + 1e-6)\n    critical_items = np.where((value_ratio1 > np.median(value_ratio1)) | (value_ratio2 > np.median(value_ratio2)))[0]\n\n    # Step 2: Perform probabilistic flipping of critical items\n    for item in critical_items:\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            if new_solution[item] == 1:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n\n    # Step 3: Perform targeted swaps between included and excluded items\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        for _ in range(3):  # Perform up to 3 swaps\n            i = np.random.choice(included)\n            j = np.random.choice(excluded)\n\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[i] + weight_lst[j]) <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.35418397636127613,
            10.304614424705505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        # Score based on how close to capacity and how many items can potentially be added\n        remaining_capacity = capacity - total_weight\n        potential_items = np.where((weight_lst <= remaining_capacity) & (sol == 0))[0]\n        score = len(potential_items) * (1 - total_weight / capacity)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Identify critical items (high value, low weight)\n    value_ratio1 = value1_lst / (weight_lst + 1e-6)\n    value_ratio2 = value2_lst / (weight_lst + 1e-6)\n    critical_items = np.where((value_ratio1 > np.median(value_ratio1)) | (value_ratio2 > np.median(value_ratio2)))[0]\n\n    # Step 2: Perform probabilistic flipping of critical items\n    for item in critical_items:\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            if new_solution[item] == 1:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n\n    # Step 3: Perform targeted swaps between included and excluded items\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        for _ in range(3):  # Perform up to 3 swaps\n            i = np.random.choice(included)\n            j = np.random.choice(excluded)\n\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[i] + weight_lst[j]) <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor by flipping items with high marginal gain in either objective\n    new_solution = base_solution.copy()\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Calculate marginal gains for excluded items\n    if len(excluded) > 0:\n        excluded_weights = weight_lst[excluded]\n        excluded_values1 = value1_lst[excluded]\n        excluded_values2 = value2_lst[excluded]\n        current_weight = np.sum(weight_lst[included])\n\n        # Find items that can be added without exceeding capacity\n        feasible_add = np.where(excluded_weights <= (capacity - current_weight))[0]\n        if len(feasible_add) > 0:\n            # Select item with highest sum of normalized marginal gains\n            marginal_gains1 = excluded_values1[feasible_add]\n            marginal_gains2 = excluded_values2[feasible_add]\n            norm_gains1 = (marginal_gains1 - marginal_gains1.min()) / (marginal_gains1.max() - marginal_gains1.min() + 1e-10)\n            norm_gains2 = (marginal_gains2 - marginal_gains2.min()) / (marginal_gains2.max() - marginal_gains2.min() + 1e-10)\n            total_gains = norm_gains1 + norm_gains2\n            best_add = feasible_add[np.argmax(total_gains)]\n            new_solution[excluded[best_add]] = 1\n\n    # Calculate marginal gains for included items\n    if len(included) > 0:\n        # Select item with lowest sum of normalized marginal gains to remove\n        marginal_gains1 = value1_lst[included]\n        marginal_gains2 = value2_lst[included]\n        norm_gains1 = (marginal_gains1 - marginal_gains1.min()) / (marginal_gains1.max() - marginal_gains1.min() + 1e-10)\n        norm_gains2 = (marginal_gains2 - marginal_gains2.min()) / (marginal_gains2.max() - marginal_gains2.min() + 1e-10)\n        total_gains = norm_gains1 + norm_gains2\n        worst_remove = np.argmin(total_gains)\n        new_solution[included[worst_remove]] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9008064552042674,
            2.1281520426273346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor by flipping items with high marginal gain in either objective\n    new_solution = base_solution.copy()\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Calculate marginal gains for excluded items\n    if len(excluded) > 0:\n        excluded_weights = weight_lst[excluded]\n        excluded_values1 = value1_lst[excluded]\n        excluded_values2 = value2_lst[excluded]\n        current_weight = np.sum(weight_lst[included])\n\n        # Find items that can be added without exceeding capacity\n        feasible_add = np.where(excluded_weights <= (capacity - current_weight))[0]\n        if len(feasible_add) > 0:\n            # Select item with highest sum of normalized marginal gains\n            marginal_gains1 = excluded_values1[feasible_add]\n            marginal_gains2 = excluded_values2[feasible_add]\n            norm_gains1 = (marginal_gains1 - marginal_gains1.min()) / (marginal_gains1.max() - marginal_gains1.min() + 1e-10)\n            norm_gains2 = (marginal_gains2 - marginal_gains2.min()) / (marginal_gains2.max() - marginal_gains2.min() + 1e-10)\n            total_gains = norm_gains1 + norm_gains2\n            best_add = feasible_add[np.argmax(total_gains)]\n            new_solution[excluded[best_add]] = 1\n\n    # Calculate marginal gains for included items\n    if len(included) > 0:\n        # Select item with lowest sum of normalized marginal gains to remove\n        marginal_gains1 = value1_lst[included]\n        marginal_gains2 = value2_lst[included]\n        norm_gains1 = (marginal_gains1 - marginal_gains1.min()) / (marginal_gains1.max() - marginal_gains1.min() + 1e-10)\n        norm_gains2 = (marginal_gains2 - marginal_gains2.min()) / (marginal_gains2.max() - marginal_gains2.min() + 1e-10)\n        total_gains = norm_gains1 + norm_gains2\n        worst_remove = np.argmin(total_gains)\n        new_solution[included[worst_remove]] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{The heuristic selects a solution from the archive by prioritizing those with higher objective values and applies a novel local search that combines random item swaps with a guided perturbation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly swap items to explore the neighborhood\n    n_items = len(weight_lst)\n    swap_indices = random.sample(range(n_items), min(3, n_items))  # Swap up to 3 items\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Step 2: Guided perturbation to ensure feasibility and diversity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_indices = np.where(new_solution == 1)[0]\n        while current_weight > capacity and len(excess_indices) > 0:\n            remove_idx = random.choice(excess_indices)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n            excess_indices = np.where(new_solution == 1)[0]\n\n    # Step 3: Add high-value items if possible\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        candidate_indices = np.where(new_solution == 0)[0]\n        for idx in candidate_indices:\n            if weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.34198253499971903,
            1.845097154378891
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly swap items to explore the neighborhood\n    n_items = len(weight_lst)\n    swap_indices = random.sample(range(n_items), min(3, n_items))  # Swap up to 3 items\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Step 2: Guided perturbation to ensure feasibility and diversity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_indices = np.where(new_solution == 1)[0]\n        while current_weight > capacity and len(excess_indices) > 0:\n            remove_idx = random.choice(excess_indices)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n            excess_indices = np.where(new_solution == 1)[0]\n\n    # Step 3: Add high-value items if possible\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        candidate_indices = np.where(new_solution == 0)[0]\n        for idx in candidate_indices:\n            if weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 307,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive based on its potential for improvement, then applies a combination of item swaps and flips, guided by both objective values and weight constraints, to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives (promising candidates)\n        normalized_archive = []\n        max_val1 = max(obj[0] for _, obj in archive)\n        max_val2 = max(obj[1] for _, obj in archive)\n        for sol, obj in archive:\n            norm_val1 = obj[0] / max_val1 if max_val1 != 0 else 0\n            norm_val2 = obj[1] / max_val2 if max_val2 != 0 else 0\n            normalized_archive.append((sol, obj, norm_val1 + norm_val2))\n\n        # Select top 30% of solutions by normalized score\n        top_solutions = sorted(normalized_archive, key=lambda x: -x[2])\n        selected = random.choice(top_solutions[:max(1, len(top_solutions) // 3)])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and flips\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Try to swap an included item with an excluded one\n    if len(included_items) > 0 and len(available_items) > 0:\n        item_in = random.choice(included_items)\n        item_out = random.choice(available_items)\n        if current_weight - weight_lst[item_in] + weight_lst[item_out] <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n\n    # Try to flip a random item (add or remove)\n    else:\n        if random.random() < 0.5 and len(available_items) > 0:\n            # Add an item\n            item_to_add = random.choice(available_items)\n            if current_weight + weight_lst[item_to_add] <= capacity:\n                new_solution[item_to_add] = 1\n        elif len(included_items) > 0:\n            # Remove an item\n            item_to_remove = random.choice(included_items)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4173221637349147,
            4.272386133670807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives (promising candidates)\n        normalized_archive = []\n        max_val1 = max(obj[0] for _, obj in archive)\n        max_val2 = max(obj[1] for _, obj in archive)\n        for sol, obj in archive:\n            norm_val1 = obj[0] / max_val1 if max_val1 != 0 else 0\n            norm_val2 = obj[1] / max_val2 if max_val2 != 0 else 0\n            normalized_archive.append((sol, obj, norm_val1 + norm_val2))\n\n        # Select top 30% of solutions by normalized score\n        top_solutions = sorted(normalized_archive, key=lambda x: -x[2])\n        selected = random.choice(top_solutions[:max(1, len(top_solutions) // 3)])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and flips\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Try to swap an included item with an excluded one\n    if len(included_items) > 0 and len(available_items) > 0:\n        item_in = random.choice(included_items)\n        item_out = random.choice(available_items)\n        if current_weight - weight_lst[item_in] + weight_lst[item_out] <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n\n    # Try to flip a random item (add or remove)\n    else:\n        if random.random() < 0.5 and len(available_items) > 0:\n            # Add an item\n            item_to_add = random.choice(available_items)\n            if current_weight + weight_lst[item_to_add] <= capacity:\n                new_solution[item_to_add] = 1\n        elif len(included_items) > 0:\n            # Remove an item\n            item_to_remove = random.choice(included_items)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    }
]